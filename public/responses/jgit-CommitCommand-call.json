{
	"repo": "https://github.com/eclipse/jgit.git",
	"file": "org.eclipse.jgit/src/org/eclipse/jgit/api/CommitCommand.java",
	"method": {
		"longName": "CommitCommand::call()",
		"startLine": 161,
		"methodName": "call",
		"isStatic": false,
		"isAbstract": false,
		"visibility": "public"
	},
	"history": {
		"9441508682b7d7c935dd976e4082cacff4a5efeb": {
			"type": "Ybodychange",
			"commitMessage": "Fix misspelled class name: EmtpyCommitException -> EmptyCommitException\n\nChange-Id: I55196020146f26951988988c14ac9a6f85061ae2\nSigned-off-by: David Pursehouse <david.pursehouse@gmail.com>\n",
			"commitDate": "2018-03-10, 11:40 AM",
			"commitName": "9441508682b7d7c935dd976e4082cacff4a5efeb",
			"commitAuthor": "David Pursehouse",
			"commitDateOld": "2018-03-05, 5:48 PM",
			"commitNameOld": "3393f78210862b3ccd954f029d831ef783b35c89",
			"commitAuthorOld": "David Pursehouse",
			"daysBetweenCommits": 4.74,
			"commitsBetweenForRepo": 45,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,155 +1,155 @@\n \tpublic RevCommit call() throws GitAPIException, NoHeadException,\n \t\t\tNoMessageException, UnmergedPathsException,\n \t\t\tConcurrentRefUpdateException, WrongRepositoryStateException,\n \t\t\tAbortedByHookException {\n \t\tcheckCallable();\n \t\tCollections.sort(only);\n \n \t\ttry (RevWalk rw = new RevWalk(repo)) {\n \t\t\tRepositoryState state = repo.getRepositoryState();\n \t\t\tif (!state.canCommit())\n \t\t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n \t\t\t\t\t\tJGitText.get().cannotCommitOnARepoWithState,\n \t\t\t\t\t\tstate.name()));\n \n \t\t\tif (!noVerify) {\n \t\t\t\tHooks.preCommit(repo, hookOutRedirect.get(PreCommitHook.NAME))\n \t\t\t\t\t\t.call();\n \t\t\t}\n \n \t\t\tprocessOptions(state, rw);\n \n \t\t\tif (all && !repo.isBare()) {\n \t\t\t\ttry (Git git = new Git(repo)) {\n \t\t\t\t\tgit.add()\n \t\t\t\t\t\t\t.addFilepattern(\".\") //$NON-NLS-1$\n \t\t\t\t\t\t\t.setUpdate(true).call();\n \t\t\t\t} catch (NoFilepatternException e) {\n \t\t\t\t\t// should really not happen\n \t\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tRef head = repo.exactRef(Constants.HEAD);\n \t\t\tif (head == null)\n \t\t\t\tthrow new NoHeadException(\n \t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n \n \t\t\t// determine the current HEAD and the commit it is referring to\n \t\t\tObjectId headId = repo.resolve(Constants.HEAD + \"^{commit}\"); //$NON-NLS-1$\n \t\t\tif (headId == null && amend)\n \t\t\t\tthrow new WrongRepositoryStateException(\n \t\t\t\t\t\tJGitText.get().commitAmendOnInitialNotPossible);\n \n \t\t\tif (headId != null)\n \t\t\t\tif (amend) {\n \t\t\t\t\tRevCommit previousCommit = rw.parseCommit(headId);\n \t\t\t\t\tfor (RevCommit p : previousCommit.getParents())\n \t\t\t\t\t\tparents.add(p.getId());\n \t\t\t\t\tif (author == null)\n \t\t\t\t\t\tauthor = previousCommit.getAuthorIdent();\n \t\t\t\t} else {\n \t\t\t\t\tparents.add(0, headId);\n \t\t\t\t}\n \n \t\t\tif (!noVerify) {\n \t\t\t\tmessage = Hooks\n \t\t\t\t\t\t.commitMsg(repo,\n \t\t\t\t\t\t\t\thookOutRedirect.get(CommitMsgHook.NAME))\n \t\t\t\t\t\t.setCommitMessage(message).call();\n \t\t\t}\n \n \t\t\t// lock the index\n \t\t\tDirCache index = repo.lockDirCache();\n \t\t\ttry (ObjectInserter odi = repo.newObjectInserter()) {\n \t\t\t\tif (!only.isEmpty())\n \t\t\t\t\tindex = createTemporaryIndex(headId, index, rw);\n \n \t\t\t\t// Write the index as tree to the object database. This may\n \t\t\t\t// fail for example when the index contains unmerged paths\n \t\t\t\t// (unresolved conflicts)\n \t\t\t\tObjectId indexTreeId = index.writeTree(odi);\n \n \t\t\t\tif (insertChangeId)\n \t\t\t\t\tinsertChangeId(indexTreeId);\n \n \t\t\t\t// Check for empty commits\n \t\t\t\tif (headId != null && !allowEmpty.booleanValue()) {\n \t\t\t\t\tRevCommit headCommit = rw.parseCommit(headId);\n \t\t\t\t\theadCommit.getTree();\n \t\t\t\t\tif (indexTreeId.equals(headCommit.getTree())) {\n-\t\t\t\t\t\tthrow new EmtpyCommitException(\n+\t\t\t\t\t\tthrow new EmptyCommitException(\n \t\t\t\t\t\t\t\tJGitText.get().emptyCommit);\n \t\t\t\t\t}\n \t\t\t\t}\n \n \t\t\t\t// Create a Commit object, populate it and write it\n \t\t\t\tCommitBuilder commit = new CommitBuilder();\n \t\t\t\tcommit.setCommitter(committer);\n \t\t\t\tcommit.setAuthor(author);\n \t\t\t\tcommit.setMessage(message);\n \n \t\t\t\tcommit.setParentIds(parents);\n \t\t\t\tcommit.setTreeId(indexTreeId);\n \t\t\t\tObjectId commitId = odi.insert(commit);\n \t\t\t\todi.flush();\n \n \t\t\t\tRevCommit revCommit = rw.parseCommit(commitId);\n \t\t\t\tRefUpdate ru = repo.updateRef(Constants.HEAD);\n \t\t\t\tru.setNewObjectId(commitId);\n \t\t\t\tif (!useDefaultReflogMessage) {\n \t\t\t\t\tru.setRefLogMessage(reflogComment, false);\n \t\t\t\t} else {\n \t\t\t\t\tString prefix = amend ? \"commit (amend): \" //$NON-NLS-1$\n \t\t\t\t\t\t\t: parents.size() == 0 ? \"commit (initial): \" //$NON-NLS-1$\n \t\t\t\t\t\t\t\t\t: \"commit: \"; //$NON-NLS-1$\n \t\t\t\t\tru.setRefLogMessage(prefix + revCommit.getShortMessage(),\n \t\t\t\t\t\t\tfalse);\n \t\t\t\t}\n \t\t\t\tif (headId != null)\n \t\t\t\t\tru.setExpectedOldObjectId(headId);\n \t\t\t\telse\n \t\t\t\t\tru.setExpectedOldObjectId(ObjectId.zeroId());\n \t\t\t\tResult rc = ru.forceUpdate();\n \t\t\t\tswitch (rc) {\n \t\t\t\tcase NEW:\n \t\t\t\tcase FORCED:\n \t\t\t\tcase FAST_FORWARD: {\n \t\t\t\t\tsetCallable(false);\n \t\t\t\t\tif (state == RepositoryState.MERGING_RESOLVED\n \t\t\t\t\t\t\t|| isMergeDuringRebase(state)) {\n \t\t\t\t\t\t// Commit was successful. Now delete the files\n \t\t\t\t\t\t// used for merge commits\n \t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n \t\t\t\t\t\trepo.writeMergeHeads(null);\n \t\t\t\t\t} else if (state == RepositoryState.CHERRY_PICKING_RESOLVED) {\n \t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n \t\t\t\t\t\trepo.writeCherryPickHead(null);\n \t\t\t\t\t} else if (state == RepositoryState.REVERTING_RESOLVED) {\n \t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n \t\t\t\t\t\trepo.writeRevertHead(null);\n \t\t\t\t\t}\n \t\t\t\t\tHooks.postCommit(repo,\n \t\t\t\t\t\t\thookOutRedirect.get(PostCommitHook.NAME)).call();\n \n \t\t\t\t\treturn revCommit;\n \t\t\t\t}\n \t\t\t\tcase REJECTED:\n \t\t\t\tcase LOCK_FAILURE:\n \t\t\t\t\tthrow new ConcurrentRefUpdateException(\n \t\t\t\t\t\t\tJGitText.get().couldNotLockHEAD, ru.getRef(), rc);\n \t\t\t\tdefault:\n \t\t\t\t\tthrow new JGitInternalException(MessageFormat.format(\n \t\t\t\t\t\t\tJGitText.get().updatingRefFailed, Constants.HEAD,\n \t\t\t\t\t\t\tcommitId.toString(), rc));\n \t\t\t\t}\n \t\t\t} finally {\n \t\t\t\tindex.unlock();\n \t\t\t}\n \t\t} catch (UnmergedPathException e) {\n \t\t\tthrow new UnmergedPathsException(e);\n \t\t} catch (IOException e) {\n \t\t\tthrow new JGitInternalException(\n \t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"57a263f1823d164142235a72072154f0568cb61c": {
			"type": "Ybodychange",
			"commitMessage": "Add support for post-commit hooks\n\nChange-Id: I6691b454404dd4db3c690ecfc7515de765bc2ef7\nSigned-off-by: Martin Goellnitz <m.goellnitz@outlook.com>\nSigned-off-by: Matthias Sohn <matthias.sohn@sap.com>",
			"commitDate": "2016-09-13, 9:13 AM",
			"commitName": "57a263f1823d164142235a72072154f0568cb61c",
			"commitAuthor": "Martin Goellnitz",
			"commitDateOld": "2016-05-30, 4:11 PM",
			"commitNameOld": "4c236ff4bbf664fd177a33f42517b0eef52510c8",
			"commitAuthorOld": "Matthias Sohn",
			"daysBetweenCommits": 105.71,
			"commitsBetweenForRepo": 136,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,149 +1,155 @@\n \tpublic RevCommit call() throws GitAPIException, NoHeadException,\n \t\t\tNoMessageException, UnmergedPathsException,\n \t\t\tConcurrentRefUpdateException, WrongRepositoryStateException,\n \t\t\tAbortedByHookException {\n \t\tcheckCallable();\n \t\tCollections.sort(only);\n \n \t\ttry (RevWalk rw = new RevWalk(repo)) {\n \t\t\tRepositoryState state = repo.getRepositoryState();\n \t\t\tif (!state.canCommit())\n \t\t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n \t\t\t\t\t\tJGitText.get().cannotCommitOnARepoWithState,\n \t\t\t\t\t\tstate.name()));\n \n \t\t\tif (!noVerify) {\n-\t\t\t\tHooks.preCommit(repo, hookOutRedirect).call();\n+\t\t\t\tHooks.preCommit(repo, hookOutRedirect.get(PreCommitHook.NAME))\n+\t\t\t\t\t\t.call();\n \t\t\t}\n \n \t\t\tprocessOptions(state, rw);\n \n \t\t\tif (all && !repo.isBare()) {\n \t\t\t\ttry (Git git = new Git(repo)) {\n \t\t\t\t\tgit.add()\n \t\t\t\t\t\t\t.addFilepattern(\".\") //$NON-NLS-1$\n \t\t\t\t\t\t\t.setUpdate(true).call();\n \t\t\t\t} catch (NoFilepatternException e) {\n \t\t\t\t\t// should really not happen\n \t\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tRef head = repo.exactRef(Constants.HEAD);\n \t\t\tif (head == null)\n \t\t\t\tthrow new NoHeadException(\n \t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n \n \t\t\t// determine the current HEAD and the commit it is referring to\n \t\t\tObjectId headId = repo.resolve(Constants.HEAD + \"^{commit}\"); //$NON-NLS-1$\n \t\t\tif (headId == null && amend)\n \t\t\t\tthrow new WrongRepositoryStateException(\n \t\t\t\t\t\tJGitText.get().commitAmendOnInitialNotPossible);\n \n \t\t\tif (headId != null)\n \t\t\t\tif (amend) {\n \t\t\t\t\tRevCommit previousCommit = rw.parseCommit(headId);\n \t\t\t\t\tfor (RevCommit p : previousCommit.getParents())\n \t\t\t\t\t\tparents.add(p.getId());\n \t\t\t\t\tif (author == null)\n \t\t\t\t\t\tauthor = previousCommit.getAuthorIdent();\n \t\t\t\t} else {\n \t\t\t\t\tparents.add(0, headId);\n \t\t\t\t}\n \n \t\t\tif (!noVerify) {\n-\t\t\t\tmessage = Hooks.commitMsg(repo, hookOutRedirect)\n+\t\t\t\tmessage = Hooks\n+\t\t\t\t\t\t.commitMsg(repo,\n+\t\t\t\t\t\t\t\thookOutRedirect.get(CommitMsgHook.NAME))\n \t\t\t\t\t\t.setCommitMessage(message).call();\n \t\t\t}\n \n \t\t\t// lock the index\n \t\t\tDirCache index = repo.lockDirCache();\n \t\t\ttry (ObjectInserter odi = repo.newObjectInserter()) {\n \t\t\t\tif (!only.isEmpty())\n \t\t\t\t\tindex = createTemporaryIndex(headId, index, rw);\n \n \t\t\t\t// Write the index as tree to the object database. This may\n \t\t\t\t// fail for example when the index contains unmerged paths\n \t\t\t\t// (unresolved conflicts)\n \t\t\t\tObjectId indexTreeId = index.writeTree(odi);\n \n \t\t\t\tif (insertChangeId)\n \t\t\t\t\tinsertChangeId(indexTreeId);\n \n \t\t\t\t// Check for empty commits\n \t\t\t\tif (headId != null && !allowEmpty.booleanValue()) {\n \t\t\t\t\tRevCommit headCommit = rw.parseCommit(headId);\n \t\t\t\t\theadCommit.getTree();\n \t\t\t\t\tif (indexTreeId.equals(headCommit.getTree())) {\n \t\t\t\t\t\tthrow new EmtpyCommitException(\n \t\t\t\t\t\t\t\tJGitText.get().emptyCommit);\n \t\t\t\t\t}\n \t\t\t\t}\n \n \t\t\t\t// Create a Commit object, populate it and write it\n \t\t\t\tCommitBuilder commit = new CommitBuilder();\n \t\t\t\tcommit.setCommitter(committer);\n \t\t\t\tcommit.setAuthor(author);\n \t\t\t\tcommit.setMessage(message);\n \n \t\t\t\tcommit.setParentIds(parents);\n \t\t\t\tcommit.setTreeId(indexTreeId);\n \t\t\t\tObjectId commitId = odi.insert(commit);\n \t\t\t\todi.flush();\n \n \t\t\t\tRevCommit revCommit = rw.parseCommit(commitId);\n \t\t\t\tRefUpdate ru = repo.updateRef(Constants.HEAD);\n \t\t\t\tru.setNewObjectId(commitId);\n \t\t\t\tif (!useDefaultReflogMessage) {\n \t\t\t\t\tru.setRefLogMessage(reflogComment, false);\n \t\t\t\t} else {\n \t\t\t\t\tString prefix = amend ? \"commit (amend): \" //$NON-NLS-1$\n \t\t\t\t\t\t\t: parents.size() == 0 ? \"commit (initial): \" //$NON-NLS-1$\n \t\t\t\t\t\t\t\t\t: \"commit: \"; //$NON-NLS-1$\n \t\t\t\t\tru.setRefLogMessage(prefix + revCommit.getShortMessage(),\n \t\t\t\t\t\t\tfalse);\n \t\t\t\t}\n \t\t\t\tif (headId != null)\n \t\t\t\t\tru.setExpectedOldObjectId(headId);\n \t\t\t\telse\n \t\t\t\t\tru.setExpectedOldObjectId(ObjectId.zeroId());\n \t\t\t\tResult rc = ru.forceUpdate();\n \t\t\t\tswitch (rc) {\n \t\t\t\tcase NEW:\n \t\t\t\tcase FORCED:\n \t\t\t\tcase FAST_FORWARD: {\n \t\t\t\t\tsetCallable(false);\n \t\t\t\t\tif (state == RepositoryState.MERGING_RESOLVED\n \t\t\t\t\t\t\t|| isMergeDuringRebase(state)) {\n \t\t\t\t\t\t// Commit was successful. Now delete the files\n \t\t\t\t\t\t// used for merge commits\n \t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n \t\t\t\t\t\trepo.writeMergeHeads(null);\n \t\t\t\t\t} else if (state == RepositoryState.CHERRY_PICKING_RESOLVED) {\n \t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n \t\t\t\t\t\trepo.writeCherryPickHead(null);\n \t\t\t\t\t} else if (state == RepositoryState.REVERTING_RESOLVED) {\n \t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n \t\t\t\t\t\trepo.writeRevertHead(null);\n \t\t\t\t\t}\n+\t\t\t\t\tHooks.postCommit(repo,\n+\t\t\t\t\t\t\thookOutRedirect.get(PostCommitHook.NAME)).call();\n+\n \t\t\t\t\treturn revCommit;\n \t\t\t\t}\n \t\t\t\tcase REJECTED:\n \t\t\t\tcase LOCK_FAILURE:\n \t\t\t\t\tthrow new ConcurrentRefUpdateException(\n \t\t\t\t\t\t\tJGitText.get().couldNotLockHEAD, ru.getRef(), rc);\n \t\t\t\tdefault:\n \t\t\t\t\tthrow new JGitInternalException(MessageFormat.format(\n \t\t\t\t\t\t\tJGitText.get().updatingRefFailed, Constants.HEAD,\n \t\t\t\t\t\t\tcommitId.toString(), rc));\n \t\t\t\t}\n \t\t\t} finally {\n \t\t\t\tindex.unlock();\n \t\t\t}\n \t\t} catch (UnmergedPathException e) {\n \t\t\tthrow new UnmergedPathsException(e);\n \t\t} catch (IOException e) {\n \t\t\tthrow new JGitInternalException(\n \t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"4c236ff4bbf664fd177a33f42517b0eef52510c8": {
			"type": "Ybodychange",
			"commitMessage": "Replace use of deprecated method Repository.getRef()\n\nChange-Id: Iecf2b8deafc4991cc3333702fb9fa0638be7b914\nSigned-off-by: Matthias Sohn <matthias.sohn@sap.com>",
			"commitDate": "2016-05-30, 4:11 PM",
			"commitName": "4c236ff4bbf664fd177a33f42517b0eef52510c8",
			"commitAuthor": "Matthias Sohn",
			"commitDateOld": "2016-04-11, 12:58 AM",
			"commitNameOld": "36a53d1a3cdd66c40b6db241a75a28293f22f5e1",
			"commitAuthorOld": "Christian Halstrick",
			"daysBetweenCommits": 49.63,
			"commitsBetweenForRepo": 42,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,149 +1,149 @@\n \tpublic RevCommit call() throws GitAPIException, NoHeadException,\n \t\t\tNoMessageException, UnmergedPathsException,\n \t\t\tConcurrentRefUpdateException, WrongRepositoryStateException,\n \t\t\tAbortedByHookException {\n \t\tcheckCallable();\n \t\tCollections.sort(only);\n \n \t\ttry (RevWalk rw = new RevWalk(repo)) {\n \t\t\tRepositoryState state = repo.getRepositoryState();\n \t\t\tif (!state.canCommit())\n \t\t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n \t\t\t\t\t\tJGitText.get().cannotCommitOnARepoWithState,\n \t\t\t\t\t\tstate.name()));\n \n \t\t\tif (!noVerify) {\n \t\t\t\tHooks.preCommit(repo, hookOutRedirect).call();\n \t\t\t}\n \n \t\t\tprocessOptions(state, rw);\n \n \t\t\tif (all && !repo.isBare()) {\n \t\t\t\ttry (Git git = new Git(repo)) {\n \t\t\t\t\tgit.add()\n \t\t\t\t\t\t\t.addFilepattern(\".\") //$NON-NLS-1$\n \t\t\t\t\t\t\t.setUpdate(true).call();\n \t\t\t\t} catch (NoFilepatternException e) {\n \t\t\t\t\t// should really not happen\n \t\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t\t}\n \t\t\t}\n \n-\t\t\tRef head = repo.getRef(Constants.HEAD);\n+\t\t\tRef head = repo.exactRef(Constants.HEAD);\n \t\t\tif (head == null)\n \t\t\t\tthrow new NoHeadException(\n \t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n \n \t\t\t// determine the current HEAD and the commit it is referring to\n \t\t\tObjectId headId = repo.resolve(Constants.HEAD + \"^{commit}\"); //$NON-NLS-1$\n \t\t\tif (headId == null && amend)\n \t\t\t\tthrow new WrongRepositoryStateException(\n \t\t\t\t\t\tJGitText.get().commitAmendOnInitialNotPossible);\n \n \t\t\tif (headId != null)\n \t\t\t\tif (amend) {\n \t\t\t\t\tRevCommit previousCommit = rw.parseCommit(headId);\n \t\t\t\t\tfor (RevCommit p : previousCommit.getParents())\n \t\t\t\t\t\tparents.add(p.getId());\n \t\t\t\t\tif (author == null)\n \t\t\t\t\t\tauthor = previousCommit.getAuthorIdent();\n \t\t\t\t} else {\n \t\t\t\t\tparents.add(0, headId);\n \t\t\t\t}\n \n \t\t\tif (!noVerify) {\n \t\t\t\tmessage = Hooks.commitMsg(repo, hookOutRedirect)\n \t\t\t\t\t\t.setCommitMessage(message).call();\n \t\t\t}\n \n \t\t\t// lock the index\n \t\t\tDirCache index = repo.lockDirCache();\n \t\t\ttry (ObjectInserter odi = repo.newObjectInserter()) {\n \t\t\t\tif (!only.isEmpty())\n \t\t\t\t\tindex = createTemporaryIndex(headId, index, rw);\n \n \t\t\t\t// Write the index as tree to the object database. This may\n \t\t\t\t// fail for example when the index contains unmerged paths\n \t\t\t\t// (unresolved conflicts)\n \t\t\t\tObjectId indexTreeId = index.writeTree(odi);\n \n \t\t\t\tif (insertChangeId)\n \t\t\t\t\tinsertChangeId(indexTreeId);\n \n \t\t\t\t// Check for empty commits\n \t\t\t\tif (headId != null && !allowEmpty.booleanValue()) {\n \t\t\t\t\tRevCommit headCommit = rw.parseCommit(headId);\n \t\t\t\t\theadCommit.getTree();\n \t\t\t\t\tif (indexTreeId.equals(headCommit.getTree())) {\n \t\t\t\t\t\tthrow new EmtpyCommitException(\n \t\t\t\t\t\t\t\tJGitText.get().emptyCommit);\n \t\t\t\t\t}\n \t\t\t\t}\n \n \t\t\t\t// Create a Commit object, populate it and write it\n \t\t\t\tCommitBuilder commit = new CommitBuilder();\n \t\t\t\tcommit.setCommitter(committer);\n \t\t\t\tcommit.setAuthor(author);\n \t\t\t\tcommit.setMessage(message);\n \n \t\t\t\tcommit.setParentIds(parents);\n \t\t\t\tcommit.setTreeId(indexTreeId);\n \t\t\t\tObjectId commitId = odi.insert(commit);\n \t\t\t\todi.flush();\n \n \t\t\t\tRevCommit revCommit = rw.parseCommit(commitId);\n \t\t\t\tRefUpdate ru = repo.updateRef(Constants.HEAD);\n \t\t\t\tru.setNewObjectId(commitId);\n \t\t\t\tif (!useDefaultReflogMessage) {\n \t\t\t\t\tru.setRefLogMessage(reflogComment, false);\n \t\t\t\t} else {\n \t\t\t\t\tString prefix = amend ? \"commit (amend): \" //$NON-NLS-1$\n \t\t\t\t\t\t\t: parents.size() == 0 ? \"commit (initial): \" //$NON-NLS-1$\n \t\t\t\t\t\t\t\t\t: \"commit: \"; //$NON-NLS-1$\n \t\t\t\t\tru.setRefLogMessage(prefix + revCommit.getShortMessage(),\n \t\t\t\t\t\t\tfalse);\n \t\t\t\t}\n \t\t\t\tif (headId != null)\n \t\t\t\t\tru.setExpectedOldObjectId(headId);\n \t\t\t\telse\n \t\t\t\t\tru.setExpectedOldObjectId(ObjectId.zeroId());\n \t\t\t\tResult rc = ru.forceUpdate();\n \t\t\t\tswitch (rc) {\n \t\t\t\tcase NEW:\n \t\t\t\tcase FORCED:\n \t\t\t\tcase FAST_FORWARD: {\n \t\t\t\t\tsetCallable(false);\n \t\t\t\t\tif (state == RepositoryState.MERGING_RESOLVED\n \t\t\t\t\t\t\t|| isMergeDuringRebase(state)) {\n \t\t\t\t\t\t// Commit was successful. Now delete the files\n \t\t\t\t\t\t// used for merge commits\n \t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n \t\t\t\t\t\trepo.writeMergeHeads(null);\n \t\t\t\t\t} else if (state == RepositoryState.CHERRY_PICKING_RESOLVED) {\n \t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n \t\t\t\t\t\trepo.writeCherryPickHead(null);\n \t\t\t\t\t} else if (state == RepositoryState.REVERTING_RESOLVED) {\n \t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n \t\t\t\t\t\trepo.writeRevertHead(null);\n \t\t\t\t\t}\n \t\t\t\t\treturn revCommit;\n \t\t\t\t}\n \t\t\t\tcase REJECTED:\n \t\t\t\tcase LOCK_FAILURE:\n \t\t\t\t\tthrow new ConcurrentRefUpdateException(\n \t\t\t\t\t\t\tJGitText.get().couldNotLockHEAD, ru.getRef(), rc);\n \t\t\t\tdefault:\n \t\t\t\t\tthrow new JGitInternalException(MessageFormat.format(\n \t\t\t\t\t\t\tJGitText.get().updatingRefFailed, Constants.HEAD,\n \t\t\t\t\t\t\tcommitId.toString(), rc));\n \t\t\t\t}\n \t\t\t} finally {\n \t\t\t\tindex.unlock();\n \t\t\t}\n \t\t} catch (UnmergedPathException e) {\n \t\t\tthrow new UnmergedPathsException(e);\n \t\t} catch (IOException e) {\n \t\t\tthrow new JGitInternalException(\n \t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"36a53d1a3cdd66c40b6db241a75a28293f22f5e1": {
			"type": "Ybodychange",
			"commitMessage": "Fix CommitCommand to be able to skip writing to RefLog\n\nCommitCommand already provided a method to set the comment which should\nbe written into the reflog. The underlying RefUpdate class supported to\nskip writing a reflog entry. But through the CommitCommand API it was\nnot possible to prevent writing a reflog entry. Fix this and allow\ncreating commits which don't occur in the reflog.\n\nChange-Id: I193c53de71fb5958ea749c4bfa8360a51acc9b58\n",
			"commitDate": "2016-04-11, 12:58 AM",
			"commitName": "36a53d1a3cdd66c40b6db241a75a28293f22f5e1",
			"commitAuthor": "Christian Halstrick",
			"commitDateOld": "2016-02-02, 2:27 AM",
			"commitNameOld": "521f513d6d5d43bbf27b976434a4b75c4798d718",
			"commitAuthorOld": "David Pursehouse",
			"daysBetweenCommits": 68.9,
			"commitsBetweenForRepo": 97,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,149 +1,149 @@\n \tpublic RevCommit call() throws GitAPIException, NoHeadException,\n \t\t\tNoMessageException, UnmergedPathsException,\n \t\t\tConcurrentRefUpdateException, WrongRepositoryStateException,\n \t\t\tAbortedByHookException {\n \t\tcheckCallable();\n \t\tCollections.sort(only);\n \n \t\ttry (RevWalk rw = new RevWalk(repo)) {\n \t\t\tRepositoryState state = repo.getRepositoryState();\n \t\t\tif (!state.canCommit())\n \t\t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n \t\t\t\t\t\tJGitText.get().cannotCommitOnARepoWithState,\n \t\t\t\t\t\tstate.name()));\n \n \t\t\tif (!noVerify) {\n \t\t\t\tHooks.preCommit(repo, hookOutRedirect).call();\n \t\t\t}\n \n \t\t\tprocessOptions(state, rw);\n \n \t\t\tif (all && !repo.isBare()) {\n \t\t\t\ttry (Git git = new Git(repo)) {\n \t\t\t\t\tgit.add()\n \t\t\t\t\t\t\t.addFilepattern(\".\") //$NON-NLS-1$\n \t\t\t\t\t\t\t.setUpdate(true).call();\n \t\t\t\t} catch (NoFilepatternException e) {\n \t\t\t\t\t// should really not happen\n \t\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tRef head = repo.getRef(Constants.HEAD);\n \t\t\tif (head == null)\n \t\t\t\tthrow new NoHeadException(\n \t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n \n \t\t\t// determine the current HEAD and the commit it is referring to\n \t\t\tObjectId headId = repo.resolve(Constants.HEAD + \"^{commit}\"); //$NON-NLS-1$\n \t\t\tif (headId == null && amend)\n \t\t\t\tthrow new WrongRepositoryStateException(\n \t\t\t\t\t\tJGitText.get().commitAmendOnInitialNotPossible);\n \n \t\t\tif (headId != null)\n \t\t\t\tif (amend) {\n \t\t\t\t\tRevCommit previousCommit = rw.parseCommit(headId);\n \t\t\t\t\tfor (RevCommit p : previousCommit.getParents())\n \t\t\t\t\t\tparents.add(p.getId());\n \t\t\t\t\tif (author == null)\n \t\t\t\t\t\tauthor = previousCommit.getAuthorIdent();\n \t\t\t\t} else {\n \t\t\t\t\tparents.add(0, headId);\n \t\t\t\t}\n \n \t\t\tif (!noVerify) {\n \t\t\t\tmessage = Hooks.commitMsg(repo, hookOutRedirect)\n \t\t\t\t\t\t.setCommitMessage(message).call();\n \t\t\t}\n \n \t\t\t// lock the index\n \t\t\tDirCache index = repo.lockDirCache();\n \t\t\ttry (ObjectInserter odi = repo.newObjectInserter()) {\n \t\t\t\tif (!only.isEmpty())\n \t\t\t\t\tindex = createTemporaryIndex(headId, index, rw);\n \n \t\t\t\t// Write the index as tree to the object database. This may\n \t\t\t\t// fail for example when the index contains unmerged paths\n \t\t\t\t// (unresolved conflicts)\n \t\t\t\tObjectId indexTreeId = index.writeTree(odi);\n \n \t\t\t\tif (insertChangeId)\n \t\t\t\t\tinsertChangeId(indexTreeId);\n \n \t\t\t\t// Check for empty commits\n \t\t\t\tif (headId != null && !allowEmpty.booleanValue()) {\n \t\t\t\t\tRevCommit headCommit = rw.parseCommit(headId);\n \t\t\t\t\theadCommit.getTree();\n \t\t\t\t\tif (indexTreeId.equals(headCommit.getTree())) {\n \t\t\t\t\t\tthrow new EmtpyCommitException(\n \t\t\t\t\t\t\t\tJGitText.get().emptyCommit);\n \t\t\t\t\t}\n \t\t\t\t}\n \n \t\t\t\t// Create a Commit object, populate it and write it\n \t\t\t\tCommitBuilder commit = new CommitBuilder();\n \t\t\t\tcommit.setCommitter(committer);\n \t\t\t\tcommit.setAuthor(author);\n \t\t\t\tcommit.setMessage(message);\n \n \t\t\t\tcommit.setParentIds(parents);\n \t\t\t\tcommit.setTreeId(indexTreeId);\n \t\t\t\tObjectId commitId = odi.insert(commit);\n \t\t\t\todi.flush();\n \n \t\t\t\tRevCommit revCommit = rw.parseCommit(commitId);\n \t\t\t\tRefUpdate ru = repo.updateRef(Constants.HEAD);\n \t\t\t\tru.setNewObjectId(commitId);\n-\t\t\t\tif (reflogComment != null) {\n+\t\t\t\tif (!useDefaultReflogMessage) {\n \t\t\t\t\tru.setRefLogMessage(reflogComment, false);\n \t\t\t\t} else {\n \t\t\t\t\tString prefix = amend ? \"commit (amend): \" //$NON-NLS-1$\n \t\t\t\t\t\t\t: parents.size() == 0 ? \"commit (initial): \" //$NON-NLS-1$\n \t\t\t\t\t\t\t\t\t: \"commit: \"; //$NON-NLS-1$\n \t\t\t\t\tru.setRefLogMessage(prefix + revCommit.getShortMessage(),\n \t\t\t\t\t\t\tfalse);\n \t\t\t\t}\n \t\t\t\tif (headId != null)\n \t\t\t\t\tru.setExpectedOldObjectId(headId);\n \t\t\t\telse\n \t\t\t\t\tru.setExpectedOldObjectId(ObjectId.zeroId());\n \t\t\t\tResult rc = ru.forceUpdate();\n \t\t\t\tswitch (rc) {\n \t\t\t\tcase NEW:\n \t\t\t\tcase FORCED:\n \t\t\t\tcase FAST_FORWARD: {\n \t\t\t\t\tsetCallable(false);\n \t\t\t\t\tif (state == RepositoryState.MERGING_RESOLVED\n \t\t\t\t\t\t\t|| isMergeDuringRebase(state)) {\n \t\t\t\t\t\t// Commit was successful. Now delete the files\n \t\t\t\t\t\t// used for merge commits\n \t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n \t\t\t\t\t\trepo.writeMergeHeads(null);\n \t\t\t\t\t} else if (state == RepositoryState.CHERRY_PICKING_RESOLVED) {\n \t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n \t\t\t\t\t\trepo.writeCherryPickHead(null);\n \t\t\t\t\t} else if (state == RepositoryState.REVERTING_RESOLVED) {\n \t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n \t\t\t\t\t\trepo.writeRevertHead(null);\n \t\t\t\t\t}\n \t\t\t\t\treturn revCommit;\n \t\t\t\t}\n \t\t\t\tcase REJECTED:\n \t\t\t\tcase LOCK_FAILURE:\n \t\t\t\t\tthrow new ConcurrentRefUpdateException(\n \t\t\t\t\t\t\tJGitText.get().couldNotLockHEAD, ru.getRef(), rc);\n \t\t\t\tdefault:\n \t\t\t\t\tthrow new JGitInternalException(MessageFormat.format(\n \t\t\t\t\t\t\tJGitText.get().updatingRefFailed, Constants.HEAD,\n \t\t\t\t\t\t\tcommitId.toString(), rc));\n \t\t\t\t}\n \t\t\t} finally {\n \t\t\t\tindex.unlock();\n \t\t\t}\n \t\t} catch (UnmergedPathException e) {\n \t\t\tthrow new UnmergedPathsException(e);\n \t\t} catch (IOException e) {\n \t\t\tthrow new JGitInternalException(\n \t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"da43d8d79890e561a993a4d90e6a2724a04cd60f": {
			"type": "Ybodychange",
			"commitMessage": "Add option to allow empty commits to CommitCommand\n\nCommitCommand should allow to specify whether empty commits (commits\nhaving the same tree as the sole predecessor commit) are allowed or not.\nSimilar to native git's \"--allow-empty\" flag.\n\nThe defaults differ between JGit and native git even after this change.\nWhen not specifying paths then by default JGit allows to create empty\ncommits while native git does not. It would be API breaking to change\nthis now.\n\nBug: 460301\nChange-Id: I88feb0c3ffb2c686b1d0594e669729b065cda4cb\nSigned-off-by: Matthias Sohn <matthias.sohn@sap.com>",
			"commitDate": "2016-01-20, 3:14 AM",
			"commitName": "da43d8d79890e561a993a4d90e6a2724a04cd60f",
			"commitAuthor": "Christian Halstrick",
			"commitDateOld": "2016-01-19, 5:45 PM",
			"commitNameOld": "aca07fac464834611bab83b91e828308838f361c",
			"commitAuthorOld": "",
			"daysBetweenCommits": 0.39,
			"commitsBetweenForRepo": 2,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,139 +1,149 @@\n \tpublic RevCommit call() throws GitAPIException, NoHeadException,\n \t\t\tNoMessageException, UnmergedPathsException,\n \t\t\tConcurrentRefUpdateException, WrongRepositoryStateException,\n \t\t\tAbortedByHookException {\n \t\tcheckCallable();\n \t\tCollections.sort(only);\n \n \t\ttry (RevWalk rw = new RevWalk(repo)) {\n \t\t\tRepositoryState state = repo.getRepositoryState();\n \t\t\tif (!state.canCommit())\n \t\t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n \t\t\t\t\t\tJGitText.get().cannotCommitOnARepoWithState,\n \t\t\t\t\t\tstate.name()));\n \n \t\t\tif (!noVerify) {\n \t\t\t\tHooks.preCommit(repo, hookOutRedirect).call();\n \t\t\t}\n \n \t\t\tprocessOptions(state, rw);\n \n \t\t\tif (all && !repo.isBare()) {\n \t\t\t\ttry (Git git = new Git(repo)) {\n \t\t\t\t\tgit.add()\n \t\t\t\t\t\t\t.addFilepattern(\".\") //$NON-NLS-1$\n \t\t\t\t\t\t\t.setUpdate(true).call();\n \t\t\t\t} catch (NoFilepatternException e) {\n \t\t\t\t\t// should really not happen\n \t\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tRef head = repo.getRef(Constants.HEAD);\n \t\t\tif (head == null)\n \t\t\t\tthrow new NoHeadException(\n \t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n \n \t\t\t// determine the current HEAD and the commit it is referring to\n \t\t\tObjectId headId = repo.resolve(Constants.HEAD + \"^{commit}\"); //$NON-NLS-1$\n \t\t\tif (headId == null && amend)\n \t\t\t\tthrow new WrongRepositoryStateException(\n \t\t\t\t\t\tJGitText.get().commitAmendOnInitialNotPossible);\n \n \t\t\tif (headId != null)\n \t\t\t\tif (amend) {\n \t\t\t\t\tRevCommit previousCommit = rw.parseCommit(headId);\n \t\t\t\t\tfor (RevCommit p : previousCommit.getParents())\n \t\t\t\t\t\tparents.add(p.getId());\n \t\t\t\t\tif (author == null)\n \t\t\t\t\t\tauthor = previousCommit.getAuthorIdent();\n \t\t\t\t} else {\n \t\t\t\t\tparents.add(0, headId);\n \t\t\t\t}\n \n \t\t\tif (!noVerify) {\n \t\t\t\tmessage = Hooks.commitMsg(repo, hookOutRedirect)\n \t\t\t\t\t\t.setCommitMessage(message).call();\n \t\t\t}\n \n \t\t\t// lock the index\n \t\t\tDirCache index = repo.lockDirCache();\n \t\t\ttry (ObjectInserter odi = repo.newObjectInserter()) {\n \t\t\t\tif (!only.isEmpty())\n \t\t\t\t\tindex = createTemporaryIndex(headId, index, rw);\n \n \t\t\t\t// Write the index as tree to the object database. This may\n \t\t\t\t// fail for example when the index contains unmerged paths\n \t\t\t\t// (unresolved conflicts)\n \t\t\t\tObjectId indexTreeId = index.writeTree(odi);\n \n \t\t\t\tif (insertChangeId)\n \t\t\t\t\tinsertChangeId(indexTreeId);\n \n+\t\t\t\t// Check for empty commits\n+\t\t\t\tif (headId != null && !allowEmpty.booleanValue()) {\n+\t\t\t\t\tRevCommit headCommit = rw.parseCommit(headId);\n+\t\t\t\t\theadCommit.getTree();\n+\t\t\t\t\tif (indexTreeId.equals(headCommit.getTree())) {\n+\t\t\t\t\t\tthrow new EmtpyCommitException(\n+\t\t\t\t\t\t\t\tJGitText.get().emptyCommit);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\n \t\t\t\t// Create a Commit object, populate it and write it\n \t\t\t\tCommitBuilder commit = new CommitBuilder();\n \t\t\t\tcommit.setCommitter(committer);\n \t\t\t\tcommit.setAuthor(author);\n \t\t\t\tcommit.setMessage(message);\n \n \t\t\t\tcommit.setParentIds(parents);\n \t\t\t\tcommit.setTreeId(indexTreeId);\n \t\t\t\tObjectId commitId = odi.insert(commit);\n \t\t\t\todi.flush();\n \n \t\t\t\tRevCommit revCommit = rw.parseCommit(commitId);\n \t\t\t\tRefUpdate ru = repo.updateRef(Constants.HEAD);\n \t\t\t\tru.setNewObjectId(commitId);\n \t\t\t\tif (reflogComment != null) {\n \t\t\t\t\tru.setRefLogMessage(reflogComment, false);\n \t\t\t\t} else {\n \t\t\t\t\tString prefix = amend ? \"commit (amend): \" //$NON-NLS-1$\n \t\t\t\t\t\t\t: parents.size() == 0 ? \"commit (initial): \" //$NON-NLS-1$\n \t\t\t\t\t\t\t\t\t: \"commit: \"; //$NON-NLS-1$\n \t\t\t\t\tru.setRefLogMessage(prefix + revCommit.getShortMessage(),\n \t\t\t\t\t\t\tfalse);\n \t\t\t\t}\n \t\t\t\tif (headId != null)\n \t\t\t\t\tru.setExpectedOldObjectId(headId);\n \t\t\t\telse\n \t\t\t\t\tru.setExpectedOldObjectId(ObjectId.zeroId());\n \t\t\t\tResult rc = ru.forceUpdate();\n \t\t\t\tswitch (rc) {\n \t\t\t\tcase NEW:\n \t\t\t\tcase FORCED:\n \t\t\t\tcase FAST_FORWARD: {\n \t\t\t\t\tsetCallable(false);\n \t\t\t\t\tif (state == RepositoryState.MERGING_RESOLVED\n \t\t\t\t\t\t\t|| isMergeDuringRebase(state)) {\n \t\t\t\t\t\t// Commit was successful. Now delete the files\n \t\t\t\t\t\t// used for merge commits\n \t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n \t\t\t\t\t\trepo.writeMergeHeads(null);\n \t\t\t\t\t} else if (state == RepositoryState.CHERRY_PICKING_RESOLVED) {\n \t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n \t\t\t\t\t\trepo.writeCherryPickHead(null);\n \t\t\t\t\t} else if (state == RepositoryState.REVERTING_RESOLVED) {\n \t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n \t\t\t\t\t\trepo.writeRevertHead(null);\n \t\t\t\t\t}\n \t\t\t\t\treturn revCommit;\n \t\t\t\t}\n \t\t\t\tcase REJECTED:\n \t\t\t\tcase LOCK_FAILURE:\n \t\t\t\t\tthrow new ConcurrentRefUpdateException(\n \t\t\t\t\t\t\tJGitText.get().couldNotLockHEAD, ru.getRef(), rc);\n \t\t\t\tdefault:\n \t\t\t\t\tthrow new JGitInternalException(MessageFormat.format(\n \t\t\t\t\t\t\tJGitText.get().updatingRefFailed, Constants.HEAD,\n \t\t\t\t\t\t\tcommitId.toString(), rc));\n \t\t\t\t}\n \t\t\t} finally {\n \t\t\t\tindex.unlock();\n \t\t\t}\n \t\t} catch (UnmergedPathException e) {\n \t\t\tthrow new UnmergedPathsException(e);\n \t\t} catch (IOException e) {\n \t\t\tthrow new JGitInternalException(\n \t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"1ed5382b37453309580e11a11cf4c3bb134813fa": {
			"type": "Ybodychange",
			"commitMessage": "CommitCommand: Remove redundant null check\n\nRepository.getWorkTree is annotated as @NonNull, so the check\nfor it returning null is redundant.\n\nChange-Id: I597b0f774ff857b8900519f14a1a17a904cf7c6f\nSigned-off-by: David Pursehouse <david.pursehouse@sonymobile.com>\n",
			"commitDate": "2016-01-13, 11:04 PM",
			"commitName": "1ed5382b37453309580e11a11cf4c3bb134813fa",
			"commitAuthor": "David Pursehouse",
			"commitDateOld": "2015-11-27, 3:23 PM",
			"commitNameOld": "5d9f595eb87fba31c2253051102116fc7876e6c0",
			"commitAuthorOld": "Christian Halstrick",
			"daysBetweenCommits": 47.32,
			"commitsBetweenForRepo": 19,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,139 +1,139 @@\n \tpublic RevCommit call() throws GitAPIException, NoHeadException,\n \t\t\tNoMessageException, UnmergedPathsException,\n \t\t\tConcurrentRefUpdateException, WrongRepositoryStateException,\n \t\t\tAbortedByHookException {\n \t\tcheckCallable();\n \t\tCollections.sort(only);\n \n \t\ttry (RevWalk rw = new RevWalk(repo)) {\n \t\t\tRepositoryState state = repo.getRepositoryState();\n \t\t\tif (!state.canCommit())\n \t\t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n \t\t\t\t\t\tJGitText.get().cannotCommitOnARepoWithState,\n \t\t\t\t\t\tstate.name()));\n \n \t\t\tif (!noVerify) {\n \t\t\t\tHooks.preCommit(repo, hookOutRedirect).call();\n \t\t\t}\n \n \t\t\tprocessOptions(state, rw);\n \n-\t\t\tif (all && !repo.isBare() && repo.getWorkTree() != null) {\n+\t\t\tif (all && !repo.isBare()) {\n \t\t\t\ttry (Git git = new Git(repo)) {\n \t\t\t\t\tgit.add()\n \t\t\t\t\t\t\t.addFilepattern(\".\") //$NON-NLS-1$\n \t\t\t\t\t\t\t.setUpdate(true).call();\n \t\t\t\t} catch (NoFilepatternException e) {\n \t\t\t\t\t// should really not happen\n \t\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tRef head = repo.getRef(Constants.HEAD);\n \t\t\tif (head == null)\n \t\t\t\tthrow new NoHeadException(\n \t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n \n \t\t\t// determine the current HEAD and the commit it is referring to\n \t\t\tObjectId headId = repo.resolve(Constants.HEAD + \"^{commit}\"); //$NON-NLS-1$\n \t\t\tif (headId == null && amend)\n \t\t\t\tthrow new WrongRepositoryStateException(\n \t\t\t\t\t\tJGitText.get().commitAmendOnInitialNotPossible);\n \n \t\t\tif (headId != null)\n \t\t\t\tif (amend) {\n \t\t\t\t\tRevCommit previousCommit = rw.parseCommit(headId);\n \t\t\t\t\tfor (RevCommit p : previousCommit.getParents())\n \t\t\t\t\t\tparents.add(p.getId());\n \t\t\t\t\tif (author == null)\n \t\t\t\t\t\tauthor = previousCommit.getAuthorIdent();\n \t\t\t\t} else {\n \t\t\t\t\tparents.add(0, headId);\n \t\t\t\t}\n \n \t\t\tif (!noVerify) {\n \t\t\t\tmessage = Hooks.commitMsg(repo, hookOutRedirect)\n \t\t\t\t\t\t.setCommitMessage(message).call();\n \t\t\t}\n \n \t\t\t// lock the index\n \t\t\tDirCache index = repo.lockDirCache();\n \t\t\ttry (ObjectInserter odi = repo.newObjectInserter()) {\n \t\t\t\tif (!only.isEmpty())\n \t\t\t\t\tindex = createTemporaryIndex(headId, index, rw);\n \n \t\t\t\t// Write the index as tree to the object database. This may\n \t\t\t\t// fail for example when the index contains unmerged paths\n \t\t\t\t// (unresolved conflicts)\n \t\t\t\tObjectId indexTreeId = index.writeTree(odi);\n \n \t\t\t\tif (insertChangeId)\n \t\t\t\t\tinsertChangeId(indexTreeId);\n \n \t\t\t\t// Create a Commit object, populate it and write it\n \t\t\t\tCommitBuilder commit = new CommitBuilder();\n \t\t\t\tcommit.setCommitter(committer);\n \t\t\t\tcommit.setAuthor(author);\n \t\t\t\tcommit.setMessage(message);\n \n \t\t\t\tcommit.setParentIds(parents);\n \t\t\t\tcommit.setTreeId(indexTreeId);\n \t\t\t\tObjectId commitId = odi.insert(commit);\n \t\t\t\todi.flush();\n \n \t\t\t\tRevCommit revCommit = rw.parseCommit(commitId);\n \t\t\t\tRefUpdate ru = repo.updateRef(Constants.HEAD);\n \t\t\t\tru.setNewObjectId(commitId);\n \t\t\t\tif (reflogComment != null) {\n \t\t\t\t\tru.setRefLogMessage(reflogComment, false);\n \t\t\t\t} else {\n \t\t\t\t\tString prefix = amend ? \"commit (amend): \" //$NON-NLS-1$\n \t\t\t\t\t\t\t: parents.size() == 0 ? \"commit (initial): \" //$NON-NLS-1$\n \t\t\t\t\t\t\t\t\t: \"commit: \"; //$NON-NLS-1$\n \t\t\t\t\tru.setRefLogMessage(prefix + revCommit.getShortMessage(),\n \t\t\t\t\t\t\tfalse);\n \t\t\t\t}\n \t\t\t\tif (headId != null)\n \t\t\t\t\tru.setExpectedOldObjectId(headId);\n \t\t\t\telse\n \t\t\t\t\tru.setExpectedOldObjectId(ObjectId.zeroId());\n \t\t\t\tResult rc = ru.forceUpdate();\n \t\t\t\tswitch (rc) {\n \t\t\t\tcase NEW:\n \t\t\t\tcase FORCED:\n \t\t\t\tcase FAST_FORWARD: {\n \t\t\t\t\tsetCallable(false);\n \t\t\t\t\tif (state == RepositoryState.MERGING_RESOLVED\n \t\t\t\t\t\t\t|| isMergeDuringRebase(state)) {\n \t\t\t\t\t\t// Commit was successful. Now delete the files\n \t\t\t\t\t\t// used for merge commits\n \t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n \t\t\t\t\t\trepo.writeMergeHeads(null);\n \t\t\t\t\t} else if (state == RepositoryState.CHERRY_PICKING_RESOLVED) {\n \t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n \t\t\t\t\t\trepo.writeCherryPickHead(null);\n \t\t\t\t\t} else if (state == RepositoryState.REVERTING_RESOLVED) {\n \t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n \t\t\t\t\t\trepo.writeRevertHead(null);\n \t\t\t\t\t}\n \t\t\t\t\treturn revCommit;\n \t\t\t\t}\n \t\t\t\tcase REJECTED:\n \t\t\t\tcase LOCK_FAILURE:\n \t\t\t\t\tthrow new ConcurrentRefUpdateException(\n \t\t\t\t\t\t\tJGitText.get().couldNotLockHEAD, ru.getRef(), rc);\n \t\t\t\tdefault:\n \t\t\t\t\tthrow new JGitInternalException(MessageFormat.format(\n \t\t\t\t\t\t\tJGitText.get().updatingRefFailed, Constants.HEAD,\n \t\t\t\t\t\t\tcommitId.toString(), rc));\n \t\t\t\t}\n \t\t\t} finally {\n \t\t\t\tindex.unlock();\n \t\t\t}\n \t\t} catch (UnmergedPathException e) {\n \t\t\tthrow new UnmergedPathsException(e);\n \t\t} catch (IOException e) {\n \t\t\tthrow new JGitInternalException(\n \t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"d726f0c1e02c196e2dd87de53b54338be15503f1": {
			"type": "Ybodychange",
			"commitMessage": "Use try-with-resource to close resources in CommitCommand\n\nChange-Id: Ibbbc74acfd050f28e68f318970660b5959caf7e3\nSigned-off-by: Matthias Sohn <matthias.sohn@sap.com>",
			"commitDate": "2015-04-08, 2:53 PM",
			"commitName": "d726f0c1e02c196e2dd87de53b54338be15503f1",
			"commitAuthor": "Matthias Sohn",
			"commitDateOld": "2015-03-02, 9:45 AM",
			"commitNameOld": "efeb02bf2bed32ef94d5c4891404f551cdc6957f",
			"commitAuthorOld": "Laurent Delaigue",
			"daysBetweenCommits": 37.17,
			"commitsBetweenForRepo": 74,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,150 +1,139 @@\n \tpublic RevCommit call() throws GitAPIException, NoHeadException,\n \t\t\tNoMessageException, UnmergedPathsException,\n \t\t\tConcurrentRefUpdateException, WrongRepositoryStateException,\n \t\t\tAbortedByHookException {\n \t\tcheckCallable();\n \t\tCollections.sort(only);\n \n-\t\tRevWalk rw = new RevWalk(repo);\n-\n-\t\ttry {\n+\t\ttry (RevWalk rw = new RevWalk(repo)) {\n \t\t\tRepositoryState state = repo.getRepositoryState();\n \t\t\tif (!state.canCommit())\n \t\t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n \t\t\t\t\t\tJGitText.get().cannotCommitOnARepoWithState,\n \t\t\t\t\t\tstate.name()));\n \n \t\t\tif (!noVerify) {\n \t\t\t\tHooks.preCommit(repo, hookOutRedirect).call();\n \t\t\t}\n \n \t\t\tprocessOptions(state, rw);\n \n \t\t\tif (all && !repo.isBare() && repo.getWorkTree() != null) {\n-\t\t\t\tGit git = new Git(repo);\n-\t\t\t\ttry {\n+\t\t\t\ttry (Git git = new Git(repo)) {\n \t\t\t\t\tgit.add()\n \t\t\t\t\t\t\t.addFilepattern(\".\") //$NON-NLS-1$\n \t\t\t\t\t\t\t.setUpdate(true).call();\n \t\t\t\t} catch (NoFilepatternException e) {\n \t\t\t\t\t// should really not happen\n \t\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tRef head = repo.getRef(Constants.HEAD);\n \t\t\tif (head == null)\n \t\t\t\tthrow new NoHeadException(\n \t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n \n \t\t\t// determine the current HEAD and the commit it is referring to\n \t\t\tObjectId headId = repo.resolve(Constants.HEAD + \"^{commit}\"); //$NON-NLS-1$\n \t\t\tif (headId == null && amend)\n \t\t\t\tthrow new WrongRepositoryStateException(\n \t\t\t\t\t\tJGitText.get().commitAmendOnInitialNotPossible);\n \n \t\t\tif (headId != null)\n \t\t\t\tif (amend) {\n \t\t\t\t\tRevCommit previousCommit = rw.parseCommit(headId);\n \t\t\t\t\tfor (RevCommit p : previousCommit.getParents())\n \t\t\t\t\t\tparents.add(p.getId());\n \t\t\t\t\tif (author == null)\n \t\t\t\t\t\tauthor = previousCommit.getAuthorIdent();\n \t\t\t\t} else {\n \t\t\t\t\tparents.add(0, headId);\n \t\t\t\t}\n \n \t\t\tif (!noVerify) {\n \t\t\t\tmessage = Hooks.commitMsg(repo, hookOutRedirect)\n \t\t\t\t\t\t.setCommitMessage(message).call();\n \t\t\t}\n \n \t\t\t// lock the index\n \t\t\tDirCache index = repo.lockDirCache();\n-\t\t\ttry {\n+\t\t\ttry (ObjectInserter odi = repo.newObjectInserter()) {\n \t\t\t\tif (!only.isEmpty())\n \t\t\t\t\tindex = createTemporaryIndex(headId, index, rw);\n \n-\t\t\t\tObjectInserter odi = repo.newObjectInserter();\n-\t\t\t\ttry {\n-\t\t\t\t\t// Write the index as tree to the object database. This may\n-\t\t\t\t\t// fail for example when the index contains unmerged paths\n-\t\t\t\t\t// (unresolved conflicts)\n-\t\t\t\t\tObjectId indexTreeId = index.writeTree(odi);\n+\t\t\t\t// Write the index as tree to the object database. This may\n+\t\t\t\t// fail for example when the index contains unmerged paths\n+\t\t\t\t// (unresolved conflicts)\n+\t\t\t\tObjectId indexTreeId = index.writeTree(odi);\n \n-\t\t\t\t\tif (insertChangeId)\n-\t\t\t\t\t\tinsertChangeId(indexTreeId);\n+\t\t\t\tif (insertChangeId)\n+\t\t\t\t\tinsertChangeId(indexTreeId);\n \n-\t\t\t\t\t// Create a Commit object, populate it and write it\n-\t\t\t\t\tCommitBuilder commit = new CommitBuilder();\n-\t\t\t\t\tcommit.setCommitter(committer);\n-\t\t\t\t\tcommit.setAuthor(author);\n-\t\t\t\t\tcommit.setMessage(message);\n+\t\t\t\t// Create a Commit object, populate it and write it\n+\t\t\t\tCommitBuilder commit = new CommitBuilder();\n+\t\t\t\tcommit.setCommitter(committer);\n+\t\t\t\tcommit.setAuthor(author);\n+\t\t\t\tcommit.setMessage(message);\n \n-\t\t\t\t\tcommit.setParentIds(parents);\n-\t\t\t\t\tcommit.setTreeId(indexTreeId);\n-\t\t\t\t\tObjectId commitId = odi.insert(commit);\n-\t\t\t\t\todi.flush();\n+\t\t\t\tcommit.setParentIds(parents);\n+\t\t\t\tcommit.setTreeId(indexTreeId);\n+\t\t\t\tObjectId commitId = odi.insert(commit);\n+\t\t\t\todi.flush();\n \n-\t\t\t\t\tRevCommit revCommit = rw.parseCommit(commitId);\n-\t\t\t\t\tRefUpdate ru = repo.updateRef(Constants.HEAD);\n-\t\t\t\t\tru.setNewObjectId(commitId);\n-\t\t\t\t\tif (reflogComment != null) {\n-\t\t\t\t\t\tru.setRefLogMessage(reflogComment, false);\n-\t\t\t\t\t} else {\n-\t\t\t\t\t\tString prefix = amend ? \"commit (amend): \" //$NON-NLS-1$\n-\t\t\t\t\t\t\t\t: parents.size() == 0 ? \"commit (initial): \" //$NON-NLS-1$\n-\t\t\t\t\t\t\t\t\t\t: \"commit: \"; //$NON-NLS-1$\n-\t\t\t\t\t\tru.setRefLogMessage(\n-\t\t\t\t\t\t\t\tprefix + revCommit.getShortMessage(), false);\n+\t\t\t\tRevCommit revCommit = rw.parseCommit(commitId);\n+\t\t\t\tRefUpdate ru = repo.updateRef(Constants.HEAD);\n+\t\t\t\tru.setNewObjectId(commitId);\n+\t\t\t\tif (reflogComment != null) {\n+\t\t\t\t\tru.setRefLogMessage(reflogComment, false);\n+\t\t\t\t} else {\n+\t\t\t\t\tString prefix = amend ? \"commit (amend): \" //$NON-NLS-1$\n+\t\t\t\t\t\t\t: parents.size() == 0 ? \"commit (initial): \" //$NON-NLS-1$\n+\t\t\t\t\t\t\t\t\t: \"commit: \"; //$NON-NLS-1$\n+\t\t\t\t\tru.setRefLogMessage(prefix + revCommit.getShortMessage(),\n+\t\t\t\t\t\t\tfalse);\n+\t\t\t\t}\n+\t\t\t\tif (headId != null)\n+\t\t\t\t\tru.setExpectedOldObjectId(headId);\n+\t\t\t\telse\n+\t\t\t\t\tru.setExpectedOldObjectId(ObjectId.zeroId());\n+\t\t\t\tResult rc = ru.forceUpdate();\n+\t\t\t\tswitch (rc) {\n+\t\t\t\tcase NEW:\n+\t\t\t\tcase FORCED:\n+\t\t\t\tcase FAST_FORWARD: {\n+\t\t\t\t\tsetCallable(false);\n+\t\t\t\t\tif (state == RepositoryState.MERGING_RESOLVED\n+\t\t\t\t\t\t\t|| isMergeDuringRebase(state)) {\n+\t\t\t\t\t\t// Commit was successful. Now delete the files\n+\t\t\t\t\t\t// used for merge commits\n+\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n+\t\t\t\t\t\trepo.writeMergeHeads(null);\n+\t\t\t\t\t} else if (state == RepositoryState.CHERRY_PICKING_RESOLVED) {\n+\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n+\t\t\t\t\t\trepo.writeCherryPickHead(null);\n+\t\t\t\t\t} else if (state == RepositoryState.REVERTING_RESOLVED) {\n+\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n+\t\t\t\t\t\trepo.writeRevertHead(null);\n \t\t\t\t\t}\n-\t\t\t\t\tif (headId != null)\n-\t\t\t\t\t\tru.setExpectedOldObjectId(headId);\n-\t\t\t\t\telse\n-\t\t\t\t\t\tru.setExpectedOldObjectId(ObjectId.zeroId());\n-\t\t\t\t\tResult rc = ru.forceUpdate();\n-\t\t\t\t\tswitch (rc) {\n-\t\t\t\t\tcase NEW:\n-\t\t\t\t\tcase FORCED:\n-\t\t\t\t\tcase FAST_FORWARD: {\n-\t\t\t\t\t\tsetCallable(false);\n-\t\t\t\t\t\tif (state == RepositoryState.MERGING_RESOLVED\n-\t\t\t\t\t\t\t\t|| isMergeDuringRebase(state)) {\n-\t\t\t\t\t\t\t// Commit was successful. Now delete the files\n-\t\t\t\t\t\t\t// used for merge commits\n-\t\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n-\t\t\t\t\t\t\trepo.writeMergeHeads(null);\n-\t\t\t\t\t\t} else if (state == RepositoryState.CHERRY_PICKING_RESOLVED) {\n-\t\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n-\t\t\t\t\t\t\trepo.writeCherryPickHead(null);\n-\t\t\t\t\t\t} else if (state == RepositoryState.REVERTING_RESOLVED) {\n-\t\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n-\t\t\t\t\t\t\trepo.writeRevertHead(null);\n-\t\t\t\t\t\t}\n-\t\t\t\t\t\treturn revCommit;\n-\t\t\t\t\t}\n-\t\t\t\t\tcase REJECTED:\n-\t\t\t\t\tcase LOCK_FAILURE:\n-\t\t\t\t\t\tthrow new ConcurrentRefUpdateException(\n-\t\t\t\t\t\t\t\tJGitText.get().couldNotLockHEAD, ru.getRef(),\n-\t\t\t\t\t\t\t\trc);\n-\t\t\t\t\tdefault:\n-\t\t\t\t\t\tthrow new JGitInternalException(MessageFormat.format(\n-\t\t\t\t\t\t\t\tJGitText.get().updatingRefFailed,\n-\t\t\t\t\t\t\t\tConstants.HEAD, commitId.toString(), rc));\n-\t\t\t\t\t}\n-\t\t\t\t} finally {\n-\t\t\t\t\todi.release();\n+\t\t\t\t\treturn revCommit;\n+\t\t\t\t}\n+\t\t\t\tcase REJECTED:\n+\t\t\t\tcase LOCK_FAILURE:\n+\t\t\t\t\tthrow new ConcurrentRefUpdateException(\n+\t\t\t\t\t\t\tJGitText.get().couldNotLockHEAD, ru.getRef(), rc);\n+\t\t\t\tdefault:\n+\t\t\t\t\tthrow new JGitInternalException(MessageFormat.format(\n+\t\t\t\t\t\t\tJGitText.get().updatingRefFailed, Constants.HEAD,\n+\t\t\t\t\t\t\tcommitId.toString(), rc));\n \t\t\t\t}\n \t\t\t} finally {\n \t\t\t\tindex.unlock();\n \t\t\t}\n \t\t} catch (UnmergedPathException e) {\n \t\t\tthrow new UnmergedPathsException(e);\n \t\t} catch (IOException e) {\n \t\t\tthrow new JGitInternalException(\n \t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n-\t\t} finally {\n-\t\t\trw.dispose();\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"efeb02bf2bed32ef94d5c4891404f551cdc6957f": {
			"type": "Ybodychange",
			"commitMessage": "Support for the commit-msg hook.\n\nThis hook uses the file .git/COMMIT_EDITMSG to receive and potentially\nmodify the commit message.\n\nChange-Id: Ibe2faadfb5d3932a5a3da2252d8156c4c04856c7\nSigned-off-by: Laurent Delaigue <laurent.delaigue@obeo.fr>\nSigned-off-by: Matthias Sohn <matthias.sohn@sap.com>",
			"commitDate": "2015-03-02, 9:45 AM",
			"commitName": "efeb02bf2bed32ef94d5c4891404f551cdc6957f",
			"commitAuthor": "Laurent Delaigue",
			"commitDateOld": "2015-03-02, 7:33 AM",
			"commitNameOld": "26fd56f167e6377777e6d46c14779183e4bcb55a",
			"commitAuthorOld": "Laurent Delaigue",
			"daysBetweenCommits": 0.09,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,145 +1,150 @@\n \tpublic RevCommit call() throws GitAPIException, NoHeadException,\n \t\t\tNoMessageException, UnmergedPathsException,\n \t\t\tConcurrentRefUpdateException, WrongRepositoryStateException,\n \t\t\tAbortedByHookException {\n \t\tcheckCallable();\n \t\tCollections.sort(only);\n \n \t\tRevWalk rw = new RevWalk(repo);\n \n \t\ttry {\n \t\t\tRepositoryState state = repo.getRepositoryState();\n \t\t\tif (!state.canCommit())\n \t\t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n \t\t\t\t\t\tJGitText.get().cannotCommitOnARepoWithState,\n \t\t\t\t\t\tstate.name()));\n \n \t\t\tif (!noVerify) {\n \t\t\t\tHooks.preCommit(repo, hookOutRedirect).call();\n \t\t\t}\n \n \t\t\tprocessOptions(state, rw);\n \n \t\t\tif (all && !repo.isBare() && repo.getWorkTree() != null) {\n \t\t\t\tGit git = new Git(repo);\n \t\t\t\ttry {\n \t\t\t\t\tgit.add()\n \t\t\t\t\t\t\t.addFilepattern(\".\") //$NON-NLS-1$\n \t\t\t\t\t\t\t.setUpdate(true).call();\n \t\t\t\t} catch (NoFilepatternException e) {\n \t\t\t\t\t// should really not happen\n \t\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tRef head = repo.getRef(Constants.HEAD);\n \t\t\tif (head == null)\n \t\t\t\tthrow new NoHeadException(\n \t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n \n \t\t\t// determine the current HEAD and the commit it is referring to\n \t\t\tObjectId headId = repo.resolve(Constants.HEAD + \"^{commit}\"); //$NON-NLS-1$\n \t\t\tif (headId == null && amend)\n \t\t\t\tthrow new WrongRepositoryStateException(\n \t\t\t\t\t\tJGitText.get().commitAmendOnInitialNotPossible);\n \n \t\t\tif (headId != null)\n \t\t\t\tif (amend) {\n \t\t\t\t\tRevCommit previousCommit = rw.parseCommit(headId);\n \t\t\t\t\tfor (RevCommit p : previousCommit.getParents())\n \t\t\t\t\t\tparents.add(p.getId());\n \t\t\t\t\tif (author == null)\n \t\t\t\t\t\tauthor = previousCommit.getAuthorIdent();\n \t\t\t\t} else {\n \t\t\t\t\tparents.add(0, headId);\n \t\t\t\t}\n \n+\t\t\tif (!noVerify) {\n+\t\t\t\tmessage = Hooks.commitMsg(repo, hookOutRedirect)\n+\t\t\t\t\t\t.setCommitMessage(message).call();\n+\t\t\t}\n+\n \t\t\t// lock the index\n \t\t\tDirCache index = repo.lockDirCache();\n \t\t\ttry {\n \t\t\t\tif (!only.isEmpty())\n \t\t\t\t\tindex = createTemporaryIndex(headId, index, rw);\n \n \t\t\t\tObjectInserter odi = repo.newObjectInserter();\n \t\t\t\ttry {\n \t\t\t\t\t// Write the index as tree to the object database. This may\n \t\t\t\t\t// fail for example when the index contains unmerged paths\n \t\t\t\t\t// (unresolved conflicts)\n \t\t\t\t\tObjectId indexTreeId = index.writeTree(odi);\n \n \t\t\t\t\tif (insertChangeId)\n \t\t\t\t\t\tinsertChangeId(indexTreeId);\n \n \t\t\t\t\t// Create a Commit object, populate it and write it\n \t\t\t\t\tCommitBuilder commit = new CommitBuilder();\n \t\t\t\t\tcommit.setCommitter(committer);\n \t\t\t\t\tcommit.setAuthor(author);\n \t\t\t\t\tcommit.setMessage(message);\n \n \t\t\t\t\tcommit.setParentIds(parents);\n \t\t\t\t\tcommit.setTreeId(indexTreeId);\n \t\t\t\t\tObjectId commitId = odi.insert(commit);\n \t\t\t\t\todi.flush();\n \n \t\t\t\t\tRevCommit revCommit = rw.parseCommit(commitId);\n \t\t\t\t\tRefUpdate ru = repo.updateRef(Constants.HEAD);\n \t\t\t\t\tru.setNewObjectId(commitId);\n \t\t\t\t\tif (reflogComment != null) {\n \t\t\t\t\t\tru.setRefLogMessage(reflogComment, false);\n \t\t\t\t\t} else {\n \t\t\t\t\t\tString prefix = amend ? \"commit (amend): \" //$NON-NLS-1$\n \t\t\t\t\t\t\t\t: parents.size() == 0 ? \"commit (initial): \" //$NON-NLS-1$\n \t\t\t\t\t\t\t\t\t\t: \"commit: \"; //$NON-NLS-1$\n \t\t\t\t\t\tru.setRefLogMessage(\n \t\t\t\t\t\t\t\tprefix + revCommit.getShortMessage(), false);\n \t\t\t\t\t}\n \t\t\t\t\tif (headId != null)\n \t\t\t\t\t\tru.setExpectedOldObjectId(headId);\n \t\t\t\t\telse\n \t\t\t\t\t\tru.setExpectedOldObjectId(ObjectId.zeroId());\n \t\t\t\t\tResult rc = ru.forceUpdate();\n \t\t\t\t\tswitch (rc) {\n \t\t\t\t\tcase NEW:\n \t\t\t\t\tcase FORCED:\n \t\t\t\t\tcase FAST_FORWARD: {\n \t\t\t\t\t\tsetCallable(false);\n \t\t\t\t\t\tif (state == RepositoryState.MERGING_RESOLVED\n \t\t\t\t\t\t\t\t|| isMergeDuringRebase(state)) {\n \t\t\t\t\t\t\t// Commit was successful. Now delete the files\n \t\t\t\t\t\t\t// used for merge commits\n \t\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n \t\t\t\t\t\t\trepo.writeMergeHeads(null);\n \t\t\t\t\t\t} else if (state == RepositoryState.CHERRY_PICKING_RESOLVED) {\n \t\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n \t\t\t\t\t\t\trepo.writeCherryPickHead(null);\n \t\t\t\t\t\t} else if (state == RepositoryState.REVERTING_RESOLVED) {\n \t\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n \t\t\t\t\t\t\trepo.writeRevertHead(null);\n \t\t\t\t\t\t}\n \t\t\t\t\t\treturn revCommit;\n \t\t\t\t\t}\n \t\t\t\t\tcase REJECTED:\n \t\t\t\t\tcase LOCK_FAILURE:\n \t\t\t\t\t\tthrow new ConcurrentRefUpdateException(\n \t\t\t\t\t\t\t\tJGitText.get().couldNotLockHEAD, ru.getRef(),\n \t\t\t\t\t\t\t\trc);\n \t\t\t\t\tdefault:\n \t\t\t\t\t\tthrow new JGitInternalException(MessageFormat.format(\n \t\t\t\t\t\t\t\tJGitText.get().updatingRefFailed,\n \t\t\t\t\t\t\t\tConstants.HEAD, commitId.toString(), rc));\n \t\t\t\t\t}\n \t\t\t\t} finally {\n \t\t\t\t\todi.release();\n \t\t\t\t}\n \t\t\t} finally {\n \t\t\t\tindex.unlock();\n \t\t\t}\n \t\t} catch (UnmergedPathException e) {\n \t\t\tthrow new UnmergedPathsException(e);\n \t\t} catch (IOException e) {\n \t\t\tthrow new JGitInternalException(\n \t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n \t\t} finally {\n \t\t\trw.dispose();\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"26fd56f167e6377777e6d46c14779183e4bcb55a": {
			"type": "Ymultichange(Yexceptionschange,Ybodychange)",
			"commitMessage": "Refactored pre-commit hook to make it less invasive.\n\nHooks are now obtained via a convenient API like git commands, and\ncallers don't have to check for their existence.\nThe pre-commit hook has been updated accordingly.\n\nChange-Id: I3383ffb10e2f3b588d7367b9139b606ec7f62758\nSigned-off-by: Laurent Delaigue <laurent.delaigue@obeo.fr>\nSigned-off-by: Matthias Sohn <matthias.sohn@sap.com>",
			"commitDate": "2015-03-02, 7:33 AM",
			"commitName": "26fd56f167e6377777e6d46c14779183e4bcb55a",
			"commitAuthor": "Laurent Delaigue",
			"subchanges": [
				{
					"type": "Yexceptionschange",
					"commitMessage": "Refactored pre-commit hook to make it less invasive.\n\nHooks are now obtained via a convenient API like git commands, and\ncallers don't have to check for their existence.\nThe pre-commit hook has been updated accordingly.\n\nChange-Id: I3383ffb10e2f3b588d7367b9139b606ec7f62758\nSigned-off-by: Laurent Delaigue <laurent.delaigue@obeo.fr>\nSigned-off-by: Matthias Sohn <matthias.sohn@sap.com>",
					"commitDate": "2015-03-02, 7:33 AM",
					"commitName": "26fd56f167e6377777e6d46c14779183e4bcb55a",
					"commitAuthor": "Laurent Delaigue",
					"commitDateOld": "2015-02-02, 1:23 PM",
					"commitNameOld": "494e893c541b5cf465b362c69354c08d7a81c249",
					"commitAuthorOld": "Laurent Goubet",
					"daysBetweenCommits": 27.76,
					"commitsBetweenForRepo": 20,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,157 +1,145 @@\n \tpublic RevCommit call() throws GitAPIException, NoHeadException,\n \t\t\tNoMessageException, UnmergedPathsException,\n \t\t\tConcurrentRefUpdateException, WrongRepositoryStateException,\n-\t\t\tRejectCommitException {\n+\t\t\tAbortedByHookException {\n \t\tcheckCallable();\n \t\tCollections.sort(only);\n \n \t\tRevWalk rw = new RevWalk(repo);\n \n \t\ttry {\n \t\t\tRepositoryState state = repo.getRepositoryState();\n \t\t\tif (!state.canCommit())\n \t\t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n \t\t\t\t\t\tJGitText.get().cannotCommitOnARepoWithState,\n \t\t\t\t\t\tstate.name()));\n \n \t\t\tif (!noVerify) {\n-\t\t\t\tfinal ByteArrayOutputStream errorByteArray = new ByteArrayOutputStream();\n-\t\t\t\tfinal PrintStream hookErrRedirect = new PrintStream(\n-\t\t\t\t\t\terrorByteArray);\n-\t\t\t\tProcessResult preCommitHookResult = FS.DETECTED.runIfPresent(\n-\t\t\t\t\t\trepo, Hook.PRE_COMMIT, new String[0], hookOutRedirect,\n-\t\t\t\t\t\thookErrRedirect, null);\n-\t\t\t\tif (preCommitHookResult.getStatus() == ProcessResult.Status.OK\n-\t\t\t\t\t\t&& preCommitHookResult.getExitCode() != 0) {\n-\t\t\t\t\tString errorMessage = MessageFormat.format(\n-\t\t\t\t\t\t\tJGitText.get().commitRejectedByHook, Hook.PRE_COMMIT.getName(),\n-\t\t\t\t\t\t\terrorByteArray.toString());\n-\t\t\t\t\tthrow new RejectCommitException(errorMessage);\n-\t\t\t\t}\n+\t\t\t\tHooks.preCommit(repo, hookOutRedirect).call();\n \t\t\t}\n \n \t\t\tprocessOptions(state, rw);\n \n \t\t\tif (all && !repo.isBare() && repo.getWorkTree() != null) {\n \t\t\t\tGit git = new Git(repo);\n \t\t\t\ttry {\n \t\t\t\t\tgit.add()\n \t\t\t\t\t\t\t.addFilepattern(\".\") //$NON-NLS-1$\n \t\t\t\t\t\t\t.setUpdate(true).call();\n \t\t\t\t} catch (NoFilepatternException e) {\n \t\t\t\t\t// should really not happen\n \t\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tRef head = repo.getRef(Constants.HEAD);\n \t\t\tif (head == null)\n \t\t\t\tthrow new NoHeadException(\n \t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n \n \t\t\t// determine the current HEAD and the commit it is referring to\n \t\t\tObjectId headId = repo.resolve(Constants.HEAD + \"^{commit}\"); //$NON-NLS-1$\n \t\t\tif (headId == null && amend)\n \t\t\t\tthrow new WrongRepositoryStateException(\n \t\t\t\t\t\tJGitText.get().commitAmendOnInitialNotPossible);\n \n \t\t\tif (headId != null)\n \t\t\t\tif (amend) {\n \t\t\t\t\tRevCommit previousCommit = rw.parseCommit(headId);\n \t\t\t\t\tfor (RevCommit p : previousCommit.getParents())\n \t\t\t\t\t\tparents.add(p.getId());\n \t\t\t\t\tif (author == null)\n \t\t\t\t\t\tauthor = previousCommit.getAuthorIdent();\n \t\t\t\t} else {\n \t\t\t\t\tparents.add(0, headId);\n \t\t\t\t}\n \n \t\t\t// lock the index\n \t\t\tDirCache index = repo.lockDirCache();\n \t\t\ttry {\n \t\t\t\tif (!only.isEmpty())\n \t\t\t\t\tindex = createTemporaryIndex(headId, index, rw);\n \n \t\t\t\tObjectInserter odi = repo.newObjectInserter();\n \t\t\t\ttry {\n \t\t\t\t\t// Write the index as tree to the object database. This may\n \t\t\t\t\t// fail for example when the index contains unmerged paths\n \t\t\t\t\t// (unresolved conflicts)\n \t\t\t\t\tObjectId indexTreeId = index.writeTree(odi);\n \n \t\t\t\t\tif (insertChangeId)\n \t\t\t\t\t\tinsertChangeId(indexTreeId);\n \n \t\t\t\t\t// Create a Commit object, populate it and write it\n \t\t\t\t\tCommitBuilder commit = new CommitBuilder();\n \t\t\t\t\tcommit.setCommitter(committer);\n \t\t\t\t\tcommit.setAuthor(author);\n \t\t\t\t\tcommit.setMessage(message);\n \n \t\t\t\t\tcommit.setParentIds(parents);\n \t\t\t\t\tcommit.setTreeId(indexTreeId);\n \t\t\t\t\tObjectId commitId = odi.insert(commit);\n \t\t\t\t\todi.flush();\n \n \t\t\t\t\tRevCommit revCommit = rw.parseCommit(commitId);\n \t\t\t\t\tRefUpdate ru = repo.updateRef(Constants.HEAD);\n \t\t\t\t\tru.setNewObjectId(commitId);\n \t\t\t\t\tif (reflogComment != null) {\n \t\t\t\t\t\tru.setRefLogMessage(reflogComment, false);\n \t\t\t\t\t} else {\n \t\t\t\t\t\tString prefix = amend ? \"commit (amend): \" //$NON-NLS-1$\n \t\t\t\t\t\t\t\t: parents.size() == 0 ? \"commit (initial): \" //$NON-NLS-1$\n \t\t\t\t\t\t\t\t\t\t: \"commit: \"; //$NON-NLS-1$\n \t\t\t\t\t\tru.setRefLogMessage(\n \t\t\t\t\t\t\t\tprefix + revCommit.getShortMessage(), false);\n \t\t\t\t\t}\n \t\t\t\t\tif (headId != null)\n \t\t\t\t\t\tru.setExpectedOldObjectId(headId);\n \t\t\t\t\telse\n \t\t\t\t\t\tru.setExpectedOldObjectId(ObjectId.zeroId());\n \t\t\t\t\tResult rc = ru.forceUpdate();\n \t\t\t\t\tswitch (rc) {\n \t\t\t\t\tcase NEW:\n \t\t\t\t\tcase FORCED:\n \t\t\t\t\tcase FAST_FORWARD: {\n \t\t\t\t\t\tsetCallable(false);\n \t\t\t\t\t\tif (state == RepositoryState.MERGING_RESOLVED\n \t\t\t\t\t\t\t\t|| isMergeDuringRebase(state)) {\n \t\t\t\t\t\t\t// Commit was successful. Now delete the files\n \t\t\t\t\t\t\t// used for merge commits\n \t\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n \t\t\t\t\t\t\trepo.writeMergeHeads(null);\n \t\t\t\t\t\t} else if (state == RepositoryState.CHERRY_PICKING_RESOLVED) {\n \t\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n \t\t\t\t\t\t\trepo.writeCherryPickHead(null);\n \t\t\t\t\t\t} else if (state == RepositoryState.REVERTING_RESOLVED) {\n \t\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n \t\t\t\t\t\t\trepo.writeRevertHead(null);\n \t\t\t\t\t\t}\n \t\t\t\t\t\treturn revCommit;\n \t\t\t\t\t}\n \t\t\t\t\tcase REJECTED:\n \t\t\t\t\tcase LOCK_FAILURE:\n \t\t\t\t\t\tthrow new ConcurrentRefUpdateException(\n \t\t\t\t\t\t\t\tJGitText.get().couldNotLockHEAD, ru.getRef(),\n \t\t\t\t\t\t\t\trc);\n \t\t\t\t\tdefault:\n \t\t\t\t\t\tthrow new JGitInternalException(MessageFormat.format(\n \t\t\t\t\t\t\t\tJGitText.get().updatingRefFailed,\n \t\t\t\t\t\t\t\tConstants.HEAD, commitId.toString(), rc));\n \t\t\t\t\t}\n \t\t\t\t} finally {\n \t\t\t\t\todi.release();\n \t\t\t\t}\n \t\t\t} finally {\n \t\t\t\tindex.unlock();\n \t\t\t}\n \t\t} catch (UnmergedPathException e) {\n \t\t\tthrow new UnmergedPathsException(e);\n \t\t} catch (IOException e) {\n \t\t\tthrow new JGitInternalException(\n \t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n \t\t} finally {\n \t\t\trw.dispose();\n \t\t}\n \t}\n\\ No newline at end of file\n",
					"extendedDetails": {
						"oldValue": "[GitAPIException, NoHeadException, NoMessageException, UnmergedPathsException, ConcurrentRefUpdateException, WrongRepositoryStateException, RejectCommitException]",
						"newValue": "[GitAPIException, NoHeadException, NoMessageException, UnmergedPathsException, ConcurrentRefUpdateException, WrongRepositoryStateException, AbortedByHookException]"
					}
				},
				{
					"type": "Ybodychange",
					"commitMessage": "Refactored pre-commit hook to make it less invasive.\n\nHooks are now obtained via a convenient API like git commands, and\ncallers don't have to check for their existence.\nThe pre-commit hook has been updated accordingly.\n\nChange-Id: I3383ffb10e2f3b588d7367b9139b606ec7f62758\nSigned-off-by: Laurent Delaigue <laurent.delaigue@obeo.fr>\nSigned-off-by: Matthias Sohn <matthias.sohn@sap.com>",
					"commitDate": "2015-03-02, 7:33 AM",
					"commitName": "26fd56f167e6377777e6d46c14779183e4bcb55a",
					"commitAuthor": "Laurent Delaigue",
					"commitDateOld": "2015-02-02, 1:23 PM",
					"commitNameOld": "494e893c541b5cf465b362c69354c08d7a81c249",
					"commitAuthorOld": "Laurent Goubet",
					"daysBetweenCommits": 27.76,
					"commitsBetweenForRepo": 20,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,157 +1,145 @@\n \tpublic RevCommit call() throws GitAPIException, NoHeadException,\n \t\t\tNoMessageException, UnmergedPathsException,\n \t\t\tConcurrentRefUpdateException, WrongRepositoryStateException,\n-\t\t\tRejectCommitException {\n+\t\t\tAbortedByHookException {\n \t\tcheckCallable();\n \t\tCollections.sort(only);\n \n \t\tRevWalk rw = new RevWalk(repo);\n \n \t\ttry {\n \t\t\tRepositoryState state = repo.getRepositoryState();\n \t\t\tif (!state.canCommit())\n \t\t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n \t\t\t\t\t\tJGitText.get().cannotCommitOnARepoWithState,\n \t\t\t\t\t\tstate.name()));\n \n \t\t\tif (!noVerify) {\n-\t\t\t\tfinal ByteArrayOutputStream errorByteArray = new ByteArrayOutputStream();\n-\t\t\t\tfinal PrintStream hookErrRedirect = new PrintStream(\n-\t\t\t\t\t\terrorByteArray);\n-\t\t\t\tProcessResult preCommitHookResult = FS.DETECTED.runIfPresent(\n-\t\t\t\t\t\trepo, Hook.PRE_COMMIT, new String[0], hookOutRedirect,\n-\t\t\t\t\t\thookErrRedirect, null);\n-\t\t\t\tif (preCommitHookResult.getStatus() == ProcessResult.Status.OK\n-\t\t\t\t\t\t&& preCommitHookResult.getExitCode() != 0) {\n-\t\t\t\t\tString errorMessage = MessageFormat.format(\n-\t\t\t\t\t\t\tJGitText.get().commitRejectedByHook, Hook.PRE_COMMIT.getName(),\n-\t\t\t\t\t\t\terrorByteArray.toString());\n-\t\t\t\t\tthrow new RejectCommitException(errorMessage);\n-\t\t\t\t}\n+\t\t\t\tHooks.preCommit(repo, hookOutRedirect).call();\n \t\t\t}\n \n \t\t\tprocessOptions(state, rw);\n \n \t\t\tif (all && !repo.isBare() && repo.getWorkTree() != null) {\n \t\t\t\tGit git = new Git(repo);\n \t\t\t\ttry {\n \t\t\t\t\tgit.add()\n \t\t\t\t\t\t\t.addFilepattern(\".\") //$NON-NLS-1$\n \t\t\t\t\t\t\t.setUpdate(true).call();\n \t\t\t\t} catch (NoFilepatternException e) {\n \t\t\t\t\t// should really not happen\n \t\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tRef head = repo.getRef(Constants.HEAD);\n \t\t\tif (head == null)\n \t\t\t\tthrow new NoHeadException(\n \t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n \n \t\t\t// determine the current HEAD and the commit it is referring to\n \t\t\tObjectId headId = repo.resolve(Constants.HEAD + \"^{commit}\"); //$NON-NLS-1$\n \t\t\tif (headId == null && amend)\n \t\t\t\tthrow new WrongRepositoryStateException(\n \t\t\t\t\t\tJGitText.get().commitAmendOnInitialNotPossible);\n \n \t\t\tif (headId != null)\n \t\t\t\tif (amend) {\n \t\t\t\t\tRevCommit previousCommit = rw.parseCommit(headId);\n \t\t\t\t\tfor (RevCommit p : previousCommit.getParents())\n \t\t\t\t\t\tparents.add(p.getId());\n \t\t\t\t\tif (author == null)\n \t\t\t\t\t\tauthor = previousCommit.getAuthorIdent();\n \t\t\t\t} else {\n \t\t\t\t\tparents.add(0, headId);\n \t\t\t\t}\n \n \t\t\t// lock the index\n \t\t\tDirCache index = repo.lockDirCache();\n \t\t\ttry {\n \t\t\t\tif (!only.isEmpty())\n \t\t\t\t\tindex = createTemporaryIndex(headId, index, rw);\n \n \t\t\t\tObjectInserter odi = repo.newObjectInserter();\n \t\t\t\ttry {\n \t\t\t\t\t// Write the index as tree to the object database. This may\n \t\t\t\t\t// fail for example when the index contains unmerged paths\n \t\t\t\t\t// (unresolved conflicts)\n \t\t\t\t\tObjectId indexTreeId = index.writeTree(odi);\n \n \t\t\t\t\tif (insertChangeId)\n \t\t\t\t\t\tinsertChangeId(indexTreeId);\n \n \t\t\t\t\t// Create a Commit object, populate it and write it\n \t\t\t\t\tCommitBuilder commit = new CommitBuilder();\n \t\t\t\t\tcommit.setCommitter(committer);\n \t\t\t\t\tcommit.setAuthor(author);\n \t\t\t\t\tcommit.setMessage(message);\n \n \t\t\t\t\tcommit.setParentIds(parents);\n \t\t\t\t\tcommit.setTreeId(indexTreeId);\n \t\t\t\t\tObjectId commitId = odi.insert(commit);\n \t\t\t\t\todi.flush();\n \n \t\t\t\t\tRevCommit revCommit = rw.parseCommit(commitId);\n \t\t\t\t\tRefUpdate ru = repo.updateRef(Constants.HEAD);\n \t\t\t\t\tru.setNewObjectId(commitId);\n \t\t\t\t\tif (reflogComment != null) {\n \t\t\t\t\t\tru.setRefLogMessage(reflogComment, false);\n \t\t\t\t\t} else {\n \t\t\t\t\t\tString prefix = amend ? \"commit (amend): \" //$NON-NLS-1$\n \t\t\t\t\t\t\t\t: parents.size() == 0 ? \"commit (initial): \" //$NON-NLS-1$\n \t\t\t\t\t\t\t\t\t\t: \"commit: \"; //$NON-NLS-1$\n \t\t\t\t\t\tru.setRefLogMessage(\n \t\t\t\t\t\t\t\tprefix + revCommit.getShortMessage(), false);\n \t\t\t\t\t}\n \t\t\t\t\tif (headId != null)\n \t\t\t\t\t\tru.setExpectedOldObjectId(headId);\n \t\t\t\t\telse\n \t\t\t\t\t\tru.setExpectedOldObjectId(ObjectId.zeroId());\n \t\t\t\t\tResult rc = ru.forceUpdate();\n \t\t\t\t\tswitch (rc) {\n \t\t\t\t\tcase NEW:\n \t\t\t\t\tcase FORCED:\n \t\t\t\t\tcase FAST_FORWARD: {\n \t\t\t\t\t\tsetCallable(false);\n \t\t\t\t\t\tif (state == RepositoryState.MERGING_RESOLVED\n \t\t\t\t\t\t\t\t|| isMergeDuringRebase(state)) {\n \t\t\t\t\t\t\t// Commit was successful. Now delete the files\n \t\t\t\t\t\t\t// used for merge commits\n \t\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n \t\t\t\t\t\t\trepo.writeMergeHeads(null);\n \t\t\t\t\t\t} else if (state == RepositoryState.CHERRY_PICKING_RESOLVED) {\n \t\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n \t\t\t\t\t\t\trepo.writeCherryPickHead(null);\n \t\t\t\t\t\t} else if (state == RepositoryState.REVERTING_RESOLVED) {\n \t\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n \t\t\t\t\t\t\trepo.writeRevertHead(null);\n \t\t\t\t\t\t}\n \t\t\t\t\t\treturn revCommit;\n \t\t\t\t\t}\n \t\t\t\t\tcase REJECTED:\n \t\t\t\t\tcase LOCK_FAILURE:\n \t\t\t\t\t\tthrow new ConcurrentRefUpdateException(\n \t\t\t\t\t\t\t\tJGitText.get().couldNotLockHEAD, ru.getRef(),\n \t\t\t\t\t\t\t\trc);\n \t\t\t\t\tdefault:\n \t\t\t\t\t\tthrow new JGitInternalException(MessageFormat.format(\n \t\t\t\t\t\t\t\tJGitText.get().updatingRefFailed,\n \t\t\t\t\t\t\t\tConstants.HEAD, commitId.toString(), rc));\n \t\t\t\t\t}\n \t\t\t\t} finally {\n \t\t\t\t\todi.release();\n \t\t\t\t}\n \t\t\t} finally {\n \t\t\t\tindex.unlock();\n \t\t\t}\n \t\t} catch (UnmergedPathException e) {\n \t\t\tthrow new UnmergedPathsException(e);\n \t\t} catch (IOException e) {\n \t\t\tthrow new JGitInternalException(\n \t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n \t\t} finally {\n \t\t\trw.dispose();\n \t\t}\n \t}\n\\ No newline at end of file\n",
					"extendedDetails": {}
				}
			]
		},
		"494e893c541b5cf465b362c69354c08d7a81c249": {
			"type": "Ymultichange(Yexceptionschange,Ybodychange)",
			"commitMessage": "Support for the pre-commit hook\n\nIntroduce support for the pre-commit hook into JGit, along with the\n--no-verify commit command option to bypass it when rebasing /\ncherry-picking.\n\nChange-Id: If86df98577fa56c5c03d783579c895a38bee9d18\nSigned-off-by: Laurent Goubet <laurent.goubet@obeo.fr>\nSigned-off-by: Matthias Sohn <matthias.sohn@sap.com>",
			"commitDate": "2015-02-02, 1:23 PM",
			"commitName": "494e893c541b5cf465b362c69354c08d7a81c249",
			"commitAuthor": "Laurent Goubet",
			"subchanges": [
				{
					"type": "Yexceptionschange",
					"commitMessage": "Support for the pre-commit hook\n\nIntroduce support for the pre-commit hook into JGit, along with the\n--no-verify commit command option to bypass it when rebasing /\ncherry-picking.\n\nChange-Id: If86df98577fa56c5c03d783579c895a38bee9d18\nSigned-off-by: Laurent Goubet <laurent.goubet@obeo.fr>\nSigned-off-by: Matthias Sohn <matthias.sohn@sap.com>",
					"commitDate": "2015-02-02, 1:23 PM",
					"commitName": "494e893c541b5cf465b362c69354c08d7a81c249",
					"commitAuthor": "Laurent Goubet",
					"commitDateOld": "2014-07-15, 5:00 PM",
					"commitNameOld": "e0fbae5dc3fc2345383ec373b384fcca10e64f24",
					"commitAuthorOld": "Konrad Kügler",
					"daysBetweenCommits": 201.89,
					"commitsBetweenForRepo": 227,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,140 +1,157 @@\n \tpublic RevCommit call() throws GitAPIException, NoHeadException,\n \t\t\tNoMessageException, UnmergedPathsException,\n-\t\t\tConcurrentRefUpdateException,\n-\t\t\tWrongRepositoryStateException {\n+\t\t\tConcurrentRefUpdateException, WrongRepositoryStateException,\n+\t\t\tRejectCommitException {\n \t\tcheckCallable();\n \t\tCollections.sort(only);\n \n \t\tRevWalk rw = new RevWalk(repo);\n \n \t\ttry {\n \t\t\tRepositoryState state = repo.getRepositoryState();\n \t\t\tif (!state.canCommit())\n \t\t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n \t\t\t\t\t\tJGitText.get().cannotCommitOnARepoWithState,\n \t\t\t\t\t\tstate.name()));\n+\n+\t\t\tif (!noVerify) {\n+\t\t\t\tfinal ByteArrayOutputStream errorByteArray = new ByteArrayOutputStream();\n+\t\t\t\tfinal PrintStream hookErrRedirect = new PrintStream(\n+\t\t\t\t\t\terrorByteArray);\n+\t\t\t\tProcessResult preCommitHookResult = FS.DETECTED.runIfPresent(\n+\t\t\t\t\t\trepo, Hook.PRE_COMMIT, new String[0], hookOutRedirect,\n+\t\t\t\t\t\thookErrRedirect, null);\n+\t\t\t\tif (preCommitHookResult.getStatus() == ProcessResult.Status.OK\n+\t\t\t\t\t\t&& preCommitHookResult.getExitCode() != 0) {\n+\t\t\t\t\tString errorMessage = MessageFormat.format(\n+\t\t\t\t\t\t\tJGitText.get().commitRejectedByHook, Hook.PRE_COMMIT.getName(),\n+\t\t\t\t\t\t\terrorByteArray.toString());\n+\t\t\t\t\tthrow new RejectCommitException(errorMessage);\n+\t\t\t\t}\n+\t\t\t}\n+\n \t\t\tprocessOptions(state, rw);\n \n \t\t\tif (all && !repo.isBare() && repo.getWorkTree() != null) {\n \t\t\t\tGit git = new Git(repo);\n \t\t\t\ttry {\n \t\t\t\t\tgit.add()\n \t\t\t\t\t\t\t.addFilepattern(\".\") //$NON-NLS-1$\n \t\t\t\t\t\t\t.setUpdate(true).call();\n \t\t\t\t} catch (NoFilepatternException e) {\n \t\t\t\t\t// should really not happen\n \t\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tRef head = repo.getRef(Constants.HEAD);\n \t\t\tif (head == null)\n \t\t\t\tthrow new NoHeadException(\n \t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n \n \t\t\t// determine the current HEAD and the commit it is referring to\n \t\t\tObjectId headId = repo.resolve(Constants.HEAD + \"^{commit}\"); //$NON-NLS-1$\n \t\t\tif (headId == null && amend)\n \t\t\t\tthrow new WrongRepositoryStateException(\n \t\t\t\t\t\tJGitText.get().commitAmendOnInitialNotPossible);\n \n \t\t\tif (headId != null)\n \t\t\t\tif (amend) {\n \t\t\t\t\tRevCommit previousCommit = rw.parseCommit(headId);\n \t\t\t\t\tfor (RevCommit p : previousCommit.getParents())\n \t\t\t\t\t\tparents.add(p.getId());\n \t\t\t\t\tif (author == null)\n \t\t\t\t\t\tauthor = previousCommit.getAuthorIdent();\n \t\t\t\t} else {\n \t\t\t\t\tparents.add(0, headId);\n \t\t\t\t}\n \n \t\t\t// lock the index\n \t\t\tDirCache index = repo.lockDirCache();\n \t\t\ttry {\n \t\t\t\tif (!only.isEmpty())\n \t\t\t\t\tindex = createTemporaryIndex(headId, index, rw);\n \n \t\t\t\tObjectInserter odi = repo.newObjectInserter();\n \t\t\t\ttry {\n \t\t\t\t\t// Write the index as tree to the object database. This may\n \t\t\t\t\t// fail for example when the index contains unmerged paths\n \t\t\t\t\t// (unresolved conflicts)\n \t\t\t\t\tObjectId indexTreeId = index.writeTree(odi);\n \n \t\t\t\t\tif (insertChangeId)\n \t\t\t\t\t\tinsertChangeId(indexTreeId);\n \n \t\t\t\t\t// Create a Commit object, populate it and write it\n \t\t\t\t\tCommitBuilder commit = new CommitBuilder();\n \t\t\t\t\tcommit.setCommitter(committer);\n \t\t\t\t\tcommit.setAuthor(author);\n \t\t\t\t\tcommit.setMessage(message);\n \n \t\t\t\t\tcommit.setParentIds(parents);\n \t\t\t\t\tcommit.setTreeId(indexTreeId);\n \t\t\t\t\tObjectId commitId = odi.insert(commit);\n \t\t\t\t\todi.flush();\n \n \t\t\t\t\tRevCommit revCommit = rw.parseCommit(commitId);\n \t\t\t\t\tRefUpdate ru = repo.updateRef(Constants.HEAD);\n \t\t\t\t\tru.setNewObjectId(commitId);\n \t\t\t\t\tif (reflogComment != null) {\n \t\t\t\t\t\tru.setRefLogMessage(reflogComment, false);\n \t\t\t\t\t} else {\n \t\t\t\t\t\tString prefix = amend ? \"commit (amend): \" //$NON-NLS-1$\n \t\t\t\t\t\t\t\t: parents.size() == 0 ? \"commit (initial): \" //$NON-NLS-1$\n \t\t\t\t\t\t\t\t\t\t: \"commit: \"; //$NON-NLS-1$\n \t\t\t\t\t\tru.setRefLogMessage(\n \t\t\t\t\t\t\t\tprefix + revCommit.getShortMessage(), false);\n \t\t\t\t\t}\n \t\t\t\t\tif (headId != null)\n \t\t\t\t\t\tru.setExpectedOldObjectId(headId);\n \t\t\t\t\telse\n \t\t\t\t\t\tru.setExpectedOldObjectId(ObjectId.zeroId());\n \t\t\t\t\tResult rc = ru.forceUpdate();\n \t\t\t\t\tswitch (rc) {\n \t\t\t\t\tcase NEW:\n \t\t\t\t\tcase FORCED:\n \t\t\t\t\tcase FAST_FORWARD: {\n \t\t\t\t\t\tsetCallable(false);\n \t\t\t\t\t\tif (state == RepositoryState.MERGING_RESOLVED\n \t\t\t\t\t\t\t\t|| isMergeDuringRebase(state)) {\n \t\t\t\t\t\t\t// Commit was successful. Now delete the files\n \t\t\t\t\t\t\t// used for merge commits\n \t\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n \t\t\t\t\t\t\trepo.writeMergeHeads(null);\n \t\t\t\t\t\t} else if (state == RepositoryState.CHERRY_PICKING_RESOLVED) {\n \t\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n \t\t\t\t\t\t\trepo.writeCherryPickHead(null);\n \t\t\t\t\t\t} else if (state == RepositoryState.REVERTING_RESOLVED) {\n \t\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n \t\t\t\t\t\t\trepo.writeRevertHead(null);\n \t\t\t\t\t\t}\n \t\t\t\t\t\treturn revCommit;\n \t\t\t\t\t}\n \t\t\t\t\tcase REJECTED:\n \t\t\t\t\tcase LOCK_FAILURE:\n \t\t\t\t\t\tthrow new ConcurrentRefUpdateException(\n \t\t\t\t\t\t\t\tJGitText.get().couldNotLockHEAD, ru.getRef(),\n \t\t\t\t\t\t\t\trc);\n \t\t\t\t\tdefault:\n \t\t\t\t\t\tthrow new JGitInternalException(MessageFormat.format(\n \t\t\t\t\t\t\t\tJGitText.get().updatingRefFailed,\n \t\t\t\t\t\t\t\tConstants.HEAD, commitId.toString(), rc));\n \t\t\t\t\t}\n \t\t\t\t} finally {\n \t\t\t\t\todi.release();\n \t\t\t\t}\n \t\t\t} finally {\n \t\t\t\tindex.unlock();\n \t\t\t}\n \t\t} catch (UnmergedPathException e) {\n \t\t\tthrow new UnmergedPathsException(e);\n \t\t} catch (IOException e) {\n \t\t\tthrow new JGitInternalException(\n \t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n \t\t} finally {\n \t\t\trw.dispose();\n \t\t}\n \t}\n\\ No newline at end of file\n",
					"extendedDetails": {
						"oldValue": "[GitAPIException, NoHeadException, NoMessageException, UnmergedPathsException, ConcurrentRefUpdateException, WrongRepositoryStateException]",
						"newValue": "[GitAPIException, NoHeadException, NoMessageException, UnmergedPathsException, ConcurrentRefUpdateException, WrongRepositoryStateException, RejectCommitException]"
					}
				},
				{
					"type": "Ybodychange",
					"commitMessage": "Support for the pre-commit hook\n\nIntroduce support for the pre-commit hook into JGit, along with the\n--no-verify commit command option to bypass it when rebasing /\ncherry-picking.\n\nChange-Id: If86df98577fa56c5c03d783579c895a38bee9d18\nSigned-off-by: Laurent Goubet <laurent.goubet@obeo.fr>\nSigned-off-by: Matthias Sohn <matthias.sohn@sap.com>",
					"commitDate": "2015-02-02, 1:23 PM",
					"commitName": "494e893c541b5cf465b362c69354c08d7a81c249",
					"commitAuthor": "Laurent Goubet",
					"commitDateOld": "2014-07-15, 5:00 PM",
					"commitNameOld": "e0fbae5dc3fc2345383ec373b384fcca10e64f24",
					"commitAuthorOld": "Konrad Kügler",
					"daysBetweenCommits": 201.89,
					"commitsBetweenForRepo": 227,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,140 +1,157 @@\n \tpublic RevCommit call() throws GitAPIException, NoHeadException,\n \t\t\tNoMessageException, UnmergedPathsException,\n-\t\t\tConcurrentRefUpdateException,\n-\t\t\tWrongRepositoryStateException {\n+\t\t\tConcurrentRefUpdateException, WrongRepositoryStateException,\n+\t\t\tRejectCommitException {\n \t\tcheckCallable();\n \t\tCollections.sort(only);\n \n \t\tRevWalk rw = new RevWalk(repo);\n \n \t\ttry {\n \t\t\tRepositoryState state = repo.getRepositoryState();\n \t\t\tif (!state.canCommit())\n \t\t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n \t\t\t\t\t\tJGitText.get().cannotCommitOnARepoWithState,\n \t\t\t\t\t\tstate.name()));\n+\n+\t\t\tif (!noVerify) {\n+\t\t\t\tfinal ByteArrayOutputStream errorByteArray = new ByteArrayOutputStream();\n+\t\t\t\tfinal PrintStream hookErrRedirect = new PrintStream(\n+\t\t\t\t\t\terrorByteArray);\n+\t\t\t\tProcessResult preCommitHookResult = FS.DETECTED.runIfPresent(\n+\t\t\t\t\t\trepo, Hook.PRE_COMMIT, new String[0], hookOutRedirect,\n+\t\t\t\t\t\thookErrRedirect, null);\n+\t\t\t\tif (preCommitHookResult.getStatus() == ProcessResult.Status.OK\n+\t\t\t\t\t\t&& preCommitHookResult.getExitCode() != 0) {\n+\t\t\t\t\tString errorMessage = MessageFormat.format(\n+\t\t\t\t\t\t\tJGitText.get().commitRejectedByHook, Hook.PRE_COMMIT.getName(),\n+\t\t\t\t\t\t\terrorByteArray.toString());\n+\t\t\t\t\tthrow new RejectCommitException(errorMessage);\n+\t\t\t\t}\n+\t\t\t}\n+\n \t\t\tprocessOptions(state, rw);\n \n \t\t\tif (all && !repo.isBare() && repo.getWorkTree() != null) {\n \t\t\t\tGit git = new Git(repo);\n \t\t\t\ttry {\n \t\t\t\t\tgit.add()\n \t\t\t\t\t\t\t.addFilepattern(\".\") //$NON-NLS-1$\n \t\t\t\t\t\t\t.setUpdate(true).call();\n \t\t\t\t} catch (NoFilepatternException e) {\n \t\t\t\t\t// should really not happen\n \t\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tRef head = repo.getRef(Constants.HEAD);\n \t\t\tif (head == null)\n \t\t\t\tthrow new NoHeadException(\n \t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n \n \t\t\t// determine the current HEAD and the commit it is referring to\n \t\t\tObjectId headId = repo.resolve(Constants.HEAD + \"^{commit}\"); //$NON-NLS-1$\n \t\t\tif (headId == null && amend)\n \t\t\t\tthrow new WrongRepositoryStateException(\n \t\t\t\t\t\tJGitText.get().commitAmendOnInitialNotPossible);\n \n \t\t\tif (headId != null)\n \t\t\t\tif (amend) {\n \t\t\t\t\tRevCommit previousCommit = rw.parseCommit(headId);\n \t\t\t\t\tfor (RevCommit p : previousCommit.getParents())\n \t\t\t\t\t\tparents.add(p.getId());\n \t\t\t\t\tif (author == null)\n \t\t\t\t\t\tauthor = previousCommit.getAuthorIdent();\n \t\t\t\t} else {\n \t\t\t\t\tparents.add(0, headId);\n \t\t\t\t}\n \n \t\t\t// lock the index\n \t\t\tDirCache index = repo.lockDirCache();\n \t\t\ttry {\n \t\t\t\tif (!only.isEmpty())\n \t\t\t\t\tindex = createTemporaryIndex(headId, index, rw);\n \n \t\t\t\tObjectInserter odi = repo.newObjectInserter();\n \t\t\t\ttry {\n \t\t\t\t\t// Write the index as tree to the object database. This may\n \t\t\t\t\t// fail for example when the index contains unmerged paths\n \t\t\t\t\t// (unresolved conflicts)\n \t\t\t\t\tObjectId indexTreeId = index.writeTree(odi);\n \n \t\t\t\t\tif (insertChangeId)\n \t\t\t\t\t\tinsertChangeId(indexTreeId);\n \n \t\t\t\t\t// Create a Commit object, populate it and write it\n \t\t\t\t\tCommitBuilder commit = new CommitBuilder();\n \t\t\t\t\tcommit.setCommitter(committer);\n \t\t\t\t\tcommit.setAuthor(author);\n \t\t\t\t\tcommit.setMessage(message);\n \n \t\t\t\t\tcommit.setParentIds(parents);\n \t\t\t\t\tcommit.setTreeId(indexTreeId);\n \t\t\t\t\tObjectId commitId = odi.insert(commit);\n \t\t\t\t\todi.flush();\n \n \t\t\t\t\tRevCommit revCommit = rw.parseCommit(commitId);\n \t\t\t\t\tRefUpdate ru = repo.updateRef(Constants.HEAD);\n \t\t\t\t\tru.setNewObjectId(commitId);\n \t\t\t\t\tif (reflogComment != null) {\n \t\t\t\t\t\tru.setRefLogMessage(reflogComment, false);\n \t\t\t\t\t} else {\n \t\t\t\t\t\tString prefix = amend ? \"commit (amend): \" //$NON-NLS-1$\n \t\t\t\t\t\t\t\t: parents.size() == 0 ? \"commit (initial): \" //$NON-NLS-1$\n \t\t\t\t\t\t\t\t\t\t: \"commit: \"; //$NON-NLS-1$\n \t\t\t\t\t\tru.setRefLogMessage(\n \t\t\t\t\t\t\t\tprefix + revCommit.getShortMessage(), false);\n \t\t\t\t\t}\n \t\t\t\t\tif (headId != null)\n \t\t\t\t\t\tru.setExpectedOldObjectId(headId);\n \t\t\t\t\telse\n \t\t\t\t\t\tru.setExpectedOldObjectId(ObjectId.zeroId());\n \t\t\t\t\tResult rc = ru.forceUpdate();\n \t\t\t\t\tswitch (rc) {\n \t\t\t\t\tcase NEW:\n \t\t\t\t\tcase FORCED:\n \t\t\t\t\tcase FAST_FORWARD: {\n \t\t\t\t\t\tsetCallable(false);\n \t\t\t\t\t\tif (state == RepositoryState.MERGING_RESOLVED\n \t\t\t\t\t\t\t\t|| isMergeDuringRebase(state)) {\n \t\t\t\t\t\t\t// Commit was successful. Now delete the files\n \t\t\t\t\t\t\t// used for merge commits\n \t\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n \t\t\t\t\t\t\trepo.writeMergeHeads(null);\n \t\t\t\t\t\t} else if (state == RepositoryState.CHERRY_PICKING_RESOLVED) {\n \t\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n \t\t\t\t\t\t\trepo.writeCherryPickHead(null);\n \t\t\t\t\t\t} else if (state == RepositoryState.REVERTING_RESOLVED) {\n \t\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n \t\t\t\t\t\t\trepo.writeRevertHead(null);\n \t\t\t\t\t\t}\n \t\t\t\t\t\treturn revCommit;\n \t\t\t\t\t}\n \t\t\t\t\tcase REJECTED:\n \t\t\t\t\tcase LOCK_FAILURE:\n \t\t\t\t\t\tthrow new ConcurrentRefUpdateException(\n \t\t\t\t\t\t\t\tJGitText.get().couldNotLockHEAD, ru.getRef(),\n \t\t\t\t\t\t\t\trc);\n \t\t\t\t\tdefault:\n \t\t\t\t\t\tthrow new JGitInternalException(MessageFormat.format(\n \t\t\t\t\t\t\t\tJGitText.get().updatingRefFailed,\n \t\t\t\t\t\t\t\tConstants.HEAD, commitId.toString(), rc));\n \t\t\t\t\t}\n \t\t\t\t} finally {\n \t\t\t\t\todi.release();\n \t\t\t\t}\n \t\t\t} finally {\n \t\t\t\tindex.unlock();\n \t\t\t}\n \t\t} catch (UnmergedPathException e) {\n \t\t\tthrow new UnmergedPathsException(e);\n \t\t} catch (IOException e) {\n \t\t\tthrow new JGitInternalException(\n \t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n \t\t} finally {\n \t\t\trw.dispose();\n \t\t}\n \t}\n\\ No newline at end of file\n",
					"extendedDetails": {}
				}
			]
		},
		"e0fbae5dc3fc2345383ec373b384fcca10e64f24": {
			"type": "Ybodychange",
			"commitMessage": "Rebase: Add --preserve-merges support\n\nWith --preserve-merges C Git re-does merges using the rewritten merge\nparents, discarding the old merge commit. For the common use-case of\npull with rebase this is unfortunate, as it loses the merge conflict\nresolution (and other fixes in the merge), which may have taken quite\nsome time to get right in the first place.\n\nTo overcome this we use a two-fold approach:\nIf any of the (non-first) merge parents of a merge were rewritten, we\nalso redo the merge, to include the (potential) new changes in those\ncommits.\nIf only the first parent was rewritten, i.e. we are merging a branch\nthat is otherwise unaffected by the rebase, we instead cherry-pick the\nmerge commit at hand. This is done with the --mainline 1 and --no-commit\noptions to apply the changes introduced by the merge. Then we set up an\nappropriate MERGE_HEAD and commit the result, thus effectively forging a\nmerge.\n\nApart from the approach taken to rebase merge commits, this\nimplementation closely follows C Git. As a result, both Git\nimplementations can continue rebases of each other.\n\nPreserving merges works for both interactive and non-interactive rebase,\nbut as in C Git it is easy do get undesired outcomes with interactive\nrebase.\n\nCommitCommand supports committing merges during rebase now.\n\nBug: 439421\nChange-Id: I4cf69b9d4ec6109d130ab8e3f42fcbdac25a13b2\nSigned-off-by: Konrad Kügler <swamblumat-eclipsebugs@yahoo.de>\n",
			"commitDate": "2014-07-15, 5:00 PM",
			"commitName": "e0fbae5dc3fc2345383ec373b384fcca10e64f24",
			"commitAuthor": "Konrad Kügler",
			"commitDateOld": "2013-11-15, 11:20 AM",
			"commitNameOld": "97b8115be4fd5c8901ce39e53e11b3b425697574",
			"commitAuthorOld": "Robin Stocker",
			"daysBetweenCommits": 242.2,
			"commitsBetweenForRepo": 290,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,139 +1,140 @@\n \tpublic RevCommit call() throws GitAPIException, NoHeadException,\n \t\t\tNoMessageException, UnmergedPathsException,\n \t\t\tConcurrentRefUpdateException,\n \t\t\tWrongRepositoryStateException {\n \t\tcheckCallable();\n \t\tCollections.sort(only);\n \n \t\tRevWalk rw = new RevWalk(repo);\n \n \t\ttry {\n \t\t\tRepositoryState state = repo.getRepositoryState();\n \t\t\tif (!state.canCommit())\n \t\t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n \t\t\t\t\t\tJGitText.get().cannotCommitOnARepoWithState,\n \t\t\t\t\t\tstate.name()));\n \t\t\tprocessOptions(state, rw);\n \n \t\t\tif (all && !repo.isBare() && repo.getWorkTree() != null) {\n \t\t\t\tGit git = new Git(repo);\n \t\t\t\ttry {\n \t\t\t\t\tgit.add()\n \t\t\t\t\t\t\t.addFilepattern(\".\") //$NON-NLS-1$\n \t\t\t\t\t\t\t.setUpdate(true).call();\n \t\t\t\t} catch (NoFilepatternException e) {\n \t\t\t\t\t// should really not happen\n \t\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tRef head = repo.getRef(Constants.HEAD);\n \t\t\tif (head == null)\n \t\t\t\tthrow new NoHeadException(\n \t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n \n \t\t\t// determine the current HEAD and the commit it is referring to\n \t\t\tObjectId headId = repo.resolve(Constants.HEAD + \"^{commit}\"); //$NON-NLS-1$\n \t\t\tif (headId == null && amend)\n \t\t\t\tthrow new WrongRepositoryStateException(\n \t\t\t\t\t\tJGitText.get().commitAmendOnInitialNotPossible);\n \n \t\t\tif (headId != null)\n \t\t\t\tif (amend) {\n \t\t\t\t\tRevCommit previousCommit = rw.parseCommit(headId);\n \t\t\t\t\tfor (RevCommit p : previousCommit.getParents())\n \t\t\t\t\t\tparents.add(p.getId());\n \t\t\t\t\tif (author == null)\n \t\t\t\t\t\tauthor = previousCommit.getAuthorIdent();\n \t\t\t\t} else {\n \t\t\t\t\tparents.add(0, headId);\n \t\t\t\t}\n \n \t\t\t// lock the index\n \t\t\tDirCache index = repo.lockDirCache();\n \t\t\ttry {\n \t\t\t\tif (!only.isEmpty())\n \t\t\t\t\tindex = createTemporaryIndex(headId, index, rw);\n \n \t\t\t\tObjectInserter odi = repo.newObjectInserter();\n \t\t\t\ttry {\n \t\t\t\t\t// Write the index as tree to the object database. This may\n \t\t\t\t\t// fail for example when the index contains unmerged paths\n \t\t\t\t\t// (unresolved conflicts)\n \t\t\t\t\tObjectId indexTreeId = index.writeTree(odi);\n \n \t\t\t\t\tif (insertChangeId)\n \t\t\t\t\t\tinsertChangeId(indexTreeId);\n \n \t\t\t\t\t// Create a Commit object, populate it and write it\n \t\t\t\t\tCommitBuilder commit = new CommitBuilder();\n \t\t\t\t\tcommit.setCommitter(committer);\n \t\t\t\t\tcommit.setAuthor(author);\n \t\t\t\t\tcommit.setMessage(message);\n \n \t\t\t\t\tcommit.setParentIds(parents);\n \t\t\t\t\tcommit.setTreeId(indexTreeId);\n \t\t\t\t\tObjectId commitId = odi.insert(commit);\n \t\t\t\t\todi.flush();\n \n \t\t\t\t\tRevCommit revCommit = rw.parseCommit(commitId);\n \t\t\t\t\tRefUpdate ru = repo.updateRef(Constants.HEAD);\n \t\t\t\t\tru.setNewObjectId(commitId);\n \t\t\t\t\tif (reflogComment != null) {\n \t\t\t\t\t\tru.setRefLogMessage(reflogComment, false);\n \t\t\t\t\t} else {\n \t\t\t\t\t\tString prefix = amend ? \"commit (amend): \" //$NON-NLS-1$\n \t\t\t\t\t\t\t\t: parents.size() == 0 ? \"commit (initial): \" //$NON-NLS-1$\n \t\t\t\t\t\t\t\t\t\t: \"commit: \"; //$NON-NLS-1$\n \t\t\t\t\t\tru.setRefLogMessage(\n \t\t\t\t\t\t\t\tprefix + revCommit.getShortMessage(), false);\n \t\t\t\t\t}\n \t\t\t\t\tif (headId != null)\n \t\t\t\t\t\tru.setExpectedOldObjectId(headId);\n \t\t\t\t\telse\n \t\t\t\t\t\tru.setExpectedOldObjectId(ObjectId.zeroId());\n \t\t\t\t\tResult rc = ru.forceUpdate();\n \t\t\t\t\tswitch (rc) {\n \t\t\t\t\tcase NEW:\n \t\t\t\t\tcase FORCED:\n \t\t\t\t\tcase FAST_FORWARD: {\n \t\t\t\t\t\tsetCallable(false);\n-\t\t\t\t\t\tif (state == RepositoryState.MERGING_RESOLVED) {\n+\t\t\t\t\t\tif (state == RepositoryState.MERGING_RESOLVED\n+\t\t\t\t\t\t\t\t|| isMergeDuringRebase(state)) {\n \t\t\t\t\t\t\t// Commit was successful. Now delete the files\n \t\t\t\t\t\t\t// used for merge commits\n \t\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n \t\t\t\t\t\t\trepo.writeMergeHeads(null);\n \t\t\t\t\t\t} else if (state == RepositoryState.CHERRY_PICKING_RESOLVED) {\n \t\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n \t\t\t\t\t\t\trepo.writeCherryPickHead(null);\n \t\t\t\t\t\t} else if (state == RepositoryState.REVERTING_RESOLVED) {\n \t\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n \t\t\t\t\t\t\trepo.writeRevertHead(null);\n \t\t\t\t\t\t}\n \t\t\t\t\t\treturn revCommit;\n \t\t\t\t\t}\n \t\t\t\t\tcase REJECTED:\n \t\t\t\t\tcase LOCK_FAILURE:\n \t\t\t\t\t\tthrow new ConcurrentRefUpdateException(\n \t\t\t\t\t\t\t\tJGitText.get().couldNotLockHEAD, ru.getRef(),\n \t\t\t\t\t\t\t\trc);\n \t\t\t\t\tdefault:\n \t\t\t\t\t\tthrow new JGitInternalException(MessageFormat.format(\n \t\t\t\t\t\t\t\tJGitText.get().updatingRefFailed,\n \t\t\t\t\t\t\t\tConstants.HEAD, commitId.toString(), rc));\n \t\t\t\t\t}\n \t\t\t\t} finally {\n \t\t\t\t\todi.release();\n \t\t\t\t}\n \t\t\t} finally {\n \t\t\t\tindex.unlock();\n \t\t\t}\n \t\t} catch (UnmergedPathException e) {\n \t\t\tthrow new UnmergedPathsException(e);\n \t\t} catch (IOException e) {\n \t\t\tthrow new JGitInternalException(\n \t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n \t\t} finally {\n \t\t\trw.dispose();\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"a2b33a8ac33c63eea82f300b802a26af54a3d61d": {
			"type": "Ybodychange",
			"commitMessage": "Add NON-NLS comments for some obviously untranslatable strings\n\nChange-Id: I2d1076b46695dac84961b8ae663bfc5cb123b3a3\nSigned-off-by: Chris Aniszczyk <caniszczyk@gmail.com>\n",
			"commitDate": "2013-07-21, 9:06 PM",
			"commitName": "a2b33a8ac33c63eea82f300b802a26af54a3d61d",
			"commitAuthor": "Robin Rosenberg",
			"commitDateOld": "2013-05-11, 2:45 PM",
			"commitNameOld": "c93a59330249677cd990820b59558a39f747009f",
			"commitAuthorOld": "Christian Halstrick",
			"daysBetweenCommits": 71.26,
			"commitsBetweenForRepo": 80,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,139 +1,139 @@\n \tpublic RevCommit call() throws GitAPIException, NoHeadException,\n \t\t\tNoMessageException, UnmergedPathsException,\n \t\t\tConcurrentRefUpdateException,\n \t\t\tWrongRepositoryStateException {\n \t\tcheckCallable();\n \t\tCollections.sort(only);\n \n \t\tRevWalk rw = new RevWalk(repo);\n \n \t\ttry {\n \t\t\tRepositoryState state = repo.getRepositoryState();\n \t\t\tif (!state.canCommit())\n \t\t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n \t\t\t\t\t\tJGitText.get().cannotCommitOnARepoWithState,\n \t\t\t\t\t\tstate.name()));\n \t\t\tprocessOptions(state, rw);\n \n \t\t\tif (all && !repo.isBare() && repo.getWorkTree() != null) {\n \t\t\t\tGit git = new Git(repo);\n \t\t\t\ttry {\n \t\t\t\t\tgit.add()\n \t\t\t\t\t\t\t.addFilepattern(\".\") //$NON-NLS-1$\n \t\t\t\t\t\t\t.setUpdate(true).call();\n \t\t\t\t} catch (NoFilepatternException e) {\n \t\t\t\t\t// should really not happen\n \t\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tRef head = repo.getRef(Constants.HEAD);\n \t\t\tif (head == null)\n \t\t\t\tthrow new NoHeadException(\n \t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n \n \t\t\t// determine the current HEAD and the commit it is referring to\n \t\t\tObjectId headId = repo.resolve(Constants.HEAD + \"^{commit}\"); //$NON-NLS-1$\n \t\t\tif (headId == null && amend)\n \t\t\t\tthrow new WrongRepositoryStateException(\n \t\t\t\t\t\tJGitText.get().commitAmendOnInitialNotPossible);\n \n \t\t\tif (headId != null)\n \t\t\t\tif (amend) {\n \t\t\t\t\tRevCommit previousCommit = rw.parseCommit(headId);\n \t\t\t\t\tfor (RevCommit p : previousCommit.getParents())\n \t\t\t\t\t\tparents.add(p.getId());\n \t\t\t\t\tif (author == null)\n \t\t\t\t\t\tauthor = previousCommit.getAuthorIdent();\n \t\t\t\t} else {\n \t\t\t\t\tparents.add(0, headId);\n \t\t\t\t}\n \n \t\t\t// lock the index\n \t\t\tDirCache index = repo.lockDirCache();\n \t\t\ttry {\n \t\t\t\tif (!only.isEmpty())\n \t\t\t\t\tindex = createTemporaryIndex(headId, index, rw);\n \n \t\t\t\tObjectInserter odi = repo.newObjectInserter();\n \t\t\t\ttry {\n \t\t\t\t\t// Write the index as tree to the object database. This may\n \t\t\t\t\t// fail for example when the index contains unmerged paths\n \t\t\t\t\t// (unresolved conflicts)\n \t\t\t\t\tObjectId indexTreeId = index.writeTree(odi);\n \n \t\t\t\t\tif (insertChangeId)\n \t\t\t\t\t\tinsertChangeId(indexTreeId);\n \n \t\t\t\t\t// Create a Commit object, populate it and write it\n \t\t\t\t\tCommitBuilder commit = new CommitBuilder();\n \t\t\t\t\tcommit.setCommitter(committer);\n \t\t\t\t\tcommit.setAuthor(author);\n \t\t\t\t\tcommit.setMessage(message);\n \n \t\t\t\t\tcommit.setParentIds(parents);\n \t\t\t\t\tcommit.setTreeId(indexTreeId);\n \t\t\t\t\tObjectId commitId = odi.insert(commit);\n \t\t\t\t\todi.flush();\n \n \t\t\t\t\tRevCommit revCommit = rw.parseCommit(commitId);\n \t\t\t\t\tRefUpdate ru = repo.updateRef(Constants.HEAD);\n \t\t\t\t\tru.setNewObjectId(commitId);\n \t\t\t\t\tif (reflogComment != null) {\n \t\t\t\t\t\tru.setRefLogMessage(reflogComment, false);\n \t\t\t\t\t} else {\n \t\t\t\t\t\tString prefix = amend ? \"commit (amend): \" //$NON-NLS-1$\n-\t\t\t\t\t\t\t\t: parents.size() == 0 ? \"commit (initial): \"\n-\t\t\t\t\t\t\t\t\t\t: \"commit: \";\n+\t\t\t\t\t\t\t\t: parents.size() == 0 ? \"commit (initial): \" //$NON-NLS-1$\n+\t\t\t\t\t\t\t\t\t\t: \"commit: \"; //$NON-NLS-1$\n \t\t\t\t\t\tru.setRefLogMessage(\n \t\t\t\t\t\t\t\tprefix + revCommit.getShortMessage(), false);\n \t\t\t\t\t}\n \t\t\t\t\tif (headId != null)\n \t\t\t\t\t\tru.setExpectedOldObjectId(headId);\n \t\t\t\t\telse\n \t\t\t\t\t\tru.setExpectedOldObjectId(ObjectId.zeroId());\n \t\t\t\t\tResult rc = ru.forceUpdate();\n \t\t\t\t\tswitch (rc) {\n \t\t\t\t\tcase NEW:\n \t\t\t\t\tcase FORCED:\n \t\t\t\t\tcase FAST_FORWARD: {\n \t\t\t\t\t\tsetCallable(false);\n \t\t\t\t\t\tif (state == RepositoryState.MERGING_RESOLVED) {\n \t\t\t\t\t\t\t// Commit was successful. Now delete the files\n \t\t\t\t\t\t\t// used for merge commits\n \t\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n \t\t\t\t\t\t\trepo.writeMergeHeads(null);\n \t\t\t\t\t\t} else if (state == RepositoryState.CHERRY_PICKING_RESOLVED) {\n \t\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n \t\t\t\t\t\t\trepo.writeCherryPickHead(null);\n \t\t\t\t\t\t} else if (state == RepositoryState.REVERTING_RESOLVED) {\n \t\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n \t\t\t\t\t\t\trepo.writeRevertHead(null);\n \t\t\t\t\t\t}\n \t\t\t\t\t\treturn revCommit;\n \t\t\t\t\t}\n \t\t\t\t\tcase REJECTED:\n \t\t\t\t\tcase LOCK_FAILURE:\n \t\t\t\t\t\tthrow new ConcurrentRefUpdateException(\n \t\t\t\t\t\t\t\tJGitText.get().couldNotLockHEAD, ru.getRef(),\n \t\t\t\t\t\t\t\trc);\n \t\t\t\t\tdefault:\n \t\t\t\t\t\tthrow new JGitInternalException(MessageFormat.format(\n \t\t\t\t\t\t\t\tJGitText.get().updatingRefFailed,\n \t\t\t\t\t\t\t\tConstants.HEAD, commitId.toString(), rc));\n \t\t\t\t\t}\n \t\t\t\t} finally {\n \t\t\t\t\todi.release();\n \t\t\t\t}\n \t\t\t} finally {\n \t\t\t\tindex.unlock();\n \t\t\t}\n \t\t} catch (UnmergedPathException e) {\n \t\t\tthrow new UnmergedPathsException(e);\n \t\t} catch (IOException e) {\n \t\t\tthrow new JGitInternalException(\n \t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n \t\t} finally {\n \t\t\trw.dispose();\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"c93a59330249677cd990820b59558a39f747009f": {
			"type": "Ybodychange",
			"commitMessage": "Fix CommitCommand not to destroy repo\n\nThere was a severe bug in CommitCommand which could corrupt\nrepos. When merging an annotated tag the JGit MergeCommand writes\ncorrectly the ID of the tag (and not the id of the commit the tag was\npointing to) into MERGE_HEAD. Native git does the same. But\nCommitCommand was reading this file and trusting blindly that it will\ncontain only IDs of commits. Then the CommitCommand created a\ncommit which has as parent a non-commit object (the tag object). That's\nso corrupt that even native git gives up when you call \"git log\" in\nsuch a repo.\n\nTo reproduce that with EGit simply right-click on a tag in the\nRepository View and select Merge. The result was a corrupt repo!\n\nBug: 336291\nChange-Id: I24cd5de19ce6ca7b68b4052c9e73dcc6d207b57c\nSigned-off-by: Matthias Sohn <matthias.sohn@sap.com>",
			"commitDate": "2013-05-11, 2:45 PM",
			"commitName": "c93a59330249677cd990820b59558a39f747009f",
			"commitAuthor": "Christian Halstrick",
			"commitDateOld": "2013-04-02, 1:57 PM",
			"commitNameOld": "65027d8bb429581635f51d0c588493e5c458cc25",
			"commitAuthorOld": "Robin Rosenberg",
			"daysBetweenCommits": 39.03,
			"commitsBetweenForRepo": 88,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,140 +1,139 @@\n \tpublic RevCommit call() throws GitAPIException, NoHeadException,\n \t\t\tNoMessageException, UnmergedPathsException,\n \t\t\tConcurrentRefUpdateException,\n \t\t\tWrongRepositoryStateException {\n \t\tcheckCallable();\n \t\tCollections.sort(only);\n \n-\t\tRepositoryState state = repo.getRepositoryState();\n-\t\tif (!state.canCommit())\n-\t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n-\t\t\t\t\tJGitText.get().cannotCommitOnARepoWithState, state.name()));\n-\t\tprocessOptions(state);\n+\t\tRevWalk rw = new RevWalk(repo);\n \n \t\ttry {\n+\t\t\tRepositoryState state = repo.getRepositoryState();\n+\t\t\tif (!state.canCommit())\n+\t\t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n+\t\t\t\t\t\tJGitText.get().cannotCommitOnARepoWithState,\n+\t\t\t\t\t\tstate.name()));\n+\t\t\tprocessOptions(state, rw);\n+\n \t\t\tif (all && !repo.isBare() && repo.getWorkTree() != null) {\n \t\t\t\tGit git = new Git(repo);\n \t\t\t\ttry {\n \t\t\t\t\tgit.add()\n \t\t\t\t\t\t\t.addFilepattern(\".\") //$NON-NLS-1$\n \t\t\t\t\t\t\t.setUpdate(true).call();\n \t\t\t\t} catch (NoFilepatternException e) {\n \t\t\t\t\t// should really not happen\n \t\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tRef head = repo.getRef(Constants.HEAD);\n \t\t\tif (head == null)\n \t\t\t\tthrow new NoHeadException(\n \t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n \n \t\t\t// determine the current HEAD and the commit it is referring to\n \t\t\tObjectId headId = repo.resolve(Constants.HEAD + \"^{commit}\"); //$NON-NLS-1$\n \t\t\tif (headId == null && amend)\n \t\t\t\tthrow new WrongRepositoryStateException(\n \t\t\t\t\t\tJGitText.get().commitAmendOnInitialNotPossible);\n \n \t\t\tif (headId != null)\n \t\t\t\tif (amend) {\n-\t\t\t\t\tRevCommit previousCommit = new RevWalk(repo)\n-\t\t\t\t\t\t\t.parseCommit(headId);\n+\t\t\t\t\tRevCommit previousCommit = rw.parseCommit(headId);\n \t\t\t\t\tfor (RevCommit p : previousCommit.getParents())\n \t\t\t\t\t\tparents.add(p.getId());\n \t\t\t\t\tif (author == null)\n \t\t\t\t\t\tauthor = previousCommit.getAuthorIdent();\n \t\t\t\t} else {\n \t\t\t\t\tparents.add(0, headId);\n \t\t\t\t}\n \n \t\t\t// lock the index\n \t\t\tDirCache index = repo.lockDirCache();\n \t\t\ttry {\n \t\t\t\tif (!only.isEmpty())\n-\t\t\t\t\tindex = createTemporaryIndex(headId, index);\n+\t\t\t\t\tindex = createTemporaryIndex(headId, index, rw);\n \n \t\t\t\tObjectInserter odi = repo.newObjectInserter();\n \t\t\t\ttry {\n \t\t\t\t\t// Write the index as tree to the object database. This may\n \t\t\t\t\t// fail for example when the index contains unmerged paths\n \t\t\t\t\t// (unresolved conflicts)\n \t\t\t\t\tObjectId indexTreeId = index.writeTree(odi);\n \n \t\t\t\t\tif (insertChangeId)\n \t\t\t\t\t\tinsertChangeId(indexTreeId);\n \n \t\t\t\t\t// Create a Commit object, populate it and write it\n \t\t\t\t\tCommitBuilder commit = new CommitBuilder();\n \t\t\t\t\tcommit.setCommitter(committer);\n \t\t\t\t\tcommit.setAuthor(author);\n \t\t\t\t\tcommit.setMessage(message);\n \n \t\t\t\t\tcommit.setParentIds(parents);\n \t\t\t\t\tcommit.setTreeId(indexTreeId);\n \t\t\t\t\tObjectId commitId = odi.insert(commit);\n \t\t\t\t\todi.flush();\n \n-\t\t\t\t\tRevWalk revWalk = new RevWalk(repo);\n-\t\t\t\t\ttry {\n-\t\t\t\t\t\tRevCommit revCommit = revWalk.parseCommit(commitId);\n-\t\t\t\t\t\tRefUpdate ru = repo.updateRef(Constants.HEAD);\n-\t\t\t\t\t\tru.setNewObjectId(commitId);\n-\t\t\t\t\t\tif (reflogComment != null) {\n-\t\t\t\t\t\t\tru.setRefLogMessage(reflogComment, false);\n-\t\t\t\t\t\t} else {\n-\t\t\t\t\t\t\tString prefix = amend ? \"commit (amend): \" //$NON-NLS-1$\n-\t\t\t\t\t\t\t\t\t: parents.size() == 0 ? \"commit (initial): \"\n-\t\t\t\t\t\t\t\t\t\t\t: \"commit: \";\n-\t\t\t\t\t\t\tru.setRefLogMessage(\n-\t\t\t\t\t\t\t\t\tprefix + revCommit.getShortMessage(), false);\n+\t\t\t\t\tRevCommit revCommit = rw.parseCommit(commitId);\n+\t\t\t\t\tRefUpdate ru = repo.updateRef(Constants.HEAD);\n+\t\t\t\t\tru.setNewObjectId(commitId);\n+\t\t\t\t\tif (reflogComment != null) {\n+\t\t\t\t\t\tru.setRefLogMessage(reflogComment, false);\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tString prefix = amend ? \"commit (amend): \" //$NON-NLS-1$\n+\t\t\t\t\t\t\t\t: parents.size() == 0 ? \"commit (initial): \"\n+\t\t\t\t\t\t\t\t\t\t: \"commit: \";\n+\t\t\t\t\t\tru.setRefLogMessage(\n+\t\t\t\t\t\t\t\tprefix + revCommit.getShortMessage(), false);\n+\t\t\t\t\t}\n+\t\t\t\t\tif (headId != null)\n+\t\t\t\t\t\tru.setExpectedOldObjectId(headId);\n+\t\t\t\t\telse\n+\t\t\t\t\t\tru.setExpectedOldObjectId(ObjectId.zeroId());\n+\t\t\t\t\tResult rc = ru.forceUpdate();\n+\t\t\t\t\tswitch (rc) {\n+\t\t\t\t\tcase NEW:\n+\t\t\t\t\tcase FORCED:\n+\t\t\t\t\tcase FAST_FORWARD: {\n+\t\t\t\t\t\tsetCallable(false);\n+\t\t\t\t\t\tif (state == RepositoryState.MERGING_RESOLVED) {\n+\t\t\t\t\t\t\t// Commit was successful. Now delete the files\n+\t\t\t\t\t\t\t// used for merge commits\n+\t\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n+\t\t\t\t\t\t\trepo.writeMergeHeads(null);\n+\t\t\t\t\t\t} else if (state == RepositoryState.CHERRY_PICKING_RESOLVED) {\n+\t\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n+\t\t\t\t\t\t\trepo.writeCherryPickHead(null);\n+\t\t\t\t\t\t} else if (state == RepositoryState.REVERTING_RESOLVED) {\n+\t\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n+\t\t\t\t\t\t\trepo.writeRevertHead(null);\n \t\t\t\t\t\t}\n-\t\t\t\t\t\tif (headId != null)\n-\t\t\t\t\t\t\tru.setExpectedOldObjectId(headId);\n-\t\t\t\t\t\telse\n-\t\t\t\t\t\t\tru.setExpectedOldObjectId(ObjectId.zeroId());\n-\t\t\t\t\t\tResult rc = ru.forceUpdate();\n-\t\t\t\t\t\tswitch (rc) {\n-\t\t\t\t\t\tcase NEW:\n-\t\t\t\t\t\tcase FORCED:\n-\t\t\t\t\t\tcase FAST_FORWARD: {\n-\t\t\t\t\t\t\tsetCallable(false);\n-\t\t\t\t\t\t\tif (state == RepositoryState.MERGING_RESOLVED) {\n-\t\t\t\t\t\t\t\t// Commit was successful. Now delete the files\n-\t\t\t\t\t\t\t\t// used for merge commits\n-\t\t\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n-\t\t\t\t\t\t\t\trepo.writeMergeHeads(null);\n-\t\t\t\t\t\t\t} else if (state == RepositoryState.CHERRY_PICKING_RESOLVED) {\n-\t\t\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n-\t\t\t\t\t\t\t\trepo.writeCherryPickHead(null);\n-\t\t\t\t\t\t\t} else if (state == RepositoryState.REVERTING_RESOLVED) {\n-\t\t\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n-\t\t\t\t\t\t\t\trepo.writeRevertHead(null);\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\treturn revCommit;\n-\t\t\t\t\t\t}\n-\t\t\t\t\t\tcase REJECTED:\n-\t\t\t\t\t\tcase LOCK_FAILURE:\n-\t\t\t\t\t\t\tthrow new ConcurrentRefUpdateException(JGitText\n-\t\t\t\t\t\t\t\t\t.get().couldNotLockHEAD, ru.getRef(), rc);\n-\t\t\t\t\t\tdefault:\n-\t\t\t\t\t\t\tthrow new JGitInternalException(MessageFormat\n-\t\t\t\t\t\t\t\t\t.format(JGitText.get().updatingRefFailed,\n-\t\t\t\t\t\t\t\t\t\t\tConstants.HEAD,\n-\t\t\t\t\t\t\t\t\t\t\tcommitId.toString(), rc));\n-\t\t\t\t\t\t}\n-\t\t\t\t\t} finally {\n-\t\t\t\t\t\trevWalk.release();\n+\t\t\t\t\t\treturn revCommit;\n+\t\t\t\t\t}\n+\t\t\t\t\tcase REJECTED:\n+\t\t\t\t\tcase LOCK_FAILURE:\n+\t\t\t\t\t\tthrow new ConcurrentRefUpdateException(\n+\t\t\t\t\t\t\t\tJGitText.get().couldNotLockHEAD, ru.getRef(),\n+\t\t\t\t\t\t\t\trc);\n+\t\t\t\t\tdefault:\n+\t\t\t\t\t\tthrow new JGitInternalException(MessageFormat.format(\n+\t\t\t\t\t\t\t\tJGitText.get().updatingRefFailed,\n+\t\t\t\t\t\t\t\tConstants.HEAD, commitId.toString(), rc));\n \t\t\t\t\t}\n \t\t\t\t} finally {\n \t\t\t\t\todi.release();\n \t\t\t\t}\n \t\t\t} finally {\n \t\t\t\tindex.unlock();\n \t\t\t}\n \t\t} catch (UnmergedPathException e) {\n \t\t\tthrow new UnmergedPathsException(e);\n \t\t} catch (IOException e) {\n \t\t\tthrow new JGitInternalException(\n \t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n+\t\t} finally {\n+\t\t\trw.dispose();\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"65027d8bb429581635f51d0c588493e5c458cc25": {
			"type": "Ybodychange",
			"commitMessage": "Indicate initial commit on a branch in the reflog\n\nBug: 393463\nChange-Id: I4733d6f719bc0dc694e7a6a6ad2092de6364898c\n",
			"commitDate": "2013-04-02, 1:57 PM",
			"commitName": "65027d8bb429581635f51d0c588493e5c458cc25",
			"commitAuthor": "Robin Rosenberg",
			"commitDateOld": "2013-03-28, 11:58 AM",
			"commitNameOld": "1f51aecf95d61e48618d478a693f73dcf1ec1146",
			"commitAuthorOld": "Shawn Pearce",
			"daysBetweenCommits": 5.08,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,139 +1,140 @@\n \tpublic RevCommit call() throws GitAPIException, NoHeadException,\n \t\t\tNoMessageException, UnmergedPathsException,\n \t\t\tConcurrentRefUpdateException,\n \t\t\tWrongRepositoryStateException {\n \t\tcheckCallable();\n \t\tCollections.sort(only);\n \n \t\tRepositoryState state = repo.getRepositoryState();\n \t\tif (!state.canCommit())\n \t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().cannotCommitOnARepoWithState, state.name()));\n \t\tprocessOptions(state);\n \n \t\ttry {\n \t\t\tif (all && !repo.isBare() && repo.getWorkTree() != null) {\n \t\t\t\tGit git = new Git(repo);\n \t\t\t\ttry {\n \t\t\t\t\tgit.add()\n \t\t\t\t\t\t\t.addFilepattern(\".\") //$NON-NLS-1$\n \t\t\t\t\t\t\t.setUpdate(true).call();\n \t\t\t\t} catch (NoFilepatternException e) {\n \t\t\t\t\t// should really not happen\n \t\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tRef head = repo.getRef(Constants.HEAD);\n \t\t\tif (head == null)\n \t\t\t\tthrow new NoHeadException(\n \t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n \n \t\t\t// determine the current HEAD and the commit it is referring to\n \t\t\tObjectId headId = repo.resolve(Constants.HEAD + \"^{commit}\"); //$NON-NLS-1$\n \t\t\tif (headId == null && amend)\n \t\t\t\tthrow new WrongRepositoryStateException(\n \t\t\t\t\t\tJGitText.get().commitAmendOnInitialNotPossible);\n \n \t\t\tif (headId != null)\n \t\t\t\tif (amend) {\n \t\t\t\t\tRevCommit previousCommit = new RevWalk(repo)\n \t\t\t\t\t\t\t.parseCommit(headId);\n \t\t\t\t\tfor (RevCommit p : previousCommit.getParents())\n \t\t\t\t\t\tparents.add(p.getId());\n \t\t\t\t\tif (author == null)\n \t\t\t\t\t\tauthor = previousCommit.getAuthorIdent();\n \t\t\t\t} else {\n \t\t\t\t\tparents.add(0, headId);\n \t\t\t\t}\n \n \t\t\t// lock the index\n \t\t\tDirCache index = repo.lockDirCache();\n \t\t\ttry {\n \t\t\t\tif (!only.isEmpty())\n \t\t\t\t\tindex = createTemporaryIndex(headId, index);\n \n \t\t\t\tObjectInserter odi = repo.newObjectInserter();\n \t\t\t\ttry {\n \t\t\t\t\t// Write the index as tree to the object database. This may\n \t\t\t\t\t// fail for example when the index contains unmerged paths\n \t\t\t\t\t// (unresolved conflicts)\n \t\t\t\t\tObjectId indexTreeId = index.writeTree(odi);\n \n \t\t\t\t\tif (insertChangeId)\n \t\t\t\t\t\tinsertChangeId(indexTreeId);\n \n \t\t\t\t\t// Create a Commit object, populate it and write it\n \t\t\t\t\tCommitBuilder commit = new CommitBuilder();\n \t\t\t\t\tcommit.setCommitter(committer);\n \t\t\t\t\tcommit.setAuthor(author);\n \t\t\t\t\tcommit.setMessage(message);\n \n \t\t\t\t\tcommit.setParentIds(parents);\n \t\t\t\t\tcommit.setTreeId(indexTreeId);\n \t\t\t\t\tObjectId commitId = odi.insert(commit);\n \t\t\t\t\todi.flush();\n \n \t\t\t\t\tRevWalk revWalk = new RevWalk(repo);\n \t\t\t\t\ttry {\n \t\t\t\t\t\tRevCommit revCommit = revWalk.parseCommit(commitId);\n \t\t\t\t\t\tRefUpdate ru = repo.updateRef(Constants.HEAD);\n \t\t\t\t\t\tru.setNewObjectId(commitId);\n \t\t\t\t\t\tif (reflogComment != null) {\n \t\t\t\t\t\t\tru.setRefLogMessage(reflogComment, false);\n \t\t\t\t\t\t} else {\n \t\t\t\t\t\t\tString prefix = amend ? \"commit (amend): \" //$NON-NLS-1$\n-\t\t\t\t\t\t\t\t\t: \"commit: \";\n+\t\t\t\t\t\t\t\t\t: parents.size() == 0 ? \"commit (initial): \"\n+\t\t\t\t\t\t\t\t\t\t\t: \"commit: \";\n \t\t\t\t\t\t\tru.setRefLogMessage(\n \t\t\t\t\t\t\t\t\tprefix + revCommit.getShortMessage(), false);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tif (headId != null)\n \t\t\t\t\t\t\tru.setExpectedOldObjectId(headId);\n \t\t\t\t\t\telse\n \t\t\t\t\t\t\tru.setExpectedOldObjectId(ObjectId.zeroId());\n \t\t\t\t\t\tResult rc = ru.forceUpdate();\n \t\t\t\t\t\tswitch (rc) {\n \t\t\t\t\t\tcase NEW:\n \t\t\t\t\t\tcase FORCED:\n \t\t\t\t\t\tcase FAST_FORWARD: {\n \t\t\t\t\t\t\tsetCallable(false);\n \t\t\t\t\t\t\tif (state == RepositoryState.MERGING_RESOLVED) {\n \t\t\t\t\t\t\t\t// Commit was successful. Now delete the files\n \t\t\t\t\t\t\t\t// used for merge commits\n \t\t\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n \t\t\t\t\t\t\t\trepo.writeMergeHeads(null);\n \t\t\t\t\t\t\t} else if (state == RepositoryState.CHERRY_PICKING_RESOLVED) {\n \t\t\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n \t\t\t\t\t\t\t\trepo.writeCherryPickHead(null);\n \t\t\t\t\t\t\t} else if (state == RepositoryState.REVERTING_RESOLVED) {\n \t\t\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n \t\t\t\t\t\t\t\trepo.writeRevertHead(null);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\treturn revCommit;\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcase REJECTED:\n \t\t\t\t\t\tcase LOCK_FAILURE:\n \t\t\t\t\t\t\tthrow new ConcurrentRefUpdateException(JGitText\n \t\t\t\t\t\t\t\t\t.get().couldNotLockHEAD, ru.getRef(), rc);\n \t\t\t\t\t\tdefault:\n \t\t\t\t\t\t\tthrow new JGitInternalException(MessageFormat\n \t\t\t\t\t\t\t\t\t.format(JGitText.get().updatingRefFailed,\n \t\t\t\t\t\t\t\t\t\t\tConstants.HEAD,\n \t\t\t\t\t\t\t\t\t\t\tcommitId.toString(), rc));\n \t\t\t\t\t\t}\n \t\t\t\t\t} finally {\n \t\t\t\t\t\trevWalk.release();\n \t\t\t\t\t}\n \t\t\t\t} finally {\n \t\t\t\t\todi.release();\n \t\t\t\t}\n \t\t\t} finally {\n \t\t\t\tindex.unlock();\n \t\t\t}\n \t\t} catch (UnmergedPathException e) {\n \t\t\tthrow new UnmergedPathsException(e);\n \t\t} catch (IOException e) {\n \t\t\tthrow new JGitInternalException(\n \t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"1f51aecf95d61e48618d478a693f73dcf1ec1146": {
			"type": "Ybodychange",
			"commitMessage": "Fix CommitCommand amend mode to preserve parent order\n\nChange-Id: I476921ff8dfa6a357932d42ee59340873502b582\n",
			"commitDate": "2013-03-28, 11:58 AM",
			"commitName": "1f51aecf95d61e48618d478a693f73dcf1ec1146",
			"commitAuthor": "Shawn Pearce",
			"commitDateOld": "2013-01-06, 5:08 PM",
			"commitNameOld": "549034500a55ffc8f401fd73a74d8dc55f096d2f",
			"commitAuthorOld": "Robin Rosenberg",
			"daysBetweenCommits": 80.74,
			"commitsBetweenForRepo": 127,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,140 +1,139 @@\n \tpublic RevCommit call() throws GitAPIException, NoHeadException,\n \t\t\tNoMessageException, UnmergedPathsException,\n \t\t\tConcurrentRefUpdateException,\n \t\t\tWrongRepositoryStateException {\n \t\tcheckCallable();\n \t\tCollections.sort(only);\n \n \t\tRepositoryState state = repo.getRepositoryState();\n \t\tif (!state.canCommit())\n \t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().cannotCommitOnARepoWithState, state.name()));\n \t\tprocessOptions(state);\n \n \t\ttry {\n \t\t\tif (all && !repo.isBare() && repo.getWorkTree() != null) {\n \t\t\t\tGit git = new Git(repo);\n \t\t\t\ttry {\n \t\t\t\t\tgit.add()\n \t\t\t\t\t\t\t.addFilepattern(\".\") //$NON-NLS-1$\n \t\t\t\t\t\t\t.setUpdate(true).call();\n \t\t\t\t} catch (NoFilepatternException e) {\n \t\t\t\t\t// should really not happen\n \t\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tRef head = repo.getRef(Constants.HEAD);\n \t\t\tif (head == null)\n \t\t\t\tthrow new NoHeadException(\n \t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n \n \t\t\t// determine the current HEAD and the commit it is referring to\n \t\t\tObjectId headId = repo.resolve(Constants.HEAD + \"^{commit}\"); //$NON-NLS-1$\n \t\t\tif (headId == null && amend)\n \t\t\t\tthrow new WrongRepositoryStateException(\n \t\t\t\t\t\tJGitText.get().commitAmendOnInitialNotPossible);\n \n \t\t\tif (headId != null)\n \t\t\t\tif (amend) {\n \t\t\t\t\tRevCommit previousCommit = new RevWalk(repo)\n \t\t\t\t\t\t\t.parseCommit(headId);\n-\t\t\t\t\tRevCommit[] p = previousCommit.getParents();\n-\t\t\t\t\tfor (int i = 0; i < p.length; i++)\n-\t\t\t\t\t\tparents.add(0, p[i].getId());\n+\t\t\t\t\tfor (RevCommit p : previousCommit.getParents())\n+\t\t\t\t\t\tparents.add(p.getId());\n \t\t\t\t\tif (author == null)\n \t\t\t\t\t\tauthor = previousCommit.getAuthorIdent();\n \t\t\t\t} else {\n \t\t\t\t\tparents.add(0, headId);\n \t\t\t\t}\n \n \t\t\t// lock the index\n \t\t\tDirCache index = repo.lockDirCache();\n \t\t\ttry {\n \t\t\t\tif (!only.isEmpty())\n \t\t\t\t\tindex = createTemporaryIndex(headId, index);\n \n \t\t\t\tObjectInserter odi = repo.newObjectInserter();\n \t\t\t\ttry {\n \t\t\t\t\t// Write the index as tree to the object database. This may\n \t\t\t\t\t// fail for example when the index contains unmerged paths\n \t\t\t\t\t// (unresolved conflicts)\n \t\t\t\t\tObjectId indexTreeId = index.writeTree(odi);\n \n \t\t\t\t\tif (insertChangeId)\n \t\t\t\t\t\tinsertChangeId(indexTreeId);\n \n \t\t\t\t\t// Create a Commit object, populate it and write it\n \t\t\t\t\tCommitBuilder commit = new CommitBuilder();\n \t\t\t\t\tcommit.setCommitter(committer);\n \t\t\t\t\tcommit.setAuthor(author);\n \t\t\t\t\tcommit.setMessage(message);\n \n \t\t\t\t\tcommit.setParentIds(parents);\n \t\t\t\t\tcommit.setTreeId(indexTreeId);\n \t\t\t\t\tObjectId commitId = odi.insert(commit);\n \t\t\t\t\todi.flush();\n \n \t\t\t\t\tRevWalk revWalk = new RevWalk(repo);\n \t\t\t\t\ttry {\n \t\t\t\t\t\tRevCommit revCommit = revWalk.parseCommit(commitId);\n \t\t\t\t\t\tRefUpdate ru = repo.updateRef(Constants.HEAD);\n \t\t\t\t\t\tru.setNewObjectId(commitId);\n \t\t\t\t\t\tif (reflogComment != null) {\n \t\t\t\t\t\t\tru.setRefLogMessage(reflogComment, false);\n \t\t\t\t\t\t} else {\n \t\t\t\t\t\t\tString prefix = amend ? \"commit (amend): \" //$NON-NLS-1$\n \t\t\t\t\t\t\t\t\t: \"commit: \";\n \t\t\t\t\t\t\tru.setRefLogMessage(\n \t\t\t\t\t\t\t\t\tprefix + revCommit.getShortMessage(), false);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tif (headId != null)\n \t\t\t\t\t\t\tru.setExpectedOldObjectId(headId);\n \t\t\t\t\t\telse\n \t\t\t\t\t\t\tru.setExpectedOldObjectId(ObjectId.zeroId());\n \t\t\t\t\t\tResult rc = ru.forceUpdate();\n \t\t\t\t\t\tswitch (rc) {\n \t\t\t\t\t\tcase NEW:\n \t\t\t\t\t\tcase FORCED:\n \t\t\t\t\t\tcase FAST_FORWARD: {\n \t\t\t\t\t\t\tsetCallable(false);\n \t\t\t\t\t\t\tif (state == RepositoryState.MERGING_RESOLVED) {\n \t\t\t\t\t\t\t\t// Commit was successful. Now delete the files\n \t\t\t\t\t\t\t\t// used for merge commits\n \t\t\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n \t\t\t\t\t\t\t\trepo.writeMergeHeads(null);\n \t\t\t\t\t\t\t} else if (state == RepositoryState.CHERRY_PICKING_RESOLVED) {\n \t\t\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n \t\t\t\t\t\t\t\trepo.writeCherryPickHead(null);\n \t\t\t\t\t\t\t} else if (state == RepositoryState.REVERTING_RESOLVED) {\n \t\t\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n \t\t\t\t\t\t\t\trepo.writeRevertHead(null);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\treturn revCommit;\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcase REJECTED:\n \t\t\t\t\t\tcase LOCK_FAILURE:\n \t\t\t\t\t\t\tthrow new ConcurrentRefUpdateException(JGitText\n \t\t\t\t\t\t\t\t\t.get().couldNotLockHEAD, ru.getRef(), rc);\n \t\t\t\t\t\tdefault:\n \t\t\t\t\t\t\tthrow new JGitInternalException(MessageFormat\n \t\t\t\t\t\t\t\t\t.format(JGitText.get().updatingRefFailed,\n \t\t\t\t\t\t\t\t\t\t\tConstants.HEAD,\n \t\t\t\t\t\t\t\t\t\t\tcommitId.toString(), rc));\n \t\t\t\t\t\t}\n \t\t\t\t\t} finally {\n \t\t\t\t\t\trevWalk.release();\n \t\t\t\t\t}\n \t\t\t\t} finally {\n \t\t\t\t\todi.release();\n \t\t\t\t}\n \t\t\t} finally {\n \t\t\t\tindex.unlock();\n \t\t\t}\n \t\t} catch (UnmergedPathException e) {\n \t\t\tthrow new UnmergedPathsException(e);\n \t\t} catch (IOException e) {\n \t\t\tthrow new JGitInternalException(\n \t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"549034500a55ffc8f401fd73a74d8dc55f096d2f": {
			"type": "Ybodychange",
			"commitMessage": "Speed up handling of \"only\" paths in the CommitCommand\n\nUse binary search to reduce the number of lookups for very large number\nof paths.\n\nChange-Id: I76a16594b756bffd95298897414485a9cd637819\n",
			"commitDate": "2013-01-06, 5:08 PM",
			"commitName": "549034500a55ffc8f401fd73a74d8dc55f096d2f",
			"commitAuthor": "Robin Rosenberg",
			"commitDateOld": "2012-12-28, 3:44 PM",
			"commitNameOld": "315f1cfa5c63f4d3355704c80d00ac1323a36171",
			"commitAuthorOld": "Robin Rosenberg",
			"daysBetweenCommits": 9.06,
			"commitsBetweenForRepo": 4,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,139 +1,140 @@\n \tpublic RevCommit call() throws GitAPIException, NoHeadException,\n \t\t\tNoMessageException, UnmergedPathsException,\n \t\t\tConcurrentRefUpdateException,\n \t\t\tWrongRepositoryStateException {\n \t\tcheckCallable();\n+\t\tCollections.sort(only);\n \n \t\tRepositoryState state = repo.getRepositoryState();\n \t\tif (!state.canCommit())\n \t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().cannotCommitOnARepoWithState, state.name()));\n \t\tprocessOptions(state);\n \n \t\ttry {\n \t\t\tif (all && !repo.isBare() && repo.getWorkTree() != null) {\n \t\t\t\tGit git = new Git(repo);\n \t\t\t\ttry {\n \t\t\t\t\tgit.add()\n \t\t\t\t\t\t\t.addFilepattern(\".\") //$NON-NLS-1$\n \t\t\t\t\t\t\t.setUpdate(true).call();\n \t\t\t\t} catch (NoFilepatternException e) {\n \t\t\t\t\t// should really not happen\n \t\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tRef head = repo.getRef(Constants.HEAD);\n \t\t\tif (head == null)\n \t\t\t\tthrow new NoHeadException(\n \t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n \n \t\t\t// determine the current HEAD and the commit it is referring to\n \t\t\tObjectId headId = repo.resolve(Constants.HEAD + \"^{commit}\"); //$NON-NLS-1$\n \t\t\tif (headId == null && amend)\n \t\t\t\tthrow new WrongRepositoryStateException(\n \t\t\t\t\t\tJGitText.get().commitAmendOnInitialNotPossible);\n \n \t\t\tif (headId != null)\n \t\t\t\tif (amend) {\n \t\t\t\t\tRevCommit previousCommit = new RevWalk(repo)\n \t\t\t\t\t\t\t.parseCommit(headId);\n \t\t\t\t\tRevCommit[] p = previousCommit.getParents();\n \t\t\t\t\tfor (int i = 0; i < p.length; i++)\n \t\t\t\t\t\tparents.add(0, p[i].getId());\n \t\t\t\t\tif (author == null)\n \t\t\t\t\t\tauthor = previousCommit.getAuthorIdent();\n \t\t\t\t} else {\n \t\t\t\t\tparents.add(0, headId);\n \t\t\t\t}\n \n \t\t\t// lock the index\n \t\t\tDirCache index = repo.lockDirCache();\n \t\t\ttry {\n \t\t\t\tif (!only.isEmpty())\n \t\t\t\t\tindex = createTemporaryIndex(headId, index);\n \n \t\t\t\tObjectInserter odi = repo.newObjectInserter();\n \t\t\t\ttry {\n \t\t\t\t\t// Write the index as tree to the object database. This may\n \t\t\t\t\t// fail for example when the index contains unmerged paths\n \t\t\t\t\t// (unresolved conflicts)\n \t\t\t\t\tObjectId indexTreeId = index.writeTree(odi);\n \n \t\t\t\t\tif (insertChangeId)\n \t\t\t\t\t\tinsertChangeId(indexTreeId);\n \n \t\t\t\t\t// Create a Commit object, populate it and write it\n \t\t\t\t\tCommitBuilder commit = new CommitBuilder();\n \t\t\t\t\tcommit.setCommitter(committer);\n \t\t\t\t\tcommit.setAuthor(author);\n \t\t\t\t\tcommit.setMessage(message);\n \n \t\t\t\t\tcommit.setParentIds(parents);\n \t\t\t\t\tcommit.setTreeId(indexTreeId);\n \t\t\t\t\tObjectId commitId = odi.insert(commit);\n \t\t\t\t\todi.flush();\n \n \t\t\t\t\tRevWalk revWalk = new RevWalk(repo);\n \t\t\t\t\ttry {\n \t\t\t\t\t\tRevCommit revCommit = revWalk.parseCommit(commitId);\n \t\t\t\t\t\tRefUpdate ru = repo.updateRef(Constants.HEAD);\n \t\t\t\t\t\tru.setNewObjectId(commitId);\n \t\t\t\t\t\tif (reflogComment != null) {\n \t\t\t\t\t\t\tru.setRefLogMessage(reflogComment, false);\n \t\t\t\t\t\t} else {\n \t\t\t\t\t\t\tString prefix = amend ? \"commit (amend): \" //$NON-NLS-1$\n \t\t\t\t\t\t\t\t\t: \"commit: \";\n \t\t\t\t\t\t\tru.setRefLogMessage(\n \t\t\t\t\t\t\t\t\tprefix + revCommit.getShortMessage(), false);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tif (headId != null)\n \t\t\t\t\t\t\tru.setExpectedOldObjectId(headId);\n \t\t\t\t\t\telse\n \t\t\t\t\t\t\tru.setExpectedOldObjectId(ObjectId.zeroId());\n \t\t\t\t\t\tResult rc = ru.forceUpdate();\n \t\t\t\t\t\tswitch (rc) {\n \t\t\t\t\t\tcase NEW:\n \t\t\t\t\t\tcase FORCED:\n \t\t\t\t\t\tcase FAST_FORWARD: {\n \t\t\t\t\t\t\tsetCallable(false);\n \t\t\t\t\t\t\tif (state == RepositoryState.MERGING_RESOLVED) {\n \t\t\t\t\t\t\t\t// Commit was successful. Now delete the files\n \t\t\t\t\t\t\t\t// used for merge commits\n \t\t\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n \t\t\t\t\t\t\t\trepo.writeMergeHeads(null);\n \t\t\t\t\t\t\t} else if (state == RepositoryState.CHERRY_PICKING_RESOLVED) {\n \t\t\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n \t\t\t\t\t\t\t\trepo.writeCherryPickHead(null);\n \t\t\t\t\t\t\t} else if (state == RepositoryState.REVERTING_RESOLVED) {\n \t\t\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n \t\t\t\t\t\t\t\trepo.writeRevertHead(null);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\treturn revCommit;\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcase REJECTED:\n \t\t\t\t\t\tcase LOCK_FAILURE:\n \t\t\t\t\t\t\tthrow new ConcurrentRefUpdateException(JGitText\n \t\t\t\t\t\t\t\t\t.get().couldNotLockHEAD, ru.getRef(), rc);\n \t\t\t\t\t\tdefault:\n \t\t\t\t\t\t\tthrow new JGitInternalException(MessageFormat\n \t\t\t\t\t\t\t\t\t.format(JGitText.get().updatingRefFailed,\n \t\t\t\t\t\t\t\t\t\t\tConstants.HEAD,\n \t\t\t\t\t\t\t\t\t\t\tcommitId.toString(), rc));\n \t\t\t\t\t\t}\n \t\t\t\t\t} finally {\n \t\t\t\t\t\trevWalk.release();\n \t\t\t\t\t}\n \t\t\t\t} finally {\n \t\t\t\t\todi.release();\n \t\t\t\t}\n \t\t\t} finally {\n \t\t\t\tindex.unlock();\n \t\t\t}\n \t\t} catch (UnmergedPathException e) {\n \t\t\tthrow new UnmergedPathsException(e);\n \t\t} catch (IOException e) {\n \t\t\tthrow new JGitInternalException(\n \t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"315f1cfa5c63f4d3355704c80d00ac1323a36171": {
			"type": "Ybodychange",
			"commitMessage": "Update the revert command and things relating to revert\n\nCherry-pick has been fixed, but even though revert does\nbasically the same thing, the fixes were not carried over here.\n\n- Recognize the revert-states, analogous to the cherry picking states\n- Make reset handle a revert-in-progress\n- Update REVERT_HEAD and MERGE_MSG when revert fails due to conflicts\n- Clear revert state on commit and reset\n- Format the message similarily to how cherry-pick does. This is\n  not exactly how C Git does it.\n\nThe interface is still not the same as for cherry-picking.\n\nChange-Id: I8ea956fcbc9526d62a2365360feea23a9280eba3\nSigned-off-by: Chris Aniszczyk <zx@twitter.com>\n",
			"commitDate": "2012-12-28, 3:44 PM",
			"commitName": "315f1cfa5c63f4d3355704c80d00ac1323a36171",
			"commitAuthor": "Robin Rosenberg",
			"commitDateOld": "2012-12-27, 8:57 AM",
			"commitNameOld": "c310fa0c802f40a774edb58641de3ac5bfad0e2c",
			"commitAuthorOld": "Robin Rosenberg",
			"daysBetweenCommits": 1.28,
			"commitsBetweenForRepo": 9,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,136 +1,139 @@\n \tpublic RevCommit call() throws GitAPIException, NoHeadException,\n \t\t\tNoMessageException, UnmergedPathsException,\n \t\t\tConcurrentRefUpdateException,\n \t\t\tWrongRepositoryStateException {\n \t\tcheckCallable();\n \n \t\tRepositoryState state = repo.getRepositoryState();\n \t\tif (!state.canCommit())\n \t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().cannotCommitOnARepoWithState, state.name()));\n \t\tprocessOptions(state);\n \n \t\ttry {\n \t\t\tif (all && !repo.isBare() && repo.getWorkTree() != null) {\n \t\t\t\tGit git = new Git(repo);\n \t\t\t\ttry {\n \t\t\t\t\tgit.add()\n \t\t\t\t\t\t\t.addFilepattern(\".\") //$NON-NLS-1$\n \t\t\t\t\t\t\t.setUpdate(true).call();\n \t\t\t\t} catch (NoFilepatternException e) {\n \t\t\t\t\t// should really not happen\n \t\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tRef head = repo.getRef(Constants.HEAD);\n \t\t\tif (head == null)\n \t\t\t\tthrow new NoHeadException(\n \t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n \n \t\t\t// determine the current HEAD and the commit it is referring to\n \t\t\tObjectId headId = repo.resolve(Constants.HEAD + \"^{commit}\"); //$NON-NLS-1$\n \t\t\tif (headId == null && amend)\n \t\t\t\tthrow new WrongRepositoryStateException(\n \t\t\t\t\t\tJGitText.get().commitAmendOnInitialNotPossible);\n \n \t\t\tif (headId != null)\n \t\t\t\tif (amend) {\n \t\t\t\t\tRevCommit previousCommit = new RevWalk(repo)\n \t\t\t\t\t\t\t.parseCommit(headId);\n \t\t\t\t\tRevCommit[] p = previousCommit.getParents();\n \t\t\t\t\tfor (int i = 0; i < p.length; i++)\n \t\t\t\t\t\tparents.add(0, p[i].getId());\n \t\t\t\t\tif (author == null)\n \t\t\t\t\t\tauthor = previousCommit.getAuthorIdent();\n \t\t\t\t} else {\n \t\t\t\t\tparents.add(0, headId);\n \t\t\t\t}\n \n \t\t\t// lock the index\n \t\t\tDirCache index = repo.lockDirCache();\n \t\t\ttry {\n \t\t\t\tif (!only.isEmpty())\n \t\t\t\t\tindex = createTemporaryIndex(headId, index);\n \n \t\t\t\tObjectInserter odi = repo.newObjectInserter();\n \t\t\t\ttry {\n \t\t\t\t\t// Write the index as tree to the object database. This may\n \t\t\t\t\t// fail for example when the index contains unmerged paths\n \t\t\t\t\t// (unresolved conflicts)\n \t\t\t\t\tObjectId indexTreeId = index.writeTree(odi);\n \n \t\t\t\t\tif (insertChangeId)\n \t\t\t\t\t\tinsertChangeId(indexTreeId);\n \n \t\t\t\t\t// Create a Commit object, populate it and write it\n \t\t\t\t\tCommitBuilder commit = new CommitBuilder();\n \t\t\t\t\tcommit.setCommitter(committer);\n \t\t\t\t\tcommit.setAuthor(author);\n \t\t\t\t\tcommit.setMessage(message);\n \n \t\t\t\t\tcommit.setParentIds(parents);\n \t\t\t\t\tcommit.setTreeId(indexTreeId);\n \t\t\t\t\tObjectId commitId = odi.insert(commit);\n \t\t\t\t\todi.flush();\n \n \t\t\t\t\tRevWalk revWalk = new RevWalk(repo);\n \t\t\t\t\ttry {\n \t\t\t\t\t\tRevCommit revCommit = revWalk.parseCommit(commitId);\n \t\t\t\t\t\tRefUpdate ru = repo.updateRef(Constants.HEAD);\n \t\t\t\t\t\tru.setNewObjectId(commitId);\n \t\t\t\t\t\tif (reflogComment != null) {\n \t\t\t\t\t\t\tru.setRefLogMessage(reflogComment, false);\n \t\t\t\t\t\t} else {\n \t\t\t\t\t\t\tString prefix = amend ? \"commit (amend): \" //$NON-NLS-1$\n \t\t\t\t\t\t\t\t\t: \"commit: \";\n \t\t\t\t\t\t\tru.setRefLogMessage(\n \t\t\t\t\t\t\t\t\tprefix + revCommit.getShortMessage(), false);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tif (headId != null)\n \t\t\t\t\t\t\tru.setExpectedOldObjectId(headId);\n \t\t\t\t\t\telse\n \t\t\t\t\t\t\tru.setExpectedOldObjectId(ObjectId.zeroId());\n \t\t\t\t\t\tResult rc = ru.forceUpdate();\n \t\t\t\t\t\tswitch (rc) {\n \t\t\t\t\t\tcase NEW:\n \t\t\t\t\t\tcase FORCED:\n \t\t\t\t\t\tcase FAST_FORWARD: {\n \t\t\t\t\t\t\tsetCallable(false);\n \t\t\t\t\t\t\tif (state == RepositoryState.MERGING_RESOLVED) {\n \t\t\t\t\t\t\t\t// Commit was successful. Now delete the files\n \t\t\t\t\t\t\t\t// used for merge commits\n \t\t\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n \t\t\t\t\t\t\t\trepo.writeMergeHeads(null);\n \t\t\t\t\t\t\t} else if (state == RepositoryState.CHERRY_PICKING_RESOLVED) {\n \t\t\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n \t\t\t\t\t\t\t\trepo.writeCherryPickHead(null);\n+\t\t\t\t\t\t\t} else if (state == RepositoryState.REVERTING_RESOLVED) {\n+\t\t\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n+\t\t\t\t\t\t\t\trepo.writeRevertHead(null);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\treturn revCommit;\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcase REJECTED:\n \t\t\t\t\t\tcase LOCK_FAILURE:\n \t\t\t\t\t\t\tthrow new ConcurrentRefUpdateException(JGitText\n \t\t\t\t\t\t\t\t\t.get().couldNotLockHEAD, ru.getRef(), rc);\n \t\t\t\t\t\tdefault:\n \t\t\t\t\t\t\tthrow new JGitInternalException(MessageFormat\n \t\t\t\t\t\t\t\t\t.format(JGitText.get().updatingRefFailed,\n \t\t\t\t\t\t\t\t\t\t\tConstants.HEAD,\n \t\t\t\t\t\t\t\t\t\t\tcommitId.toString(), rc));\n \t\t\t\t\t\t}\n \t\t\t\t\t} finally {\n \t\t\t\t\t\trevWalk.release();\n \t\t\t\t\t}\n \t\t\t\t} finally {\n \t\t\t\t\todi.release();\n \t\t\t\t}\n \t\t\t} finally {\n \t\t\t\tindex.unlock();\n \t\t\t}\n \t\t} catch (UnmergedPathException e) {\n \t\t\tthrow new UnmergedPathsException(e);\n \t\t} catch (IOException e) {\n \t\t\tthrow new JGitInternalException(\n \t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"c310fa0c802f40a774edb58641de3ac5bfad0e2c": {
			"type": "Ybodychange",
			"commitMessage": "Mark non-externalizable strings as such\n\nA few classes such as Constanrs are marked with @SuppressWarnings, as are\ntoString() methods with many liternal, but otherwise $NLS-n$ is used for\nstring containing text that should not be translated. A few literals may\nfall into the gray zone, but mostly I've tried to only tag the obvious\nones.\n\nChange-Id: I22e50a77e2bf9e0b842a66bdf674e8fa1692f590\n",
			"commitDate": "2012-12-27, 8:57 AM",
			"commitName": "c310fa0c802f40a774edb58641de3ac5bfad0e2c",
			"commitAuthor": "Robin Rosenberg",
			"commitDateOld": "2012-11-12, 2:51 PM",
			"commitNameOld": "0f88d7b72ff09297954930cbe2a23cf8feff9382",
			"commitAuthorOld": "Robin Stocker",
			"daysBetweenCommits": 44.75,
			"commitsBetweenForRepo": 49,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,136 +1,136 @@\n \tpublic RevCommit call() throws GitAPIException, NoHeadException,\n \t\t\tNoMessageException, UnmergedPathsException,\n \t\t\tConcurrentRefUpdateException,\n \t\t\tWrongRepositoryStateException {\n \t\tcheckCallable();\n \n \t\tRepositoryState state = repo.getRepositoryState();\n \t\tif (!state.canCommit())\n \t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().cannotCommitOnARepoWithState, state.name()));\n \t\tprocessOptions(state);\n \n \t\ttry {\n \t\t\tif (all && !repo.isBare() && repo.getWorkTree() != null) {\n \t\t\t\tGit git = new Git(repo);\n \t\t\t\ttry {\n \t\t\t\t\tgit.add()\n-\t\t\t\t\t\t\t.addFilepattern(\".\")\n+\t\t\t\t\t\t\t.addFilepattern(\".\") //$NON-NLS-1$\n \t\t\t\t\t\t\t.setUpdate(true).call();\n \t\t\t\t} catch (NoFilepatternException e) {\n \t\t\t\t\t// should really not happen\n \t\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tRef head = repo.getRef(Constants.HEAD);\n \t\t\tif (head == null)\n \t\t\t\tthrow new NoHeadException(\n \t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n \n \t\t\t// determine the current HEAD and the commit it is referring to\n-\t\t\tObjectId headId = repo.resolve(Constants.HEAD + \"^{commit}\");\n+\t\t\tObjectId headId = repo.resolve(Constants.HEAD + \"^{commit}\"); //$NON-NLS-1$\n \t\t\tif (headId == null && amend)\n \t\t\t\tthrow new WrongRepositoryStateException(\n \t\t\t\t\t\tJGitText.get().commitAmendOnInitialNotPossible);\n \n \t\t\tif (headId != null)\n \t\t\t\tif (amend) {\n \t\t\t\t\tRevCommit previousCommit = new RevWalk(repo)\n \t\t\t\t\t\t\t.parseCommit(headId);\n \t\t\t\t\tRevCommit[] p = previousCommit.getParents();\n \t\t\t\t\tfor (int i = 0; i < p.length; i++)\n \t\t\t\t\t\tparents.add(0, p[i].getId());\n \t\t\t\t\tif (author == null)\n \t\t\t\t\t\tauthor = previousCommit.getAuthorIdent();\n \t\t\t\t} else {\n \t\t\t\t\tparents.add(0, headId);\n \t\t\t\t}\n \n \t\t\t// lock the index\n \t\t\tDirCache index = repo.lockDirCache();\n \t\t\ttry {\n \t\t\t\tif (!only.isEmpty())\n \t\t\t\t\tindex = createTemporaryIndex(headId, index);\n \n \t\t\t\tObjectInserter odi = repo.newObjectInserter();\n \t\t\t\ttry {\n \t\t\t\t\t// Write the index as tree to the object database. This may\n \t\t\t\t\t// fail for example when the index contains unmerged paths\n \t\t\t\t\t// (unresolved conflicts)\n \t\t\t\t\tObjectId indexTreeId = index.writeTree(odi);\n \n \t\t\t\t\tif (insertChangeId)\n \t\t\t\t\t\tinsertChangeId(indexTreeId);\n \n \t\t\t\t\t// Create a Commit object, populate it and write it\n \t\t\t\t\tCommitBuilder commit = new CommitBuilder();\n \t\t\t\t\tcommit.setCommitter(committer);\n \t\t\t\t\tcommit.setAuthor(author);\n \t\t\t\t\tcommit.setMessage(message);\n \n \t\t\t\t\tcommit.setParentIds(parents);\n \t\t\t\t\tcommit.setTreeId(indexTreeId);\n \t\t\t\t\tObjectId commitId = odi.insert(commit);\n \t\t\t\t\todi.flush();\n \n \t\t\t\t\tRevWalk revWalk = new RevWalk(repo);\n \t\t\t\t\ttry {\n \t\t\t\t\t\tRevCommit revCommit = revWalk.parseCommit(commitId);\n \t\t\t\t\t\tRefUpdate ru = repo.updateRef(Constants.HEAD);\n \t\t\t\t\t\tru.setNewObjectId(commitId);\n \t\t\t\t\t\tif (reflogComment != null) {\n \t\t\t\t\t\t\tru.setRefLogMessage(reflogComment, false);\n \t\t\t\t\t\t} else {\n-\t\t\t\t\t\t\tString prefix = amend ? \"commit (amend): \"\n+\t\t\t\t\t\t\tString prefix = amend ? \"commit (amend): \" //$NON-NLS-1$\n \t\t\t\t\t\t\t\t\t: \"commit: \";\n \t\t\t\t\t\t\tru.setRefLogMessage(\n \t\t\t\t\t\t\t\t\tprefix + revCommit.getShortMessage(), false);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tif (headId != null)\n \t\t\t\t\t\t\tru.setExpectedOldObjectId(headId);\n \t\t\t\t\t\telse\n \t\t\t\t\t\t\tru.setExpectedOldObjectId(ObjectId.zeroId());\n \t\t\t\t\t\tResult rc = ru.forceUpdate();\n \t\t\t\t\t\tswitch (rc) {\n \t\t\t\t\t\tcase NEW:\n \t\t\t\t\t\tcase FORCED:\n \t\t\t\t\t\tcase FAST_FORWARD: {\n \t\t\t\t\t\t\tsetCallable(false);\n \t\t\t\t\t\t\tif (state == RepositoryState.MERGING_RESOLVED) {\n \t\t\t\t\t\t\t\t// Commit was successful. Now delete the files\n \t\t\t\t\t\t\t\t// used for merge commits\n \t\t\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n \t\t\t\t\t\t\t\trepo.writeMergeHeads(null);\n \t\t\t\t\t\t\t} else if (state == RepositoryState.CHERRY_PICKING_RESOLVED) {\n \t\t\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n \t\t\t\t\t\t\t\trepo.writeCherryPickHead(null);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\treturn revCommit;\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcase REJECTED:\n \t\t\t\t\t\tcase LOCK_FAILURE:\n \t\t\t\t\t\t\tthrow new ConcurrentRefUpdateException(JGitText\n \t\t\t\t\t\t\t\t\t.get().couldNotLockHEAD, ru.getRef(), rc);\n \t\t\t\t\t\tdefault:\n \t\t\t\t\t\t\tthrow new JGitInternalException(MessageFormat\n \t\t\t\t\t\t\t\t\t.format(JGitText.get().updatingRefFailed,\n \t\t\t\t\t\t\t\t\t\t\tConstants.HEAD,\n \t\t\t\t\t\t\t\t\t\t\tcommitId.toString(), rc));\n \t\t\t\t\t\t}\n \t\t\t\t\t} finally {\n \t\t\t\t\t\trevWalk.release();\n \t\t\t\t\t}\n \t\t\t\t} finally {\n \t\t\t\t\todi.release();\n \t\t\t\t}\n \t\t\t} finally {\n \t\t\t\tindex.unlock();\n \t\t\t}\n \t\t} catch (UnmergedPathException e) {\n \t\t\tthrow new UnmergedPathsException(e);\n \t\t} catch (IOException e) {\n \t\t\tthrow new JGitInternalException(\n \t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"79f33419ec073edf31a1db16ae9b11e69ee997a1": {
			"type": "Ybodychange",
			"commitMessage": "CommitCommand: Use original author on amend if author is not set\n\nThis way, callers don't have to parse author ident of HEAD themselves.\n\nBug: 362391\nChange-Id: I383a817e6ed4707d637c52c007bc7b57728e6c85\n",
			"commitDate": "2012-10-07, 4:31 PM",
			"commitName": "79f33419ec073edf31a1db16ae9b11e69ee997a1",
			"commitAuthor": "Robin Stocker",
			"commitDateOld": "2012-10-07, 4:31 PM",
			"commitNameOld": "c96b40d5921d68edb96afad38b9c171388af4e05",
			"commitAuthorOld": "Robin Stocker",
			"daysBetweenCommits": 0,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,134 +1,136 @@\n \tpublic RevCommit call() throws GitAPIException, NoHeadException,\n \t\t\tNoMessageException, UnmergedPathsException,\n \t\t\tConcurrentRefUpdateException,\n \t\t\tWrongRepositoryStateException {\n \t\tcheckCallable();\n \n \t\tRepositoryState state = repo.getRepositoryState();\n \t\tif (!state.canCommit())\n \t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().cannotCommitOnARepoWithState, state.name()));\n \t\tprocessOptions(state);\n \n \t\ttry {\n \t\t\tif (all && !repo.isBare() && repo.getWorkTree() != null) {\n \t\t\t\tGit git = new Git(repo);\n \t\t\t\ttry {\n \t\t\t\t\tgit.add()\n \t\t\t\t\t\t\t.addFilepattern(\".\")\n \t\t\t\t\t\t\t.setUpdate(true).call();\n \t\t\t\t} catch (NoFilepatternException e) {\n \t\t\t\t\t// should really not happen\n \t\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tRef head = repo.getRef(Constants.HEAD);\n \t\t\tif (head == null)\n \t\t\t\tthrow new NoHeadException(\n \t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n \n \t\t\t// determine the current HEAD and the commit it is referring to\n \t\t\tObjectId headId = repo.resolve(Constants.HEAD + \"^{commit}\");\n \t\t\tif (headId == null && amend)\n \t\t\t\tthrow new WrongRepositoryStateException(\n \t\t\t\t\t\tJGitText.get().commitAmendOnInitialNotPossible);\n \n \t\t\tif (headId != null)\n \t\t\t\tif (amend) {\n \t\t\t\t\tRevCommit previousCommit = new RevWalk(repo)\n \t\t\t\t\t\t\t.parseCommit(headId);\n \t\t\t\t\tRevCommit[] p = previousCommit.getParents();\n \t\t\t\t\tfor (int i = 0; i < p.length; i++)\n \t\t\t\t\t\tparents.add(0, p[i].getId());\n+\t\t\t\t\tif (author == null)\n+\t\t\t\t\t\tauthor = previousCommit.getAuthorIdent();\n \t\t\t\t} else {\n \t\t\t\t\tparents.add(0, headId);\n \t\t\t\t}\n \n \t\t\t// lock the index\n \t\t\tDirCache index = repo.lockDirCache();\n \t\t\ttry {\n \t\t\t\tif (!only.isEmpty())\n \t\t\t\t\tindex = createTemporaryIndex(headId, index);\n \n \t\t\t\tObjectInserter odi = repo.newObjectInserter();\n \t\t\t\ttry {\n \t\t\t\t\t// Write the index as tree to the object database. This may\n \t\t\t\t\t// fail for example when the index contains unmerged paths\n \t\t\t\t\t// (unresolved conflicts)\n \t\t\t\t\tObjectId indexTreeId = index.writeTree(odi);\n \n \t\t\t\t\tif (insertChangeId)\n \t\t\t\t\t\tinsertChangeId(indexTreeId);\n \n \t\t\t\t\t// Create a Commit object, populate it and write it\n \t\t\t\t\tCommitBuilder commit = new CommitBuilder();\n \t\t\t\t\tcommit.setCommitter(committer);\n \t\t\t\t\tcommit.setAuthor(author);\n \t\t\t\t\tcommit.setMessage(message);\n \n \t\t\t\t\tcommit.setParentIds(parents);\n \t\t\t\t\tcommit.setTreeId(indexTreeId);\n \t\t\t\t\tObjectId commitId = odi.insert(commit);\n \t\t\t\t\todi.flush();\n \n \t\t\t\t\tRevWalk revWalk = new RevWalk(repo);\n \t\t\t\t\ttry {\n \t\t\t\t\t\tRevCommit revCommit = revWalk.parseCommit(commitId);\n \t\t\t\t\t\tRefUpdate ru = repo.updateRef(Constants.HEAD);\n \t\t\t\t\t\tru.setNewObjectId(commitId);\n \t\t\t\t\t\tif (reflogComment != null) {\n \t\t\t\t\t\t\tru.setRefLogMessage(reflogComment, false);\n \t\t\t\t\t\t} else {\n \t\t\t\t\t\t\tString prefix = amend ? \"commit (amend): \"\n \t\t\t\t\t\t\t\t\t: \"commit: \";\n \t\t\t\t\t\t\tru.setRefLogMessage(\n \t\t\t\t\t\t\t\t\tprefix + revCommit.getShortMessage(), false);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tif (headId != null)\n \t\t\t\t\t\t\tru.setExpectedOldObjectId(headId);\n \t\t\t\t\t\telse\n \t\t\t\t\t\t\tru.setExpectedOldObjectId(ObjectId.zeroId());\n \t\t\t\t\t\tResult rc = ru.forceUpdate();\n \t\t\t\t\t\tswitch (rc) {\n \t\t\t\t\t\tcase NEW:\n \t\t\t\t\t\tcase FORCED:\n \t\t\t\t\t\tcase FAST_FORWARD: {\n \t\t\t\t\t\t\tsetCallable(false);\n \t\t\t\t\t\t\tif (state == RepositoryState.MERGING_RESOLVED) {\n \t\t\t\t\t\t\t\t// Commit was successful. Now delete the files\n \t\t\t\t\t\t\t\t// used for merge commits\n \t\t\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n \t\t\t\t\t\t\t\trepo.writeMergeHeads(null);\n \t\t\t\t\t\t\t} else if (state == RepositoryState.CHERRY_PICKING_RESOLVED) {\n \t\t\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n \t\t\t\t\t\t\t\trepo.writeCherryPickHead(null);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\treturn revCommit;\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcase REJECTED:\n \t\t\t\t\t\tcase LOCK_FAILURE:\n \t\t\t\t\t\t\tthrow new ConcurrentRefUpdateException(JGitText\n \t\t\t\t\t\t\t\t\t.get().couldNotLockHEAD, ru.getRef(), rc);\n \t\t\t\t\t\tdefault:\n \t\t\t\t\t\t\tthrow new JGitInternalException(MessageFormat\n \t\t\t\t\t\t\t\t\t.format(JGitText.get().updatingRefFailed,\n \t\t\t\t\t\t\t\t\t\t\tConstants.HEAD,\n \t\t\t\t\t\t\t\t\t\t\tcommitId.toString(), rc));\n \t\t\t\t\t\t}\n \t\t\t\t\t} finally {\n \t\t\t\t\t\trevWalk.release();\n \t\t\t\t\t}\n \t\t\t\t} finally {\n \t\t\t\t\todi.release();\n \t\t\t\t}\n \t\t\t} finally {\n \t\t\t\tindex.unlock();\n \t\t\t}\n \t\t} catch (UnmergedPathException e) {\n \t\t\tthrow new UnmergedPathsException(e);\n \t\t} catch (IOException e) {\n \t\t\tthrow new JGitInternalException(\n \t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"c96b40d5921d68edb96afad38b9c171388af4e05": {
			"type": "Ybodychange",
			"commitMessage": "CommitCommand: Don't allow amending on initial commit\n\nChange-Id: I27b13510eb6756da21d0d359d76031da4a875e28\n",
			"commitDate": "2012-10-07, 4:31 PM",
			"commitName": "c96b40d5921d68edb96afad38b9c171388af4e05",
			"commitAuthor": "Robin Stocker",
			"commitDateOld": "2012-06-15, 12:59 AM",
			"commitNameOld": "2656ac1b5acb9b73c6b47e2cf8830a0a0b2cc214",
			"commitAuthorOld": "Tomasz Zarna",
			"daysBetweenCommits": 114.65,
			"commitsBetweenForRepo": 116,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,130 +1,134 @@\n \tpublic RevCommit call() throws GitAPIException, NoHeadException,\n \t\t\tNoMessageException, UnmergedPathsException,\n \t\t\tConcurrentRefUpdateException,\n \t\t\tWrongRepositoryStateException {\n \t\tcheckCallable();\n \n \t\tRepositoryState state = repo.getRepositoryState();\n \t\tif (!state.canCommit())\n \t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().cannotCommitOnARepoWithState, state.name()));\n \t\tprocessOptions(state);\n \n \t\ttry {\n \t\t\tif (all && !repo.isBare() && repo.getWorkTree() != null) {\n \t\t\t\tGit git = new Git(repo);\n \t\t\t\ttry {\n \t\t\t\t\tgit.add()\n \t\t\t\t\t\t\t.addFilepattern(\".\")\n \t\t\t\t\t\t\t.setUpdate(true).call();\n \t\t\t\t} catch (NoFilepatternException e) {\n \t\t\t\t\t// should really not happen\n \t\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tRef head = repo.getRef(Constants.HEAD);\n \t\t\tif (head == null)\n \t\t\t\tthrow new NoHeadException(\n \t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n \n \t\t\t// determine the current HEAD and the commit it is referring to\n \t\t\tObjectId headId = repo.resolve(Constants.HEAD + \"^{commit}\");\n+\t\t\tif (headId == null && amend)\n+\t\t\t\tthrow new WrongRepositoryStateException(\n+\t\t\t\t\t\tJGitText.get().commitAmendOnInitialNotPossible);\n+\n \t\t\tif (headId != null)\n \t\t\t\tif (amend) {\n \t\t\t\t\tRevCommit previousCommit = new RevWalk(repo)\n \t\t\t\t\t\t\t.parseCommit(headId);\n \t\t\t\t\tRevCommit[] p = previousCommit.getParents();\n \t\t\t\t\tfor (int i = 0; i < p.length; i++)\n \t\t\t\t\t\tparents.add(0, p[i].getId());\n \t\t\t\t} else {\n \t\t\t\t\tparents.add(0, headId);\n \t\t\t\t}\n \n \t\t\t// lock the index\n \t\t\tDirCache index = repo.lockDirCache();\n \t\t\ttry {\n \t\t\t\tif (!only.isEmpty())\n \t\t\t\t\tindex = createTemporaryIndex(headId, index);\n \n \t\t\t\tObjectInserter odi = repo.newObjectInserter();\n \t\t\t\ttry {\n \t\t\t\t\t// Write the index as tree to the object database. This may\n \t\t\t\t\t// fail for example when the index contains unmerged paths\n \t\t\t\t\t// (unresolved conflicts)\n \t\t\t\t\tObjectId indexTreeId = index.writeTree(odi);\n \n \t\t\t\t\tif (insertChangeId)\n \t\t\t\t\t\tinsertChangeId(indexTreeId);\n \n \t\t\t\t\t// Create a Commit object, populate it and write it\n \t\t\t\t\tCommitBuilder commit = new CommitBuilder();\n \t\t\t\t\tcommit.setCommitter(committer);\n \t\t\t\t\tcommit.setAuthor(author);\n \t\t\t\t\tcommit.setMessage(message);\n \n \t\t\t\t\tcommit.setParentIds(parents);\n \t\t\t\t\tcommit.setTreeId(indexTreeId);\n \t\t\t\t\tObjectId commitId = odi.insert(commit);\n \t\t\t\t\todi.flush();\n \n \t\t\t\t\tRevWalk revWalk = new RevWalk(repo);\n \t\t\t\t\ttry {\n \t\t\t\t\t\tRevCommit revCommit = revWalk.parseCommit(commitId);\n \t\t\t\t\t\tRefUpdate ru = repo.updateRef(Constants.HEAD);\n \t\t\t\t\t\tru.setNewObjectId(commitId);\n \t\t\t\t\t\tif (reflogComment != null) {\n \t\t\t\t\t\t\tru.setRefLogMessage(reflogComment, false);\n \t\t\t\t\t\t} else {\n \t\t\t\t\t\t\tString prefix = amend ? \"commit (amend): \"\n \t\t\t\t\t\t\t\t\t: \"commit: \";\n \t\t\t\t\t\t\tru.setRefLogMessage(\n \t\t\t\t\t\t\t\t\tprefix + revCommit.getShortMessage(), false);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tif (headId != null)\n \t\t\t\t\t\t\tru.setExpectedOldObjectId(headId);\n \t\t\t\t\t\telse\n \t\t\t\t\t\t\tru.setExpectedOldObjectId(ObjectId.zeroId());\n \t\t\t\t\t\tResult rc = ru.forceUpdate();\n \t\t\t\t\t\tswitch (rc) {\n \t\t\t\t\t\tcase NEW:\n \t\t\t\t\t\tcase FORCED:\n \t\t\t\t\t\tcase FAST_FORWARD: {\n \t\t\t\t\t\t\tsetCallable(false);\n \t\t\t\t\t\t\tif (state == RepositoryState.MERGING_RESOLVED) {\n \t\t\t\t\t\t\t\t// Commit was successful. Now delete the files\n \t\t\t\t\t\t\t\t// used for merge commits\n \t\t\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n \t\t\t\t\t\t\t\trepo.writeMergeHeads(null);\n \t\t\t\t\t\t\t} else if (state == RepositoryState.CHERRY_PICKING_RESOLVED) {\n \t\t\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n \t\t\t\t\t\t\t\trepo.writeCherryPickHead(null);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\treturn revCommit;\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcase REJECTED:\n \t\t\t\t\t\tcase LOCK_FAILURE:\n \t\t\t\t\t\t\tthrow new ConcurrentRefUpdateException(JGitText\n \t\t\t\t\t\t\t\t\t.get().couldNotLockHEAD, ru.getRef(), rc);\n \t\t\t\t\t\tdefault:\n \t\t\t\t\t\t\tthrow new JGitInternalException(MessageFormat\n \t\t\t\t\t\t\t\t\t.format(JGitText.get().updatingRefFailed,\n \t\t\t\t\t\t\t\t\t\t\tConstants.HEAD,\n \t\t\t\t\t\t\t\t\t\t\tcommitId.toString(), rc));\n \t\t\t\t\t\t}\n \t\t\t\t\t} finally {\n \t\t\t\t\t\trevWalk.release();\n \t\t\t\t\t}\n \t\t\t\t} finally {\n \t\t\t\t\todi.release();\n \t\t\t\t}\n \t\t\t} finally {\n \t\t\t\tindex.unlock();\n \t\t\t}\n \t\t} catch (UnmergedPathException e) {\n \t\t\tthrow new UnmergedPathsException(e);\n \t\t} catch (IOException e) {\n \t\t\tthrow new JGitInternalException(\n \t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"4e1454ded6e2fcf6cb789c004756883c3ea5f77e": {
			"type": "Ymultichange(Yexceptionschange,Ybodychange)",
			"commitMessage": "Git API does not declare GitAPIException call() and related cleanups\n\nAll commands should throw a GitAPIException so new exceptions can be\nadded without breaking the builds of old code, i.e. anyone that calls\na Git API should catch GitAPIException and not just the currently known\nexceptions.\n\nNow the only checked exceptions on Git API calls are GitException and\nsubclasses of it. New checked exceptions that are subclasses of\nGitException may be added without breaking the API.\n\nJavadoc for GitAPIException is declared on GitCommand and\ninherited to subclasses. JGitInternalException is not explicitly\ndocumented anymore.\n\nUnfortunately this change itself breaks the API. The intention is\nthat it shall be possible to add new checked subclasses of\nGitAPIException without breaking the API.\n\nBug: 366914\nEGit-Change-Id: I50380f13fc82c22d0036f47c7859cc3a77e767c5\nChange-Id: I50380f13fc82c22d0036f47c7859cc3a77e767c5\nSigned-off-by: Matthias Sohn <matthias.sohn@sap.com>\n",
			"commitDate": "2012-05-30, 2:08 PM",
			"commitName": "4e1454ded6e2fcf6cb789c004756883c3ea5f77e",
			"commitAuthor": "Robin Rosenberg",
			"subchanges": [
				{
					"type": "Yexceptionschange",
					"commitMessage": "Git API does not declare GitAPIException call() and related cleanups\n\nAll commands should throw a GitAPIException so new exceptions can be\nadded without breaking the builds of old code, i.e. anyone that calls\na Git API should catch GitAPIException and not just the currently known\nexceptions.\n\nNow the only checked exceptions on Git API calls are GitException and\nsubclasses of it. New checked exceptions that are subclasses of\nGitException may be added without breaking the API.\n\nJavadoc for GitAPIException is declared on GitCommand and\ninherited to subclasses. JGitInternalException is not explicitly\ndocumented anymore.\n\nUnfortunately this change itself breaks the API. The intention is\nthat it shall be possible to add new checked subclasses of\nGitAPIException without breaking the API.\n\nBug: 366914\nEGit-Change-Id: I50380f13fc82c22d0036f47c7859cc3a77e767c5\nChange-Id: I50380f13fc82c22d0036f47c7859cc3a77e767c5\nSigned-off-by: Matthias Sohn <matthias.sohn@sap.com>\n",
					"commitDate": "2012-05-30, 2:08 PM",
					"commitName": "4e1454ded6e2fcf6cb789c004756883c3ea5f77e",
					"commitAuthor": "Robin Rosenberg",
					"commitDateOld": "2012-03-26, 4:47 PM",
					"commitNameOld": "3f4725c179c176560937d756682fcd6cfbf685fe",
					"commitAuthorOld": "Robin Rosenberg",
					"daysBetweenCommits": 64.89,
					"commitsBetweenForRepo": 48,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,132 +1,130 @@\n-\tpublic RevCommit call() throws NoHeadException, NoMessageException,\n-\t\t\tUnmergedPathException, ConcurrentRefUpdateException,\n-\t\t\tJGitInternalException, WrongRepositoryStateException {\n+\tpublic RevCommit call() throws GitAPIException, NoHeadException,\n+\t\t\tNoMessageException, UnmergedPathsException,\n+\t\t\tConcurrentRefUpdateException,\n+\t\t\tWrongRepositoryStateException {\n \t\tcheckCallable();\n \n \t\tRepositoryState state = repo.getRepositoryState();\n \t\tif (!state.canCommit())\n \t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().cannotCommitOnARepoWithState, state.name()));\n \t\tprocessOptions(state);\n \n \t\ttry {\n \t\t\tif (all && !repo.isBare() && repo.getWorkTree() != null) {\n \t\t\t\tGit git = new Git(repo);\n \t\t\t\ttry {\n \t\t\t\t\tgit.add()\n \t\t\t\t\t\t\t.addFilepattern(\".\")\n \t\t\t\t\t\t\t.setUpdate(true).call();\n \t\t\t\t} catch (NoFilepatternException e) {\n \t\t\t\t\t// should really not happen\n \t\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tRef head = repo.getRef(Constants.HEAD);\n \t\t\tif (head == null)\n \t\t\t\tthrow new NoHeadException(\n \t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n \n \t\t\t// determine the current HEAD and the commit it is referring to\n \t\t\tObjectId headId = repo.resolve(Constants.HEAD + \"^{commit}\");\n \t\t\tif (headId != null)\n \t\t\t\tif (amend) {\n \t\t\t\t\tRevCommit previousCommit = new RevWalk(repo)\n \t\t\t\t\t\t\t.parseCommit(headId);\n \t\t\t\t\tRevCommit[] p = previousCommit.getParents();\n \t\t\t\t\tfor (int i = 0; i < p.length; i++)\n \t\t\t\t\t\tparents.add(0, p[i].getId());\n \t\t\t\t} else {\n \t\t\t\t\tparents.add(0, headId);\n \t\t\t\t}\n \n \t\t\t// lock the index\n \t\t\tDirCache index = repo.lockDirCache();\n \t\t\ttry {\n \t\t\t\tif (!only.isEmpty())\n \t\t\t\t\tindex = createTemporaryIndex(headId, index);\n \n \t\t\t\tObjectInserter odi = repo.newObjectInserter();\n \t\t\t\ttry {\n \t\t\t\t\t// Write the index as tree to the object database. This may\n \t\t\t\t\t// fail for example when the index contains unmerged paths\n \t\t\t\t\t// (unresolved conflicts)\n \t\t\t\t\tObjectId indexTreeId = index.writeTree(odi);\n \n \t\t\t\t\tif (insertChangeId)\n \t\t\t\t\t\tinsertChangeId(indexTreeId);\n \n \t\t\t\t\t// Create a Commit object, populate it and write it\n \t\t\t\t\tCommitBuilder commit = new CommitBuilder();\n \t\t\t\t\tcommit.setCommitter(committer);\n \t\t\t\t\tcommit.setAuthor(author);\n \t\t\t\t\tcommit.setMessage(message);\n \n \t\t\t\t\tcommit.setParentIds(parents);\n \t\t\t\t\tcommit.setTreeId(indexTreeId);\n \t\t\t\t\tObjectId commitId = odi.insert(commit);\n \t\t\t\t\todi.flush();\n \n \t\t\t\t\tRevWalk revWalk = new RevWalk(repo);\n \t\t\t\t\ttry {\n \t\t\t\t\t\tRevCommit revCommit = revWalk.parseCommit(commitId);\n \t\t\t\t\t\tRefUpdate ru = repo.updateRef(Constants.HEAD);\n \t\t\t\t\t\tru.setNewObjectId(commitId);\n \t\t\t\t\t\tif (reflogComment != null) {\n \t\t\t\t\t\t\tru.setRefLogMessage(reflogComment, false);\n \t\t\t\t\t\t} else {\n \t\t\t\t\t\t\tString prefix = amend ? \"commit (amend): \"\n \t\t\t\t\t\t\t\t\t: \"commit: \";\n \t\t\t\t\t\t\tru.setRefLogMessage(\n \t\t\t\t\t\t\t\t\tprefix + revCommit.getShortMessage(), false);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tif (headId != null)\n \t\t\t\t\t\t\tru.setExpectedOldObjectId(headId);\n \t\t\t\t\t\telse\n \t\t\t\t\t\t\tru.setExpectedOldObjectId(ObjectId.zeroId());\n \t\t\t\t\t\tResult rc = ru.forceUpdate();\n \t\t\t\t\t\tswitch (rc) {\n \t\t\t\t\t\tcase NEW:\n \t\t\t\t\t\tcase FORCED:\n \t\t\t\t\t\tcase FAST_FORWARD: {\n \t\t\t\t\t\t\tsetCallable(false);\n \t\t\t\t\t\t\tif (state == RepositoryState.MERGING_RESOLVED) {\n \t\t\t\t\t\t\t\t// Commit was successful. Now delete the files\n \t\t\t\t\t\t\t\t// used for merge commits\n \t\t\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n \t\t\t\t\t\t\t\trepo.writeMergeHeads(null);\n \t\t\t\t\t\t\t} else if (state == RepositoryState.CHERRY_PICKING_RESOLVED) {\n \t\t\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n \t\t\t\t\t\t\t\trepo.writeCherryPickHead(null);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\treturn revCommit;\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcase REJECTED:\n \t\t\t\t\t\tcase LOCK_FAILURE:\n \t\t\t\t\t\t\tthrow new ConcurrentRefUpdateException(JGitText\n \t\t\t\t\t\t\t\t\t.get().couldNotLockHEAD, ru.getRef(), rc);\n \t\t\t\t\t\tdefault:\n \t\t\t\t\t\t\tthrow new JGitInternalException(MessageFormat\n \t\t\t\t\t\t\t\t\t.format(JGitText.get().updatingRefFailed,\n \t\t\t\t\t\t\t\t\t\t\tConstants.HEAD,\n \t\t\t\t\t\t\t\t\t\t\tcommitId.toString(), rc));\n \t\t\t\t\t\t}\n \t\t\t\t\t} finally {\n \t\t\t\t\t\trevWalk.release();\n \t\t\t\t\t}\n \t\t\t\t} finally {\n \t\t\t\t\todi.release();\n \t\t\t\t}\n \t\t\t} finally {\n \t\t\t\tindex.unlock();\n \t\t\t}\n \t\t} catch (UnmergedPathException e) {\n-\t\t\t// since UnmergedPathException is a subclass of IOException\n-\t\t\t// which should not be wrapped by a JGitInternalException we\n-\t\t\t// have to catch and re-throw it here\n-\t\t\tthrow e;\n+\t\t\tthrow new UnmergedPathsException(e);\n \t\t} catch (IOException e) {\n \t\t\tthrow new JGitInternalException(\n \t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n \t\t}\n \t}\n\\ No newline at end of file\n",
					"extendedDetails": {
						"oldValue": "[NoHeadException, NoMessageException, UnmergedPathException, ConcurrentRefUpdateException, JGitInternalException, WrongRepositoryStateException]",
						"newValue": "[GitAPIException, NoHeadException, NoMessageException, UnmergedPathsException, ConcurrentRefUpdateException, WrongRepositoryStateException]"
					}
				},
				{
					"type": "Ybodychange",
					"commitMessage": "Git API does not declare GitAPIException call() and related cleanups\n\nAll commands should throw a GitAPIException so new exceptions can be\nadded without breaking the builds of old code, i.e. anyone that calls\na Git API should catch GitAPIException and not just the currently known\nexceptions.\n\nNow the only checked exceptions on Git API calls are GitException and\nsubclasses of it. New checked exceptions that are subclasses of\nGitException may be added without breaking the API.\n\nJavadoc for GitAPIException is declared on GitCommand and\ninherited to subclasses. JGitInternalException is not explicitly\ndocumented anymore.\n\nUnfortunately this change itself breaks the API. The intention is\nthat it shall be possible to add new checked subclasses of\nGitAPIException without breaking the API.\n\nBug: 366914\nEGit-Change-Id: I50380f13fc82c22d0036f47c7859cc3a77e767c5\nChange-Id: I50380f13fc82c22d0036f47c7859cc3a77e767c5\nSigned-off-by: Matthias Sohn <matthias.sohn@sap.com>\n",
					"commitDate": "2012-05-30, 2:08 PM",
					"commitName": "4e1454ded6e2fcf6cb789c004756883c3ea5f77e",
					"commitAuthor": "Robin Rosenberg",
					"commitDateOld": "2012-03-26, 4:47 PM",
					"commitNameOld": "3f4725c179c176560937d756682fcd6cfbf685fe",
					"commitAuthorOld": "Robin Rosenberg",
					"daysBetweenCommits": 64.89,
					"commitsBetweenForRepo": 48,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,132 +1,130 @@\n-\tpublic RevCommit call() throws NoHeadException, NoMessageException,\n-\t\t\tUnmergedPathException, ConcurrentRefUpdateException,\n-\t\t\tJGitInternalException, WrongRepositoryStateException {\n+\tpublic RevCommit call() throws GitAPIException, NoHeadException,\n+\t\t\tNoMessageException, UnmergedPathsException,\n+\t\t\tConcurrentRefUpdateException,\n+\t\t\tWrongRepositoryStateException {\n \t\tcheckCallable();\n \n \t\tRepositoryState state = repo.getRepositoryState();\n \t\tif (!state.canCommit())\n \t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().cannotCommitOnARepoWithState, state.name()));\n \t\tprocessOptions(state);\n \n \t\ttry {\n \t\t\tif (all && !repo.isBare() && repo.getWorkTree() != null) {\n \t\t\t\tGit git = new Git(repo);\n \t\t\t\ttry {\n \t\t\t\t\tgit.add()\n \t\t\t\t\t\t\t.addFilepattern(\".\")\n \t\t\t\t\t\t\t.setUpdate(true).call();\n \t\t\t\t} catch (NoFilepatternException e) {\n \t\t\t\t\t// should really not happen\n \t\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tRef head = repo.getRef(Constants.HEAD);\n \t\t\tif (head == null)\n \t\t\t\tthrow new NoHeadException(\n \t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n \n \t\t\t// determine the current HEAD and the commit it is referring to\n \t\t\tObjectId headId = repo.resolve(Constants.HEAD + \"^{commit}\");\n \t\t\tif (headId != null)\n \t\t\t\tif (amend) {\n \t\t\t\t\tRevCommit previousCommit = new RevWalk(repo)\n \t\t\t\t\t\t\t.parseCommit(headId);\n \t\t\t\t\tRevCommit[] p = previousCommit.getParents();\n \t\t\t\t\tfor (int i = 0; i < p.length; i++)\n \t\t\t\t\t\tparents.add(0, p[i].getId());\n \t\t\t\t} else {\n \t\t\t\t\tparents.add(0, headId);\n \t\t\t\t}\n \n \t\t\t// lock the index\n \t\t\tDirCache index = repo.lockDirCache();\n \t\t\ttry {\n \t\t\t\tif (!only.isEmpty())\n \t\t\t\t\tindex = createTemporaryIndex(headId, index);\n \n \t\t\t\tObjectInserter odi = repo.newObjectInserter();\n \t\t\t\ttry {\n \t\t\t\t\t// Write the index as tree to the object database. This may\n \t\t\t\t\t// fail for example when the index contains unmerged paths\n \t\t\t\t\t// (unresolved conflicts)\n \t\t\t\t\tObjectId indexTreeId = index.writeTree(odi);\n \n \t\t\t\t\tif (insertChangeId)\n \t\t\t\t\t\tinsertChangeId(indexTreeId);\n \n \t\t\t\t\t// Create a Commit object, populate it and write it\n \t\t\t\t\tCommitBuilder commit = new CommitBuilder();\n \t\t\t\t\tcommit.setCommitter(committer);\n \t\t\t\t\tcommit.setAuthor(author);\n \t\t\t\t\tcommit.setMessage(message);\n \n \t\t\t\t\tcommit.setParentIds(parents);\n \t\t\t\t\tcommit.setTreeId(indexTreeId);\n \t\t\t\t\tObjectId commitId = odi.insert(commit);\n \t\t\t\t\todi.flush();\n \n \t\t\t\t\tRevWalk revWalk = new RevWalk(repo);\n \t\t\t\t\ttry {\n \t\t\t\t\t\tRevCommit revCommit = revWalk.parseCommit(commitId);\n \t\t\t\t\t\tRefUpdate ru = repo.updateRef(Constants.HEAD);\n \t\t\t\t\t\tru.setNewObjectId(commitId);\n \t\t\t\t\t\tif (reflogComment != null) {\n \t\t\t\t\t\t\tru.setRefLogMessage(reflogComment, false);\n \t\t\t\t\t\t} else {\n \t\t\t\t\t\t\tString prefix = amend ? \"commit (amend): \"\n \t\t\t\t\t\t\t\t\t: \"commit: \";\n \t\t\t\t\t\t\tru.setRefLogMessage(\n \t\t\t\t\t\t\t\t\tprefix + revCommit.getShortMessage(), false);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tif (headId != null)\n \t\t\t\t\t\t\tru.setExpectedOldObjectId(headId);\n \t\t\t\t\t\telse\n \t\t\t\t\t\t\tru.setExpectedOldObjectId(ObjectId.zeroId());\n \t\t\t\t\t\tResult rc = ru.forceUpdate();\n \t\t\t\t\t\tswitch (rc) {\n \t\t\t\t\t\tcase NEW:\n \t\t\t\t\t\tcase FORCED:\n \t\t\t\t\t\tcase FAST_FORWARD: {\n \t\t\t\t\t\t\tsetCallable(false);\n \t\t\t\t\t\t\tif (state == RepositoryState.MERGING_RESOLVED) {\n \t\t\t\t\t\t\t\t// Commit was successful. Now delete the files\n \t\t\t\t\t\t\t\t// used for merge commits\n \t\t\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n \t\t\t\t\t\t\t\trepo.writeMergeHeads(null);\n \t\t\t\t\t\t\t} else if (state == RepositoryState.CHERRY_PICKING_RESOLVED) {\n \t\t\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n \t\t\t\t\t\t\t\trepo.writeCherryPickHead(null);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\treturn revCommit;\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcase REJECTED:\n \t\t\t\t\t\tcase LOCK_FAILURE:\n \t\t\t\t\t\t\tthrow new ConcurrentRefUpdateException(JGitText\n \t\t\t\t\t\t\t\t\t.get().couldNotLockHEAD, ru.getRef(), rc);\n \t\t\t\t\t\tdefault:\n \t\t\t\t\t\t\tthrow new JGitInternalException(MessageFormat\n \t\t\t\t\t\t\t\t\t.format(JGitText.get().updatingRefFailed,\n \t\t\t\t\t\t\t\t\t\t\tConstants.HEAD,\n \t\t\t\t\t\t\t\t\t\t\tcommitId.toString(), rc));\n \t\t\t\t\t\t}\n \t\t\t\t\t} finally {\n \t\t\t\t\t\trevWalk.release();\n \t\t\t\t\t}\n \t\t\t\t} finally {\n \t\t\t\t\todi.release();\n \t\t\t\t}\n \t\t\t} finally {\n \t\t\t\tindex.unlock();\n \t\t\t}\n \t\t} catch (UnmergedPathException e) {\n-\t\t\t// since UnmergedPathException is a subclass of IOException\n-\t\t\t// which should not be wrapped by a JGitInternalException we\n-\t\t\t// have to catch and re-throw it here\n-\t\t\tthrow e;\n+\t\t\tthrow new UnmergedPathsException(e);\n \t\t} catch (IOException e) {\n \t\t\tthrow new JGitInternalException(\n \t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n \t\t}\n \t}\n\\ No newline at end of file\n",
					"extendedDetails": {}
				}
			]
		},
		"2539b1ee096266b7fcca64545f93d7c08ab30f53": {
			"type": "Ybodychange",
			"commitMessage": "Set expected old object id to all zeros when head id is null\n\nThis will be the case on the initial commit to a repository\nand the ref update should expect a non-existent ref\n\nChange-Id: Iaa06e47e6e8cc4a0281c7683b367d4806dd980ea\n",
			"commitDate": "2011-12-06, 7:02 PM",
			"commitName": "2539b1ee096266b7fcca64545f93d7c08ab30f53",
			"commitAuthor": "Kevin Sawicki",
			"commitDateOld": "2011-09-21, 3:36 PM",
			"commitNameOld": "4f4e468f6f344ed7c106b86b850d2c9171dd1a0f",
			"commitAuthorOld": "Robin Rosenberg",
			"daysBetweenCommits": 76.18,
			"commitsBetweenForRepo": 86,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,129 +1,132 @@\n \tpublic RevCommit call() throws NoHeadException, NoMessageException,\n \t\t\tUnmergedPathException, ConcurrentRefUpdateException,\n \t\t\tJGitInternalException, WrongRepositoryStateException {\n \t\tcheckCallable();\n \n \t\tRepositoryState state = repo.getRepositoryState();\n \t\tif (!state.canCommit())\n \t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().cannotCommitOnARepoWithState, state.name()));\n \t\tprocessOptions(state);\n \n \t\ttry {\n \t\t\tif (all && !repo.isBare() && repo.getWorkTree() != null) {\n \t\t\t\tGit git = new Git(repo);\n \t\t\t\ttry {\n \t\t\t\t\tgit.add()\n \t\t\t\t\t\t\t.addFilepattern(\".\")\n \t\t\t\t\t\t\t.setUpdate(true).call();\n \t\t\t\t} catch (NoFilepatternException e) {\n \t\t\t\t\t// should really not happen\n \t\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tRef head = repo.getRef(Constants.HEAD);\n \t\t\tif (head == null)\n \t\t\t\tthrow new NoHeadException(\n \t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n \n \t\t\t// determine the current HEAD and the commit it is referring to\n \t\t\tObjectId headId = repo.resolve(Constants.HEAD + \"^{commit}\");\n \t\t\tif (headId != null)\n \t\t\t\tif (amend) {\n \t\t\t\t\tRevCommit previousCommit = new RevWalk(repo)\n \t\t\t\t\t\t\t.parseCommit(headId);\n \t\t\t\t\tRevCommit[] p = previousCommit.getParents();\n \t\t\t\t\tfor (int i = 0; i < p.length; i++)\n \t\t\t\t\t\tparents.add(0, p[i].getId());\n \t\t\t\t} else {\n \t\t\t\t\tparents.add(0, headId);\n \t\t\t\t}\n \n \t\t\t// lock the index\n \t\t\tDirCache index = repo.lockDirCache();\n \t\t\ttry {\n \t\t\t\tif (!only.isEmpty())\n \t\t\t\t\tindex = createTemporaryIndex(headId, index);\n \n \t\t\t\tObjectInserter odi = repo.newObjectInserter();\n \t\t\t\ttry {\n \t\t\t\t\t// Write the index as tree to the object database. This may\n \t\t\t\t\t// fail for example when the index contains unmerged paths\n \t\t\t\t\t// (unresolved conflicts)\n \t\t\t\t\tObjectId indexTreeId = index.writeTree(odi);\n \n \t\t\t\t\tif (insertChangeId)\n \t\t\t\t\t\tinsertChangeId(indexTreeId);\n \n \t\t\t\t\t// Create a Commit object, populate it and write it\n \t\t\t\t\tCommitBuilder commit = new CommitBuilder();\n \t\t\t\t\tcommit.setCommitter(committer);\n \t\t\t\t\tcommit.setAuthor(author);\n \t\t\t\t\tcommit.setMessage(message);\n \n \t\t\t\t\tcommit.setParentIds(parents);\n \t\t\t\t\tcommit.setTreeId(indexTreeId);\n \t\t\t\t\tObjectId commitId = odi.insert(commit);\n \t\t\t\t\todi.flush();\n \n \t\t\t\t\tRevWalk revWalk = new RevWalk(repo);\n \t\t\t\t\ttry {\n \t\t\t\t\t\tRevCommit revCommit = revWalk.parseCommit(commitId);\n \t\t\t\t\t\tRefUpdate ru = repo.updateRef(Constants.HEAD);\n \t\t\t\t\t\tru.setNewObjectId(commitId);\n \t\t\t\t\t\tif (reflogComment != null) {\n \t\t\t\t\t\t\tru.setRefLogMessage(reflogComment, false);\n \t\t\t\t\t\t} else {\n \t\t\t\t\t\t\tString prefix = amend ? \"commit (amend): \"\n \t\t\t\t\t\t\t\t\t: \"commit: \";\n \t\t\t\t\t\t\tru.setRefLogMessage(\n \t\t\t\t\t\t\t\t\tprefix + revCommit.getShortMessage(), false);\n \t\t\t\t\t\t}\n-\t\t\t\t\t\tru.setExpectedOldObjectId(headId);\n+\t\t\t\t\t\tif (headId != null)\n+\t\t\t\t\t\t\tru.setExpectedOldObjectId(headId);\n+\t\t\t\t\t\telse\n+\t\t\t\t\t\t\tru.setExpectedOldObjectId(ObjectId.zeroId());\n \t\t\t\t\t\tResult rc = ru.forceUpdate();\n \t\t\t\t\t\tswitch (rc) {\n \t\t\t\t\t\tcase NEW:\n \t\t\t\t\t\tcase FORCED:\n \t\t\t\t\t\tcase FAST_FORWARD: {\n \t\t\t\t\t\t\tsetCallable(false);\n \t\t\t\t\t\t\tif (state == RepositoryState.MERGING_RESOLVED) {\n \t\t\t\t\t\t\t\t// Commit was successful. Now delete the files\n \t\t\t\t\t\t\t\t// used for merge commits\n \t\t\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n \t\t\t\t\t\t\t\trepo.writeMergeHeads(null);\n \t\t\t\t\t\t\t} else if (state == RepositoryState.CHERRY_PICKING_RESOLVED) {\n \t\t\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n \t\t\t\t\t\t\t\trepo.writeCherryPickHead(null);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\treturn revCommit;\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcase REJECTED:\n \t\t\t\t\t\tcase LOCK_FAILURE:\n \t\t\t\t\t\t\tthrow new ConcurrentRefUpdateException(JGitText\n \t\t\t\t\t\t\t\t\t.get().couldNotLockHEAD, ru.getRef(), rc);\n \t\t\t\t\t\tdefault:\n \t\t\t\t\t\t\tthrow new JGitInternalException(MessageFormat\n \t\t\t\t\t\t\t\t\t.format(JGitText.get().updatingRefFailed,\n \t\t\t\t\t\t\t\t\t\t\tConstants.HEAD,\n \t\t\t\t\t\t\t\t\t\t\tcommitId.toString(), rc));\n \t\t\t\t\t\t}\n \t\t\t\t\t} finally {\n \t\t\t\t\t\trevWalk.release();\n \t\t\t\t\t}\n \t\t\t\t} finally {\n \t\t\t\t\todi.release();\n \t\t\t\t}\n \t\t\t} finally {\n \t\t\t\tindex.unlock();\n \t\t\t}\n \t\t} catch (UnmergedPathException e) {\n \t\t\t// since UnmergedPathException is a subclass of IOException\n \t\t\t// which should not be wrapped by a JGitInternalException we\n \t\t\t// have to catch and re-throw it here\n \t\t\tthrow e;\n \t\t} catch (IOException e) {\n \t\t\tthrow new JGitInternalException(\n \t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"4f4e468f6f344ed7c106b86b850d2c9171dd1a0f": {
			"type": "Ybodychange",
			"commitMessage": "Fix the reflog prefix for cherry-pick, revert and merge commands\n\nWe should see whether the commit was a regular commit or something\nelse.\n\nChange-Id: I82d8300cf3c53cb2bdcb6495386aadb803e0c6f7\nSigned-off-by: Robin Rosenberg <robin.rosenberg@dewire.com>\nSigned-off-by: Matthias Sohn <matthias.sohn@sap.com>\n",
			"commitDate": "2011-09-21, 3:36 PM",
			"commitName": "4f4e468f6f344ed7c106b86b850d2c9171dd1a0f",
			"commitAuthor": "Robin Rosenberg",
			"commitDateOld": "2011-09-08, 8:46 AM",
			"commitNameOld": "a7d3c680151aa27608c6381db0983b51828c2358",
			"commitAuthorOld": "Robin Rosenberg",
			"daysBetweenCommits": 13.28,
			"commitsBetweenForRepo": 4,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,125 +1,129 @@\n \tpublic RevCommit call() throws NoHeadException, NoMessageException,\n \t\t\tUnmergedPathException, ConcurrentRefUpdateException,\n \t\t\tJGitInternalException, WrongRepositoryStateException {\n \t\tcheckCallable();\n \n \t\tRepositoryState state = repo.getRepositoryState();\n \t\tif (!state.canCommit())\n \t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().cannotCommitOnARepoWithState, state.name()));\n \t\tprocessOptions(state);\n \n \t\ttry {\n \t\t\tif (all && !repo.isBare() && repo.getWorkTree() != null) {\n \t\t\t\tGit git = new Git(repo);\n \t\t\t\ttry {\n \t\t\t\t\tgit.add()\n \t\t\t\t\t\t\t.addFilepattern(\".\")\n \t\t\t\t\t\t\t.setUpdate(true).call();\n \t\t\t\t} catch (NoFilepatternException e) {\n \t\t\t\t\t// should really not happen\n \t\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tRef head = repo.getRef(Constants.HEAD);\n \t\t\tif (head == null)\n \t\t\t\tthrow new NoHeadException(\n \t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n \n \t\t\t// determine the current HEAD and the commit it is referring to\n \t\t\tObjectId headId = repo.resolve(Constants.HEAD + \"^{commit}\");\n \t\t\tif (headId != null)\n \t\t\t\tif (amend) {\n \t\t\t\t\tRevCommit previousCommit = new RevWalk(repo)\n \t\t\t\t\t\t\t.parseCommit(headId);\n \t\t\t\t\tRevCommit[] p = previousCommit.getParents();\n \t\t\t\t\tfor (int i = 0; i < p.length; i++)\n \t\t\t\t\t\tparents.add(0, p[i].getId());\n \t\t\t\t} else {\n \t\t\t\t\tparents.add(0, headId);\n \t\t\t\t}\n \n \t\t\t// lock the index\n \t\t\tDirCache index = repo.lockDirCache();\n \t\t\ttry {\n \t\t\t\tif (!only.isEmpty())\n \t\t\t\t\tindex = createTemporaryIndex(headId, index);\n \n \t\t\t\tObjectInserter odi = repo.newObjectInserter();\n \t\t\t\ttry {\n \t\t\t\t\t// Write the index as tree to the object database. This may\n \t\t\t\t\t// fail for example when the index contains unmerged paths\n \t\t\t\t\t// (unresolved conflicts)\n \t\t\t\t\tObjectId indexTreeId = index.writeTree(odi);\n \n \t\t\t\t\tif (insertChangeId)\n \t\t\t\t\t\tinsertChangeId(indexTreeId);\n \n \t\t\t\t\t// Create a Commit object, populate it and write it\n \t\t\t\t\tCommitBuilder commit = new CommitBuilder();\n \t\t\t\t\tcommit.setCommitter(committer);\n \t\t\t\t\tcommit.setAuthor(author);\n \t\t\t\t\tcommit.setMessage(message);\n \n \t\t\t\t\tcommit.setParentIds(parents);\n \t\t\t\t\tcommit.setTreeId(indexTreeId);\n \t\t\t\t\tObjectId commitId = odi.insert(commit);\n \t\t\t\t\todi.flush();\n \n \t\t\t\t\tRevWalk revWalk = new RevWalk(repo);\n \t\t\t\t\ttry {\n \t\t\t\t\t\tRevCommit revCommit = revWalk.parseCommit(commitId);\n \t\t\t\t\t\tRefUpdate ru = repo.updateRef(Constants.HEAD);\n \t\t\t\t\t\tru.setNewObjectId(commitId);\n-\t\t\t\t\t\tString prefix = amend ? \"commit (amend): \" : \"commit: \";\n-\t\t\t\t\t\tru.setRefLogMessage(\n-\t\t\t\t\t\t\t\tprefix + revCommit.getShortMessage(), false);\n-\n+\t\t\t\t\t\tif (reflogComment != null) {\n+\t\t\t\t\t\t\tru.setRefLogMessage(reflogComment, false);\n+\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\tString prefix = amend ? \"commit (amend): \"\n+\t\t\t\t\t\t\t\t\t: \"commit: \";\n+\t\t\t\t\t\t\tru.setRefLogMessage(\n+\t\t\t\t\t\t\t\t\tprefix + revCommit.getShortMessage(), false);\n+\t\t\t\t\t\t}\n \t\t\t\t\t\tru.setExpectedOldObjectId(headId);\n \t\t\t\t\t\tResult rc = ru.forceUpdate();\n \t\t\t\t\t\tswitch (rc) {\n \t\t\t\t\t\tcase NEW:\n \t\t\t\t\t\tcase FORCED:\n \t\t\t\t\t\tcase FAST_FORWARD: {\n \t\t\t\t\t\t\tsetCallable(false);\n \t\t\t\t\t\t\tif (state == RepositoryState.MERGING_RESOLVED) {\n \t\t\t\t\t\t\t\t// Commit was successful. Now delete the files\n \t\t\t\t\t\t\t\t// used for merge commits\n \t\t\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n \t\t\t\t\t\t\t\trepo.writeMergeHeads(null);\n \t\t\t\t\t\t\t} else if (state == RepositoryState.CHERRY_PICKING_RESOLVED) {\n \t\t\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n \t\t\t\t\t\t\t\trepo.writeCherryPickHead(null);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\treturn revCommit;\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcase REJECTED:\n \t\t\t\t\t\tcase LOCK_FAILURE:\n \t\t\t\t\t\t\tthrow new ConcurrentRefUpdateException(JGitText\n \t\t\t\t\t\t\t\t\t.get().couldNotLockHEAD, ru.getRef(), rc);\n \t\t\t\t\t\tdefault:\n \t\t\t\t\t\t\tthrow new JGitInternalException(MessageFormat\n \t\t\t\t\t\t\t\t\t.format(JGitText.get().updatingRefFailed,\n \t\t\t\t\t\t\t\t\t\t\tConstants.HEAD,\n \t\t\t\t\t\t\t\t\t\t\tcommitId.toString(), rc));\n \t\t\t\t\t\t}\n \t\t\t\t\t} finally {\n \t\t\t\t\t\trevWalk.release();\n \t\t\t\t\t}\n \t\t\t\t} finally {\n \t\t\t\t\todi.release();\n \t\t\t\t}\n \t\t\t} finally {\n \t\t\t\tindex.unlock();\n \t\t\t}\n \t\t} catch (UnmergedPathException e) {\n \t\t\t// since UnmergedPathException is a subclass of IOException\n \t\t\t// which should not be wrapped by a JGitInternalException we\n \t\t\t// have to catch and re-throw it here\n \t\t\tthrow e;\n \t\t} catch (IOException e) {\n \t\t\tthrow new JGitInternalException(\n \t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"6e10aa42e90a25b82f00f0c27574f57ffa9e4a25": {
			"type": "Ybodychange",
			"commitMessage": "Add CHERRY_PICK_HEAD for cherry-pick conflicts\n\nAdd handling of CHERRY_PICK_HEAD file in .git (similar to MERGE_HEAD),\nwhich is written in case of a conflicting cherry-pick merge.\n\nIt is used so that Repository.getRepositoryState can return the new\nstates CHERRY_PICKING and CHERRY_PICKING_RESOLVED. These states, as well\nas CHERRY_PICK_HEAD can be used in EGit to properly show the merge tool.\n\nAlso, in case of a conflict, MERGE_MSG is written with the original\ncommit message and a \"Conflicts\" section appended. This way, the\ncherry-picked message is not lost and can later be re-used in the commit\ndialog.\n\nBug: 339092\nChange-Id: I947967fdc2f1d55016c95106b104c2afcc9797a1\nSigned-off-by: Robin Stocker <robin@nibor.org>\nSigned-off-by: Chris Aniszczyk <caniszczyk@gmail.com>\n",
			"commitDate": "2011-04-06, 12:28 PM",
			"commitName": "6e10aa42e90a25b82f00f0c27574f57ffa9e4a25",
			"commitAuthor": "Robin Stocker",
			"commitDateOld": "2011-03-17, 11:15 AM",
			"commitNameOld": "fd963a9180af73b6a05a5c1a2af6dd7168899170",
			"commitAuthorOld": "Jens Baumgart",
			"daysBetweenCommits": 20.05,
			"commitsBetweenForRepo": 52,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,122 +1,125 @@\n \tpublic RevCommit call() throws NoHeadException, NoMessageException,\n \t\t\tUnmergedPathException, ConcurrentRefUpdateException,\n \t\t\tJGitInternalException, WrongRepositoryStateException {\n \t\tcheckCallable();\n \n \t\tRepositoryState state = repo.getRepositoryState();\n \t\tif (!state.canCommit())\n \t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().cannotCommitOnARepoWithState, state.name()));\n \t\tprocessOptions(state);\n \n \t\ttry {\n \t\t\tif (all && !repo.isBare() && repo.getWorkTree() != null) {\n \t\t\t\tGit git = new Git(repo);\n \t\t\t\ttry {\n \t\t\t\t\tgit.add()\n \t\t\t\t\t\t\t.addFilepattern(\".\")\n \t\t\t\t\t\t\t.setUpdate(true).call();\n \t\t\t\t} catch (NoFilepatternException e) {\n \t\t\t\t\t// should really not happen\n \t\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tRef head = repo.getRef(Constants.HEAD);\n \t\t\tif (head == null)\n \t\t\t\tthrow new NoHeadException(\n \t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n \n \t\t\t// determine the current HEAD and the commit it is referring to\n \t\t\tObjectId headId = repo.resolve(Constants.HEAD + \"^{commit}\");\n \t\t\tif (headId != null)\n \t\t\t\tif (amend) {\n \t\t\t\t\tRevCommit previousCommit = new RevWalk(repo)\n \t\t\t\t\t\t\t.parseCommit(headId);\n \t\t\t\t\tRevCommit[] p = previousCommit.getParents();\n \t\t\t\t\tfor (int i = 0; i < p.length; i++)\n \t\t\t\t\t\tparents.add(0, p[i].getId());\n \t\t\t\t} else {\n \t\t\t\t\tparents.add(0, headId);\n \t\t\t\t}\n \n \t\t\t// lock the index\n \t\t\tDirCache index = repo.lockDirCache();\n \t\t\ttry {\n \t\t\t\tif (!only.isEmpty())\n \t\t\t\t\tindex = createTemporaryIndex(headId, index);\n \n \t\t\t\tObjectInserter odi = repo.newObjectInserter();\n \t\t\t\ttry {\n \t\t\t\t\t// Write the index as tree to the object database. This may\n \t\t\t\t\t// fail for example when the index contains unmerged paths\n \t\t\t\t\t// (unresolved conflicts)\n \t\t\t\t\tObjectId indexTreeId = index.writeTree(odi);\n \n \t\t\t\t\tif (insertChangeId)\n \t\t\t\t\t\tinsertChangeId(indexTreeId);\n \n \t\t\t\t\t// Create a Commit object, populate it and write it\n \t\t\t\t\tCommitBuilder commit = new CommitBuilder();\n \t\t\t\t\tcommit.setCommitter(committer);\n \t\t\t\t\tcommit.setAuthor(author);\n \t\t\t\t\tcommit.setMessage(message);\n \n \t\t\t\t\tcommit.setParentIds(parents);\n \t\t\t\t\tcommit.setTreeId(indexTreeId);\n \t\t\t\t\tObjectId commitId = odi.insert(commit);\n \t\t\t\t\todi.flush();\n \n \t\t\t\t\tRevWalk revWalk = new RevWalk(repo);\n \t\t\t\t\ttry {\n \t\t\t\t\t\tRevCommit revCommit = revWalk.parseCommit(commitId);\n \t\t\t\t\t\tRefUpdate ru = repo.updateRef(Constants.HEAD);\n \t\t\t\t\t\tru.setNewObjectId(commitId);\n \t\t\t\t\t\tString prefix = amend ? \"commit (amend): \" : \"commit: \";\n \t\t\t\t\t\tru.setRefLogMessage(\n \t\t\t\t\t\t\t\tprefix + revCommit.getShortMessage(), false);\n \n \t\t\t\t\t\tru.setExpectedOldObjectId(headId);\n \t\t\t\t\t\tResult rc = ru.forceUpdate();\n \t\t\t\t\t\tswitch (rc) {\n \t\t\t\t\t\tcase NEW:\n \t\t\t\t\t\tcase FORCED:\n \t\t\t\t\t\tcase FAST_FORWARD: {\n \t\t\t\t\t\t\tsetCallable(false);\n \t\t\t\t\t\t\tif (state == RepositoryState.MERGING_RESOLVED) {\n \t\t\t\t\t\t\t\t// Commit was successful. Now delete the files\n \t\t\t\t\t\t\t\t// used for merge commits\n \t\t\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n \t\t\t\t\t\t\t\trepo.writeMergeHeads(null);\n+\t\t\t\t\t\t\t} else if (state == RepositoryState.CHERRY_PICKING_RESOLVED) {\n+\t\t\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n+\t\t\t\t\t\t\t\trepo.writeCherryPickHead(null);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\treturn revCommit;\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcase REJECTED:\n \t\t\t\t\t\tcase LOCK_FAILURE:\n \t\t\t\t\t\t\tthrow new ConcurrentRefUpdateException(JGitText\n \t\t\t\t\t\t\t\t\t.get().couldNotLockHEAD, ru.getRef(), rc);\n \t\t\t\t\t\tdefault:\n \t\t\t\t\t\t\tthrow new JGitInternalException(MessageFormat\n \t\t\t\t\t\t\t\t\t.format(JGitText.get().updatingRefFailed,\n \t\t\t\t\t\t\t\t\t\t\tConstants.HEAD,\n \t\t\t\t\t\t\t\t\t\t\tcommitId.toString(), rc));\n \t\t\t\t\t\t}\n \t\t\t\t\t} finally {\n \t\t\t\t\t\trevWalk.release();\n \t\t\t\t\t}\n \t\t\t\t} finally {\n \t\t\t\t\todi.release();\n \t\t\t\t}\n \t\t\t} finally {\n \t\t\t\tindex.unlock();\n \t\t\t}\n \t\t} catch (UnmergedPathException e) {\n \t\t\t// since UnmergedPathException is a subclass of IOException\n \t\t\t// which should not be wrapped by a JGitInternalException we\n \t\t\t// have to catch and re-throw it here\n \t\t\tthrow e;\n \t\t} catch (IOException e) {\n \t\t\tthrow new JGitInternalException(\n \t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"fd963a9180af73b6a05a5c1a2af6dd7168899170": {
			"type": "Ybodychange",
			"commitMessage": "CommitCommand: add option to insert a change id\n\nAn option to insert a change id into the commit message was added\nto CommitCommand.\nThis change is a prerequisite for removing GitIndex from EGit.\n\nChange-Id: Iff9e26a8aaf21d8224bfd6ce3c98821c077bcd82\nSigned-off-by: Jens Baumgart <jens.baumgart@sap.com>\nSigned-off-by: Philipp Thun <philipp.thun@sap.com>\nSigned-off-by: Mathias Kinzler <mathias.kinzler@sap.com>",
			"commitDate": "2011-03-17, 11:15 AM",
			"commitName": "fd963a9180af73b6a05a5c1a2af6dd7168899170",
			"commitAuthor": "Jens Baumgart",
			"commitDateOld": "2011-03-15, 6:55 AM",
			"commitNameOld": "79ad15924acc2ba2412d5114c85db27f0f4aca22",
			"commitAuthorOld": "Philipp Thun",
			"daysBetweenCommits": 2.18,
			"commitsBetweenForRepo": 6,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,119 +1,122 @@\n \tpublic RevCommit call() throws NoHeadException, NoMessageException,\n \t\t\tUnmergedPathException, ConcurrentRefUpdateException,\n \t\t\tJGitInternalException, WrongRepositoryStateException {\n \t\tcheckCallable();\n \n \t\tRepositoryState state = repo.getRepositoryState();\n \t\tif (!state.canCommit())\n \t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().cannotCommitOnARepoWithState, state.name()));\n \t\tprocessOptions(state);\n \n \t\ttry {\n \t\t\tif (all && !repo.isBare() && repo.getWorkTree() != null) {\n \t\t\t\tGit git = new Git(repo);\n \t\t\t\ttry {\n \t\t\t\t\tgit.add()\n \t\t\t\t\t\t\t.addFilepattern(\".\")\n \t\t\t\t\t\t\t.setUpdate(true).call();\n \t\t\t\t} catch (NoFilepatternException e) {\n \t\t\t\t\t// should really not happen\n \t\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tRef head = repo.getRef(Constants.HEAD);\n \t\t\tif (head == null)\n \t\t\t\tthrow new NoHeadException(\n \t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n \n \t\t\t// determine the current HEAD and the commit it is referring to\n \t\t\tObjectId headId = repo.resolve(Constants.HEAD + \"^{commit}\");\n \t\t\tif (headId != null)\n \t\t\t\tif (amend) {\n \t\t\t\t\tRevCommit previousCommit = new RevWalk(repo)\n \t\t\t\t\t\t\t.parseCommit(headId);\n \t\t\t\t\tRevCommit[] p = previousCommit.getParents();\n \t\t\t\t\tfor (int i = 0; i < p.length; i++)\n \t\t\t\t\t\tparents.add(0, p[i].getId());\n \t\t\t\t} else {\n \t\t\t\t\tparents.add(0, headId);\n \t\t\t\t}\n \n \t\t\t// lock the index\n \t\t\tDirCache index = repo.lockDirCache();\n \t\t\ttry {\n \t\t\t\tif (!only.isEmpty())\n \t\t\t\t\tindex = createTemporaryIndex(headId, index);\n \n \t\t\t\tObjectInserter odi = repo.newObjectInserter();\n \t\t\t\ttry {\n \t\t\t\t\t// Write the index as tree to the object database. This may\n \t\t\t\t\t// fail for example when the index contains unmerged paths\n \t\t\t\t\t// (unresolved conflicts)\n \t\t\t\t\tObjectId indexTreeId = index.writeTree(odi);\n \n+\t\t\t\t\tif (insertChangeId)\n+\t\t\t\t\t\tinsertChangeId(indexTreeId);\n+\n \t\t\t\t\t// Create a Commit object, populate it and write it\n \t\t\t\t\tCommitBuilder commit = new CommitBuilder();\n \t\t\t\t\tcommit.setCommitter(committer);\n \t\t\t\t\tcommit.setAuthor(author);\n \t\t\t\t\tcommit.setMessage(message);\n \n \t\t\t\t\tcommit.setParentIds(parents);\n \t\t\t\t\tcommit.setTreeId(indexTreeId);\n \t\t\t\t\tObjectId commitId = odi.insert(commit);\n \t\t\t\t\todi.flush();\n \n \t\t\t\t\tRevWalk revWalk = new RevWalk(repo);\n \t\t\t\t\ttry {\n \t\t\t\t\t\tRevCommit revCommit = revWalk.parseCommit(commitId);\n \t\t\t\t\t\tRefUpdate ru = repo.updateRef(Constants.HEAD);\n \t\t\t\t\t\tru.setNewObjectId(commitId);\n \t\t\t\t\t\tString prefix = amend ? \"commit (amend): \" : \"commit: \";\n \t\t\t\t\t\tru.setRefLogMessage(\n \t\t\t\t\t\t\t\tprefix + revCommit.getShortMessage(), false);\n \n \t\t\t\t\t\tru.setExpectedOldObjectId(headId);\n \t\t\t\t\t\tResult rc = ru.forceUpdate();\n \t\t\t\t\t\tswitch (rc) {\n \t\t\t\t\t\tcase NEW:\n \t\t\t\t\t\tcase FORCED:\n \t\t\t\t\t\tcase FAST_FORWARD: {\n \t\t\t\t\t\t\tsetCallable(false);\n \t\t\t\t\t\t\tif (state == RepositoryState.MERGING_RESOLVED) {\n \t\t\t\t\t\t\t\t// Commit was successful. Now delete the files\n \t\t\t\t\t\t\t\t// used for merge commits\n \t\t\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n \t\t\t\t\t\t\t\trepo.writeMergeHeads(null);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\treturn revCommit;\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcase REJECTED:\n \t\t\t\t\t\tcase LOCK_FAILURE:\n \t\t\t\t\t\t\tthrow new ConcurrentRefUpdateException(JGitText\n \t\t\t\t\t\t\t\t\t.get().couldNotLockHEAD, ru.getRef(), rc);\n \t\t\t\t\t\tdefault:\n \t\t\t\t\t\t\tthrow new JGitInternalException(MessageFormat\n \t\t\t\t\t\t\t\t\t.format(JGitText.get().updatingRefFailed,\n \t\t\t\t\t\t\t\t\t\t\tConstants.HEAD,\n \t\t\t\t\t\t\t\t\t\t\tcommitId.toString(), rc));\n \t\t\t\t\t\t}\n \t\t\t\t\t} finally {\n \t\t\t\t\t\trevWalk.release();\n \t\t\t\t\t}\n \t\t\t\t} finally {\n \t\t\t\t\todi.release();\n \t\t\t\t}\n \t\t\t} finally {\n \t\t\t\tindex.unlock();\n \t\t\t}\n \t\t} catch (UnmergedPathException e) {\n \t\t\t// since UnmergedPathException is a subclass of IOException\n \t\t\t// which should not be wrapped by a JGitInternalException we\n \t\t\t// have to catch and re-throw it here\n \t\t\tthrow e;\n \t\t} catch (IOException e) {\n \t\t\tthrow new JGitInternalException(\n \t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"9830baf48dd5b3feb9780a3cc1d83b79e1d4c46b": {
			"type": "Ybodychange",
			"commitMessage": "CommitCommand: set correct Reflog message when amending\n\nChange-Id: I2322d31b09ca63bdcee50e90340e326467dc5021\nSigned-off-by: Jens Baumgart <jens.baumgart@sap.com>\nSigned-off-by: Chris Aniszczyk <caniszczyk@gmail.com>\n",
			"commitDate": "2011-03-14, 2:51 PM",
			"commitName": "9830baf48dd5b3feb9780a3cc1d83b79e1d4c46b",
			"commitAuthor": "Jens Baumgart",
			"commitDateOld": "2011-03-11, 6:25 AM",
			"commitNameOld": "a490afedba12676a53338bc52b729b9bb779f3a1",
			"commitAuthorOld": "Philipp Thun",
			"daysBetweenCommits": 3.31,
			"commitsBetweenForRepo": 6,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,118 +1,119 @@\n \tpublic RevCommit call() throws NoHeadException, NoMessageException,\n \t\t\tUnmergedPathException, ConcurrentRefUpdateException,\n \t\t\tJGitInternalException, WrongRepositoryStateException {\n \t\tcheckCallable();\n \n \t\tRepositoryState state = repo.getRepositoryState();\n \t\tif (!state.canCommit())\n \t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().cannotCommitOnARepoWithState, state.name()));\n \t\tprocessOptions(state);\n \n \t\ttry {\n \t\t\tif (all && !repo.isBare() && repo.getWorkTree() != null) {\n \t\t\t\tGit git = new Git(repo);\n \t\t\t\ttry {\n \t\t\t\t\tgit.add()\n \t\t\t\t\t\t\t.addFilepattern(\".\")\n \t\t\t\t\t\t\t.setUpdate(true).call();\n \t\t\t\t} catch (NoFilepatternException e) {\n \t\t\t\t\t// should really not happen\n \t\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tRef head = repo.getRef(Constants.HEAD);\n \t\t\tif (head == null)\n \t\t\t\tthrow new NoHeadException(\n \t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n \n \t\t\t// determine the current HEAD and the commit it is referring to\n \t\t\tObjectId headId = repo.resolve(Constants.HEAD + \"^{commit}\");\n \t\t\tif (headId != null)\n \t\t\t\tif (amend) {\n \t\t\t\t\tRevCommit previousCommit = new RevWalk(repo)\n \t\t\t\t\t\t\t.parseCommit(headId);\n \t\t\t\t\tRevCommit[] p = previousCommit.getParents();\n \t\t\t\t\tfor (int i = 0; i < p.length; i++)\n \t\t\t\t\t\tparents.add(0, p[i].getId());\n \t\t\t\t} else {\n \t\t\t\t\tparents.add(0, headId);\n \t\t\t\t}\n \n \t\t\t// lock the index\n \t\t\tDirCache index = repo.lockDirCache();\n \t\t\ttry {\n \t\t\t\tif (!only.isEmpty())\n \t\t\t\t\tindex = createTemporaryIndex(headId, index);\n \n \t\t\t\tObjectInserter odi = repo.newObjectInserter();\n \t\t\t\ttry {\n \t\t\t\t\t// Write the index as tree to the object database. This may\n \t\t\t\t\t// fail for example when the index contains unmerged paths\n \t\t\t\t\t// (unresolved conflicts)\n \t\t\t\t\tObjectId indexTreeId = index.writeTree(odi);\n \n \t\t\t\t\t// Create a Commit object, populate it and write it\n \t\t\t\t\tCommitBuilder commit = new CommitBuilder();\n \t\t\t\t\tcommit.setCommitter(committer);\n \t\t\t\t\tcommit.setAuthor(author);\n \t\t\t\t\tcommit.setMessage(message);\n \n \t\t\t\t\tcommit.setParentIds(parents);\n \t\t\t\t\tcommit.setTreeId(indexTreeId);\n \t\t\t\t\tObjectId commitId = odi.insert(commit);\n \t\t\t\t\todi.flush();\n \n \t\t\t\t\tRevWalk revWalk = new RevWalk(repo);\n \t\t\t\t\ttry {\n \t\t\t\t\t\tRevCommit revCommit = revWalk.parseCommit(commitId);\n \t\t\t\t\t\tRefUpdate ru = repo.updateRef(Constants.HEAD);\n \t\t\t\t\t\tru.setNewObjectId(commitId);\n-\t\t\t\t\t\tru.setRefLogMessage(\"commit : \"\n-\t\t\t\t\t\t\t\t+ revCommit.getShortMessage(), false);\n+\t\t\t\t\t\tString prefix = amend ? \"commit (amend): \" : \"commit: \";\n+\t\t\t\t\t\tru.setRefLogMessage(\n+\t\t\t\t\t\t\t\tprefix + revCommit.getShortMessage(), false);\n \n \t\t\t\t\t\tru.setExpectedOldObjectId(headId);\n \t\t\t\t\t\tResult rc = ru.forceUpdate();\n \t\t\t\t\t\tswitch (rc) {\n \t\t\t\t\t\tcase NEW:\n \t\t\t\t\t\tcase FORCED:\n \t\t\t\t\t\tcase FAST_FORWARD: {\n \t\t\t\t\t\t\tsetCallable(false);\n \t\t\t\t\t\t\tif (state == RepositoryState.MERGING_RESOLVED) {\n \t\t\t\t\t\t\t\t// Commit was successful. Now delete the files\n \t\t\t\t\t\t\t\t// used for merge commits\n \t\t\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n \t\t\t\t\t\t\t\trepo.writeMergeHeads(null);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\treturn revCommit;\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcase REJECTED:\n \t\t\t\t\t\tcase LOCK_FAILURE:\n \t\t\t\t\t\t\tthrow new ConcurrentRefUpdateException(JGitText\n \t\t\t\t\t\t\t\t\t.get().couldNotLockHEAD, ru.getRef(), rc);\n \t\t\t\t\t\tdefault:\n \t\t\t\t\t\t\tthrow new JGitInternalException(MessageFormat\n \t\t\t\t\t\t\t\t\t.format(JGitText.get().updatingRefFailed,\n \t\t\t\t\t\t\t\t\t\t\tConstants.HEAD,\n \t\t\t\t\t\t\t\t\t\t\tcommitId.toString(), rc));\n \t\t\t\t\t\t}\n \t\t\t\t\t} finally {\n \t\t\t\t\t\trevWalk.release();\n \t\t\t\t\t}\n \t\t\t\t} finally {\n \t\t\t\t\todi.release();\n \t\t\t\t}\n \t\t\t} finally {\n \t\t\t\tindex.unlock();\n \t\t\t}\n \t\t} catch (UnmergedPathException e) {\n \t\t\t// since UnmergedPathException is a subclass of IOException\n \t\t\t// which should not be wrapped by a JGitInternalException we\n \t\t\t// have to catch and re-throw it here\n \t\t\tthrow e;\n \t\t} catch (IOException e) {\n \t\t\tthrow new JGitInternalException(\n \t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"a490afedba12676a53338bc52b729b9bb779f3a1": {
			"type": "Ybodychange",
			"commitMessage": "Add -o option to commit command\n\nThis change adds the --only/ -o option to the commit command.\n\nChange-Id: I44352d56877f8204d985cb7a35a2e0faffb7d341\nSigned-off-by: Philipp Thun <philipp.thun@sap.com>\n",
			"commitDate": "2011-03-11, 6:25 AM",
			"commitName": "a490afedba12676a53338bc52b729b9bb779f3a1",
			"commitAuthor": "Philipp Thun",
			"commitDateOld": "2011-03-07, 9:19 AM",
			"commitNameOld": "cda64073fd45d3056486b96877e4ff6dd12dbaa5",
			"commitAuthorOld": "Tomasz Zarna",
			"daysBetweenCommits": 3.88,
			"commitsBetweenForRepo": 19,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,115 +1,118 @@\n \tpublic RevCommit call() throws NoHeadException, NoMessageException,\n \t\t\tUnmergedPathException, ConcurrentRefUpdateException,\n \t\t\tJGitInternalException, WrongRepositoryStateException {\n \t\tcheckCallable();\n \n \t\tRepositoryState state = repo.getRepositoryState();\n \t\tif (!state.canCommit())\n \t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().cannotCommitOnARepoWithState, state.name()));\n \t\tprocessOptions(state);\n \n \t\ttry {\n \t\t\tif (all && !repo.isBare() && repo.getWorkTree() != null) {\n \t\t\t\tGit git = new Git(repo);\n \t\t\t\ttry {\n \t\t\t\t\tgit.add()\n \t\t\t\t\t\t\t.addFilepattern(\".\")\n \t\t\t\t\t\t\t.setUpdate(true).call();\n \t\t\t\t} catch (NoFilepatternException e) {\n \t\t\t\t\t// should really not happen\n \t\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tRef head = repo.getRef(Constants.HEAD);\n \t\t\tif (head == null)\n \t\t\t\tthrow new NoHeadException(\n \t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n \n \t\t\t// determine the current HEAD and the commit it is referring to\n \t\t\tObjectId headId = repo.resolve(Constants.HEAD + \"^{commit}\");\n \t\t\tif (headId != null)\n \t\t\t\tif (amend) {\n \t\t\t\t\tRevCommit previousCommit = new RevWalk(repo)\n \t\t\t\t\t\t\t.parseCommit(headId);\n \t\t\t\t\tRevCommit[] p = previousCommit.getParents();\n \t\t\t\t\tfor (int i = 0; i < p.length; i++)\n \t\t\t\t\t\tparents.add(0, p[i].getId());\n \t\t\t\t} else {\n \t\t\t\t\tparents.add(0, headId);\n \t\t\t\t}\n \n \t\t\t// lock the index\n \t\t\tDirCache index = repo.lockDirCache();\n \t\t\ttry {\n+\t\t\t\tif (!only.isEmpty())\n+\t\t\t\t\tindex = createTemporaryIndex(headId, index);\n+\n \t\t\t\tObjectInserter odi = repo.newObjectInserter();\n \t\t\t\ttry {\n \t\t\t\t\t// Write the index as tree to the object database. This may\n \t\t\t\t\t// fail for example when the index contains unmerged paths\n \t\t\t\t\t// (unresolved conflicts)\n \t\t\t\t\tObjectId indexTreeId = index.writeTree(odi);\n \n \t\t\t\t\t// Create a Commit object, populate it and write it\n \t\t\t\t\tCommitBuilder commit = new CommitBuilder();\n \t\t\t\t\tcommit.setCommitter(committer);\n \t\t\t\t\tcommit.setAuthor(author);\n \t\t\t\t\tcommit.setMessage(message);\n \n \t\t\t\t\tcommit.setParentIds(parents);\n \t\t\t\t\tcommit.setTreeId(indexTreeId);\n \t\t\t\t\tObjectId commitId = odi.insert(commit);\n \t\t\t\t\todi.flush();\n \n \t\t\t\t\tRevWalk revWalk = new RevWalk(repo);\n \t\t\t\t\ttry {\n \t\t\t\t\t\tRevCommit revCommit = revWalk.parseCommit(commitId);\n \t\t\t\t\t\tRefUpdate ru = repo.updateRef(Constants.HEAD);\n \t\t\t\t\t\tru.setNewObjectId(commitId);\n \t\t\t\t\t\tru.setRefLogMessage(\"commit : \"\n \t\t\t\t\t\t\t\t+ revCommit.getShortMessage(), false);\n \n \t\t\t\t\t\tru.setExpectedOldObjectId(headId);\n \t\t\t\t\t\tResult rc = ru.forceUpdate();\n \t\t\t\t\t\tswitch (rc) {\n \t\t\t\t\t\tcase NEW:\n \t\t\t\t\t\tcase FORCED:\n \t\t\t\t\t\tcase FAST_FORWARD: {\n \t\t\t\t\t\t\tsetCallable(false);\n \t\t\t\t\t\t\tif (state == RepositoryState.MERGING_RESOLVED) {\n \t\t\t\t\t\t\t\t// Commit was successful. Now delete the files\n \t\t\t\t\t\t\t\t// used for merge commits\n \t\t\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n \t\t\t\t\t\t\t\trepo.writeMergeHeads(null);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\treturn revCommit;\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcase REJECTED:\n \t\t\t\t\t\tcase LOCK_FAILURE:\n \t\t\t\t\t\t\tthrow new ConcurrentRefUpdateException(JGitText\n \t\t\t\t\t\t\t\t\t.get().couldNotLockHEAD, ru.getRef(), rc);\n \t\t\t\t\t\tdefault:\n \t\t\t\t\t\t\tthrow new JGitInternalException(MessageFormat\n \t\t\t\t\t\t\t\t\t.format(JGitText.get().updatingRefFailed,\n \t\t\t\t\t\t\t\t\t\t\tConstants.HEAD,\n \t\t\t\t\t\t\t\t\t\t\tcommitId.toString(), rc));\n \t\t\t\t\t\t}\n \t\t\t\t\t} finally {\n \t\t\t\t\t\trevWalk.release();\n \t\t\t\t\t}\n \t\t\t\t} finally {\n \t\t\t\t\todi.release();\n \t\t\t\t}\n \t\t\t} finally {\n \t\t\t\tindex.unlock();\n \t\t\t}\n \t\t} catch (UnmergedPathException e) {\n \t\t\t// since UnmergedPathException is a subclass of IOException\n \t\t\t// which should not be wrapped by a JGitInternalException we\n \t\t\t// have to catch and re-throw it here\n \t\t\tthrow e;\n \t\t} catch (IOException e) {\n \t\t\tthrow new JGitInternalException(\n \t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"cda64073fd45d3056486b96877e4ff6dd12dbaa5": {
			"type": "Ybodychange",
			"commitMessage": "Allow to amend a commit with CommitCommand\n\nBug: 339088\nChange-Id: I57dc727688c4bb6968ac076b176661c857c05afa\nSigned-off-by: Chris Aniszczyk <caniszczyk@gmail.com>\n",
			"commitDate": "2011-03-07, 9:19 AM",
			"commitName": "cda64073fd45d3056486b96877e4ff6dd12dbaa5",
			"commitAuthor": "Tomasz Zarna",
			"commitDateOld": "2011-01-17, 2:04 PM",
			"commitNameOld": "e43887b69e27672b80e55391e0ee255efe715ab9",
			"commitAuthorOld": "Robin Rosenberg",
			"daysBetweenCommits": 48.8,
			"commitsBetweenForRepo": 134,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,106 +1,115 @@\n \tpublic RevCommit call() throws NoHeadException, NoMessageException,\n \t\t\tUnmergedPathException, ConcurrentRefUpdateException,\n \t\t\tJGitInternalException, WrongRepositoryStateException {\n \t\tcheckCallable();\n \n \t\tRepositoryState state = repo.getRepositoryState();\n \t\tif (!state.canCommit())\n \t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().cannotCommitOnARepoWithState, state.name()));\n \t\tprocessOptions(state);\n \n \t\ttry {\n \t\t\tif (all && !repo.isBare() && repo.getWorkTree() != null) {\n \t\t\t\tGit git = new Git(repo);\n \t\t\t\ttry {\n \t\t\t\t\tgit.add()\n \t\t\t\t\t\t\t.addFilepattern(\".\")\n \t\t\t\t\t\t\t.setUpdate(true).call();\n \t\t\t\t} catch (NoFilepatternException e) {\n \t\t\t\t\t// should really not happen\n \t\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tRef head = repo.getRef(Constants.HEAD);\n \t\t\tif (head == null)\n \t\t\t\tthrow new NoHeadException(\n \t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n \n \t\t\t// determine the current HEAD and the commit it is referring to\n \t\t\tObjectId headId = repo.resolve(Constants.HEAD + \"^{commit}\");\n \t\t\tif (headId != null)\n-\t\t\t\tparents.add(0, headId);\n+\t\t\t\tif (amend) {\n+\t\t\t\t\tRevCommit previousCommit = new RevWalk(repo)\n+\t\t\t\t\t\t\t.parseCommit(headId);\n+\t\t\t\t\tRevCommit[] p = previousCommit.getParents();\n+\t\t\t\t\tfor (int i = 0; i < p.length; i++)\n+\t\t\t\t\t\tparents.add(0, p[i].getId());\n+\t\t\t\t} else {\n+\t\t\t\t\tparents.add(0, headId);\n+\t\t\t\t}\n \n \t\t\t// lock the index\n \t\t\tDirCache index = repo.lockDirCache();\n \t\t\ttry {\n \t\t\t\tObjectInserter odi = repo.newObjectInserter();\n \t\t\t\ttry {\n \t\t\t\t\t// Write the index as tree to the object database. This may\n \t\t\t\t\t// fail for example when the index contains unmerged paths\n \t\t\t\t\t// (unresolved conflicts)\n \t\t\t\t\tObjectId indexTreeId = index.writeTree(odi);\n \n \t\t\t\t\t// Create a Commit object, populate it and write it\n \t\t\t\t\tCommitBuilder commit = new CommitBuilder();\n \t\t\t\t\tcommit.setCommitter(committer);\n \t\t\t\t\tcommit.setAuthor(author);\n \t\t\t\t\tcommit.setMessage(message);\n \n \t\t\t\t\tcommit.setParentIds(parents);\n \t\t\t\t\tcommit.setTreeId(indexTreeId);\n \t\t\t\t\tObjectId commitId = odi.insert(commit);\n \t\t\t\t\todi.flush();\n \n \t\t\t\t\tRevWalk revWalk = new RevWalk(repo);\n \t\t\t\t\ttry {\n \t\t\t\t\t\tRevCommit revCommit = revWalk.parseCommit(commitId);\n \t\t\t\t\t\tRefUpdate ru = repo.updateRef(Constants.HEAD);\n \t\t\t\t\t\tru.setNewObjectId(commitId);\n \t\t\t\t\t\tru.setRefLogMessage(\"commit : \"\n \t\t\t\t\t\t\t\t+ revCommit.getShortMessage(), false);\n \n \t\t\t\t\t\tru.setExpectedOldObjectId(headId);\n-\t\t\t\t\t\tResult rc = ru.update();\n+\t\t\t\t\t\tResult rc = ru.forceUpdate();\n \t\t\t\t\t\tswitch (rc) {\n \t\t\t\t\t\tcase NEW:\n+\t\t\t\t\t\tcase FORCED:\n \t\t\t\t\t\tcase FAST_FORWARD: {\n \t\t\t\t\t\t\tsetCallable(false);\n \t\t\t\t\t\t\tif (state == RepositoryState.MERGING_RESOLVED) {\n \t\t\t\t\t\t\t\t// Commit was successful. Now delete the files\n \t\t\t\t\t\t\t\t// used for merge commits\n \t\t\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n \t\t\t\t\t\t\t\trepo.writeMergeHeads(null);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\treturn revCommit;\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcase REJECTED:\n \t\t\t\t\t\tcase LOCK_FAILURE:\n \t\t\t\t\t\t\tthrow new ConcurrentRefUpdateException(JGitText\n \t\t\t\t\t\t\t\t\t.get().couldNotLockHEAD, ru.getRef(), rc);\n \t\t\t\t\t\tdefault:\n \t\t\t\t\t\t\tthrow new JGitInternalException(MessageFormat\n \t\t\t\t\t\t\t\t\t.format(JGitText.get().updatingRefFailed,\n \t\t\t\t\t\t\t\t\t\t\tConstants.HEAD,\n \t\t\t\t\t\t\t\t\t\t\tcommitId.toString(), rc));\n \t\t\t\t\t\t}\n \t\t\t\t\t} finally {\n \t\t\t\t\t\trevWalk.release();\n \t\t\t\t\t}\n \t\t\t\t} finally {\n \t\t\t\t\todi.release();\n \t\t\t\t}\n \t\t\t} finally {\n \t\t\t\tindex.unlock();\n \t\t\t}\n \t\t} catch (UnmergedPathException e) {\n \t\t\t// since UnmergedPathException is a subclass of IOException\n \t\t\t// which should not be wrapped by a JGitInternalException we\n \t\t\t// have to catch and re-throw it here\n \t\t\tthrow e;\n \t\t} catch (IOException e) {\n \t\t\tthrow new JGitInternalException(\n \t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"6df5d3397c5c9354409d21a8e207a061f2e6efc2": {
			"type": "Ybodychange",
			"commitMessage": "Move commit and tag formatting to CommitBuilder, TagBuilder\n\nThese objects should be responsible for their own formatting,\nrather than delegating it to some obtuse type called ObjectInserter.\n\nWhile we are at it, simplify the way we insert these into a database.\nPassing in the type and calling format in application code turned\nout to be a huge mistake in terms of ease-of-use of the insert API.\n\nChange-Id: Id5bb95ee56aa2a002243e9b7853b84ec8df1d7bf\nSigned-off-by: Shawn O. Pearce <spearce@spearce.org>\n",
			"commitDate": "2010-08-23, 11:13 AM",
			"commitName": "6df5d3397c5c9354409d21a8e207a061f2e6efc2",
			"commitAuthor": "Shawn O. Pearce",
			"commitDateOld": "2010-08-23, 10:46 AM",
			"commitNameOld": "22b285695a2980824c15363ef5fec709ebc3d434",
			"commitAuthorOld": "Shawn O. Pearce",
			"daysBetweenCommits": 0.02,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,107 +1,106 @@\n \tpublic RevCommit call() throws NoHeadException, NoMessageException,\n \t\t\tUnmergedPathException, ConcurrentRefUpdateException,\n \t\t\tJGitInternalException, WrongRepositoryStateException {\n \t\tcheckCallable();\n \n \t\tRepositoryState state = repo.getRepositoryState();\n \t\tif (!state.canCommit())\n \t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().cannotCommitOnARepoWithState, state.name()));\n \t\tprocessOptions(state);\n \n \t\ttry {\n \t\t\tif (all && !repo.isBare() && repo.getWorkTree() != null) {\n \t\t\t\tGit git = new Git(repo);\n \t\t\t\ttry {\n \t\t\t\t\tgit.add()\n \t\t\t\t\t\t\t.addFilepattern(\".\")\n \t\t\t\t\t\t\t.setUpdate(true).call();\n \t\t\t\t} catch (NoFilepatternException e) {\n \t\t\t\t\t// should really not happen\n \t\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tRef head = repo.getRef(Constants.HEAD);\n \t\t\tif (head == null)\n \t\t\t\tthrow new NoHeadException(\n \t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n \n \t\t\t// determine the current HEAD and the commit it is referring to\n \t\t\tObjectId headId = repo.resolve(Constants.HEAD + \"^{commit}\");\n \t\t\tif (headId != null)\n \t\t\t\tparents.add(0, headId);\n \n \t\t\t// lock the index\n \t\t\tDirCache index = repo.lockDirCache();\n \t\t\ttry {\n \t\t\t\tObjectInserter odi = repo.newObjectInserter();\n \t\t\t\ttry {\n \t\t\t\t\t// Write the index as tree to the object database. This may\n \t\t\t\t\t// fail for example when the index contains unmerged paths\n \t\t\t\t\t// (unresolved conflicts)\n \t\t\t\t\tObjectId indexTreeId = index.writeTree(odi);\n \n \t\t\t\t\t// Create a Commit object, populate it and write it\n \t\t\t\t\tCommitBuilder commit = new CommitBuilder();\n \t\t\t\t\tcommit.setCommitter(committer);\n \t\t\t\t\tcommit.setAuthor(author);\n \t\t\t\t\tcommit.setMessage(message);\n \n \t\t\t\t\tcommit.setParentIds(parents);\n \t\t\t\t\tcommit.setTreeId(indexTreeId);\n-\t\t\t\t\tObjectId commitId = odi.insert(Constants.OBJ_COMMIT, odi\n-\t\t\t\t\t\t\t.format(commit));\n+\t\t\t\t\tObjectId commitId = odi.insert(commit);\n \t\t\t\t\todi.flush();\n \n \t\t\t\t\tRevWalk revWalk = new RevWalk(repo);\n \t\t\t\t\ttry {\n \t\t\t\t\t\tRevCommit revCommit = revWalk.parseCommit(commitId);\n \t\t\t\t\t\tRefUpdate ru = repo.updateRef(Constants.HEAD);\n \t\t\t\t\t\tru.setNewObjectId(commitId);\n \t\t\t\t\t\tru.setRefLogMessage(\"commit : \"\n \t\t\t\t\t\t\t\t+ revCommit.getShortMessage(), false);\n \n \t\t\t\t\t\tru.setExpectedOldObjectId(headId);\n \t\t\t\t\t\tResult rc = ru.update();\n \t\t\t\t\t\tswitch (rc) {\n \t\t\t\t\t\tcase NEW:\n \t\t\t\t\t\tcase FAST_FORWARD: {\n \t\t\t\t\t\t\tsetCallable(false);\n \t\t\t\t\t\t\tif (state == RepositoryState.MERGING_RESOLVED) {\n \t\t\t\t\t\t\t\t// Commit was successful. Now delete the files\n \t\t\t\t\t\t\t\t// used for merge commits\n \t\t\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n \t\t\t\t\t\t\t\trepo.writeMergeHeads(null);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\treturn revCommit;\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcase REJECTED:\n \t\t\t\t\t\tcase LOCK_FAILURE:\n \t\t\t\t\t\t\tthrow new ConcurrentRefUpdateException(JGitText\n \t\t\t\t\t\t\t\t\t.get().couldNotLockHEAD, ru.getRef(), rc);\n \t\t\t\t\t\tdefault:\n \t\t\t\t\t\t\tthrow new JGitInternalException(MessageFormat\n \t\t\t\t\t\t\t\t\t.format(JGitText.get().updatingRefFailed,\n \t\t\t\t\t\t\t\t\t\t\tConstants.HEAD,\n \t\t\t\t\t\t\t\t\t\t\tcommitId.toString(), rc));\n \t\t\t\t\t\t}\n \t\t\t\t\t} finally {\n \t\t\t\t\t\trevWalk.release();\n \t\t\t\t\t}\n \t\t\t\t} finally {\n \t\t\t\t\todi.release();\n \t\t\t\t}\n \t\t\t} finally {\n \t\t\t\tindex.unlock();\n \t\t\t}\n \t\t} catch (UnmergedPathException e) {\n \t\t\t// since UnmergedPathException is a subclass of IOException\n \t\t\t// which should not be wrapped by a JGitInternalException we\n \t\t\t// have to catch and re-throw it here\n \t\t\tthrow e;\n \t\t} catch (IOException e) {\n \t\t\tthrow new JGitInternalException(\n \t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"22b285695a2980824c15363ef5fec709ebc3d434": {
			"type": "Ybodychange",
			"commitMessage": "Rename Commit, Tag to CommitBuilder, TagBuilder\n\nSince these types no longer support reading, calling them a Builder\nis a better description of what they do.  They help the caller to\nbuild a commit or a tag object.\n\nChange-Id: I53cae5a800a66ea1721b0fe5e702599df31da05d\nSigned-off-by: Shawn O. Pearce <spearce@spearce.org>\n",
			"commitDate": "2010-08-23, 10:46 AM",
			"commitName": "22b285695a2980824c15363ef5fec709ebc3d434",
			"commitAuthor": "Shawn O. Pearce",
			"commitDateOld": "2010-08-23, 2:20 AM",
			"commitNameOld": "5fc990130bbd3cf3a0d505c0e12132ec0ecd6b75",
			"commitAuthorOld": "Christian Halstrick",
			"daysBetweenCommits": 0.35,
			"commitsBetweenForRepo": 2,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,107 +1,107 @@\n \tpublic RevCommit call() throws NoHeadException, NoMessageException,\n \t\t\tUnmergedPathException, ConcurrentRefUpdateException,\n \t\t\tJGitInternalException, WrongRepositoryStateException {\n \t\tcheckCallable();\n \n \t\tRepositoryState state = repo.getRepositoryState();\n \t\tif (!state.canCommit())\n \t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().cannotCommitOnARepoWithState, state.name()));\n \t\tprocessOptions(state);\n \n \t\ttry {\n \t\t\tif (all && !repo.isBare() && repo.getWorkTree() != null) {\n \t\t\t\tGit git = new Git(repo);\n \t\t\t\ttry {\n \t\t\t\t\tgit.add()\n \t\t\t\t\t\t\t.addFilepattern(\".\")\n \t\t\t\t\t\t\t.setUpdate(true).call();\n \t\t\t\t} catch (NoFilepatternException e) {\n \t\t\t\t\t// should really not happen\n \t\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tRef head = repo.getRef(Constants.HEAD);\n \t\t\tif (head == null)\n \t\t\t\tthrow new NoHeadException(\n \t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n \n \t\t\t// determine the current HEAD and the commit it is referring to\n \t\t\tObjectId headId = repo.resolve(Constants.HEAD + \"^{commit}\");\n \t\t\tif (headId != null)\n \t\t\t\tparents.add(0, headId);\n \n \t\t\t// lock the index\n \t\t\tDirCache index = repo.lockDirCache();\n \t\t\ttry {\n \t\t\t\tObjectInserter odi = repo.newObjectInserter();\n \t\t\t\ttry {\n \t\t\t\t\t// Write the index as tree to the object database. This may\n \t\t\t\t\t// fail for example when the index contains unmerged paths\n \t\t\t\t\t// (unresolved conflicts)\n \t\t\t\t\tObjectId indexTreeId = index.writeTree(odi);\n \n \t\t\t\t\t// Create a Commit object, populate it and write it\n-\t\t\t\t\tCommit commit = new Commit();\n+\t\t\t\t\tCommitBuilder commit = new CommitBuilder();\n \t\t\t\t\tcommit.setCommitter(committer);\n \t\t\t\t\tcommit.setAuthor(author);\n \t\t\t\t\tcommit.setMessage(message);\n \n \t\t\t\t\tcommit.setParentIds(parents);\n \t\t\t\t\tcommit.setTreeId(indexTreeId);\n \t\t\t\t\tObjectId commitId = odi.insert(Constants.OBJ_COMMIT, odi\n \t\t\t\t\t\t\t.format(commit));\n \t\t\t\t\todi.flush();\n \n \t\t\t\t\tRevWalk revWalk = new RevWalk(repo);\n \t\t\t\t\ttry {\n \t\t\t\t\t\tRevCommit revCommit = revWalk.parseCommit(commitId);\n \t\t\t\t\t\tRefUpdate ru = repo.updateRef(Constants.HEAD);\n \t\t\t\t\t\tru.setNewObjectId(commitId);\n \t\t\t\t\t\tru.setRefLogMessage(\"commit : \"\n \t\t\t\t\t\t\t\t+ revCommit.getShortMessage(), false);\n \n \t\t\t\t\t\tru.setExpectedOldObjectId(headId);\n \t\t\t\t\t\tResult rc = ru.update();\n \t\t\t\t\t\tswitch (rc) {\n \t\t\t\t\t\tcase NEW:\n \t\t\t\t\t\tcase FAST_FORWARD: {\n \t\t\t\t\t\t\tsetCallable(false);\n \t\t\t\t\t\t\tif (state == RepositoryState.MERGING_RESOLVED) {\n \t\t\t\t\t\t\t\t// Commit was successful. Now delete the files\n \t\t\t\t\t\t\t\t// used for merge commits\n \t\t\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n \t\t\t\t\t\t\t\trepo.writeMergeHeads(null);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\treturn revCommit;\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcase REJECTED:\n \t\t\t\t\t\tcase LOCK_FAILURE:\n \t\t\t\t\t\t\tthrow new ConcurrentRefUpdateException(JGitText\n \t\t\t\t\t\t\t\t\t.get().couldNotLockHEAD, ru.getRef(), rc);\n \t\t\t\t\t\tdefault:\n \t\t\t\t\t\t\tthrow new JGitInternalException(MessageFormat\n \t\t\t\t\t\t\t\t\t.format(JGitText.get().updatingRefFailed,\n \t\t\t\t\t\t\t\t\t\t\tConstants.HEAD,\n \t\t\t\t\t\t\t\t\t\t\tcommitId.toString(), rc));\n \t\t\t\t\t\t}\n \t\t\t\t\t} finally {\n \t\t\t\t\t\trevWalk.release();\n \t\t\t\t\t}\n \t\t\t\t} finally {\n \t\t\t\t\todi.release();\n \t\t\t\t}\n \t\t\t} finally {\n \t\t\t\tindex.unlock();\n \t\t\t}\n \t\t} catch (UnmergedPathException e) {\n \t\t\t// since UnmergedPathException is a subclass of IOException\n \t\t\t// which should not be wrapped by a JGitInternalException we\n \t\t\t// have to catch and re-throw it here\n \t\t\tthrow e;\n \t\t} catch (IOException e) {\n \t\t\tthrow new JGitInternalException(\n \t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"b46b635c0389e01a55b2f9c490e5b6c54a8ce640": {
			"type": "Ybodychange",
			"commitMessage": "Make Commit class only for writing\n\nThe Commit class now only supports the creation of a commit object.\nTo read a commit, applictions should use RevCommit.  This permits\nus to have exactly one implementation, and RevCommit's is faster\nand more bug-free.\n\nChange-Id: Ib573f7e15f36855112815269385c21dea532e2cf\nSigned-off-by: Shawn O. Pearce <spearce@spearce.org>\n",
			"commitDate": "2010-08-20, 6:38 PM",
			"commitName": "b46b635c0389e01a55b2f9c490e5b6c54a8ce640",
			"commitAuthor": "Shawn O. Pearce",
			"commitDateOld": "2010-08-04, 5:53 AM",
			"commitNameOld": "ab57af08e83d5d042bb954ad280389b34ca36d0e",
			"commitAuthorOld": "Stefan Lay",
			"daysBetweenCommits": 16.53,
			"commitsBetweenForRepo": 28,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,107 +1,107 @@\n \tpublic RevCommit call() throws NoHeadException, NoMessageException,\n \t\t\tUnmergedPathException, ConcurrentRefUpdateException,\n \t\t\tJGitInternalException, WrongRepositoryStateException {\n \t\tcheckCallable();\n \n \t\tRepositoryState state = repo.getRepositoryState();\n \t\tif (!state.canCommit())\n \t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().cannotCommitOnARepoWithState, state.name()));\n \t\tprocessOptions(state);\n \n \t\ttry {\n \t\t\tif (all && !repo.isBare() && repo.getWorkTree() != null) {\n \t\t\t\tGit git = new Git(repo);\n \t\t\t\ttry {\n \t\t\t\t\tgit.add()\n \t\t\t\t\t\t\t.addFilepattern(\".\")\n \t\t\t\t\t\t\t.setUpdate(true).call();\n \t\t\t\t} catch (NoFilepatternException e) {\n \t\t\t\t\t// should really not happen\n \t\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tRef head = repo.getRef(Constants.HEAD);\n \t\t\tif (head == null)\n \t\t\t\tthrow new NoHeadException(\n \t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n \n \t\t\t// determine the current HEAD and the commit it is referring to\n \t\t\tObjectId headId = repo.resolve(Constants.HEAD + \"^{commit}\");\n \t\t\tif (headId != null)\n \t\t\t\tparents.add(0, headId);\n \n \t\t\t// lock the index\n \t\t\tDirCache index = repo.lockDirCache();\n \t\t\ttry {\n \t\t\t\tObjectInserter odi = repo.newObjectInserter();\n \t\t\t\ttry {\n \t\t\t\t\t// Write the index as tree to the object database. This may\n \t\t\t\t\t// fail for example when the index contains unmerged paths\n \t\t\t\t\t// (unresolved conflicts)\n \t\t\t\t\tObjectId indexTreeId = index.writeTree(odi);\n \n \t\t\t\t\t// Create a Commit object, populate it and write it\n-\t\t\t\t\tCommit commit = new Commit(repo);\n+\t\t\t\t\tCommit commit = new Commit();\n \t\t\t\t\tcommit.setCommitter(committer);\n \t\t\t\t\tcommit.setAuthor(author);\n \t\t\t\t\tcommit.setMessage(message);\n \n-\t\t\t\t\tcommit.setParentIds(parents.toArray(new ObjectId[] {}));\n+\t\t\t\t\tcommit.setParentIds(parents);\n \t\t\t\t\tcommit.setTreeId(indexTreeId);\n \t\t\t\t\tObjectId commitId = odi.insert(Constants.OBJ_COMMIT, odi\n \t\t\t\t\t\t\t.format(commit));\n \t\t\t\t\todi.flush();\n \n \t\t\t\t\tRevWalk revWalk = new RevWalk(repo);\n \t\t\t\t\ttry {\n \t\t\t\t\t\tRevCommit revCommit = revWalk.parseCommit(commitId);\n \t\t\t\t\t\tRefUpdate ru = repo.updateRef(Constants.HEAD);\n \t\t\t\t\t\tru.setNewObjectId(commitId);\n \t\t\t\t\t\tru.setRefLogMessage(\"commit : \"\n \t\t\t\t\t\t\t\t+ revCommit.getShortMessage(), false);\n \n \t\t\t\t\t\tru.setExpectedOldObjectId(headId);\n \t\t\t\t\t\tResult rc = ru.update();\n \t\t\t\t\t\tswitch (rc) {\n \t\t\t\t\t\tcase NEW:\n \t\t\t\t\t\tcase FAST_FORWARD: {\n \t\t\t\t\t\t\tsetCallable(false);\n \t\t\t\t\t\t\tif (state == RepositoryState.MERGING_RESOLVED) {\n \t\t\t\t\t\t\t\t// Commit was successful. Now delete the files\n \t\t\t\t\t\t\t\t// used for merge commits\n \t\t\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n \t\t\t\t\t\t\t\trepo.writeMergeHeads(null);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\treturn revCommit;\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcase REJECTED:\n \t\t\t\t\t\tcase LOCK_FAILURE:\n \t\t\t\t\t\t\tthrow new ConcurrentRefUpdateException(JGitText\n \t\t\t\t\t\t\t\t\t.get().couldNotLockHEAD, ru.getRef(), rc);\n \t\t\t\t\t\tdefault:\n \t\t\t\t\t\t\tthrow new JGitInternalException(MessageFormat\n \t\t\t\t\t\t\t\t\t.format(JGitText.get().updatingRefFailed,\n \t\t\t\t\t\t\t\t\t\t\tConstants.HEAD,\n \t\t\t\t\t\t\t\t\t\t\tcommitId.toString(), rc));\n \t\t\t\t\t\t}\n \t\t\t\t\t} finally {\n \t\t\t\t\t\trevWalk.release();\n \t\t\t\t\t}\n \t\t\t\t} finally {\n \t\t\t\t\todi.release();\n \t\t\t\t}\n \t\t\t} finally {\n \t\t\t\tindex.unlock();\n \t\t\t}\n \t\t} catch (UnmergedPathException e) {\n \t\t\t// since UnmergedPathException is a subclass of IOException\n \t\t\t// which should not be wrapped by a JGitInternalException we\n \t\t\t// have to catch and re-throw it here\n \t\t\tthrow e;\n \t\t} catch (IOException e) {\n \t\t\tthrow new JGitInternalException(\n \t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"ab57af08e83d5d042bb954ad280389b34ca36d0e": {
			"type": "Ybodychange",
			"commitMessage": "Add \"all\" parameter to the commit Command\n\nWhen the add parameter is set all modified and deleted files\nare staged prior to commit.\n\nChange-Id: Id23bc25730fcdd151386cd495a7cdc0935cbc00b\nSigned-off-by: Stefan Lay <stefan.lay@sap.com>\n",
			"commitDate": "2010-08-04, 5:53 AM",
			"commitName": "ab57af08e83d5d042bb954ad280389b34ca36d0e",
			"commitAuthor": "Stefan Lay",
			"commitDateOld": "2010-07-29, 7:12 AM",
			"commitNameOld": "94207f0a43a44261b8170d3cdba3028059775d9d",
			"commitAuthorOld": "Christian Halstrick",
			"daysBetweenCommits": 5.95,
			"commitsBetweenForRepo": 6,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,95 +1,107 @@\n \tpublic RevCommit call() throws NoHeadException, NoMessageException,\n \t\t\tUnmergedPathException, ConcurrentRefUpdateException,\n \t\t\tJGitInternalException, WrongRepositoryStateException {\n \t\tcheckCallable();\n \n \t\tRepositoryState state = repo.getRepositoryState();\n \t\tif (!state.canCommit())\n \t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().cannotCommitOnARepoWithState, state.name()));\n \t\tprocessOptions(state);\n \n \t\ttry {\n+\t\t\tif (all && !repo.isBare() && repo.getWorkTree() != null) {\n+\t\t\t\tGit git = new Git(repo);\n+\t\t\t\ttry {\n+\t\t\t\t\tgit.add()\n+\t\t\t\t\t\t\t.addFilepattern(\".\")\n+\t\t\t\t\t\t\t.setUpdate(true).call();\n+\t\t\t\t} catch (NoFilepatternException e) {\n+\t\t\t\t\t// should really not happen\n+\t\t\t\t\tthrow new JGitInternalException(e.getMessage(), e);\n+\t\t\t\t}\n+\t\t\t}\n+\n \t\t\tRef head = repo.getRef(Constants.HEAD);\n \t\t\tif (head == null)\n \t\t\t\tthrow new NoHeadException(\n \t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n \n \t\t\t// determine the current HEAD and the commit it is referring to\n \t\t\tObjectId headId = repo.resolve(Constants.HEAD + \"^{commit}\");\n \t\t\tif (headId != null)\n \t\t\t\tparents.add(0, headId);\n \n \t\t\t// lock the index\n \t\t\tDirCache index = repo.lockDirCache();\n \t\t\ttry {\n \t\t\t\tObjectInserter odi = repo.newObjectInserter();\n \t\t\t\ttry {\n \t\t\t\t\t// Write the index as tree to the object database. This may\n \t\t\t\t\t// fail for example when the index contains unmerged paths\n \t\t\t\t\t// (unresolved conflicts)\n \t\t\t\t\tObjectId indexTreeId = index.writeTree(odi);\n \n \t\t\t\t\t// Create a Commit object, populate it and write it\n \t\t\t\t\tCommit commit = new Commit(repo);\n \t\t\t\t\tcommit.setCommitter(committer);\n \t\t\t\t\tcommit.setAuthor(author);\n \t\t\t\t\tcommit.setMessage(message);\n \n \t\t\t\t\tcommit.setParentIds(parents.toArray(new ObjectId[] {}));\n \t\t\t\t\tcommit.setTreeId(indexTreeId);\n \t\t\t\t\tObjectId commitId = odi.insert(Constants.OBJ_COMMIT, odi\n \t\t\t\t\t\t\t.format(commit));\n \t\t\t\t\todi.flush();\n \n \t\t\t\t\tRevWalk revWalk = new RevWalk(repo);\n \t\t\t\t\ttry {\n \t\t\t\t\t\tRevCommit revCommit = revWalk.parseCommit(commitId);\n \t\t\t\t\t\tRefUpdate ru = repo.updateRef(Constants.HEAD);\n \t\t\t\t\t\tru.setNewObjectId(commitId);\n \t\t\t\t\t\tru.setRefLogMessage(\"commit : \"\n \t\t\t\t\t\t\t\t+ revCommit.getShortMessage(), false);\n \n \t\t\t\t\t\tru.setExpectedOldObjectId(headId);\n \t\t\t\t\t\tResult rc = ru.update();\n \t\t\t\t\t\tswitch (rc) {\n \t\t\t\t\t\tcase NEW:\n \t\t\t\t\t\tcase FAST_FORWARD: {\n \t\t\t\t\t\t\tsetCallable(false);\n \t\t\t\t\t\t\tif (state == RepositoryState.MERGING_RESOLVED) {\n \t\t\t\t\t\t\t\t// Commit was successful. Now delete the files\n \t\t\t\t\t\t\t\t// used for merge commits\n \t\t\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n \t\t\t\t\t\t\t\trepo.writeMergeHeads(null);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\treturn revCommit;\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcase REJECTED:\n \t\t\t\t\t\tcase LOCK_FAILURE:\n \t\t\t\t\t\t\tthrow new ConcurrentRefUpdateException(JGitText\n \t\t\t\t\t\t\t\t\t.get().couldNotLockHEAD, ru.getRef(), rc);\n \t\t\t\t\t\tdefault:\n \t\t\t\t\t\t\tthrow new JGitInternalException(MessageFormat\n \t\t\t\t\t\t\t\t\t.format(JGitText.get().updatingRefFailed,\n \t\t\t\t\t\t\t\t\t\t\tConstants.HEAD,\n \t\t\t\t\t\t\t\t\t\t\tcommitId.toString(), rc));\n \t\t\t\t\t\t}\n \t\t\t\t\t} finally {\n \t\t\t\t\t\trevWalk.release();\n \t\t\t\t\t}\n \t\t\t\t} finally {\n \t\t\t\t\todi.release();\n \t\t\t\t}\n \t\t\t} finally {\n \t\t\t\tindex.unlock();\n \t\t\t}\n \t\t} catch (UnmergedPathException e) {\n \t\t\t// since UnmergedPathException is a subclass of IOException\n \t\t\t// which should not be wrapped by a JGitInternalException we\n \t\t\t// have to catch and re-throw it here\n \t\t\tthrow e;\n \t\t} catch (IOException e) {\n \t\t\tthrow new JGitInternalException(\n \t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"94207f0a43a44261b8170d3cdba3028059775d9d": {
			"type": "Ybodychange",
			"commitMessage": "Make use of Repository.writeMerge...()\n\nThe CommitCommand should not use java.io to delete MERGE_HEAD and MERGE_MSG\nfiles since Repository already has utility methods for that.\n\nChange-Id: If66a419349b95510e5b5c2237a91f06c1d5ba0d4\nSigned-off-by: Christian Halstrick <christian.halstrick@sap.com>\n",
			"commitDate": "2010-07-29, 7:12 AM",
			"commitName": "94207f0a43a44261b8170d3cdba3028059775d9d",
			"commitAuthor": "Christian Halstrick",
			"commitDateOld": "2010-06-30, 11:39 AM",
			"commitNameOld": "a1d5f5b6b526d086a0963c634a38edb6789a4594",
			"commitAuthorOld": "Shawn O. Pearce",
			"daysBetweenCommits": 28.81,
			"commitsBetweenForRepo": 97,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,97 +1,95 @@\n \tpublic RevCommit call() throws NoHeadException, NoMessageException,\n \t\t\tUnmergedPathException, ConcurrentRefUpdateException,\n \t\t\tJGitInternalException, WrongRepositoryStateException {\n \t\tcheckCallable();\n \n \t\tRepositoryState state = repo.getRepositoryState();\n \t\tif (!state.canCommit())\n \t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().cannotCommitOnARepoWithState, state.name()));\n \t\tprocessOptions(state);\n \n \t\ttry {\n \t\t\tRef head = repo.getRef(Constants.HEAD);\n \t\t\tif (head == null)\n \t\t\t\tthrow new NoHeadException(\n \t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n \n \t\t\t// determine the current HEAD and the commit it is referring to\n \t\t\tObjectId headId = repo.resolve(Constants.HEAD + \"^{commit}\");\n \t\t\tif (headId != null)\n \t\t\t\tparents.add(0, headId);\n \n \t\t\t// lock the index\n \t\t\tDirCache index = repo.lockDirCache();\n \t\t\ttry {\n \t\t\t\tObjectInserter odi = repo.newObjectInserter();\n \t\t\t\ttry {\n \t\t\t\t\t// Write the index as tree to the object database. This may\n \t\t\t\t\t// fail for example when the index contains unmerged paths\n \t\t\t\t\t// (unresolved conflicts)\n \t\t\t\t\tObjectId indexTreeId = index.writeTree(odi);\n \n \t\t\t\t\t// Create a Commit object, populate it and write it\n \t\t\t\t\tCommit commit = new Commit(repo);\n \t\t\t\t\tcommit.setCommitter(committer);\n \t\t\t\t\tcommit.setAuthor(author);\n \t\t\t\t\tcommit.setMessage(message);\n \n \t\t\t\t\tcommit.setParentIds(parents.toArray(new ObjectId[] {}));\n \t\t\t\t\tcommit.setTreeId(indexTreeId);\n \t\t\t\t\tObjectId commitId = odi.insert(Constants.OBJ_COMMIT, odi\n \t\t\t\t\t\t\t.format(commit));\n \t\t\t\t\todi.flush();\n \n \t\t\t\t\tRevWalk revWalk = new RevWalk(repo);\n \t\t\t\t\ttry {\n \t\t\t\t\t\tRevCommit revCommit = revWalk.parseCommit(commitId);\n \t\t\t\t\t\tRefUpdate ru = repo.updateRef(Constants.HEAD);\n \t\t\t\t\t\tru.setNewObjectId(commitId);\n \t\t\t\t\t\tru.setRefLogMessage(\"commit : \"\n \t\t\t\t\t\t\t\t+ revCommit.getShortMessage(), false);\n \n \t\t\t\t\t\tru.setExpectedOldObjectId(headId);\n \t\t\t\t\t\tResult rc = ru.update();\n \t\t\t\t\t\tswitch (rc) {\n \t\t\t\t\t\tcase NEW:\n \t\t\t\t\t\tcase FAST_FORWARD: {\n \t\t\t\t\t\t\tsetCallable(false);\n-\t\t\t\t\t\t\tFile meta = repo.getDirectory();\n-\t\t\t\t\t\t\tif (state == RepositoryState.MERGING_RESOLVED\n-\t\t\t\t\t\t\t\t\t&& meta != null) {\n+\t\t\t\t\t\t\tif (state == RepositoryState.MERGING_RESOLVED) {\n \t\t\t\t\t\t\t\t// Commit was successful. Now delete the files\n \t\t\t\t\t\t\t\t// used for merge commits\n-\t\t\t\t\t\t\t\tnew File(meta, Constants.MERGE_HEAD).delete();\n-\t\t\t\t\t\t\t\tnew File(meta, Constants.MERGE_MSG).delete();\n+\t\t\t\t\t\t\t\trepo.writeMergeCommitMsg(null);\n+\t\t\t\t\t\t\t\trepo.writeMergeHeads(null);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\treturn revCommit;\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcase REJECTED:\n \t\t\t\t\t\tcase LOCK_FAILURE:\n \t\t\t\t\t\t\tthrow new ConcurrentRefUpdateException(JGitText\n \t\t\t\t\t\t\t\t\t.get().couldNotLockHEAD, ru.getRef(), rc);\n \t\t\t\t\t\tdefault:\n \t\t\t\t\t\t\tthrow new JGitInternalException(MessageFormat\n \t\t\t\t\t\t\t\t\t.format(JGitText.get().updatingRefFailed,\n \t\t\t\t\t\t\t\t\t\t\tConstants.HEAD,\n \t\t\t\t\t\t\t\t\t\t\tcommitId.toString(), rc));\n \t\t\t\t\t\t}\n \t\t\t\t\t} finally {\n \t\t\t\t\t\trevWalk.release();\n \t\t\t\t\t}\n \t\t\t\t} finally {\n \t\t\t\t\todi.release();\n \t\t\t\t}\n \t\t\t} finally {\n \t\t\t\tindex.unlock();\n \t\t\t}\n \t\t} catch (UnmergedPathException e) {\n \t\t\t// since UnmergedPathException is a subclass of IOException\n \t\t\t// which should not be wrapped by a JGitInternalException we\n \t\t\t// have to catch and re-throw it here\n \t\t\tthrow e;\n \t\t} catch (IOException e) {\n \t\t\tthrow new JGitInternalException(\n \t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"a1d5f5b6b526d086a0963c634a38edb6789a4594": {
			"type": "Ybodychange",
			"commitMessage": "Move DirCache factory methods to Repository\n\nInstead of creating the DirCache from a static factory method, use\nan instance method on Repository, permitting the implementation to\noverride the method with a completely different type of DirCache\nreading and writing.  This would better support a repository in the\ncloud strategy, or even just an in-memory unit test environment.\n\nChange-Id: I6399894b12d6480c4b3ac84d10775dfd1b8d13e7\nSigned-off-by: Shawn O. Pearce <spearce@spearce.org>\n",
			"commitDate": "2010-06-30, 11:39 AM",
			"commitName": "a1d5f5b6b526d086a0963c634a38edb6789a4594",
			"commitAuthor": "Shawn O. Pearce",
			"commitDateOld": "2010-06-29, 4:12 PM",
			"commitNameOld": "515deaf7e503738b4c53c3c2dfd6d7acab3bef18",
			"commitAuthorOld": "Shawn O. Pearce",
			"daysBetweenCommits": 0.81,
			"commitsBetweenForRepo": 2,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,97 +1,97 @@\n \tpublic RevCommit call() throws NoHeadException, NoMessageException,\n \t\t\tUnmergedPathException, ConcurrentRefUpdateException,\n \t\t\tJGitInternalException, WrongRepositoryStateException {\n \t\tcheckCallable();\n \n \t\tRepositoryState state = repo.getRepositoryState();\n \t\tif (!state.canCommit())\n \t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().cannotCommitOnARepoWithState, state.name()));\n \t\tprocessOptions(state);\n \n \t\ttry {\n \t\t\tRef head = repo.getRef(Constants.HEAD);\n \t\t\tif (head == null)\n \t\t\t\tthrow new NoHeadException(\n \t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n \n \t\t\t// determine the current HEAD and the commit it is referring to\n \t\t\tObjectId headId = repo.resolve(Constants.HEAD + \"^{commit}\");\n \t\t\tif (headId != null)\n \t\t\t\tparents.add(0, headId);\n \n \t\t\t// lock the index\n-\t\t\tDirCache index = DirCache.lock(repo);\n+\t\t\tDirCache index = repo.lockDirCache();\n \t\t\ttry {\n \t\t\t\tObjectInserter odi = repo.newObjectInserter();\n \t\t\t\ttry {\n \t\t\t\t\t// Write the index as tree to the object database. This may\n \t\t\t\t\t// fail for example when the index contains unmerged paths\n \t\t\t\t\t// (unresolved conflicts)\n \t\t\t\t\tObjectId indexTreeId = index.writeTree(odi);\n \n \t\t\t\t\t// Create a Commit object, populate it and write it\n \t\t\t\t\tCommit commit = new Commit(repo);\n \t\t\t\t\tcommit.setCommitter(committer);\n \t\t\t\t\tcommit.setAuthor(author);\n \t\t\t\t\tcommit.setMessage(message);\n \n \t\t\t\t\tcommit.setParentIds(parents.toArray(new ObjectId[] {}));\n \t\t\t\t\tcommit.setTreeId(indexTreeId);\n \t\t\t\t\tObjectId commitId = odi.insert(Constants.OBJ_COMMIT, odi\n \t\t\t\t\t\t\t.format(commit));\n \t\t\t\t\todi.flush();\n \n \t\t\t\t\tRevWalk revWalk = new RevWalk(repo);\n \t\t\t\t\ttry {\n \t\t\t\t\t\tRevCommit revCommit = revWalk.parseCommit(commitId);\n \t\t\t\t\t\tRefUpdate ru = repo.updateRef(Constants.HEAD);\n \t\t\t\t\t\tru.setNewObjectId(commitId);\n \t\t\t\t\t\tru.setRefLogMessage(\"commit : \"\n \t\t\t\t\t\t\t\t+ revCommit.getShortMessage(), false);\n \n \t\t\t\t\t\tru.setExpectedOldObjectId(headId);\n \t\t\t\t\t\tResult rc = ru.update();\n \t\t\t\t\t\tswitch (rc) {\n \t\t\t\t\t\tcase NEW:\n \t\t\t\t\t\tcase FAST_FORWARD: {\n \t\t\t\t\t\t\tsetCallable(false);\n \t\t\t\t\t\t\tFile meta = repo.getDirectory();\n \t\t\t\t\t\t\tif (state == RepositoryState.MERGING_RESOLVED\n \t\t\t\t\t\t\t\t\t&& meta != null) {\n \t\t\t\t\t\t\t\t// Commit was successful. Now delete the files\n \t\t\t\t\t\t\t\t// used for merge commits\n \t\t\t\t\t\t\t\tnew File(meta, Constants.MERGE_HEAD).delete();\n \t\t\t\t\t\t\t\tnew File(meta, Constants.MERGE_MSG).delete();\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\treturn revCommit;\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcase REJECTED:\n \t\t\t\t\t\tcase LOCK_FAILURE:\n \t\t\t\t\t\t\tthrow new ConcurrentRefUpdateException(JGitText\n \t\t\t\t\t\t\t\t\t.get().couldNotLockHEAD, ru.getRef(), rc);\n \t\t\t\t\t\tdefault:\n \t\t\t\t\t\t\tthrow new JGitInternalException(MessageFormat\n \t\t\t\t\t\t\t\t\t.format(JGitText.get().updatingRefFailed,\n \t\t\t\t\t\t\t\t\t\t\tConstants.HEAD,\n \t\t\t\t\t\t\t\t\t\t\tcommitId.toString(), rc));\n \t\t\t\t\t\t}\n \t\t\t\t\t} finally {\n \t\t\t\t\t\trevWalk.release();\n \t\t\t\t\t}\n \t\t\t\t} finally {\n \t\t\t\t\todi.release();\n \t\t\t\t}\n \t\t\t} finally {\n \t\t\t\tindex.unlock();\n \t\t\t}\n \t\t} catch (UnmergedPathException e) {\n \t\t\t// since UnmergedPathException is a subclass of IOException\n \t\t\t// which should not be wrapped by a JGitInternalException we\n \t\t\t// have to catch and re-throw it here\n \t\t\tthrow e;\n \t\t} catch (IOException e) {\n \t\t\tthrow new JGitInternalException(\n \t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"515deaf7e503738b4c53c3c2dfd6d7acab3bef18": {
			"type": "Ybodychange",
			"commitMessage": "Ensure RevWalk is released when done\n\nUpdate a number of calling sites of RevWalk to ensure the walker's\ninternal ObjectReader is released after the walk is no longer used.\nBecause the ObjectReader is likely to hold onto a native resource\nlike an Inflater, we don't want to leak them outside of their\nuseful scope.\n\nWhere possible we also try to share ObjectReaders across several\nwalk pools, or between a walker and a PackWriter.  This permits\nthe ObjectReader to actually do some caching if it felt inclined\nto do so.\n\nNot everything was updated, we'll probably need to come back and\nupdate even more call sites, but these are some of the biggest\noffenders.  Test cases in particular aren't updated.  My plan is to\nmove most storage-agnostic tests onto some purely in-memory storage\nsolution that doesn't do compression.\n\nChange-Id: I04087ec79faeea208b19848939898ad7172b6672\nSigned-off-by: Shawn O. Pearce <spearce@spearce.org>\n",
			"commitDate": "2010-06-29, 4:12 PM",
			"commitName": "515deaf7e503738b4c53c3c2dfd6d7acab3bef18",
			"commitAuthor": "Shawn O. Pearce",
			"commitDateOld": "2010-06-25, 7:03 PM",
			"commitNameOld": "ffe0614d4db653cbcd48c19e9f599fd87cdcfaba",
			"commitAuthorOld": "Shawn O. Pearce",
			"daysBetweenCommits": 3.88,
			"commitsBetweenForRepo": 30,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,93 +1,97 @@\n \tpublic RevCommit call() throws NoHeadException, NoMessageException,\n \t\t\tUnmergedPathException, ConcurrentRefUpdateException,\n \t\t\tJGitInternalException, WrongRepositoryStateException {\n \t\tcheckCallable();\n \n \t\tRepositoryState state = repo.getRepositoryState();\n \t\tif (!state.canCommit())\n \t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().cannotCommitOnARepoWithState, state.name()));\n \t\tprocessOptions(state);\n \n \t\ttry {\n \t\t\tRef head = repo.getRef(Constants.HEAD);\n \t\t\tif (head == null)\n \t\t\t\tthrow new NoHeadException(\n \t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n \n \t\t\t// determine the current HEAD and the commit it is referring to\n \t\t\tObjectId headId = repo.resolve(Constants.HEAD + \"^{commit}\");\n \t\t\tif (headId != null)\n \t\t\t\tparents.add(0, headId);\n \n \t\t\t// lock the index\n \t\t\tDirCache index = DirCache.lock(repo);\n \t\t\ttry {\n \t\t\t\tObjectInserter odi = repo.newObjectInserter();\n \t\t\t\ttry {\n \t\t\t\t\t// Write the index as tree to the object database. This may\n \t\t\t\t\t// fail for example when the index contains unmerged paths\n \t\t\t\t\t// (unresolved conflicts)\n \t\t\t\t\tObjectId indexTreeId = index.writeTree(odi);\n \n \t\t\t\t\t// Create a Commit object, populate it and write it\n \t\t\t\t\tCommit commit = new Commit(repo);\n \t\t\t\t\tcommit.setCommitter(committer);\n \t\t\t\t\tcommit.setAuthor(author);\n \t\t\t\t\tcommit.setMessage(message);\n \n \t\t\t\t\tcommit.setParentIds(parents.toArray(new ObjectId[] {}));\n \t\t\t\t\tcommit.setTreeId(indexTreeId);\n \t\t\t\t\tObjectId commitId = odi.insert(Constants.OBJ_COMMIT, odi\n \t\t\t\t\t\t\t.format(commit));\n \t\t\t\t\todi.flush();\n \n-\t\t\t\t\tRevCommit revCommit = new RevWalk(repo)\n-\t\t\t\t\t\t\t.parseCommit(commitId);\n-\t\t\t\t\tRefUpdate ru = repo.updateRef(Constants.HEAD);\n-\t\t\t\t\tru.setNewObjectId(commitId);\n-\t\t\t\t\tru.setRefLogMessage(\"commit : \"\n-\t\t\t\t\t\t\t+ revCommit.getShortMessage(), false);\n+\t\t\t\t\tRevWalk revWalk = new RevWalk(repo);\n+\t\t\t\t\ttry {\n+\t\t\t\t\t\tRevCommit revCommit = revWalk.parseCommit(commitId);\n+\t\t\t\t\t\tRefUpdate ru = repo.updateRef(Constants.HEAD);\n+\t\t\t\t\t\tru.setNewObjectId(commitId);\n+\t\t\t\t\t\tru.setRefLogMessage(\"commit : \"\n+\t\t\t\t\t\t\t\t+ revCommit.getShortMessage(), false);\n \n-\t\t\t\t\tru.setExpectedOldObjectId(headId);\n-\t\t\t\t\tResult rc = ru.update();\n-\t\t\t\t\tswitch (rc) {\n-\t\t\t\t\tcase NEW:\n-\t\t\t\t\tcase FAST_FORWARD: {\n-\t\t\t\t\t\tsetCallable(false);\n-\t\t\t\t\t\tFile meta = repo.getDirectory();\n-\t\t\t\t\t\tif (state == RepositoryState.MERGING_RESOLVED\n-\t\t\t\t\t\t\t\t&& meta != null) {\n-\t\t\t\t\t\t\t// Commit was successful. Now delete the files\n-\t\t\t\t\t\t\t// used for merge commits\n-\t\t\t\t\t\t\tnew File(meta, Constants.MERGE_HEAD).delete();\n-\t\t\t\t\t\t\tnew File(meta, Constants.MERGE_MSG).delete();\n+\t\t\t\t\t\tru.setExpectedOldObjectId(headId);\n+\t\t\t\t\t\tResult rc = ru.update();\n+\t\t\t\t\t\tswitch (rc) {\n+\t\t\t\t\t\tcase NEW:\n+\t\t\t\t\t\tcase FAST_FORWARD: {\n+\t\t\t\t\t\t\tsetCallable(false);\n+\t\t\t\t\t\t\tFile meta = repo.getDirectory();\n+\t\t\t\t\t\t\tif (state == RepositoryState.MERGING_RESOLVED\n+\t\t\t\t\t\t\t\t\t&& meta != null) {\n+\t\t\t\t\t\t\t\t// Commit was successful. Now delete the files\n+\t\t\t\t\t\t\t\t// used for merge commits\n+\t\t\t\t\t\t\t\tnew File(meta, Constants.MERGE_HEAD).delete();\n+\t\t\t\t\t\t\t\tnew File(meta, Constants.MERGE_MSG).delete();\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\treturn revCommit;\n \t\t\t\t\t\t}\n-\t\t\t\t\t\treturn revCommit;\n-\t\t\t\t\t}\n-\t\t\t\t\tcase REJECTED:\n-\t\t\t\t\tcase LOCK_FAILURE:\n-\t\t\t\t\t\tthrow new ConcurrentRefUpdateException(\n-\t\t\t\t\t\t\t\tJGitText.get().couldNotLockHEAD, ru.getRef(),\n-\t\t\t\t\t\t\t\trc);\n-\t\t\t\t\tdefault:\n-\t\t\t\t\t\tthrow new JGitInternalException(MessageFormat.format(\n-\t\t\t\t\t\t\t\tJGitText.get().updatingRefFailed,\n-\t\t\t\t\t\t\t\tConstants.HEAD, commitId.toString(), rc));\n+\t\t\t\t\t\tcase REJECTED:\n+\t\t\t\t\t\tcase LOCK_FAILURE:\n+\t\t\t\t\t\t\tthrow new ConcurrentRefUpdateException(JGitText\n+\t\t\t\t\t\t\t\t\t.get().couldNotLockHEAD, ru.getRef(), rc);\n+\t\t\t\t\t\tdefault:\n+\t\t\t\t\t\t\tthrow new JGitInternalException(MessageFormat\n+\t\t\t\t\t\t\t\t\t.format(JGitText.get().updatingRefFailed,\n+\t\t\t\t\t\t\t\t\t\t\tConstants.HEAD,\n+\t\t\t\t\t\t\t\t\t\t\tcommitId.toString(), rc));\n+\t\t\t\t\t\t}\n+\t\t\t\t\t} finally {\n+\t\t\t\t\t\trevWalk.release();\n \t\t\t\t\t}\n \t\t\t\t} finally {\n \t\t\t\t\todi.release();\n \t\t\t\t}\n \t\t\t} finally {\n \t\t\t\tindex.unlock();\n \t\t\t}\n \t\t} catch (UnmergedPathException e) {\n \t\t\t// since UnmergedPathException is a subclass of IOException\n \t\t\t// which should not be wrapped by a JGitInternalException we\n \t\t\t// have to catch and re-throw it here\n \t\t\tthrow e;\n \t\t} catch (IOException e) {\n \t\t\tthrow new JGitInternalException(\n \t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"ffe0614d4db653cbcd48c19e9f599fd87cdcfaba": {
			"type": "Ybodychange",
			"commitMessage": "Allow Repository.getDirectory() to be null\n\nSome types of repositories might not be stored on local disk.  For\nthese, they will most likely return null for getDirectory() as the\njava.io.File type cannot describe where their storage is, its not\nin the host's filesystem.\n\nDocument that getDirectory() can return null now, and update all\ncurrent non-test callers in JGit that might run into problems on\nsuch repositories.  For the most part, just act like its bare.\n\nChange-Id: I061236a691372a267fd7d41f0550650e165d2066\nSigned-off-by: Shawn O. Pearce <spearce@spearce.org>\n",
			"commitDate": "2010-06-25, 7:03 PM",
			"commitName": "ffe0614d4db653cbcd48c19e9f599fd87cdcfaba",
			"commitAuthor": "Shawn O. Pearce",
			"commitDateOld": "2010-06-25, 6:46 PM",
			"commitNameOld": "88530a179e2ddfa81de5cc441a27d66521334608",
			"commitAuthorOld": "Shawn O. Pearce",
			"daysBetweenCommits": 0.01,
			"commitsBetweenForRepo": 8,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,92 +1,93 @@\n \tpublic RevCommit call() throws NoHeadException, NoMessageException,\n \t\t\tUnmergedPathException, ConcurrentRefUpdateException,\n \t\t\tJGitInternalException, WrongRepositoryStateException {\n \t\tcheckCallable();\n \n \t\tRepositoryState state = repo.getRepositoryState();\n \t\tif (!state.canCommit())\n \t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().cannotCommitOnARepoWithState, state.name()));\n \t\tprocessOptions(state);\n \n \t\ttry {\n \t\t\tRef head = repo.getRef(Constants.HEAD);\n \t\t\tif (head == null)\n \t\t\t\tthrow new NoHeadException(\n \t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n \n \t\t\t// determine the current HEAD and the commit it is referring to\n \t\t\tObjectId headId = repo.resolve(Constants.HEAD + \"^{commit}\");\n \t\t\tif (headId != null)\n \t\t\t\tparents.add(0, headId);\n \n \t\t\t// lock the index\n \t\t\tDirCache index = DirCache.lock(repo);\n \t\t\ttry {\n \t\t\t\tObjectInserter odi = repo.newObjectInserter();\n \t\t\t\ttry {\n \t\t\t\t\t// Write the index as tree to the object database. This may\n \t\t\t\t\t// fail for example when the index contains unmerged paths\n \t\t\t\t\t// (unresolved conflicts)\n \t\t\t\t\tObjectId indexTreeId = index.writeTree(odi);\n \n \t\t\t\t\t// Create a Commit object, populate it and write it\n \t\t\t\t\tCommit commit = new Commit(repo);\n \t\t\t\t\tcommit.setCommitter(committer);\n \t\t\t\t\tcommit.setAuthor(author);\n \t\t\t\t\tcommit.setMessage(message);\n \n \t\t\t\t\tcommit.setParentIds(parents.toArray(new ObjectId[] {}));\n \t\t\t\t\tcommit.setTreeId(indexTreeId);\n \t\t\t\t\tObjectId commitId = odi.insert(Constants.OBJ_COMMIT, odi\n \t\t\t\t\t\t\t.format(commit));\n \t\t\t\t\todi.flush();\n \n \t\t\t\t\tRevCommit revCommit = new RevWalk(repo)\n \t\t\t\t\t\t\t.parseCommit(commitId);\n \t\t\t\t\tRefUpdate ru = repo.updateRef(Constants.HEAD);\n \t\t\t\t\tru.setNewObjectId(commitId);\n \t\t\t\t\tru.setRefLogMessage(\"commit : \"\n \t\t\t\t\t\t\t+ revCommit.getShortMessage(), false);\n \n \t\t\t\t\tru.setExpectedOldObjectId(headId);\n \t\t\t\t\tResult rc = ru.update();\n \t\t\t\t\tswitch (rc) {\n \t\t\t\t\tcase NEW:\n-\t\t\t\t\tcase FAST_FORWARD:\n+\t\t\t\t\tcase FAST_FORWARD: {\n \t\t\t\t\t\tsetCallable(false);\n-\t\t\t\t\t\tif (state == RepositoryState.MERGING_RESOLVED) {\n+\t\t\t\t\t\tFile meta = repo.getDirectory();\n+\t\t\t\t\t\tif (state == RepositoryState.MERGING_RESOLVED\n+\t\t\t\t\t\t\t\t&& meta != null) {\n \t\t\t\t\t\t\t// Commit was successful. Now delete the files\n \t\t\t\t\t\t\t// used for merge commits\n-\t\t\t\t\t\t\tnew File(repo.getDirectory(), Constants.MERGE_HEAD)\n-\t\t\t\t\t\t\t\t\t.delete();\n-\t\t\t\t\t\t\tnew File(repo.getDirectory(), Constants.MERGE_MSG)\n-\t\t\t\t\t\t\t\t\t.delete();\n+\t\t\t\t\t\t\tnew File(meta, Constants.MERGE_HEAD).delete();\n+\t\t\t\t\t\t\tnew File(meta, Constants.MERGE_MSG).delete();\n \t\t\t\t\t\t}\n \t\t\t\t\t\treturn revCommit;\n+\t\t\t\t\t}\n \t\t\t\t\tcase REJECTED:\n \t\t\t\t\tcase LOCK_FAILURE:\n \t\t\t\t\t\tthrow new ConcurrentRefUpdateException(\n \t\t\t\t\t\t\t\tJGitText.get().couldNotLockHEAD, ru.getRef(),\n \t\t\t\t\t\t\t\trc);\n \t\t\t\t\tdefault:\n \t\t\t\t\t\tthrow new JGitInternalException(MessageFormat.format(\n \t\t\t\t\t\t\t\tJGitText.get().updatingRefFailed,\n \t\t\t\t\t\t\t\tConstants.HEAD, commitId.toString(), rc));\n \t\t\t\t\t}\n \t\t\t\t} finally {\n \t\t\t\t\todi.release();\n \t\t\t\t}\n \t\t\t} finally {\n \t\t\t\tindex.unlock();\n \t\t\t}\n \t\t} catch (UnmergedPathException e) {\n \t\t\t// since UnmergedPathException is a subclass of IOException\n \t\t\t// which should not be wrapped by a JGitInternalException we\n \t\t\t// have to catch and re-throw it here\n \t\t\tthrow e;\n \t\t} catch (IOException e) {\n \t\t\tthrow new JGitInternalException(\n \t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"88530a179e2ddfa81de5cc441a27d66521334608": {
			"type": "Ybodychange",
			"commitMessage": "Start using ObjectInserter instead of ObjectWriter\n\nSome newer style APIs are updated to use the newer ObjectInserter\ninterface instead of the now deprecated ObjectWriter.  In many of\nthe unit tests we don't bother to release the inserter, these are\ntypically using the file backend which doesn't need a release,\nbut in the future should use an in-memory HashMap based store,\nwhich really wouldn't need it either.\n\nChange-Id: I91a15e1dc42da68e6715397814e30fbd87fa2e73\nSigned-off-by: Shawn O. Pearce <spearce@spearce.org>\n",
			"commitDate": "2010-06-25, 6:46 PM",
			"commitName": "88530a179e2ddfa81de5cc441a27d66521334608",
			"commitAuthor": "Shawn O. Pearce",
			"commitDateOld": "2010-05-20, 5:49 PM",
			"commitNameOld": "6ca9843f3ebbea152969a8b795efce1d4ff15dbf",
			"commitAuthorOld": "Christian Halstrick",
			"daysBetweenCommits": 36.04,
			"commitsBetweenForRepo": 75,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,85 +1,92 @@\n \tpublic RevCommit call() throws NoHeadException, NoMessageException,\n \t\t\tUnmergedPathException, ConcurrentRefUpdateException,\n \t\t\tJGitInternalException, WrongRepositoryStateException {\n \t\tcheckCallable();\n \n \t\tRepositoryState state = repo.getRepositoryState();\n \t\tif (!state.canCommit())\n \t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n \t\t\t\t\tJGitText.get().cannotCommitOnARepoWithState, state.name()));\n \t\tprocessOptions(state);\n \n \t\ttry {\n \t\t\tRef head = repo.getRef(Constants.HEAD);\n \t\t\tif (head == null)\n \t\t\t\tthrow new NoHeadException(\n \t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n \n \t\t\t// determine the current HEAD and the commit it is referring to\n \t\t\tObjectId headId = repo.resolve(Constants.HEAD + \"^{commit}\");\n \t\t\tif (headId != null)\n \t\t\t\tparents.add(0, headId);\n \n \t\t\t// lock the index\n \t\t\tDirCache index = DirCache.lock(repo);\n \t\t\ttry {\n-\t\t\t\tObjectWriter repoWriter = new ObjectWriter(repo);\n+\t\t\t\tObjectInserter odi = repo.newObjectInserter();\n+\t\t\t\ttry {\n+\t\t\t\t\t// Write the index as tree to the object database. This may\n+\t\t\t\t\t// fail for example when the index contains unmerged paths\n+\t\t\t\t\t// (unresolved conflicts)\n+\t\t\t\t\tObjectId indexTreeId = index.writeTree(odi);\n \n-\t\t\t\t// Write the index as tree to the object database. This may fail\n-\t\t\t\t// for example when the index contains unmerged pathes\n-\t\t\t\t// (unresolved conflicts)\n-\t\t\t\tObjectId indexTreeId = index.writeTree(repoWriter);\n+\t\t\t\t\t// Create a Commit object, populate it and write it\n+\t\t\t\t\tCommit commit = new Commit(repo);\n+\t\t\t\t\tcommit.setCommitter(committer);\n+\t\t\t\t\tcommit.setAuthor(author);\n+\t\t\t\t\tcommit.setMessage(message);\n \n-\t\t\t\t// Create a Commit object, populate it and write it\n-\t\t\t\tCommit commit = new Commit(repo);\n-\t\t\t\tcommit.setCommitter(committer);\n-\t\t\t\tcommit.setAuthor(author);\n-\t\t\t\tcommit.setMessage(message);\n+\t\t\t\t\tcommit.setParentIds(parents.toArray(new ObjectId[] {}));\n+\t\t\t\t\tcommit.setTreeId(indexTreeId);\n+\t\t\t\t\tObjectId commitId = odi.insert(Constants.OBJ_COMMIT, odi\n+\t\t\t\t\t\t\t.format(commit));\n+\t\t\t\t\todi.flush();\n \n-\t\t\t\tcommit.setParentIds(parents.toArray(new ObjectId[]{}));\n-\t\t\t\tcommit.setTreeId(indexTreeId);\n-\t\t\t\tObjectId commitId = repoWriter.writeCommit(commit);\n+\t\t\t\t\tRevCommit revCommit = new RevWalk(repo)\n+\t\t\t\t\t\t\t.parseCommit(commitId);\n+\t\t\t\t\tRefUpdate ru = repo.updateRef(Constants.HEAD);\n+\t\t\t\t\tru.setNewObjectId(commitId);\n+\t\t\t\t\tru.setRefLogMessage(\"commit : \"\n+\t\t\t\t\t\t\t+ revCommit.getShortMessage(), false);\n \n-\t\t\t\tRevCommit revCommit = new RevWalk(repo).parseCommit(commitId);\n-\t\t\t\tRefUpdate ru = repo.updateRef(Constants.HEAD);\n-\t\t\t\tru.setNewObjectId(commitId);\n-\t\t\t\tru.setRefLogMessage(\"commit : \" + revCommit.getShortMessage(),\n-\t\t\t\t\t\tfalse);\n-\n-\t\t\t\tru.setExpectedOldObjectId(headId);\n-\t\t\t\tResult rc = ru.update();\n-\t\t\t\tswitch (rc) {\n-\t\t\t\tcase NEW:\n-\t\t\t\tcase FAST_FORWARD:\n-\t\t\t\t\tsetCallable(false);\n-\t\t\t\t\tif (state == RepositoryState.MERGING_RESOLVED) {\n-\t\t\t\t\t\t// Commit was successful. Now delete the files\n-\t\t\t\t\t\t// used for merge commits\n-\t\t\t\t\t\tnew File(repo.getDirectory(), Constants.MERGE_HEAD)\n-\t\t\t\t\t\t\t\t.delete();\n-\t\t\t\t\t\tnew File(repo.getDirectory(), Constants.MERGE_MSG)\n-\t\t\t\t\t\t\t\t.delete();\n+\t\t\t\t\tru.setExpectedOldObjectId(headId);\n+\t\t\t\t\tResult rc = ru.update();\n+\t\t\t\t\tswitch (rc) {\n+\t\t\t\t\tcase NEW:\n+\t\t\t\t\tcase FAST_FORWARD:\n+\t\t\t\t\t\tsetCallable(false);\n+\t\t\t\t\t\tif (state == RepositoryState.MERGING_RESOLVED) {\n+\t\t\t\t\t\t\t// Commit was successful. Now delete the files\n+\t\t\t\t\t\t\t// used for merge commits\n+\t\t\t\t\t\t\tnew File(repo.getDirectory(), Constants.MERGE_HEAD)\n+\t\t\t\t\t\t\t\t\t.delete();\n+\t\t\t\t\t\t\tnew File(repo.getDirectory(), Constants.MERGE_MSG)\n+\t\t\t\t\t\t\t\t\t.delete();\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\treturn revCommit;\n+\t\t\t\t\tcase REJECTED:\n+\t\t\t\t\tcase LOCK_FAILURE:\n+\t\t\t\t\t\tthrow new ConcurrentRefUpdateException(\n+\t\t\t\t\t\t\t\tJGitText.get().couldNotLockHEAD, ru.getRef(),\n+\t\t\t\t\t\t\t\trc);\n+\t\t\t\t\tdefault:\n+\t\t\t\t\t\tthrow new JGitInternalException(MessageFormat.format(\n+\t\t\t\t\t\t\t\tJGitText.get().updatingRefFailed,\n+\t\t\t\t\t\t\t\tConstants.HEAD, commitId.toString(), rc));\n \t\t\t\t\t}\n-\t\t\t\t\treturn revCommit;\n-\t\t\t\tcase REJECTED:\n-\t\t\t\tcase LOCK_FAILURE:\n-\t\t\t\t\tthrow new ConcurrentRefUpdateException(\n-\t\t\t\t\t\t\tJGitText.get().couldNotLockHEAD, ru.getRef(), rc);\n-\t\t\t\tdefault:\n-\t\t\t\t\tthrow new JGitInternalException(MessageFormat.format(\n-\t\t\t\t\t\t\tJGitText.get().updatingRefFailed\n-\t\t\t\t\t\t\t, Constants.HEAD, commitId.toString(), rc));\n+\t\t\t\t} finally {\n+\t\t\t\t\todi.release();\n \t\t\t\t}\n \t\t\t} finally {\n \t\t\t\tindex.unlock();\n \t\t\t}\n \t\t} catch (UnmergedPathException e) {\n \t\t\t// since UnmergedPathException is a subclass of IOException\n \t\t\t// which should not be wrapped by a JGitInternalException we\n \t\t\t// have to catch and re-throw it here\n \t\t\tthrow e;\n \t\t} catch (IOException e) {\n \t\t\tthrow new JGitInternalException(\n \t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"6ca9843f3ebbea152969a8b795efce1d4ff15dbf": {
			"type": "Ymultichange(Yexceptionschange,Ybodychange)",
			"commitMessage": "Added merge support to CommitCommand\n\nThe CommitCommand should take care to create a merge commit if the file\n$GIT_DIR/MERGE_HEAD exists. It should then read the parents for the merge\ncommit out of this file. It should also take care that when commiting\na merge and no commit message was specified to read the message from\n$GIT_DIR/MERGE_MSG.\nFinally the CommitCommand should remove these files if the commit\nsucceeded.\n\nChange-Id: \tI4e292115085099d5b86546d2021680cb1454266c\nSigned-off-by: Christian Halstrick <christian.halstrick@sap.com>\n",
			"commitDate": "2010-05-20, 5:49 PM",
			"commitName": "6ca9843f3ebbea152969a8b795efce1d4ff15dbf",
			"commitAuthor": "Christian Halstrick",
			"subchanges": [
				{
					"type": "Yexceptionschange",
					"commitMessage": "Added merge support to CommitCommand\n\nThe CommitCommand should take care to create a merge commit if the file\n$GIT_DIR/MERGE_HEAD exists. It should then read the parents for the merge\ncommit out of this file. It should also take care that when commiting\na merge and no commit message was specified to read the message from\n$GIT_DIR/MERGE_MSG.\nFinally the CommitCommand should remove these files if the commit\nsucceeded.\n\nChange-Id: \tI4e292115085099d5b86546d2021680cb1454266c\nSigned-off-by: Christian Halstrick <christian.halstrick@sap.com>\n",
					"commitDate": "2010-05-20, 5:49 PM",
					"commitName": "6ca9843f3ebbea152969a8b795efce1d4ff15dbf",
					"commitAuthor": "Christian Halstrick",
					"commitDateOld": "2010-05-19, 3:37 PM",
					"commitNameOld": "f3d8a8ecad614906a2c4ec0077cdb24129da6c6d",
					"commitAuthorOld": "Sasa Zivkov",
					"daysBetweenCommits": 1.09,
					"commitsBetweenForRepo": 2,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,70 +1,85 @@\n \tpublic RevCommit call() throws NoHeadException, NoMessageException,\n \t\t\tUnmergedPathException, ConcurrentRefUpdateException,\n-\t\t\tJGitInternalException {\n+\t\t\tJGitInternalException, WrongRepositoryStateException {\n \t\tcheckCallable();\n-\t\tprocessOptions();\n+\n+\t\tRepositoryState state = repo.getRepositoryState();\n+\t\tif (!state.canCommit())\n+\t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n+\t\t\t\t\tJGitText.get().cannotCommitOnARepoWithState, state.name()));\n+\t\tprocessOptions(state);\n \n \t\ttry {\n \t\t\tRef head = repo.getRef(Constants.HEAD);\n \t\t\tif (head == null)\n \t\t\t\tthrow new NoHeadException(\n \t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n \n \t\t\t// determine the current HEAD and the commit it is referring to\n-\t\t\tObjectId parentID = repo.resolve(Constants.HEAD + \"^{commit}\");\n+\t\t\tObjectId headId = repo.resolve(Constants.HEAD + \"^{commit}\");\n+\t\t\tif (headId != null)\n+\t\t\t\tparents.add(0, headId);\n \n \t\t\t// lock the index\n \t\t\tDirCache index = DirCache.lock(repo);\n \t\t\ttry {\n \t\t\t\tObjectWriter repoWriter = new ObjectWriter(repo);\n \n \t\t\t\t// Write the index as tree to the object database. This may fail\n \t\t\t\t// for example when the index contains unmerged pathes\n \t\t\t\t// (unresolved conflicts)\n \t\t\t\tObjectId indexTreeId = index.writeTree(repoWriter);\n \n \t\t\t\t// Create a Commit object, populate it and write it\n \t\t\t\tCommit commit = new Commit(repo);\n \t\t\t\tcommit.setCommitter(committer);\n \t\t\t\tcommit.setAuthor(author);\n \t\t\t\tcommit.setMessage(message);\n-\t\t\t\tif (parentID != null)\n-\t\t\t\t\tcommit.setParentIds(new ObjectId[] { parentID });\n+\n+\t\t\t\tcommit.setParentIds(parents.toArray(new ObjectId[]{}));\n \t\t\t\tcommit.setTreeId(indexTreeId);\n \t\t\t\tObjectId commitId = repoWriter.writeCommit(commit);\n \n \t\t\t\tRevCommit revCommit = new RevWalk(repo).parseCommit(commitId);\n \t\t\t\tRefUpdate ru = repo.updateRef(Constants.HEAD);\n \t\t\t\tru.setNewObjectId(commitId);\n \t\t\t\tru.setRefLogMessage(\"commit : \" + revCommit.getShortMessage(),\n \t\t\t\t\t\tfalse);\n \n-\t\t\t\tru.setExpectedOldObjectId(parentID);\n+\t\t\t\tru.setExpectedOldObjectId(headId);\n \t\t\t\tResult rc = ru.update();\n \t\t\t\tswitch (rc) {\n \t\t\t\tcase NEW:\n \t\t\t\tcase FAST_FORWARD:\n \t\t\t\t\tsetCallable(false);\n+\t\t\t\t\tif (state == RepositoryState.MERGING_RESOLVED) {\n+\t\t\t\t\t\t// Commit was successful. Now delete the files\n+\t\t\t\t\t\t// used for merge commits\n+\t\t\t\t\t\tnew File(repo.getDirectory(), Constants.MERGE_HEAD)\n+\t\t\t\t\t\t\t\t.delete();\n+\t\t\t\t\t\tnew File(repo.getDirectory(), Constants.MERGE_MSG)\n+\t\t\t\t\t\t\t\t.delete();\n+\t\t\t\t\t}\n \t\t\t\t\treturn revCommit;\n \t\t\t\tcase REJECTED:\n \t\t\t\tcase LOCK_FAILURE:\n \t\t\t\t\tthrow new ConcurrentRefUpdateException(\n \t\t\t\t\t\t\tJGitText.get().couldNotLockHEAD, ru.getRef(), rc);\n \t\t\t\tdefault:\n \t\t\t\t\tthrow new JGitInternalException(MessageFormat.format(\n \t\t\t\t\t\t\tJGitText.get().updatingRefFailed\n \t\t\t\t\t\t\t, Constants.HEAD, commitId.toString(), rc));\n \t\t\t\t}\n \t\t\t} finally {\n \t\t\t\tindex.unlock();\n \t\t\t}\n \t\t} catch (UnmergedPathException e) {\n \t\t\t// since UnmergedPathException is a subclass of IOException\n \t\t\t// which should not be wrapped by a JGitInternalException we\n \t\t\t// have to catch and re-throw it here\n \t\t\tthrow e;\n \t\t} catch (IOException e) {\n \t\t\tthrow new JGitInternalException(\n \t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n \t\t}\n \t}\n\\ No newline at end of file\n",
					"extendedDetails": {
						"oldValue": "[NoHeadException, NoMessageException, UnmergedPathException, ConcurrentRefUpdateException, JGitInternalException]",
						"newValue": "[NoHeadException, NoMessageException, UnmergedPathException, ConcurrentRefUpdateException, JGitInternalException, WrongRepositoryStateException]"
					}
				},
				{
					"type": "Ybodychange",
					"commitMessage": "Added merge support to CommitCommand\n\nThe CommitCommand should take care to create a merge commit if the file\n$GIT_DIR/MERGE_HEAD exists. It should then read the parents for the merge\ncommit out of this file. It should also take care that when commiting\na merge and no commit message was specified to read the message from\n$GIT_DIR/MERGE_MSG.\nFinally the CommitCommand should remove these files if the commit\nsucceeded.\n\nChange-Id: \tI4e292115085099d5b86546d2021680cb1454266c\nSigned-off-by: Christian Halstrick <christian.halstrick@sap.com>\n",
					"commitDate": "2010-05-20, 5:49 PM",
					"commitName": "6ca9843f3ebbea152969a8b795efce1d4ff15dbf",
					"commitAuthor": "Christian Halstrick",
					"commitDateOld": "2010-05-19, 3:37 PM",
					"commitNameOld": "f3d8a8ecad614906a2c4ec0077cdb24129da6c6d",
					"commitAuthorOld": "Sasa Zivkov",
					"daysBetweenCommits": 1.09,
					"commitsBetweenForRepo": 2,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,70 +1,85 @@\n \tpublic RevCommit call() throws NoHeadException, NoMessageException,\n \t\t\tUnmergedPathException, ConcurrentRefUpdateException,\n-\t\t\tJGitInternalException {\n+\t\t\tJGitInternalException, WrongRepositoryStateException {\n \t\tcheckCallable();\n-\t\tprocessOptions();\n+\n+\t\tRepositoryState state = repo.getRepositoryState();\n+\t\tif (!state.canCommit())\n+\t\t\tthrow new WrongRepositoryStateException(MessageFormat.format(\n+\t\t\t\t\tJGitText.get().cannotCommitOnARepoWithState, state.name()));\n+\t\tprocessOptions(state);\n \n \t\ttry {\n \t\t\tRef head = repo.getRef(Constants.HEAD);\n \t\t\tif (head == null)\n \t\t\t\tthrow new NoHeadException(\n \t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n \n \t\t\t// determine the current HEAD and the commit it is referring to\n-\t\t\tObjectId parentID = repo.resolve(Constants.HEAD + \"^{commit}\");\n+\t\t\tObjectId headId = repo.resolve(Constants.HEAD + \"^{commit}\");\n+\t\t\tif (headId != null)\n+\t\t\t\tparents.add(0, headId);\n \n \t\t\t// lock the index\n \t\t\tDirCache index = DirCache.lock(repo);\n \t\t\ttry {\n \t\t\t\tObjectWriter repoWriter = new ObjectWriter(repo);\n \n \t\t\t\t// Write the index as tree to the object database. This may fail\n \t\t\t\t// for example when the index contains unmerged pathes\n \t\t\t\t// (unresolved conflicts)\n \t\t\t\tObjectId indexTreeId = index.writeTree(repoWriter);\n \n \t\t\t\t// Create a Commit object, populate it and write it\n \t\t\t\tCommit commit = new Commit(repo);\n \t\t\t\tcommit.setCommitter(committer);\n \t\t\t\tcommit.setAuthor(author);\n \t\t\t\tcommit.setMessage(message);\n-\t\t\t\tif (parentID != null)\n-\t\t\t\t\tcommit.setParentIds(new ObjectId[] { parentID });\n+\n+\t\t\t\tcommit.setParentIds(parents.toArray(new ObjectId[]{}));\n \t\t\t\tcommit.setTreeId(indexTreeId);\n \t\t\t\tObjectId commitId = repoWriter.writeCommit(commit);\n \n \t\t\t\tRevCommit revCommit = new RevWalk(repo).parseCommit(commitId);\n \t\t\t\tRefUpdate ru = repo.updateRef(Constants.HEAD);\n \t\t\t\tru.setNewObjectId(commitId);\n \t\t\t\tru.setRefLogMessage(\"commit : \" + revCommit.getShortMessage(),\n \t\t\t\t\t\tfalse);\n \n-\t\t\t\tru.setExpectedOldObjectId(parentID);\n+\t\t\t\tru.setExpectedOldObjectId(headId);\n \t\t\t\tResult rc = ru.update();\n \t\t\t\tswitch (rc) {\n \t\t\t\tcase NEW:\n \t\t\t\tcase FAST_FORWARD:\n \t\t\t\t\tsetCallable(false);\n+\t\t\t\t\tif (state == RepositoryState.MERGING_RESOLVED) {\n+\t\t\t\t\t\t// Commit was successful. Now delete the files\n+\t\t\t\t\t\t// used for merge commits\n+\t\t\t\t\t\tnew File(repo.getDirectory(), Constants.MERGE_HEAD)\n+\t\t\t\t\t\t\t\t.delete();\n+\t\t\t\t\t\tnew File(repo.getDirectory(), Constants.MERGE_MSG)\n+\t\t\t\t\t\t\t\t.delete();\n+\t\t\t\t\t}\n \t\t\t\t\treturn revCommit;\n \t\t\t\tcase REJECTED:\n \t\t\t\tcase LOCK_FAILURE:\n \t\t\t\t\tthrow new ConcurrentRefUpdateException(\n \t\t\t\t\t\t\tJGitText.get().couldNotLockHEAD, ru.getRef(), rc);\n \t\t\t\tdefault:\n \t\t\t\t\tthrow new JGitInternalException(MessageFormat.format(\n \t\t\t\t\t\t\tJGitText.get().updatingRefFailed\n \t\t\t\t\t\t\t, Constants.HEAD, commitId.toString(), rc));\n \t\t\t\t}\n \t\t\t} finally {\n \t\t\t\tindex.unlock();\n \t\t\t}\n \t\t} catch (UnmergedPathException e) {\n \t\t\t// since UnmergedPathException is a subclass of IOException\n \t\t\t// which should not be wrapped by a JGitInternalException we\n \t\t\t// have to catch and re-throw it here\n \t\t\tthrow e;\n \t\t} catch (IOException e) {\n \t\t\tthrow new JGitInternalException(\n \t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n \t\t}\n \t}\n\\ No newline at end of file\n",
					"extendedDetails": {}
				}
			]
		},
		"f3d8a8ecad614906a2c4ec0077cdb24129da6c6d": {
			"type": "Ybodychange",
			"commitMessage": "Externalize strings from JGit\n\nThe strings are externalized into the root resource bundles.\nThe resource bundles are stored under the new \"resources\" source\nfolder to get proper maven build.\n\nStrings from tests are, in general, not externalized. Only in\ncases where it was necessary to make the test pass the strings\nwere externalized. This was typically necessary in cases where\ne.getMessage() was used in assert and the exception message was\nslightly changed due to reuse of the externalized strings.\n\nChange-Id: Ic0f29c80b9a54fcec8320d8539a3e112852a1f7b\nSigned-off-by: Sasa Zivkov <sasa.zivkov@sap.com>\n",
			"commitDate": "2010-05-19, 3:37 PM",
			"commitName": "f3d8a8ecad614906a2c4ec0077cdb24129da6c6d",
			"commitAuthor": "Sasa Zivkov",
			"commitDateOld": "2010-05-10, 7:17 AM",
			"commitNameOld": "f3fb5824ba45197787bc4ffb81fafcd576c60291",
			"commitAuthorOld": "Christian Halstrick",
			"daysBetweenCommits": 9.35,
			"commitsBetweenForRepo": 16,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,74 +1,70 @@\n \tpublic RevCommit call() throws NoHeadException, NoMessageException,\n \t\t\tUnmergedPathException, ConcurrentRefUpdateException,\n \t\t\tJGitInternalException {\n \t\tcheckCallable();\n \t\tprocessOptions();\n \n \t\ttry {\n \t\t\tRef head = repo.getRef(Constants.HEAD);\n \t\t\tif (head == null)\n \t\t\t\tthrow new NoHeadException(\n-\t\t\t\t\t\t\"Commit on repo without HEAD currently not supported\");\n+\t\t\t\t\t\tJGitText.get().commitOnRepoWithoutHEADCurrentlyNotSupported);\n \n \t\t\t// determine the current HEAD and the commit it is referring to\n \t\t\tObjectId parentID = repo.resolve(Constants.HEAD + \"^{commit}\");\n \n \t\t\t// lock the index\n \t\t\tDirCache index = DirCache.lock(repo);\n \t\t\ttry {\n \t\t\t\tObjectWriter repoWriter = new ObjectWriter(repo);\n \n \t\t\t\t// Write the index as tree to the object database. This may fail\n \t\t\t\t// for example when the index contains unmerged pathes\n \t\t\t\t// (unresolved conflicts)\n \t\t\t\tObjectId indexTreeId = index.writeTree(repoWriter);\n \n \t\t\t\t// Create a Commit object, populate it and write it\n \t\t\t\tCommit commit = new Commit(repo);\n \t\t\t\tcommit.setCommitter(committer);\n \t\t\t\tcommit.setAuthor(author);\n \t\t\t\tcommit.setMessage(message);\n \t\t\t\tif (parentID != null)\n \t\t\t\t\tcommit.setParentIds(new ObjectId[] { parentID });\n \t\t\t\tcommit.setTreeId(indexTreeId);\n \t\t\t\tObjectId commitId = repoWriter.writeCommit(commit);\n \n \t\t\t\tRevCommit revCommit = new RevWalk(repo).parseCommit(commitId);\n \t\t\t\tRefUpdate ru = repo.updateRef(Constants.HEAD);\n \t\t\t\tru.setNewObjectId(commitId);\n \t\t\t\tru.setRefLogMessage(\"commit : \" + revCommit.getShortMessage(),\n \t\t\t\t\t\tfalse);\n \n \t\t\t\tru.setExpectedOldObjectId(parentID);\n \t\t\t\tResult rc = ru.update();\n \t\t\t\tswitch (rc) {\n \t\t\t\tcase NEW:\n \t\t\t\tcase FAST_FORWARD:\n \t\t\t\t\tsetCallable(false);\n \t\t\t\t\treturn revCommit;\n \t\t\t\tcase REJECTED:\n \t\t\t\tcase LOCK_FAILURE:\n \t\t\t\t\tthrow new ConcurrentRefUpdateException(\n-\t\t\t\t\t\t\t\"Could lock HEAD during commit\", ru.getRef(), rc);\n+\t\t\t\t\t\t\tJGitText.get().couldNotLockHEAD, ru.getRef(), rc);\n \t\t\t\tdefault:\n-\t\t\t\t\tthrow new JGitInternalException(\n-\t\t\t\t\t\t\t\"Updating the ref \"\n-\t\t\t\t\t\t\t\t\t+ Constants.HEAD\n-\t\t\t\t\t\t\t\t\t+ \" to \"\n-\t\t\t\t\t\t\t\t\t+ commitId.toString()\n-\t\t\t\t\t\t\t\t\t+ \" failed. ReturnCode from RefUpdate.update() was \"\n-\t\t\t\t\t\t\t\t\t+ rc);\n+\t\t\t\t\tthrow new JGitInternalException(MessageFormat.format(\n+\t\t\t\t\t\t\tJGitText.get().updatingRefFailed\n+\t\t\t\t\t\t\t, Constants.HEAD, commitId.toString(), rc));\n \t\t\t\t}\n \t\t\t} finally {\n \t\t\t\tindex.unlock();\n \t\t\t}\n \t\t} catch (UnmergedPathException e) {\n \t\t\t// since UnmergedPathException is a subclass of IOException\n \t\t\t// which should not be wrapped by a JGitInternalException we\n \t\t\t// have to catch and re-throw it here\n \t\t\tthrow e;\n \t\t} catch (IOException e) {\n \t\t\tthrow new JGitInternalException(\n-\t\t\t\t\t\"Exception caught during execution of commit command\", e);\n+\t\t\t\t\tJGitText.get().exceptionCaughtDuringExecutionOfCommitCommand, e);\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"f3fb5824ba45197787bc4ffb81fafcd576c60291": {
			"type": "Yintroduced",
			"commitMessage": "Add builder-style API to jgit and Commit & Log cmd\n\nAdded a new package org.eclipse.jgit.api and a builder-style API for\njgit. Added also the first implementation for two git commands: Commit\nand Log.\n\nThis API is intended to be used by external components when\nfunctionalities of the standard git commands are required. It will also\nhelp to ease writing JGit tests.\n\nFor internal usages this API may often not be optimal because the git\ncommands are doing much more than required or they expect parameters of\nan unappropriate type.\n\nChange-Id: I71ac4839ab9d2f848307eba9252090c586b4146b\nSigned-off-by: Christian Halstrick <christian.halstrick@sap.com>\n",
			"commitDate": "2010-05-10, 7:17 AM",
			"commitName": "f3fb5824ba45197787bc4ffb81fafcd576c60291",
			"commitAuthor": "Christian Halstrick"
		}
	},
	"sha": "bd1a82502680b5de5bf86f6c4470185fd1602386"
}