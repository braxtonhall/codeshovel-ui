{
	"repo": "https://github.com/spring-projects/spring-framework.git",
	"file": "spring-webmvc/src/main/java/org/springframework/web/servlet/mvc/method/annotation/AbstractMessageConverterMethodProcessor.java",
	"method": {
		"longName": "protected void writeWithMessageConverters(T value, MethodParameter returnType, ServletServerHttpRequest inputMessage, ServletServerHttpResponse outputMessage);",
		"startLine": 179,
		"methodName": "writeWithMessageConverters",
		"isStatic": false,
		"isAbstract": false,
		"visibility": "protected"
	},
	"history": {
		"29ce6685cad0f6caf829c49024b1885ab31d62e0": {
			"type": "Ybodychange",
			"commitMessage": "Add handleFailure property to FrameworkServlet\n\nIssue: SPR-17100\n",
			"commitDate": "2018-08-01, 2:49 PM",
			"commitName": "29ce6685cad0f6caf829c49024b1885ab31d62e0",
			"commitAuthor": "Rossen Stoyanchev",
			"commitDateOld": "2018-07-24, 5:47 PM",
			"commitNameOld": "0be8c20fca26357aa61c28dec2f3720f1d7488be",
			"commitAuthorOld": "Rossen Stoyanchev",
			"daysBetweenCommits": 7.88,
			"commitsBetweenForRepo": 48,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,130 +1,129 @@\n \tprotected <T> void writeWithMessageConverters(@Nullable T value, MethodParameter returnType,\n \t\t\tServletServerHttpRequest inputMessage, ServletServerHttpResponse outputMessage)\n \t\t\tthrows IOException, HttpMediaTypeNotAcceptableException, HttpMessageNotWritableException {\n \n \t\tObject body;\n \t\tClass<?> valueType;\n \t\tType targetType;\n \n \t\tif (value instanceof CharSequence) {\n \t\t\tbody = value.toString();\n \t\t\tvalueType = String.class;\n \t\t\ttargetType = String.class;\n \t\t}\n \t\telse {\n \t\t\tbody = value;\n \t\t\tvalueType = getReturnValueType(body, returnType);\n \t\t\ttargetType = GenericTypeResolver.resolveType(getGenericType(returnType), returnType.getContainingClass());\n \t\t}\n \n \t\tif (isResourceType(value, returnType)) {\n \t\t\toutputMessage.getHeaders().set(HttpHeaders.ACCEPT_RANGES, \"bytes\");\n \t\t\tif (value != null && inputMessage.getHeaders().getFirst(HttpHeaders.RANGE) != null &&\n \t\t\t\t\toutputMessage.getServletResponse().getStatus() == 200) {\n \t\t\t\tResource resource = (Resource) value;\n \t\t\t\ttry {\n \t\t\t\t\tList<HttpRange> httpRanges = inputMessage.getHeaders().getRange();\n \t\t\t\t\toutputMessage.getServletResponse().setStatus(HttpStatus.PARTIAL_CONTENT.value());\n \t\t\t\t\tbody = HttpRange.toResourceRegions(httpRanges, resource);\n \t\t\t\t\tvalueType = body.getClass();\n \t\t\t\t\ttargetType = RESOURCE_REGION_LIST_TYPE;\n \t\t\t\t}\n \t\t\t\tcatch (IllegalArgumentException ex) {\n \t\t\t\t\toutputMessage.getHeaders().set(HttpHeaders.CONTENT_RANGE, \"bytes */\" + resource.contentLength());\n \t\t\t\t\toutputMessage.getServletResponse().setStatus(HttpStatus.REQUESTED_RANGE_NOT_SATISFIABLE.value());\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\tMediaType selectedMediaType = null;\n \t\tMediaType contentType = outputMessage.getHeaders().getContentType();\n \t\tif (contentType != null && contentType.isConcrete()) {\n \t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\tlogger.debug(\"Found 'Content-Type:\" + contentType + \"' in response\");\n \t\t\t}\n \t\t\tselectedMediaType = contentType;\n \t\t}\n \t\telse {\n \t\t\tHttpServletRequest request = inputMessage.getServletRequest();\n \t\t\tList<MediaType> acceptableTypes = getAcceptableMediaTypes(request);\n \t\t\tList<MediaType> producibleTypes = getProducibleMediaTypes(request, valueType, targetType);\n \n \t\t\tif (body != null && producibleTypes.isEmpty()) {\n \t\t\t\tthrow new HttpMessageNotWritableException(\n \t\t\t\t\t\t\"No converter found for return value of type: \" + valueType);\n \t\t\t}\n \t\t\tList<MediaType> mediaTypesToUse = new ArrayList<>();\n \t\t\tfor (MediaType requestedType : acceptableTypes) {\n \t\t\t\tfor (MediaType producibleType : producibleTypes) {\n \t\t\t\t\tif (requestedType.isCompatibleWith(producibleType)) {\n \t\t\t\t\t\tmediaTypesToUse.add(getMostSpecificMediaType(requestedType, producibleType));\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (mediaTypesToUse.isEmpty()) {\n \t\t\t\tif (body != null) {\n \t\t\t\t\tthrow new HttpMediaTypeNotAcceptableException(producibleTypes);\n \t\t\t\t}\n \t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\tlogger.debug(\"No match for \" + acceptableTypes + \", supported: \" + producibleTypes);\n \t\t\t\t}\n \t\t\t\treturn;\n \t\t\t}\n \n \t\t\tMediaType.sortBySpecificityAndQuality(mediaTypesToUse);\n \n \t\t\tfor (MediaType mediaType : mediaTypesToUse) {\n \t\t\t\tif (mediaType.isConcrete()) {\n \t\t\t\t\tselectedMediaType = mediaType;\n \t\t\t\t\tbreak;\n \t\t\t\t}\n \t\t\t\telse if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n \t\t\t\t\tselectedMediaType = MediaType.APPLICATION_OCTET_STREAM;\n \t\t\t\t\tbreak;\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\tlogger.debug(\"Using '\" + selectedMediaType + \"', given \" +\n \t\t\t\t\t\tacceptableTypes + \" and supported \" + producibleTypes);\n \t\t\t}\n \t\t}\n \n \t\tif (selectedMediaType != null) {\n \t\t\tselectedMediaType = selectedMediaType.removeQualityValue();\n \t\t\tfor (HttpMessageConverter<?> converter : this.messageConverters) {\n \t\t\t\tGenericHttpMessageConverter genericConverter = (converter instanceof GenericHttpMessageConverter ?\n \t\t\t\t\t\t(GenericHttpMessageConverter<?>) converter : null);\n \t\t\t\tif (genericConverter != null ?\n \t\t\t\t\t\t((GenericHttpMessageConverter) converter).canWrite(targetType, valueType, selectedMediaType) :\n \t\t\t\t\t\tconverter.canWrite(valueType, selectedMediaType)) {\n \t\t\t\t\tbody = getAdvice().beforeBodyWrite(body, returnType, selectedMediaType,\n \t\t\t\t\t\t\t(Class<? extends HttpMessageConverter<?>>) converter.getClass(),\n \t\t\t\t\t\t\tinputMessage, outputMessage);\n \t\t\t\t\tif (body != null) {\n \t\t\t\t\t\tif (logger.isDebugEnabled()) {\n-\t\t\t\t\t\t\tObject formatted = (body instanceof CharSequence ? \"\\\"\" + body + \"\\\"\" : body);\n-\t\t\t\t\t\t\tlogger.debug(\"Writing [\" + formatted + \"]\");\n+\t\t\t\t\t\t\tlogger.debug(\"Writing [\" + formatValue(body) + \"]\");\n \t\t\t\t\t\t}\n \t\t\t\t\t\taddContentDispositionHeader(inputMessage, outputMessage);\n \t\t\t\t\t\tif (genericConverter != null) {\n \t\t\t\t\t\t\tgenericConverter.write(body, targetType, selectedMediaType, outputMessage);\n \t\t\t\t\t\t}\n \t\t\t\t\t\telse {\n \t\t\t\t\t\t\t((HttpMessageConverter) converter).write(body, selectedMediaType, outputMessage);\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\t\tlogger.debug(\"Nothing to write: null body\");\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\treturn;\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\tif (body != null) {\n \t\t\tthrow new HttpMediaTypeNotAcceptableException(this.allSupportedMediaTypes);\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"0be8c20fca26357aa61c28dec2f3720f1d7488be": {
			"type": "Ybodychange",
			"commitMessage": "Consistent logging of selected media types\n",
			"commitDate": "2018-07-24, 5:47 PM",
			"commitName": "0be8c20fca26357aa61c28dec2f3720f1d7488be",
			"commitAuthor": "Rossen Stoyanchev",
			"commitDateOld": "2018-07-16, 10:45 AM",
			"commitNameOld": "b915e42c387195ed956fd908602094139148aac3",
			"commitAuthorOld": "Juergen Hoeller",
			"daysBetweenCommits": 8.29,
			"commitsBetweenForRepo": 88,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,131 +1,130 @@\n \tprotected <T> void writeWithMessageConverters(@Nullable T value, MethodParameter returnType,\n \t\t\tServletServerHttpRequest inputMessage, ServletServerHttpResponse outputMessage)\n \t\t\tthrows IOException, HttpMediaTypeNotAcceptableException, HttpMessageNotWritableException {\n \n \t\tObject body;\n \t\tClass<?> valueType;\n \t\tType targetType;\n \n \t\tif (value instanceof CharSequence) {\n \t\t\tbody = value.toString();\n \t\t\tvalueType = String.class;\n \t\t\ttargetType = String.class;\n \t\t}\n \t\telse {\n \t\t\tbody = value;\n \t\t\tvalueType = getReturnValueType(body, returnType);\n \t\t\ttargetType = GenericTypeResolver.resolveType(getGenericType(returnType), returnType.getContainingClass());\n \t\t}\n \n \t\tif (isResourceType(value, returnType)) {\n \t\t\toutputMessage.getHeaders().set(HttpHeaders.ACCEPT_RANGES, \"bytes\");\n \t\t\tif (value != null && inputMessage.getHeaders().getFirst(HttpHeaders.RANGE) != null &&\n \t\t\t\t\toutputMessage.getServletResponse().getStatus() == 200) {\n \t\t\t\tResource resource = (Resource) value;\n \t\t\t\ttry {\n \t\t\t\t\tList<HttpRange> httpRanges = inputMessage.getHeaders().getRange();\n \t\t\t\t\toutputMessage.getServletResponse().setStatus(HttpStatus.PARTIAL_CONTENT.value());\n \t\t\t\t\tbody = HttpRange.toResourceRegions(httpRanges, resource);\n \t\t\t\t\tvalueType = body.getClass();\n \t\t\t\t\ttargetType = RESOURCE_REGION_LIST_TYPE;\n \t\t\t\t}\n \t\t\t\tcatch (IllegalArgumentException ex) {\n \t\t\t\t\toutputMessage.getHeaders().set(HttpHeaders.CONTENT_RANGE, \"bytes */\" + resource.contentLength());\n \t\t\t\t\toutputMessage.getServletResponse().setStatus(HttpStatus.REQUESTED_RANGE_NOT_SATISFIABLE.value());\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n-\n-\t\tList<MediaType> mediaTypesToUse;\n-\n+\t\tMediaType selectedMediaType = null;\n \t\tMediaType contentType = outputMessage.getHeaders().getContentType();\n \t\tif (contentType != null && contentType.isConcrete()) {\n \t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\tlogger.debug(\"Found 'Content-Type:\" + contentType + \"' in response\");\n \t\t\t}\n-\t\t\tmediaTypesToUse = Collections.singletonList(contentType);\n+\t\t\tselectedMediaType = contentType;\n \t\t}\n \t\telse {\n \t\t\tHttpServletRequest request = inputMessage.getServletRequest();\n-\t\t\tList<MediaType> requestedMediaTypes = getAcceptableMediaTypes(request);\n-\t\t\tList<MediaType> producibleMediaTypes = getProducibleMediaTypes(request, valueType, targetType);\n+\t\t\tList<MediaType> acceptableTypes = getAcceptableMediaTypes(request);\n+\t\t\tList<MediaType> producibleTypes = getProducibleMediaTypes(request, valueType, targetType);\n \n-\t\t\tif (body != null && producibleMediaTypes.isEmpty()) {\n+\t\t\tif (body != null && producibleTypes.isEmpty()) {\n \t\t\t\tthrow new HttpMessageNotWritableException(\n \t\t\t\t\t\t\"No converter found for return value of type: \" + valueType);\n \t\t\t}\n-\t\t\tmediaTypesToUse = new ArrayList<>();\n-\t\t\tfor (MediaType requestedType : requestedMediaTypes) {\n-\t\t\t\tfor (MediaType producibleType : producibleMediaTypes) {\n+\t\t\tList<MediaType> mediaTypesToUse = new ArrayList<>();\n+\t\t\tfor (MediaType requestedType : acceptableTypes) {\n+\t\t\t\tfor (MediaType producibleType : producibleTypes) {\n \t\t\t\t\tif (requestedType.isCompatibleWith(producibleType)) {\n \t\t\t\t\t\tmediaTypesToUse.add(getMostSpecificMediaType(requestedType, producibleType));\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n-\t\t\tif (logger.isDebugEnabled()) {\n-\t\t\t\tlogger.debug(\"No match for \" + requestedMediaTypes + \", supported: \" + producibleMediaTypes);\n-\t\t\t}\n \t\t\tif (mediaTypesToUse.isEmpty()) {\n \t\t\t\tif (body != null) {\n-\t\t\t\t\tthrow new HttpMediaTypeNotAcceptableException(producibleMediaTypes);\n+\t\t\t\t\tthrow new HttpMediaTypeNotAcceptableException(producibleTypes);\n+\t\t\t\t}\n+\t\t\t\tif (logger.isDebugEnabled()) {\n+\t\t\t\t\tlogger.debug(\"No match for \" + acceptableTypes + \", supported: \" + producibleTypes);\n \t\t\t\t}\n \t\t\t\treturn;\n \t\t\t}\n+\n \t\t\tMediaType.sortBySpecificityAndQuality(mediaTypesToUse);\n-\t\t}\n \n-\t\tMediaType selectedMediaType = null;\n-\t\tfor (MediaType mediaType : mediaTypesToUse) {\n-\t\t\tif (mediaType.isConcrete()) {\n-\t\t\t\tselectedMediaType = mediaType;\n-\t\t\t\tbreak;\n+\t\t\tfor (MediaType mediaType : mediaTypesToUse) {\n+\t\t\t\tif (mediaType.isConcrete()) {\n+\t\t\t\t\tselectedMediaType = mediaType;\n+\t\t\t\t\tbreak;\n+\t\t\t\t}\n+\t\t\t\telse if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n+\t\t\t\t\tselectedMediaType = MediaType.APPLICATION_OCTET_STREAM;\n+\t\t\t\t\tbreak;\n+\t\t\t\t}\n \t\t\t}\n-\t\t\telse if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n-\t\t\t\tselectedMediaType = MediaType.APPLICATION_OCTET_STREAM;\n-\t\t\t\tbreak;\n-\t\t\t}\n-\t\t}\n \n-\t\tif (logger.isDebugEnabled()) {\n-\t\t\tlogger.debug(\"Using '\" + selectedMediaType + \"' given \" + mediaTypesToUse);\n+\t\t\tif (logger.isDebugEnabled()) {\n+\t\t\t\tlogger.debug(\"Using '\" + selectedMediaType + \"', given \" +\n+\t\t\t\t\t\tacceptableTypes + \" and supported \" + producibleTypes);\n+\t\t\t}\n \t\t}\n \n \t\tif (selectedMediaType != null) {\n \t\t\tselectedMediaType = selectedMediaType.removeQualityValue();\n \t\t\tfor (HttpMessageConverter<?> converter : this.messageConverters) {\n \t\t\t\tGenericHttpMessageConverter genericConverter = (converter instanceof GenericHttpMessageConverter ?\n \t\t\t\t\t\t(GenericHttpMessageConverter<?>) converter : null);\n \t\t\t\tif (genericConverter != null ?\n \t\t\t\t\t\t((GenericHttpMessageConverter) converter).canWrite(targetType, valueType, selectedMediaType) :\n \t\t\t\t\t\tconverter.canWrite(valueType, selectedMediaType)) {\n \t\t\t\t\tbody = getAdvice().beforeBodyWrite(body, returnType, selectedMediaType,\n \t\t\t\t\t\t\t(Class<? extends HttpMessageConverter<?>>) converter.getClass(),\n \t\t\t\t\t\t\tinputMessage, outputMessage);\n \t\t\t\t\tif (body != null) {\n \t\t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\t\tObject formatted = (body instanceof CharSequence ? \"\\\"\" + body + \"\\\"\" : body);\n \t\t\t\t\t\t\tlogger.debug(\"Writing [\" + formatted + \"]\");\n \t\t\t\t\t\t}\n \t\t\t\t\t\taddContentDispositionHeader(inputMessage, outputMessage);\n \t\t\t\t\t\tif (genericConverter != null) {\n \t\t\t\t\t\t\tgenericConverter.write(body, targetType, selectedMediaType, outputMessage);\n \t\t\t\t\t\t}\n \t\t\t\t\t\telse {\n \t\t\t\t\t\t\t((HttpMessageConverter) converter).write(body, selectedMediaType, outputMessage);\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\t\tlogger.debug(\"Nothing to write: null body\");\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\treturn;\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\tif (body != null) {\n \t\t\tthrow new HttpMediaTypeNotAcceptableException(this.allSupportedMediaTypes);\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"b915e42c387195ed956fd908602094139148aac3": {
			"type": "Ybodychange",
			"commitMessage": "Resolve target type for GenericHttpMessageConverter.canWrite/write\n\nIssue: SPR-16877\n",
			"commitDate": "2018-07-16, 10:45 AM",
			"commitName": "b915e42c387195ed956fd908602094139148aac3",
			"commitAuthor": "Juergen Hoeller",
			"commitDateOld": "2018-07-10, 3:11 AM",
			"commitNameOld": "818e4b077640056d6e65ef37be1bec76537fa991",
			"commitAuthorOld": "Brian Clozel",
			"daysBetweenCommits": 6.32,
			"commitsBetweenForRepo": 28,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,131 +1,131 @@\n \tprotected <T> void writeWithMessageConverters(@Nullable T value, MethodParameter returnType,\n \t\t\tServletServerHttpRequest inputMessage, ServletServerHttpResponse outputMessage)\n \t\t\tthrows IOException, HttpMediaTypeNotAcceptableException, HttpMessageNotWritableException {\n \n \t\tObject body;\n \t\tClass<?> valueType;\n-\t\tType declaredType;\n+\t\tType targetType;\n \n \t\tif (value instanceof CharSequence) {\n \t\t\tbody = value.toString();\n \t\t\tvalueType = String.class;\n-\t\t\tdeclaredType = String.class;\n+\t\t\ttargetType = String.class;\n \t\t}\n \t\telse {\n \t\t\tbody = value;\n \t\t\tvalueType = getReturnValueType(body, returnType);\n-\t\t\tdeclaredType = getGenericType(returnType);\n+\t\t\ttargetType = GenericTypeResolver.resolveType(getGenericType(returnType), returnType.getContainingClass());\n \t\t}\n \n \t\tif (isResourceType(value, returnType)) {\n \t\t\toutputMessage.getHeaders().set(HttpHeaders.ACCEPT_RANGES, \"bytes\");\n-\t\t\tif (value != null && inputMessage.getHeaders().getFirst(HttpHeaders.RANGE) != null\n-\t\t\t\t\t&& outputMessage.getServletResponse().getStatus() == 200) {\n+\t\t\tif (value != null && inputMessage.getHeaders().getFirst(HttpHeaders.RANGE) != null &&\n+\t\t\t\t\toutputMessage.getServletResponse().getStatus() == 200) {\n \t\t\t\tResource resource = (Resource) value;\n \t\t\t\ttry {\n \t\t\t\t\tList<HttpRange> httpRanges = inputMessage.getHeaders().getRange();\n \t\t\t\t\toutputMessage.getServletResponse().setStatus(HttpStatus.PARTIAL_CONTENT.value());\n \t\t\t\t\tbody = HttpRange.toResourceRegions(httpRanges, resource);\n \t\t\t\t\tvalueType = body.getClass();\n-\t\t\t\t\tdeclaredType = RESOURCE_REGION_LIST_TYPE;\n+\t\t\t\t\ttargetType = RESOURCE_REGION_LIST_TYPE;\n \t\t\t\t}\n \t\t\t\tcatch (IllegalArgumentException ex) {\n \t\t\t\t\toutputMessage.getHeaders().set(HttpHeaders.CONTENT_RANGE, \"bytes */\" + resource.contentLength());\n \t\t\t\t\toutputMessage.getServletResponse().setStatus(HttpStatus.REQUESTED_RANGE_NOT_SATISFIABLE.value());\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \n \t\tList<MediaType> mediaTypesToUse;\n \n \t\tMediaType contentType = outputMessage.getHeaders().getContentType();\n \t\tif (contentType != null && contentType.isConcrete()) {\n \t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\tlogger.debug(\"Found 'Content-Type:\" + contentType + \"' in response\");\n \t\t\t}\n \t\t\tmediaTypesToUse = Collections.singletonList(contentType);\n \t\t}\n \t\telse {\n \t\t\tHttpServletRequest request = inputMessage.getServletRequest();\n \t\t\tList<MediaType> requestedMediaTypes = getAcceptableMediaTypes(request);\n-\t\t\tList<MediaType> producibleMediaTypes = getProducibleMediaTypes(request, valueType, declaredType);\n+\t\t\tList<MediaType> producibleMediaTypes = getProducibleMediaTypes(request, valueType, targetType);\n \n \t\t\tif (body != null && producibleMediaTypes.isEmpty()) {\n \t\t\t\tthrow new HttpMessageNotWritableException(\n \t\t\t\t\t\t\"No converter found for return value of type: \" + valueType);\n \t\t\t}\n \t\t\tmediaTypesToUse = new ArrayList<>();\n \t\t\tfor (MediaType requestedType : requestedMediaTypes) {\n \t\t\t\tfor (MediaType producibleType : producibleMediaTypes) {\n \t\t\t\t\tif (requestedType.isCompatibleWith(producibleType)) {\n \t\t\t\t\t\tmediaTypesToUse.add(getMostSpecificMediaType(requestedType, producibleType));\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\tlogger.debug(\"No match for \" + requestedMediaTypes + \", supported: \" + producibleMediaTypes);\n \t\t\t}\n \t\t\tif (mediaTypesToUse.isEmpty()) {\n \t\t\t\tif (body != null) {\n \t\t\t\t\tthrow new HttpMediaTypeNotAcceptableException(producibleMediaTypes);\n \t\t\t\t}\n \t\t\t\treturn;\n \t\t\t}\n \t\t\tMediaType.sortBySpecificityAndQuality(mediaTypesToUse);\n \t\t}\n \n \t\tMediaType selectedMediaType = null;\n \t\tfor (MediaType mediaType : mediaTypesToUse) {\n \t\t\tif (mediaType.isConcrete()) {\n \t\t\t\tselectedMediaType = mediaType;\n \t\t\t\tbreak;\n \t\t\t}\n \t\t\telse if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n \t\t\t\tselectedMediaType = MediaType.APPLICATION_OCTET_STREAM;\n \t\t\t\tbreak;\n \t\t\t}\n \t\t}\n \n \t\tif (logger.isDebugEnabled()) {\n \t\t\tlogger.debug(\"Using '\" + selectedMediaType + \"' given \" + mediaTypesToUse);\n \t\t}\n \n \t\tif (selectedMediaType != null) {\n \t\t\tselectedMediaType = selectedMediaType.removeQualityValue();\n \t\t\tfor (HttpMessageConverter<?> converter : this.messageConverters) {\n-\t\t\t\tGenericHttpMessageConverter genericConverter =\n-\t\t\t\t\t\t(converter instanceof GenericHttpMessageConverter ? (GenericHttpMessageConverter<?>) converter : null);\n+\t\t\t\tGenericHttpMessageConverter genericConverter = (converter instanceof GenericHttpMessageConverter ?\n+\t\t\t\t\t\t(GenericHttpMessageConverter<?>) converter : null);\n \t\t\t\tif (genericConverter != null ?\n-\t\t\t\t\t\t((GenericHttpMessageConverter) converter).canWrite(declaredType, valueType, selectedMediaType) :\n+\t\t\t\t\t\t((GenericHttpMessageConverter) converter).canWrite(targetType, valueType, selectedMediaType) :\n \t\t\t\t\t\tconverter.canWrite(valueType, selectedMediaType)) {\n \t\t\t\t\tbody = getAdvice().beforeBodyWrite(body, returnType, selectedMediaType,\n \t\t\t\t\t\t\t(Class<? extends HttpMessageConverter<?>>) converter.getClass(),\n \t\t\t\t\t\t\tinputMessage, outputMessage);\n \t\t\t\t\tif (body != null) {\n \t\t\t\t\t\tif (logger.isDebugEnabled()) {\n-\t\t\t\t\t\t\tObject formatted = body instanceof CharSequence ? \"\\\"\" + body + \"\\\"\" : body;\n+\t\t\t\t\t\t\tObject formatted = (body instanceof CharSequence ? \"\\\"\" + body + \"\\\"\" : body);\n \t\t\t\t\t\t\tlogger.debug(\"Writing [\" + formatted + \"]\");\n \t\t\t\t\t\t}\n \t\t\t\t\t\taddContentDispositionHeader(inputMessage, outputMessage);\n \t\t\t\t\t\tif (genericConverter != null) {\n-\t\t\t\t\t\t\tgenericConverter.write(body, declaredType, selectedMediaType, outputMessage);\n+\t\t\t\t\t\t\tgenericConverter.write(body, targetType, selectedMediaType, outputMessage);\n \t\t\t\t\t\t}\n \t\t\t\t\t\telse {\n \t\t\t\t\t\t\t((HttpMessageConverter) converter).write(body, selectedMediaType, outputMessage);\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\t\tlogger.debug(\"Nothing to write: null body\");\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\treturn;\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\tif (body != null) {\n \t\t\tthrow new HttpMediaTypeNotAcceptableException(this.allSupportedMediaTypes);\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"818e4b077640056d6e65ef37be1bec76537fa991": {
			"type": "Ybodychange",
			"commitMessage": "Refine Content-Range support for Resources\n\nThis commit restricts the support of `\"Content-Range\"` when returning\n`Resource` instances from Controllers - now only \"HTTP 200 OK\" responses\nwill be considered, as Controllers might want to handle content range\nthemselves.\n\nIssue: SPR-16921\n",
			"commitDate": "2018-07-10, 3:11 AM",
			"commitName": "818e4b077640056d6e65ef37be1bec76537fa991",
			"commitAuthor": "Brian Clozel",
			"commitDateOld": "2018-06-28, 1:28 AM",
			"commitNameOld": "e0480f75ac4e0367a053eabd3a07c3fa34eccf61",
			"commitAuthorOld": "Phillip Webb",
			"daysBetweenCommits": 12.07,
			"commitsBetweenForRepo": 116,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,130 +1,131 @@\n \tprotected <T> void writeWithMessageConverters(@Nullable T value, MethodParameter returnType,\n \t\t\tServletServerHttpRequest inputMessage, ServletServerHttpResponse outputMessage)\n \t\t\tthrows IOException, HttpMediaTypeNotAcceptableException, HttpMessageNotWritableException {\n \n \t\tObject body;\n \t\tClass<?> valueType;\n \t\tType declaredType;\n \n \t\tif (value instanceof CharSequence) {\n \t\t\tbody = value.toString();\n \t\t\tvalueType = String.class;\n \t\t\tdeclaredType = String.class;\n \t\t}\n \t\telse {\n \t\t\tbody = value;\n \t\t\tvalueType = getReturnValueType(body, returnType);\n \t\t\tdeclaredType = getGenericType(returnType);\n \t\t}\n \n \t\tif (isResourceType(value, returnType)) {\n \t\t\toutputMessage.getHeaders().set(HttpHeaders.ACCEPT_RANGES, \"bytes\");\n-\t\t\tif (value != null && inputMessage.getHeaders().getFirst(HttpHeaders.RANGE) != null) {\n+\t\t\tif (value != null && inputMessage.getHeaders().getFirst(HttpHeaders.RANGE) != null\n+\t\t\t\t\t&& outputMessage.getServletResponse().getStatus() == 200) {\n \t\t\t\tResource resource = (Resource) value;\n \t\t\t\ttry {\n \t\t\t\t\tList<HttpRange> httpRanges = inputMessage.getHeaders().getRange();\n \t\t\t\t\toutputMessage.getServletResponse().setStatus(HttpStatus.PARTIAL_CONTENT.value());\n \t\t\t\t\tbody = HttpRange.toResourceRegions(httpRanges, resource);\n \t\t\t\t\tvalueType = body.getClass();\n \t\t\t\t\tdeclaredType = RESOURCE_REGION_LIST_TYPE;\n \t\t\t\t}\n \t\t\t\tcatch (IllegalArgumentException ex) {\n \t\t\t\t\toutputMessage.getHeaders().set(HttpHeaders.CONTENT_RANGE, \"bytes */\" + resource.contentLength());\n \t\t\t\t\toutputMessage.getServletResponse().setStatus(HttpStatus.REQUESTED_RANGE_NOT_SATISFIABLE.value());\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \n \t\tList<MediaType> mediaTypesToUse;\n \n \t\tMediaType contentType = outputMessage.getHeaders().getContentType();\n \t\tif (contentType != null && contentType.isConcrete()) {\n \t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\tlogger.debug(\"Found 'Content-Type:\" + contentType + \"' in response\");\n \t\t\t}\n \t\t\tmediaTypesToUse = Collections.singletonList(contentType);\n \t\t}\n \t\telse {\n \t\t\tHttpServletRequest request = inputMessage.getServletRequest();\n \t\t\tList<MediaType> requestedMediaTypes = getAcceptableMediaTypes(request);\n \t\t\tList<MediaType> producibleMediaTypes = getProducibleMediaTypes(request, valueType, declaredType);\n \n \t\t\tif (body != null && producibleMediaTypes.isEmpty()) {\n \t\t\t\tthrow new HttpMessageNotWritableException(\n \t\t\t\t\t\t\"No converter found for return value of type: \" + valueType);\n \t\t\t}\n \t\t\tmediaTypesToUse = new ArrayList<>();\n \t\t\tfor (MediaType requestedType : requestedMediaTypes) {\n \t\t\t\tfor (MediaType producibleType : producibleMediaTypes) {\n \t\t\t\t\tif (requestedType.isCompatibleWith(producibleType)) {\n \t\t\t\t\t\tmediaTypesToUse.add(getMostSpecificMediaType(requestedType, producibleType));\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\tlogger.debug(\"No match for \" + requestedMediaTypes + \", supported: \" + producibleMediaTypes);\n \t\t\t}\n \t\t\tif (mediaTypesToUse.isEmpty()) {\n \t\t\t\tif (body != null) {\n \t\t\t\t\tthrow new HttpMediaTypeNotAcceptableException(producibleMediaTypes);\n \t\t\t\t}\n \t\t\t\treturn;\n \t\t\t}\n \t\t\tMediaType.sortBySpecificityAndQuality(mediaTypesToUse);\n \t\t}\n \n \t\tMediaType selectedMediaType = null;\n \t\tfor (MediaType mediaType : mediaTypesToUse) {\n \t\t\tif (mediaType.isConcrete()) {\n \t\t\t\tselectedMediaType = mediaType;\n \t\t\t\tbreak;\n \t\t\t}\n \t\t\telse if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n \t\t\t\tselectedMediaType = MediaType.APPLICATION_OCTET_STREAM;\n \t\t\t\tbreak;\n \t\t\t}\n \t\t}\n \n \t\tif (logger.isDebugEnabled()) {\n \t\t\tlogger.debug(\"Using '\" + selectedMediaType + \"' given \" + mediaTypesToUse);\n \t\t}\n \n \t\tif (selectedMediaType != null) {\n \t\t\tselectedMediaType = selectedMediaType.removeQualityValue();\n \t\t\tfor (HttpMessageConverter<?> converter : this.messageConverters) {\n \t\t\t\tGenericHttpMessageConverter genericConverter =\n \t\t\t\t\t\t(converter instanceof GenericHttpMessageConverter ? (GenericHttpMessageConverter<?>) converter : null);\n \t\t\t\tif (genericConverter != null ?\n \t\t\t\t\t\t((GenericHttpMessageConverter) converter).canWrite(declaredType, valueType, selectedMediaType) :\n \t\t\t\t\t\tconverter.canWrite(valueType, selectedMediaType)) {\n \t\t\t\t\tbody = getAdvice().beforeBodyWrite(body, returnType, selectedMediaType,\n \t\t\t\t\t\t\t(Class<? extends HttpMessageConverter<?>>) converter.getClass(),\n \t\t\t\t\t\t\tinputMessage, outputMessage);\n \t\t\t\t\tif (body != null) {\n \t\t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\t\tObject formatted = body instanceof CharSequence ? \"\\\"\" + body + \"\\\"\" : body;\n \t\t\t\t\t\t\tlogger.debug(\"Writing [\" + formatted + \"]\");\n \t\t\t\t\t\t}\n \t\t\t\t\t\taddContentDispositionHeader(inputMessage, outputMessage);\n \t\t\t\t\t\tif (genericConverter != null) {\n \t\t\t\t\t\t\tgenericConverter.write(body, declaredType, selectedMediaType, outputMessage);\n \t\t\t\t\t\t}\n \t\t\t\t\t\telse {\n \t\t\t\t\t\t\t((HttpMessageConverter) converter).write(body, selectedMediaType, outputMessage);\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\t\tlogger.debug(\"Nothing to write: null body\");\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\treturn;\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\tif (body != null) {\n \t\t\tthrow new HttpMediaTypeNotAcceptableException(this.allSupportedMediaTypes);\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"900bc8a2e341277296a463c7b5db4abb944e14d7": {
			"type": "Ybodychange",
			"commitMessage": "Logging improvements for WebFlux\n\nIssue: SPR-16898\n",
			"commitDate": "2018-06-22, 7:44 PM",
			"commitName": "900bc8a2e341277296a463c7b5db4abb944e14d7",
			"commitAuthor": "Rossen Stoyanchev",
			"commitDateOld": "2018-06-18, 3:33 PM",
			"commitNameOld": "28a5c3009ea0c31f879c0bb8b9e6cfd33faa81e5",
			"commitAuthorOld": "Rossen Stoyanchev",
			"daysBetweenCommits": 4.17,
			"commitsBetweenForRepo": 8,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,115 +1,130 @@\n \tprotected <T> void writeWithMessageConverters(@Nullable T value, MethodParameter returnType,\n \t\t\tServletServerHttpRequest inputMessage, ServletServerHttpResponse outputMessage)\n \t\t\tthrows IOException, HttpMediaTypeNotAcceptableException, HttpMessageNotWritableException {\n \n \t\tObject body;\n \t\tClass<?> valueType;\n \t\tType declaredType;\n \n \t\tif (value instanceof CharSequence) {\n \t\t\tbody = value.toString();\n \t\t\tvalueType = String.class;\n \t\t\tdeclaredType = String.class;\n \t\t}\n \t\telse {\n \t\t\tbody = value;\n \t\t\tvalueType = getReturnValueType(body, returnType);\n \t\t\tdeclaredType = getGenericType(returnType);\n \t\t}\n \n \t\tif (isResourceType(value, returnType)) {\n \t\t\toutputMessage.getHeaders().set(HttpHeaders.ACCEPT_RANGES, \"bytes\");\n \t\t\tif (value != null && inputMessage.getHeaders().getFirst(HttpHeaders.RANGE) != null) {\n \t\t\t\tResource resource = (Resource) value;\n \t\t\t\ttry {\n \t\t\t\t\tList<HttpRange> httpRanges = inputMessage.getHeaders().getRange();\n \t\t\t\t\toutputMessage.getServletResponse().setStatus(HttpStatus.PARTIAL_CONTENT.value());\n \t\t\t\t\tbody = HttpRange.toResourceRegions(httpRanges, resource);\n \t\t\t\t\tvalueType = body.getClass();\n \t\t\t\t\tdeclaredType = RESOURCE_REGION_LIST_TYPE;\n \t\t\t\t}\n \t\t\t\tcatch (IllegalArgumentException ex) {\n \t\t\t\t\toutputMessage.getHeaders().set(HttpHeaders.CONTENT_RANGE, \"bytes */\" + resource.contentLength());\n \t\t\t\t\toutputMessage.getServletResponse().setStatus(HttpStatus.REQUESTED_RANGE_NOT_SATISFIABLE.value());\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \n \t\tList<MediaType> mediaTypesToUse;\n \n \t\tMediaType contentType = outputMessage.getHeaders().getContentType();\n \t\tif (contentType != null && contentType.isConcrete()) {\n+\t\t\tif (logger.isDebugEnabled()) {\n+\t\t\t\tlogger.debug(\"Found 'Content-Type:\" + contentType + \"' in response\");\n+\t\t\t}\n \t\t\tmediaTypesToUse = Collections.singletonList(contentType);\n \t\t}\n \t\telse {\n \t\t\tHttpServletRequest request = inputMessage.getServletRequest();\n \t\t\tList<MediaType> requestedMediaTypes = getAcceptableMediaTypes(request);\n \t\t\tList<MediaType> producibleMediaTypes = getProducibleMediaTypes(request, valueType, declaredType);\n \n \t\t\tif (body != null && producibleMediaTypes.isEmpty()) {\n \t\t\t\tthrow new HttpMessageNotWritableException(\n \t\t\t\t\t\t\"No converter found for return value of type: \" + valueType);\n \t\t\t}\n \t\t\tmediaTypesToUse = new ArrayList<>();\n \t\t\tfor (MediaType requestedType : requestedMediaTypes) {\n \t\t\t\tfor (MediaType producibleType : producibleMediaTypes) {\n \t\t\t\t\tif (requestedType.isCompatibleWith(producibleType)) {\n \t\t\t\t\t\tmediaTypesToUse.add(getMostSpecificMediaType(requestedType, producibleType));\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n+\t\t\tif (logger.isDebugEnabled()) {\n+\t\t\t\tlogger.debug(\"No match for \" + requestedMediaTypes + \", supported: \" + producibleMediaTypes);\n+\t\t\t}\n \t\t\tif (mediaTypesToUse.isEmpty()) {\n \t\t\t\tif (body != null) {\n \t\t\t\t\tthrow new HttpMediaTypeNotAcceptableException(producibleMediaTypes);\n \t\t\t\t}\n \t\t\t\treturn;\n \t\t\t}\n \t\t\tMediaType.sortBySpecificityAndQuality(mediaTypesToUse);\n \t\t}\n \n \t\tMediaType selectedMediaType = null;\n \t\tfor (MediaType mediaType : mediaTypesToUse) {\n \t\t\tif (mediaType.isConcrete()) {\n \t\t\t\tselectedMediaType = mediaType;\n \t\t\t\tbreak;\n \t\t\t}\n \t\t\telse if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n \t\t\t\tselectedMediaType = MediaType.APPLICATION_OCTET_STREAM;\n \t\t\t\tbreak;\n \t\t\t}\n \t\t}\n \n+\t\tif (logger.isDebugEnabled()) {\n+\t\t\tlogger.debug(\"Using '\" + selectedMediaType + \"' given \" + mediaTypesToUse);\n+\t\t}\n+\n \t\tif (selectedMediaType != null) {\n \t\t\tselectedMediaType = selectedMediaType.removeQualityValue();\n \t\t\tfor (HttpMessageConverter<?> converter : this.messageConverters) {\n \t\t\t\tGenericHttpMessageConverter genericConverter =\n \t\t\t\t\t\t(converter instanceof GenericHttpMessageConverter ? (GenericHttpMessageConverter<?>) converter : null);\n \t\t\t\tif (genericConverter != null ?\n \t\t\t\t\t\t((GenericHttpMessageConverter) converter).canWrite(declaredType, valueType, selectedMediaType) :\n \t\t\t\t\t\tconverter.canWrite(valueType, selectedMediaType)) {\n \t\t\t\t\tbody = getAdvice().beforeBodyWrite(body, returnType, selectedMediaType,\n \t\t\t\t\t\t\t(Class<? extends HttpMessageConverter<?>>) converter.getClass(),\n \t\t\t\t\t\t\tinputMessage, outputMessage);\n \t\t\t\t\tif (body != null) {\n+\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n+\t\t\t\t\t\t\tObject formatted = body instanceof CharSequence ? \"\\\"\" + body + \"\\\"\" : body;\n+\t\t\t\t\t\t\tlogger.debug(\"Writing [\" + formatted + \"]\");\n+\t\t\t\t\t\t}\n \t\t\t\t\t\taddContentDispositionHeader(inputMessage, outputMessage);\n \t\t\t\t\t\tif (genericConverter != null) {\n \t\t\t\t\t\t\tgenericConverter.write(body, declaredType, selectedMediaType, outputMessage);\n \t\t\t\t\t\t}\n \t\t\t\t\t\telse {\n \t\t\t\t\t\t\t((HttpMessageConverter) converter).write(body, selectedMediaType, outputMessage);\n \t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t\telse {\n \t\t\t\t\t\tif (logger.isDebugEnabled()) {\n-\t\t\t\t\t\t\tlogger.debug(\"Written \\\"\" + selectedMediaType + \"\\\" from \" +\n-\t\t\t\t\t\t\t\t\t\"[\" + (body instanceof CharSequence ? \"\\\"\" + body + \"\\\"\" : body) + \"]\");\n+\t\t\t\t\t\t\tlogger.debug(\"Nothing to write: null body\");\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\treturn;\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\tif (body != null) {\n \t\t\tthrow new HttpMediaTypeNotAcceptableException(this.allSupportedMediaTypes);\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"28a5c3009ea0c31f879c0bb8b9e6cfd33faa81e5": {
			"type": "Ybodychange",
			"commitMessage": "Improve DEBUG/TRACE logging for Spring MVC\n\nIssue: SPR-16898\n",
			"commitDate": "2018-06-18, 3:33 PM",
			"commitName": "28a5c3009ea0c31f879c0bb8b9e6cfd33faa81e5",
			"commitAuthor": "Rossen Stoyanchev",
			"commitDateOld": "2018-04-23, 9:39 AM",
			"commitNameOld": "e9a8a5065bf30826bc0209b6e4db472348e51ce0",
			"commitAuthorOld": "Brian Clozel",
			"daysBetweenCommits": 56.25,
			"commitsBetweenForRepo": 239,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,115 +1,115 @@\n \tprotected <T> void writeWithMessageConverters(@Nullable T value, MethodParameter returnType,\n \t\t\tServletServerHttpRequest inputMessage, ServletServerHttpResponse outputMessage)\n \t\t\tthrows IOException, HttpMediaTypeNotAcceptableException, HttpMessageNotWritableException {\n \n-\t\tObject outputValue;\n+\t\tObject body;\n \t\tClass<?> valueType;\n \t\tType declaredType;\n \n \t\tif (value instanceof CharSequence) {\n-\t\t\toutputValue = value.toString();\n+\t\t\tbody = value.toString();\n \t\t\tvalueType = String.class;\n \t\t\tdeclaredType = String.class;\n \t\t}\n \t\telse {\n-\t\t\toutputValue = value;\n-\t\t\tvalueType = getReturnValueType(outputValue, returnType);\n+\t\t\tbody = value;\n+\t\t\tvalueType = getReturnValueType(body, returnType);\n \t\t\tdeclaredType = getGenericType(returnType);\n \t\t}\n \n \t\tif (isResourceType(value, returnType)) {\n \t\t\toutputMessage.getHeaders().set(HttpHeaders.ACCEPT_RANGES, \"bytes\");\n \t\t\tif (value != null && inputMessage.getHeaders().getFirst(HttpHeaders.RANGE) != null) {\n \t\t\t\tResource resource = (Resource) value;\n \t\t\t\ttry {\n \t\t\t\t\tList<HttpRange> httpRanges = inputMessage.getHeaders().getRange();\n \t\t\t\t\toutputMessage.getServletResponse().setStatus(HttpStatus.PARTIAL_CONTENT.value());\n-\t\t\t\t\toutputValue = HttpRange.toResourceRegions(httpRanges, resource);\n-\t\t\t\t\tvalueType = outputValue.getClass();\n+\t\t\t\t\tbody = HttpRange.toResourceRegions(httpRanges, resource);\n+\t\t\t\t\tvalueType = body.getClass();\n \t\t\t\t\tdeclaredType = RESOURCE_REGION_LIST_TYPE;\n \t\t\t\t}\n \t\t\t\tcatch (IllegalArgumentException ex) {\n \t\t\t\t\toutputMessage.getHeaders().set(HttpHeaders.CONTENT_RANGE, \"bytes */\" + resource.contentLength());\n \t\t\t\t\toutputMessage.getServletResponse().setStatus(HttpStatus.REQUESTED_RANGE_NOT_SATISFIABLE.value());\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \n \t\tList<MediaType> mediaTypesToUse;\n \n \t\tMediaType contentType = outputMessage.getHeaders().getContentType();\n \t\tif (contentType != null && contentType.isConcrete()) {\n \t\t\tmediaTypesToUse = Collections.singletonList(contentType);\n \t\t}\n \t\telse {\n \t\t\tHttpServletRequest request = inputMessage.getServletRequest();\n \t\t\tList<MediaType> requestedMediaTypes = getAcceptableMediaTypes(request);\n \t\t\tList<MediaType> producibleMediaTypes = getProducibleMediaTypes(request, valueType, declaredType);\n \n-\t\t\tif (outputValue != null && producibleMediaTypes.isEmpty()) {\n+\t\t\tif (body != null && producibleMediaTypes.isEmpty()) {\n \t\t\t\tthrow new HttpMessageNotWritableException(\n \t\t\t\t\t\t\"No converter found for return value of type: \" + valueType);\n \t\t\t}\n \t\t\tmediaTypesToUse = new ArrayList<>();\n \t\t\tfor (MediaType requestedType : requestedMediaTypes) {\n \t\t\t\tfor (MediaType producibleType : producibleMediaTypes) {\n \t\t\t\t\tif (requestedType.isCompatibleWith(producibleType)) {\n \t\t\t\t\t\tmediaTypesToUse.add(getMostSpecificMediaType(requestedType, producibleType));\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (mediaTypesToUse.isEmpty()) {\n-\t\t\t\tif (outputValue != null) {\n+\t\t\t\tif (body != null) {\n \t\t\t\t\tthrow new HttpMediaTypeNotAcceptableException(producibleMediaTypes);\n \t\t\t\t}\n \t\t\t\treturn;\n \t\t\t}\n \t\t\tMediaType.sortBySpecificityAndQuality(mediaTypesToUse);\n \t\t}\n \n \t\tMediaType selectedMediaType = null;\n \t\tfor (MediaType mediaType : mediaTypesToUse) {\n \t\t\tif (mediaType.isConcrete()) {\n \t\t\t\tselectedMediaType = mediaType;\n \t\t\t\tbreak;\n \t\t\t}\n \t\t\telse if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n \t\t\t\tselectedMediaType = MediaType.APPLICATION_OCTET_STREAM;\n \t\t\t\tbreak;\n \t\t\t}\n \t\t}\n \n \t\tif (selectedMediaType != null) {\n \t\t\tselectedMediaType = selectedMediaType.removeQualityValue();\n \t\t\tfor (HttpMessageConverter<?> converter : this.messageConverters) {\n \t\t\t\tGenericHttpMessageConverter genericConverter =\n \t\t\t\t\t\t(converter instanceof GenericHttpMessageConverter ? (GenericHttpMessageConverter<?>) converter : null);\n \t\t\t\tif (genericConverter != null ?\n \t\t\t\t\t\t((GenericHttpMessageConverter) converter).canWrite(declaredType, valueType, selectedMediaType) :\n \t\t\t\t\t\tconverter.canWrite(valueType, selectedMediaType)) {\n-\t\t\t\t\toutputValue = getAdvice().beforeBodyWrite(outputValue, returnType, selectedMediaType,\n+\t\t\t\t\tbody = getAdvice().beforeBodyWrite(body, returnType, selectedMediaType,\n \t\t\t\t\t\t\t(Class<? extends HttpMessageConverter<?>>) converter.getClass(),\n \t\t\t\t\t\t\tinputMessage, outputMessage);\n-\t\t\t\t\tif (outputValue != null) {\n+\t\t\t\t\tif (body != null) {\n \t\t\t\t\t\taddContentDispositionHeader(inputMessage, outputMessage);\n \t\t\t\t\t\tif (genericConverter != null) {\n-\t\t\t\t\t\t\tgenericConverter.write(outputValue, declaredType, selectedMediaType, outputMessage);\n+\t\t\t\t\t\t\tgenericConverter.write(body, declaredType, selectedMediaType, outputMessage);\n \t\t\t\t\t\t}\n \t\t\t\t\t\telse {\n-\t\t\t\t\t\t\t((HttpMessageConverter) converter).write(outputValue, selectedMediaType, outputMessage);\n+\t\t\t\t\t\t\t((HttpMessageConverter) converter).write(body, selectedMediaType, outputMessage);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tif (logger.isDebugEnabled()) {\n-\t\t\t\t\t\t\tlogger.debug(\"Written [\" + outputValue + \"] as \\\"\" + selectedMediaType +\n-\t\t\t\t\t\t\t\t\t\"\\\" using [\" + converter + \"]\");\n+\t\t\t\t\t\t\tlogger.debug(\"Written \\\"\" + selectedMediaType + \"\\\" from \" +\n+\t\t\t\t\t\t\t\t\t\"[\" + (body instanceof CharSequence ? \"\\\"\" + body + \"\\\"\" : body) + \"]\");\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\treturn;\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n-\t\tif (outputValue != null) {\n+\t\tif (body != null) {\n \t\t\tthrow new HttpMediaTypeNotAcceptableException(this.allSupportedMediaTypes);\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"aba882af4c4f7d2ec6e0b859dbffc1bcf65e000c": {
			"type": "Ybodychange",
			"commitMessage": "Clean up warnings in spring-webmvc\n",
			"commitDate": "2018-04-04, 5:04 AM",
			"commitName": "aba882af4c4f7d2ec6e0b859dbffc1bcf65e000c",
			"commitAuthor": "Sam Brannen",
			"commitDateOld": "2018-03-27, 1:54 PM",
			"commitNameOld": "f3994467c4e1094f5229d05c5679550f956cba8e",
			"commitAuthorOld": "Rossen Stoyanchev",
			"daysBetweenCommits": 7.63,
			"commitsBetweenForRepo": 74,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,115 +1,115 @@\n \tprotected <T> void writeWithMessageConverters(@Nullable T value, MethodParameter returnType,\n \t\t\tServletServerHttpRequest inputMessage, ServletServerHttpResponse outputMessage)\n \t\t\tthrows IOException, HttpMediaTypeNotAcceptableException, HttpMessageNotWritableException {\n \n \t\tObject outputValue;\n \t\tClass<?> valueType;\n \t\tType declaredType;\n \n \t\tif (value instanceof CharSequence) {\n \t\t\toutputValue = value.toString();\n \t\t\tvalueType = String.class;\n \t\t\tdeclaredType = String.class;\n \t\t}\n \t\telse {\n \t\t\toutputValue = value;\n \t\t\tvalueType = getReturnValueType(outputValue, returnType);\n \t\t\tdeclaredType = getGenericType(returnType);\n \t\t}\n-\t\t\n+\n \t\tif (isResourceType(value, returnType)) {\n \t\t\toutputMessage.getHeaders().set(HttpHeaders.ACCEPT_RANGES, \"bytes\");\n \t\t\tif (value != null && inputMessage.getHeaders().getFirst(HttpHeaders.RANGE) != null) {\n \t\t\t\tResource resource = (Resource) value;\n \t\t\t\ttry {\n \t\t\t\t\tList<HttpRange> httpRanges = inputMessage.getHeaders().getRange();\n \t\t\t\t\toutputMessage.getServletResponse().setStatus(HttpStatus.PARTIAL_CONTENT.value());\n \t\t\t\t\toutputValue = HttpRange.toResourceRegions(httpRanges, resource);\n \t\t\t\t\tvalueType = outputValue.getClass();\n \t\t\t\t\tdeclaredType = RESOURCE_REGION_LIST_TYPE;\n \t\t\t\t}\n \t\t\t\tcatch (IllegalArgumentException ex) {\n \t\t\t\t\toutputMessage.getHeaders().set(HttpHeaders.CONTENT_RANGE, \"bytes */\" + resource.contentLength());\n \t\t\t\t\toutputMessage.getServletResponse().setStatus(HttpStatus.REQUESTED_RANGE_NOT_SATISFIABLE.value());\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \n \t\tList<MediaType> mediaTypesToUse;\n \n \t\tMediaType contentType = outputMessage.getHeaders().getContentType();\n \t\tif (contentType != null && contentType.isConcrete()) {\n \t\t\tmediaTypesToUse = Collections.singletonList(contentType);\n \t\t}\n \t\telse {\n \t\t\tHttpServletRequest request = inputMessage.getServletRequest();\n \t\t\tList<MediaType> requestedMediaTypes = getAcceptableMediaTypes(request);\n \t\t\tList<MediaType> producibleMediaTypes = getProducibleMediaTypes(request, valueType, declaredType);\n \n \t\t\tif (outputValue != null && producibleMediaTypes.isEmpty()) {\n \t\t\t\tthrow new HttpMessageNotWritableException(\n \t\t\t\t\t\t\"No converter found for return value of type: \" + valueType);\n \t\t\t}\n \t\t\tmediaTypesToUse = new ArrayList<>();\n \t\t\tfor (MediaType requestedType : requestedMediaTypes) {\n \t\t\t\tfor (MediaType producibleType : producibleMediaTypes) {\n \t\t\t\t\tif (requestedType.isCompatibleWith(producibleType)) {\n \t\t\t\t\t\tmediaTypesToUse.add(getMostSpecificMediaType(requestedType, producibleType));\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (mediaTypesToUse.isEmpty()) {\n \t\t\t\tif (outputValue != null) {\n \t\t\t\t\tthrow new HttpMediaTypeNotAcceptableException(producibleMediaTypes);\n \t\t\t\t}\n \t\t\t\treturn;\n \t\t\t}\n \t\t\tMediaType.sortBySpecificityAndQuality(mediaTypesToUse);\n \t\t}\n \n \t\tMediaType selectedMediaType = null;\n \t\tfor (MediaType mediaType : mediaTypesToUse) {\n \t\t\tif (mediaType.isConcrete()) {\n \t\t\t\tselectedMediaType = mediaType;\n \t\t\t\tbreak;\n \t\t\t}\n \t\t\telse if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n \t\t\t\tselectedMediaType = MediaType.APPLICATION_OCTET_STREAM;\n \t\t\t\tbreak;\n \t\t\t}\n \t\t}\n \n \t\tif (selectedMediaType != null) {\n \t\t\tselectedMediaType = selectedMediaType.removeQualityValue();\n \t\t\tfor (HttpMessageConverter<?> converter : this.messageConverters) {\n \t\t\t\tGenericHttpMessageConverter genericConverter =\n \t\t\t\t\t\t(converter instanceof GenericHttpMessageConverter ? (GenericHttpMessageConverter<?>) converter : null);\n \t\t\t\tif (genericConverter != null ?\n \t\t\t\t\t\t((GenericHttpMessageConverter) converter).canWrite(declaredType, valueType, selectedMediaType) :\n \t\t\t\t\t\tconverter.canWrite(valueType, selectedMediaType)) {\n-\t\t\t\t\toutputValue = (T) getAdvice().beforeBodyWrite(outputValue, returnType, selectedMediaType,\n+\t\t\t\t\toutputValue = getAdvice().beforeBodyWrite(outputValue, returnType, selectedMediaType,\n \t\t\t\t\t\t\t(Class<? extends HttpMessageConverter<?>>) converter.getClass(),\n \t\t\t\t\t\t\tinputMessage, outputMessage);\n \t\t\t\t\tif (outputValue != null) {\n \t\t\t\t\t\taddContentDispositionHeader(inputMessage, outputMessage);\n \t\t\t\t\t\tif (genericConverter != null) {\n \t\t\t\t\t\t\tgenericConverter.write(outputValue, declaredType, selectedMediaType, outputMessage);\n \t\t\t\t\t\t}\n \t\t\t\t\t\telse {\n \t\t\t\t\t\t\t((HttpMessageConverter) converter).write(outputValue, selectedMediaType, outputMessage);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\t\tlogger.debug(\"Written [\" + outputValue + \"] as \\\"\" + selectedMediaType +\n \t\t\t\t\t\t\t\t\t\"\\\" using [\" + converter + \"]\");\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\treturn;\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\tif (outputValue != null) {\n \t\t\tthrow new HttpMediaTypeNotAcceptableException(this.allSupportedMediaTypes);\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"fda08852ba9f5d52c149209382c0d03380de413c": {
			"type": "Ybodychange",
			"commitMessage": "Take content-type from ResponseEntity unconditionally\n\nFrom #9a894a we began using the content-type from the ResponseEntity\nbut cross-checking it still against the requested content type.\n\nArguably there isn't any purpose in cross-checking. The only possible\noutcomes are: a) it's compatible or b) it's not, which would result in\n406 (NOT_ACCEPTABLE). As we've been given explicitly the media type to\nuse, it makes little sense to send 406, ignoring the wish to use that\ncontent type.\n\nIssue: SPR-16251\n",
			"commitDate": "2017-12-01, 9:43 PM",
			"commitName": "fda08852ba9f5d52c149209382c0d03380de413c",
			"commitAuthor": "Rossen Stoyanchev",
			"commitDateOld": "2017-11-10, 12:05 PM",
			"commitNameOld": "9a894ab61e4613af176029761b75d7ad2a733440",
			"commitAuthorOld": "Rossen Stoyanchev",
			"daysBetweenCommits": 21.4,
			"commitsBetweenForRepo": 96,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,111 +1,115 @@\n \tprotected <T> void writeWithMessageConverters(@Nullable T value, MethodParameter returnType,\n \t\t\tServletServerHttpRequest inputMessage, ServletServerHttpResponse outputMessage)\n \t\t\tthrows IOException, HttpMediaTypeNotAcceptableException, HttpMessageNotWritableException {\n \n \t\tObject outputValue;\n \t\tClass<?> valueType;\n \t\tType declaredType;\n \n \t\tif (value instanceof CharSequence) {\n \t\t\toutputValue = value.toString();\n \t\t\tvalueType = String.class;\n \t\t\tdeclaredType = String.class;\n \t\t}\n \t\telse {\n \t\t\toutputValue = value;\n \t\t\tvalueType = getReturnValueType(outputValue, returnType);\n \t\t\tdeclaredType = getGenericType(returnType);\n \t\t}\n \t\t\n \t\tif (isResourceType(value, returnType)) {\n \t\t\toutputMessage.getHeaders().set(HttpHeaders.ACCEPT_RANGES, \"bytes\");\n \t\t\tif (value != null && inputMessage.getHeaders().getFirst(HttpHeaders.RANGE) != null) {\n \t\t\t\tResource resource = (Resource) value;\n \t\t\t\ttry {\n \t\t\t\t\tList<HttpRange> httpRanges = inputMessage.getHeaders().getRange();\n \t\t\t\t\toutputMessage.getServletResponse().setStatus(HttpStatus.PARTIAL_CONTENT.value());\n \t\t\t\t\toutputValue = HttpRange.toResourceRegions(httpRanges, resource);\n \t\t\t\t\tvalueType = outputValue.getClass();\n \t\t\t\t\tdeclaredType = RESOURCE_REGION_LIST_TYPE;\n \t\t\t\t}\n \t\t\t\tcatch (IllegalArgumentException ex) {\n \t\t\t\t\toutputMessage.getHeaders().set(HttpHeaders.CONTENT_RANGE, \"bytes */\" + resource.contentLength());\n \t\t\t\t\toutputMessage.getServletResponse().setStatus(HttpStatus.REQUESTED_RANGE_NOT_SATISFIABLE.value());\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n-\t\tHttpServletRequest request = inputMessage.getServletRequest();\n-\t\tList<MediaType> requestedMediaTypes = getAcceptableMediaTypes(request);\n+\n+\t\tList<MediaType> mediaTypesToUse;\n \n \t\tMediaType contentType = outputMessage.getHeaders().getContentType();\n-\t\tList<MediaType> producibleMediaTypes = (contentType != null && contentType.isConcrete() ?\n-\t\t\t\tCollections.singletonList(contentType) : getProducibleMediaTypes(request, valueType, declaredType));\n-\n-\t\tif (outputValue != null && producibleMediaTypes.isEmpty()) {\n-\t\t\tthrow new HttpMessageNotWritableException(\"No converter found for return value of type: \" + valueType);\n+\t\tif (contentType != null && contentType.isConcrete()) {\n+\t\t\tmediaTypesToUse = Collections.singletonList(contentType);\n \t\t}\n+\t\telse {\n+\t\t\tHttpServletRequest request = inputMessage.getServletRequest();\n+\t\t\tList<MediaType> requestedMediaTypes = getAcceptableMediaTypes(request);\n+\t\t\tList<MediaType> producibleMediaTypes = getProducibleMediaTypes(request, valueType, declaredType);\n \n-\t\tSet<MediaType> compatibleMediaTypes = new LinkedHashSet<>();\n-\t\tfor (MediaType requestedType : requestedMediaTypes) {\n-\t\t\tfor (MediaType producibleType : producibleMediaTypes) {\n-\t\t\t\tif (requestedType.isCompatibleWith(producibleType)) {\n-\t\t\t\t\tcompatibleMediaTypes.add(getMostSpecificMediaType(requestedType, producibleType));\n+\t\t\tif (outputValue != null && producibleMediaTypes.isEmpty()) {\n+\t\t\t\tthrow new HttpMessageNotWritableException(\n+\t\t\t\t\t\t\"No converter found for return value of type: \" + valueType);\n+\t\t\t}\n+\t\t\tmediaTypesToUse = new ArrayList<>();\n+\t\t\tfor (MediaType requestedType : requestedMediaTypes) {\n+\t\t\t\tfor (MediaType producibleType : producibleMediaTypes) {\n+\t\t\t\t\tif (requestedType.isCompatibleWith(producibleType)) {\n+\t\t\t\t\t\tmediaTypesToUse.add(getMostSpecificMediaType(requestedType, producibleType));\n+\t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n-\t\t}\n-\t\tif (compatibleMediaTypes.isEmpty()) {\n-\t\t\tif (outputValue != null) {\n-\t\t\t\tthrow new HttpMediaTypeNotAcceptableException(producibleMediaTypes);\n+\t\t\tif (mediaTypesToUse.isEmpty()) {\n+\t\t\t\tif (outputValue != null) {\n+\t\t\t\t\tthrow new HttpMediaTypeNotAcceptableException(producibleMediaTypes);\n+\t\t\t\t}\n+\t\t\t\treturn;\n \t\t\t}\n-\t\t\treturn;\n+\t\t\tMediaType.sortBySpecificityAndQuality(mediaTypesToUse);\n \t\t}\n \n-\t\tList<MediaType> mediaTypes = new ArrayList<>(compatibleMediaTypes);\n-\t\tMediaType.sortBySpecificityAndQuality(mediaTypes);\n-\n \t\tMediaType selectedMediaType = null;\n-\t\tfor (MediaType mediaType : mediaTypes) {\n+\t\tfor (MediaType mediaType : mediaTypesToUse) {\n \t\t\tif (mediaType.isConcrete()) {\n \t\t\t\tselectedMediaType = mediaType;\n \t\t\t\tbreak;\n \t\t\t}\n \t\t\telse if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n \t\t\t\tselectedMediaType = MediaType.APPLICATION_OCTET_STREAM;\n \t\t\t\tbreak;\n \t\t\t}\n \t\t}\n \n \t\tif (selectedMediaType != null) {\n \t\t\tselectedMediaType = selectedMediaType.removeQualityValue();\n \t\t\tfor (HttpMessageConverter<?> converter : this.messageConverters) {\n \t\t\t\tGenericHttpMessageConverter genericConverter =\n \t\t\t\t\t\t(converter instanceof GenericHttpMessageConverter ? (GenericHttpMessageConverter<?>) converter : null);\n \t\t\t\tif (genericConverter != null ?\n \t\t\t\t\t\t((GenericHttpMessageConverter) converter).canWrite(declaredType, valueType, selectedMediaType) :\n \t\t\t\t\t\tconverter.canWrite(valueType, selectedMediaType)) {\n \t\t\t\t\toutputValue = (T) getAdvice().beforeBodyWrite(outputValue, returnType, selectedMediaType,\n \t\t\t\t\t\t\t(Class<? extends HttpMessageConverter<?>>) converter.getClass(),\n \t\t\t\t\t\t\tinputMessage, outputMessage);\n \t\t\t\t\tif (outputValue != null) {\n \t\t\t\t\t\taddContentDispositionHeader(inputMessage, outputMessage);\n \t\t\t\t\t\tif (genericConverter != null) {\n \t\t\t\t\t\t\tgenericConverter.write(outputValue, declaredType, selectedMediaType, outputMessage);\n \t\t\t\t\t\t}\n \t\t\t\t\t\telse {\n \t\t\t\t\t\t\t((HttpMessageConverter) converter).write(outputValue, selectedMediaType, outputMessage);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\t\tlogger.debug(\"Written [\" + outputValue + \"] as \\\"\" + selectedMediaType +\n \t\t\t\t\t\t\t\t\t\"\\\" using [\" + converter + \"]\");\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\treturn;\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\tif (outputValue != null) {\n \t\t\tthrow new HttpMediaTypeNotAcceptableException(this.allSupportedMediaTypes);\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"9a894ab61e4613af176029761b75d7ad2a733440": {
			"type": "Ybodychange",
			"commitMessage": "Use ResponseEntity Content-Type as producible media type\n\nIssue: SPR-16172\n",
			"commitDate": "2017-11-10, 12:05 PM",
			"commitName": "9a894ab61e4613af176029761b75d7ad2a733440",
			"commitAuthor": "Rossen Stoyanchev",
			"commitDateOld": "2017-10-20, 1:42 PM",
			"commitNameOld": "1cc5afe24b592a50ab68c090e438138ab180374a",
			"commitAuthorOld": "Rossen Stoyanchev",
			"daysBetweenCommits": 20.97,
			"commitsBetweenForRepo": 123,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,108 +1,111 @@\n \tprotected <T> void writeWithMessageConverters(@Nullable T value, MethodParameter returnType,\n \t\t\tServletServerHttpRequest inputMessage, ServletServerHttpResponse outputMessage)\n \t\t\tthrows IOException, HttpMediaTypeNotAcceptableException, HttpMessageNotWritableException {\n \n \t\tObject outputValue;\n \t\tClass<?> valueType;\n \t\tType declaredType;\n \n \t\tif (value instanceof CharSequence) {\n \t\t\toutputValue = value.toString();\n \t\t\tvalueType = String.class;\n \t\t\tdeclaredType = String.class;\n \t\t}\n \t\telse {\n \t\t\toutputValue = value;\n \t\t\tvalueType = getReturnValueType(outputValue, returnType);\n \t\t\tdeclaredType = getGenericType(returnType);\n \t\t}\n \t\t\n \t\tif (isResourceType(value, returnType)) {\n \t\t\toutputMessage.getHeaders().set(HttpHeaders.ACCEPT_RANGES, \"bytes\");\n \t\t\tif (value != null && inputMessage.getHeaders().getFirst(HttpHeaders.RANGE) != null) {\n \t\t\t\tResource resource = (Resource) value;\n \t\t\t\ttry {\n \t\t\t\t\tList<HttpRange> httpRanges = inputMessage.getHeaders().getRange();\n \t\t\t\t\toutputMessage.getServletResponse().setStatus(HttpStatus.PARTIAL_CONTENT.value());\n \t\t\t\t\toutputValue = HttpRange.toResourceRegions(httpRanges, resource);\n \t\t\t\t\tvalueType = outputValue.getClass();\n \t\t\t\t\tdeclaredType = RESOURCE_REGION_LIST_TYPE;\n \t\t\t\t}\n \t\t\t\tcatch (IllegalArgumentException ex) {\n \t\t\t\t\toutputMessage.getHeaders().set(HttpHeaders.CONTENT_RANGE, \"bytes */\" + resource.contentLength());\n \t\t\t\t\toutputMessage.getServletResponse().setStatus(HttpStatus.REQUESTED_RANGE_NOT_SATISFIABLE.value());\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\tHttpServletRequest request = inputMessage.getServletRequest();\n \t\tList<MediaType> requestedMediaTypes = getAcceptableMediaTypes(request);\n-\t\tList<MediaType> producibleMediaTypes = getProducibleMediaTypes(request, valueType, declaredType);\n+\n+\t\tMediaType contentType = outputMessage.getHeaders().getContentType();\n+\t\tList<MediaType> producibleMediaTypes = (contentType != null && contentType.isConcrete() ?\n+\t\t\t\tCollections.singletonList(contentType) : getProducibleMediaTypes(request, valueType, declaredType));\n \n \t\tif (outputValue != null && producibleMediaTypes.isEmpty()) {\n \t\t\tthrow new HttpMessageNotWritableException(\"No converter found for return value of type: \" + valueType);\n \t\t}\n \n \t\tSet<MediaType> compatibleMediaTypes = new LinkedHashSet<>();\n \t\tfor (MediaType requestedType : requestedMediaTypes) {\n \t\t\tfor (MediaType producibleType : producibleMediaTypes) {\n \t\t\t\tif (requestedType.isCompatibleWith(producibleType)) {\n \t\t\t\t\tcompatibleMediaTypes.add(getMostSpecificMediaType(requestedType, producibleType));\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\tif (compatibleMediaTypes.isEmpty()) {\n \t\t\tif (outputValue != null) {\n \t\t\t\tthrow new HttpMediaTypeNotAcceptableException(producibleMediaTypes);\n \t\t\t}\n \t\t\treturn;\n \t\t}\n \n \t\tList<MediaType> mediaTypes = new ArrayList<>(compatibleMediaTypes);\n \t\tMediaType.sortBySpecificityAndQuality(mediaTypes);\n \n \t\tMediaType selectedMediaType = null;\n \t\tfor (MediaType mediaType : mediaTypes) {\n \t\t\tif (mediaType.isConcrete()) {\n \t\t\t\tselectedMediaType = mediaType;\n \t\t\t\tbreak;\n \t\t\t}\n \t\t\telse if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n \t\t\t\tselectedMediaType = MediaType.APPLICATION_OCTET_STREAM;\n \t\t\t\tbreak;\n \t\t\t}\n \t\t}\n \n \t\tif (selectedMediaType != null) {\n \t\t\tselectedMediaType = selectedMediaType.removeQualityValue();\n \t\t\tfor (HttpMessageConverter<?> converter : this.messageConverters) {\n \t\t\t\tGenericHttpMessageConverter genericConverter =\n \t\t\t\t\t\t(converter instanceof GenericHttpMessageConverter ? (GenericHttpMessageConverter<?>) converter : null);\n \t\t\t\tif (genericConverter != null ?\n \t\t\t\t\t\t((GenericHttpMessageConverter) converter).canWrite(declaredType, valueType, selectedMediaType) :\n \t\t\t\t\t\tconverter.canWrite(valueType, selectedMediaType)) {\n \t\t\t\t\toutputValue = (T) getAdvice().beforeBodyWrite(outputValue, returnType, selectedMediaType,\n \t\t\t\t\t\t\t(Class<? extends HttpMessageConverter<?>>) converter.getClass(),\n \t\t\t\t\t\t\tinputMessage, outputMessage);\n \t\t\t\t\tif (outputValue != null) {\n \t\t\t\t\t\taddContentDispositionHeader(inputMessage, outputMessage);\n \t\t\t\t\t\tif (genericConverter != null) {\n \t\t\t\t\t\t\tgenericConverter.write(outputValue, declaredType, selectedMediaType, outputMessage);\n \t\t\t\t\t\t}\n \t\t\t\t\t\telse {\n \t\t\t\t\t\t\t((HttpMessageConverter) converter).write(outputValue, selectedMediaType, outputMessage);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\t\tlogger.debug(\"Written [\" + outputValue + \"] as \\\"\" + selectedMediaType +\n \t\t\t\t\t\t\t\t\t\"\\\" using [\" + converter + \"]\");\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\treturn;\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\tif (outputValue != null) {\n \t\t\tthrow new HttpMediaTypeNotAcceptableException(this.allSupportedMediaTypes);\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"582014e944002609b562f6e4998935c06bbe6922": {
			"type": "Ybodychange",
			"commitMessage": "Support HTTP range requests in MVC Controllers\n\nPrior to this commit, HTTP Range requests were only supported by the\nResourceHttpRequestHandler when serving static resources.\n\nThis commit improves the `HttpEntityMethodProcessor` and\nthe `RequestResponseBodyMethodProcessor`. They now extract\n`ResourceRegion`s from the `Resource` instance returned by the\nController and let the Resource-related message converters\nhandle the writing of the resource (including partial writes).\n\nController methods can now handle Range requests for\nreturn types that extend Resource or HttpEntity:\n\n    @RequestMapping(\"/example/video.mp4\")\n    public Resource handler() { }\n\n    @RequestMapping(\"/example/video.mp4\")\n    public HttpEntity<Resource> handler() { }\n\nIssue: SPR-15789, SPR-13834\n",
			"commitDate": "2017-08-24, 11:50 AM",
			"commitName": "582014e944002609b562f6e4998935c06bbe6922",
			"commitAuthor": "Brian Clozel",
			"commitDateOld": "2017-06-13, 2:37 AM",
			"commitNameOld": "7dd8dc62a5fa08e3cc99d2388ff62f5825151fb9",
			"commitAuthorOld": "Juergen Hoeller",
			"daysBetweenCommits": 72.38,
			"commitsBetweenForRepo": 359,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,90 +1,108 @@\n \tprotected <T> void writeWithMessageConverters(@Nullable T value, MethodParameter returnType,\n \t\t\tServletServerHttpRequest inputMessage, ServletServerHttpResponse outputMessage)\n \t\t\tthrows IOException, HttpMediaTypeNotAcceptableException, HttpMessageNotWritableException {\n \n \t\tObject outputValue;\n \t\tClass<?> valueType;\n \t\tType declaredType;\n \n \t\tif (value instanceof CharSequence) {\n \t\t\toutputValue = value.toString();\n \t\t\tvalueType = String.class;\n \t\t\tdeclaredType = String.class;\n \t\t}\n \t\telse {\n \t\t\toutputValue = value;\n \t\t\tvalueType = getReturnValueType(outputValue, returnType);\n \t\t\tdeclaredType = getGenericType(returnType);\n \t\t}\n+\t\t\n+\t\tif (isResourceType(value, returnType)) {\n+\t\t\toutputMessage.getHeaders().set(HttpHeaders.ACCEPT_RANGES, \"bytes\");\n+\t\t\tif (value != null && inputMessage.getHeaders().getFirst(HttpHeaders.RANGE) != null) {\n+\t\t\t\tResource resource = (Resource) value;\n+\t\t\t\ttry {\n+\t\t\t\t\tList<HttpRange> httpRanges = inputMessage.getHeaders().getRange();\n+\t\t\t\t\toutputMessage.getServletResponse().setStatus(HttpStatus.PARTIAL_CONTENT.value());\n+\t\t\t\t\toutputValue = HttpRange.toResourceRegions(httpRanges, resource);\n+\t\t\t\t\tvalueType = outputValue.getClass();\n+\t\t\t\t\tdeclaredType = RESOURCE_REGION_LIST_TYPE;\n+\t\t\t\t}\n+\t\t\t\tcatch (IllegalArgumentException ex) {\n+\t\t\t\t\toutputMessage.getHeaders().set(HttpHeaders.CONTENT_RANGE, \"bytes */\" + resource.contentLength());\n+\t\t\t\t\toutputMessage.getServletResponse().setStatus(HttpStatus.REQUESTED_RANGE_NOT_SATISFIABLE.value());\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n \t\tHttpServletRequest request = inputMessage.getServletRequest();\n \t\tList<MediaType> requestedMediaTypes = getAcceptableMediaTypes(request);\n \t\tList<MediaType> producibleMediaTypes = getProducibleMediaTypes(request, valueType, declaredType);\n \n \t\tif (outputValue != null && producibleMediaTypes.isEmpty()) {\n \t\t\tthrow new HttpMessageNotWritableException(\"No converter found for return value of type: \" + valueType);\n \t\t}\n \n \t\tSet<MediaType> compatibleMediaTypes = new LinkedHashSet<>();\n \t\tfor (MediaType requestedType : requestedMediaTypes) {\n \t\t\tfor (MediaType producibleType : producibleMediaTypes) {\n \t\t\t\tif (requestedType.isCompatibleWith(producibleType)) {\n \t\t\t\t\tcompatibleMediaTypes.add(getMostSpecificMediaType(requestedType, producibleType));\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\tif (compatibleMediaTypes.isEmpty()) {\n \t\t\tif (outputValue != null) {\n \t\t\t\tthrow new HttpMediaTypeNotAcceptableException(producibleMediaTypes);\n \t\t\t}\n \t\t\treturn;\n \t\t}\n \n \t\tList<MediaType> mediaTypes = new ArrayList<>(compatibleMediaTypes);\n \t\tMediaType.sortBySpecificityAndQuality(mediaTypes);\n \n \t\tMediaType selectedMediaType = null;\n \t\tfor (MediaType mediaType : mediaTypes) {\n \t\t\tif (mediaType.isConcrete()) {\n \t\t\t\tselectedMediaType = mediaType;\n \t\t\t\tbreak;\n \t\t\t}\n \t\t\telse if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n \t\t\t\tselectedMediaType = MediaType.APPLICATION_OCTET_STREAM;\n \t\t\t\tbreak;\n \t\t\t}\n \t\t}\n \n \t\tif (selectedMediaType != null) {\n \t\t\tselectedMediaType = selectedMediaType.removeQualityValue();\n \t\t\tfor (HttpMessageConverter<?> converter : this.messageConverters) {\n \t\t\t\tGenericHttpMessageConverter genericConverter =\n \t\t\t\t\t\t(converter instanceof GenericHttpMessageConverter ? (GenericHttpMessageConverter<?>) converter : null);\n \t\t\t\tif (genericConverter != null ?\n \t\t\t\t\t\t((GenericHttpMessageConverter) converter).canWrite(declaredType, valueType, selectedMediaType) :\n \t\t\t\t\t\tconverter.canWrite(valueType, selectedMediaType)) {\n \t\t\t\t\toutputValue = (T) getAdvice().beforeBodyWrite(outputValue, returnType, selectedMediaType,\n \t\t\t\t\t\t\t(Class<? extends HttpMessageConverter<?>>) converter.getClass(),\n \t\t\t\t\t\t\tinputMessage, outputMessage);\n \t\t\t\t\tif (outputValue != null) {\n \t\t\t\t\t\taddContentDispositionHeader(inputMessage, outputMessage);\n \t\t\t\t\t\tif (genericConverter != null) {\n \t\t\t\t\t\t\tgenericConverter.write(outputValue, declaredType, selectedMediaType, outputMessage);\n \t\t\t\t\t\t}\n \t\t\t\t\t\telse {\n \t\t\t\t\t\t\t((HttpMessageConverter) converter).write(outputValue, selectedMediaType, outputMessage);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\t\tlogger.debug(\"Written [\" + outputValue + \"] as \\\"\" + selectedMediaType +\n \t\t\t\t\t\t\t\t\t\"\\\" using [\" + converter + \"]\");\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\treturn;\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\tif (outputValue != null) {\n \t\t\tthrow new HttpMediaTypeNotAcceptableException(this.allSupportedMediaTypes);\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"7dd8dc62a5fa08e3cc99d2388ff62f5825151fb9": {
			"type": "Ybodychange",
			"commitMessage": "Fixes for ignored tests after last week's nullability commit\n\nIssue: SPR-15540\n",
			"commitDate": "2017-06-13, 2:37 AM",
			"commitName": "7dd8dc62a5fa08e3cc99d2388ff62f5825151fb9",
			"commitAuthor": "Juergen Hoeller",
			"commitDateOld": "2017-06-08, 1:52 PM",
			"commitNameOld": "fd53d2a51a4de263ac18d2f698abeab7afabce75",
			"commitAuthorOld": "Juergen Hoeller",
			"daysBetweenCommits": 4.53,
			"commitsBetweenForRepo": 39,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,99 +1,90 @@\n \tprotected <T> void writeWithMessageConverters(@Nullable T value, MethodParameter returnType,\n \t\t\tServletServerHttpRequest inputMessage, ServletServerHttpResponse outputMessage)\n \t\t\tthrows IOException, HttpMediaTypeNotAcceptableException, HttpMessageNotWritableException {\n \n \t\tObject outputValue;\n \t\tClass<?> valueType;\n \t\tType declaredType;\n \n \t\tif (value instanceof CharSequence) {\n \t\t\toutputValue = value.toString();\n \t\t\tvalueType = String.class;\n \t\t\tdeclaredType = String.class;\n \t\t}\n \t\telse {\n \t\t\toutputValue = value;\n \t\t\tvalueType = getReturnValueType(outputValue, returnType);\n \t\t\tdeclaredType = getGenericType(returnType);\n \t\t}\n \n \t\tHttpServletRequest request = inputMessage.getServletRequest();\n \t\tList<MediaType> requestedMediaTypes = getAcceptableMediaTypes(request);\n \t\tList<MediaType> producibleMediaTypes = getProducibleMediaTypes(request, valueType, declaredType);\n \n \t\tif (outputValue != null && producibleMediaTypes.isEmpty()) {\n \t\t\tthrow new HttpMessageNotWritableException(\"No converter found for return value of type: \" + valueType);\n \t\t}\n \n \t\tSet<MediaType> compatibleMediaTypes = new LinkedHashSet<>();\n \t\tfor (MediaType requestedType : requestedMediaTypes) {\n \t\t\tfor (MediaType producibleType : producibleMediaTypes) {\n \t\t\t\tif (requestedType.isCompatibleWith(producibleType)) {\n \t\t\t\t\tcompatibleMediaTypes.add(getMostSpecificMediaType(requestedType, producibleType));\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\tif (compatibleMediaTypes.isEmpty()) {\n \t\t\tif (outputValue != null) {\n \t\t\t\tthrow new HttpMediaTypeNotAcceptableException(producibleMediaTypes);\n \t\t\t}\n \t\t\treturn;\n \t\t}\n \n \t\tList<MediaType> mediaTypes = new ArrayList<>(compatibleMediaTypes);\n \t\tMediaType.sortBySpecificityAndQuality(mediaTypes);\n \n \t\tMediaType selectedMediaType = null;\n \t\tfor (MediaType mediaType : mediaTypes) {\n \t\t\tif (mediaType.isConcrete()) {\n \t\t\t\tselectedMediaType = mediaType;\n \t\t\t\tbreak;\n \t\t\t}\n \t\t\telse if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n \t\t\t\tselectedMediaType = MediaType.APPLICATION_OCTET_STREAM;\n \t\t\t\tbreak;\n \t\t\t}\n \t\t}\n \n \t\tif (selectedMediaType != null) {\n \t\t\tselectedMediaType = selectedMediaType.removeQualityValue();\n-\t\t\tfor (HttpMessageConverter<?> messageConverter : this.messageConverters) {\n-\t\t\t\tif (messageConverter instanceof GenericHttpMessageConverter) {\n-\t\t\t\t\tif (((GenericHttpMessageConverter) messageConverter).canWrite(\n-\t\t\t\t\t\t\tdeclaredType, valueType, selectedMediaType)) {\n-\t\t\t\t\t\toutputValue = (T) getAdvice().beforeBodyWrite(outputValue, returnType, selectedMediaType,\n-\t\t\t\t\t\t\t\t(Class<? extends HttpMessageConverter<?>>) messageConverter.getClass(),\n-\t\t\t\t\t\t\t\tinputMessage, outputMessage);\n-\t\t\t\t\t\tif (outputValue != null) {\n-\t\t\t\t\t\t\taddContentDispositionHeader(inputMessage, outputMessage);\n-\t\t\t\t\t\t\t((GenericHttpMessageConverter) messageConverter).write(\n-\t\t\t\t\t\t\t\t\toutputValue, declaredType, selectedMediaType, outputMessage);\n-\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n-\t\t\t\t\t\t\t\tlogger.debug(\"Written [\" + outputValue + \"] as \\\"\" + selectedMediaType +\n-\t\t\t\t\t\t\t\t\t\t\"\\\" using [\" + messageConverter + \"]\");\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t}\n-\t\t\t\t\t\treturn;\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t\telse if (messageConverter.canWrite(valueType, selectedMediaType)) {\n+\t\t\tfor (HttpMessageConverter<?> converter : this.messageConverters) {\n+\t\t\t\tGenericHttpMessageConverter genericConverter =\n+\t\t\t\t\t\t(converter instanceof GenericHttpMessageConverter ? (GenericHttpMessageConverter<?>) converter : null);\n+\t\t\t\tif (genericConverter != null ?\n+\t\t\t\t\t\t((GenericHttpMessageConverter) converter).canWrite(declaredType, valueType, selectedMediaType) :\n+\t\t\t\t\t\tconverter.canWrite(valueType, selectedMediaType)) {\n \t\t\t\t\toutputValue = (T) getAdvice().beforeBodyWrite(outputValue, returnType, selectedMediaType,\n-\t\t\t\t\t\t\t(Class<? extends HttpMessageConverter<?>>) messageConverter.getClass(),\n+\t\t\t\t\t\t\t(Class<? extends HttpMessageConverter<?>>) converter.getClass(),\n \t\t\t\t\t\t\tinputMessage, outputMessage);\n \t\t\t\t\tif (outputValue != null) {\n \t\t\t\t\t\taddContentDispositionHeader(inputMessage, outputMessage);\n-\t\t\t\t\t\t((HttpMessageConverter) messageConverter).write(outputValue, selectedMediaType, outputMessage);\n+\t\t\t\t\t\tif (genericConverter != null) {\n+\t\t\t\t\t\t\tgenericConverter.write(outputValue, declaredType, selectedMediaType, outputMessage);\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\telse {\n+\t\t\t\t\t\t\t((HttpMessageConverter) converter).write(outputValue, selectedMediaType, outputMessage);\n+\t\t\t\t\t\t}\n \t\t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\t\tlogger.debug(\"Written [\" + outputValue + \"] as \\\"\" + selectedMediaType +\n-\t\t\t\t\t\t\t\t\t\"\\\" using [\" + messageConverter + \"]\");\n+\t\t\t\t\t\t\t\t\t\"\\\" using [\" + converter + \"]\");\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\treturn;\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\tif (outputValue != null) {\n \t\t\tthrow new HttpMediaTypeNotAcceptableException(this.allSupportedMediaTypes);\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"f813712f5b413b354560cd7cc006352e9defa9a3": {
			"type": "Ymultichange(Ybodychange,Yparametermetachange)",
			"commitMessage": "Consistent use of @Nullable across the codebase (even for internals)\n\nBeyond just formally declaring the current behavior, this revision actually enforces non-null behavior in selected signatures now, not tolerating null values anymore when not explicitly documented. It also changes some utility methods with historic null-in/null-out tolerance towards enforced non-null return values, making them a proper citizen in non-null assignments.\n\nSome issues are left as to-do: in particular a thorough revision of spring-test, and a few tests with unclear failures (ignored as \"TODO: NULLABLE\") to be sorted out in a follow-up commit.\n\nIssue: SPR-15540\n",
			"commitDate": "2017-06-07, 5:19 AM",
			"commitName": "f813712f5b413b354560cd7cc006352e9defa9a3",
			"commitAuthor": "Juergen Hoeller",
			"subchanges": [
				{
					"type": "Ybodychange",
					"commitMessage": "Consistent use of @Nullable across the codebase (even for internals)\n\nBeyond just formally declaring the current behavior, this revision actually enforces non-null behavior in selected signatures now, not tolerating null values anymore when not explicitly documented. It also changes some utility methods with historic null-in/null-out tolerance towards enforced non-null return values, making them a proper citizen in non-null assignments.\n\nSome issues are left as to-do: in particular a thorough revision of spring-test, and a few tests with unclear failures (ignored as \"TODO: NULLABLE\") to be sorted out in a follow-up commit.\n\nIssue: SPR-15540\n",
					"commitDate": "2017-06-07, 5:19 AM",
					"commitName": "f813712f5b413b354560cd7cc006352e9defa9a3",
					"commitAuthor": "Juergen Hoeller",
					"commitDateOld": "2017-05-31, 12:42 PM",
					"commitNameOld": "1f28825f9da63a13aaf8940aadedcf81358dc506",
					"commitAuthorOld": "Sebastien Deleuze",
					"daysBetweenCommits": 6.69,
					"commitsBetweenForRepo": 26,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,99 +1,99 @@\n-\tprotected <T> void writeWithMessageConverters(T value, MethodParameter returnType,\n+\tprotected <T> void writeWithMessageConverters(@Nullable T value, MethodParameter returnType,\n \t\t\tServletServerHttpRequest inputMessage, ServletServerHttpResponse outputMessage)\n \t\t\tthrows IOException, HttpMediaTypeNotAcceptableException, HttpMessageNotWritableException {\n \n \t\tObject outputValue;\n \t\tClass<?> valueType;\n \t\tType declaredType;\n \n \t\tif (value instanceof CharSequence) {\n \t\t\toutputValue = value.toString();\n \t\t\tvalueType = String.class;\n \t\t\tdeclaredType = String.class;\n \t\t}\n \t\telse {\n \t\t\toutputValue = value;\n \t\t\tvalueType = getReturnValueType(outputValue, returnType);\n \t\t\tdeclaredType = getGenericType(returnType);\n \t\t}\n \n \t\tHttpServletRequest request = inputMessage.getServletRequest();\n \t\tList<MediaType> requestedMediaTypes = getAcceptableMediaTypes(request);\n \t\tList<MediaType> producibleMediaTypes = getProducibleMediaTypes(request, valueType, declaredType);\n \n \t\tif (outputValue != null && producibleMediaTypes.isEmpty()) {\n-\t\t\tthrow new IllegalArgumentException(\"No converter found for return value of type: \" + valueType);\n+\t\t\tthrow new HttpMessageNotWritableException(\"No converter found for return value of type: \" + valueType);\n \t\t}\n \n \t\tSet<MediaType> compatibleMediaTypes = new LinkedHashSet<>();\n \t\tfor (MediaType requestedType : requestedMediaTypes) {\n \t\t\tfor (MediaType producibleType : producibleMediaTypes) {\n \t\t\t\tif (requestedType.isCompatibleWith(producibleType)) {\n \t\t\t\t\tcompatibleMediaTypes.add(getMostSpecificMediaType(requestedType, producibleType));\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\tif (compatibleMediaTypes.isEmpty()) {\n \t\t\tif (outputValue != null) {\n \t\t\t\tthrow new HttpMediaTypeNotAcceptableException(producibleMediaTypes);\n \t\t\t}\n \t\t\treturn;\n \t\t}\n \n \t\tList<MediaType> mediaTypes = new ArrayList<>(compatibleMediaTypes);\n \t\tMediaType.sortBySpecificityAndQuality(mediaTypes);\n \n \t\tMediaType selectedMediaType = null;\n \t\tfor (MediaType mediaType : mediaTypes) {\n \t\t\tif (mediaType.isConcrete()) {\n \t\t\t\tselectedMediaType = mediaType;\n \t\t\t\tbreak;\n \t\t\t}\n \t\t\telse if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n \t\t\t\tselectedMediaType = MediaType.APPLICATION_OCTET_STREAM;\n \t\t\t\tbreak;\n \t\t\t}\n \t\t}\n \n \t\tif (selectedMediaType != null) {\n \t\t\tselectedMediaType = selectedMediaType.removeQualityValue();\n \t\t\tfor (HttpMessageConverter<?> messageConverter : this.messageConverters) {\n \t\t\t\tif (messageConverter instanceof GenericHttpMessageConverter) {\n \t\t\t\t\tif (((GenericHttpMessageConverter) messageConverter).canWrite(\n \t\t\t\t\t\t\tdeclaredType, valueType, selectedMediaType)) {\n \t\t\t\t\t\toutputValue = (T) getAdvice().beforeBodyWrite(outputValue, returnType, selectedMediaType,\n \t\t\t\t\t\t\t\t(Class<? extends HttpMessageConverter<?>>) messageConverter.getClass(),\n \t\t\t\t\t\t\t\tinputMessage, outputMessage);\n \t\t\t\t\t\tif (outputValue != null) {\n \t\t\t\t\t\t\taddContentDispositionHeader(inputMessage, outputMessage);\n \t\t\t\t\t\t\t((GenericHttpMessageConverter) messageConverter).write(\n \t\t\t\t\t\t\t\t\toutputValue, declaredType, selectedMediaType, outputMessage);\n \t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\t\t\tlogger.debug(\"Written [\" + outputValue + \"] as \\\"\" + selectedMediaType +\n \t\t\t\t\t\t\t\t\t\t\"\\\" using [\" + messageConverter + \"]\");\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t\treturn;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\telse if (messageConverter.canWrite(valueType, selectedMediaType)) {\n \t\t\t\t\toutputValue = (T) getAdvice().beforeBodyWrite(outputValue, returnType, selectedMediaType,\n \t\t\t\t\t\t\t(Class<? extends HttpMessageConverter<?>>) messageConverter.getClass(),\n \t\t\t\t\t\t\tinputMessage, outputMessage);\n \t\t\t\t\tif (outputValue != null) {\n \t\t\t\t\t\taddContentDispositionHeader(inputMessage, outputMessage);\n \t\t\t\t\t\t((HttpMessageConverter) messageConverter).write(outputValue, selectedMediaType, outputMessage);\n \t\t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\t\tlogger.debug(\"Written [\" + outputValue + \"] as \\\"\" + selectedMediaType +\n \t\t\t\t\t\t\t\t\t\"\\\" using [\" + messageConverter + \"]\");\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\treturn;\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\tif (outputValue != null) {\n \t\t\tthrow new HttpMediaTypeNotAcceptableException(this.allSupportedMediaTypes);\n \t\t}\n \t}\n\\ No newline at end of file\n",
					"extendedDetails": {}
				},
				{
					"type": "Yparametermetachange",
					"commitMessage": "Consistent use of @Nullable across the codebase (even for internals)\n\nBeyond just formally declaring the current behavior, this revision actually enforces non-null behavior in selected signatures now, not tolerating null values anymore when not explicitly documented. It also changes some utility methods with historic null-in/null-out tolerance towards enforced non-null return values, making them a proper citizen in non-null assignments.\n\nSome issues are left as to-do: in particular a thorough revision of spring-test, and a few tests with unclear failures (ignored as \"TODO: NULLABLE\") to be sorted out in a follow-up commit.\n\nIssue: SPR-15540\n",
					"commitDate": "2017-06-07, 5:19 AM",
					"commitName": "f813712f5b413b354560cd7cc006352e9defa9a3",
					"commitAuthor": "Juergen Hoeller",
					"commitDateOld": "2017-05-31, 12:42 PM",
					"commitNameOld": "1f28825f9da63a13aaf8940aadedcf81358dc506",
					"commitAuthorOld": "Sebastien Deleuze",
					"daysBetweenCommits": 6.69,
					"commitsBetweenForRepo": 26,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,99 +1,99 @@\n-\tprotected <T> void writeWithMessageConverters(T value, MethodParameter returnType,\n+\tprotected <T> void writeWithMessageConverters(@Nullable T value, MethodParameter returnType,\n \t\t\tServletServerHttpRequest inputMessage, ServletServerHttpResponse outputMessage)\n \t\t\tthrows IOException, HttpMediaTypeNotAcceptableException, HttpMessageNotWritableException {\n \n \t\tObject outputValue;\n \t\tClass<?> valueType;\n \t\tType declaredType;\n \n \t\tif (value instanceof CharSequence) {\n \t\t\toutputValue = value.toString();\n \t\t\tvalueType = String.class;\n \t\t\tdeclaredType = String.class;\n \t\t}\n \t\telse {\n \t\t\toutputValue = value;\n \t\t\tvalueType = getReturnValueType(outputValue, returnType);\n \t\t\tdeclaredType = getGenericType(returnType);\n \t\t}\n \n \t\tHttpServletRequest request = inputMessage.getServletRequest();\n \t\tList<MediaType> requestedMediaTypes = getAcceptableMediaTypes(request);\n \t\tList<MediaType> producibleMediaTypes = getProducibleMediaTypes(request, valueType, declaredType);\n \n \t\tif (outputValue != null && producibleMediaTypes.isEmpty()) {\n-\t\t\tthrow new IllegalArgumentException(\"No converter found for return value of type: \" + valueType);\n+\t\t\tthrow new HttpMessageNotWritableException(\"No converter found for return value of type: \" + valueType);\n \t\t}\n \n \t\tSet<MediaType> compatibleMediaTypes = new LinkedHashSet<>();\n \t\tfor (MediaType requestedType : requestedMediaTypes) {\n \t\t\tfor (MediaType producibleType : producibleMediaTypes) {\n \t\t\t\tif (requestedType.isCompatibleWith(producibleType)) {\n \t\t\t\t\tcompatibleMediaTypes.add(getMostSpecificMediaType(requestedType, producibleType));\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\tif (compatibleMediaTypes.isEmpty()) {\n \t\t\tif (outputValue != null) {\n \t\t\t\tthrow new HttpMediaTypeNotAcceptableException(producibleMediaTypes);\n \t\t\t}\n \t\t\treturn;\n \t\t}\n \n \t\tList<MediaType> mediaTypes = new ArrayList<>(compatibleMediaTypes);\n \t\tMediaType.sortBySpecificityAndQuality(mediaTypes);\n \n \t\tMediaType selectedMediaType = null;\n \t\tfor (MediaType mediaType : mediaTypes) {\n \t\t\tif (mediaType.isConcrete()) {\n \t\t\t\tselectedMediaType = mediaType;\n \t\t\t\tbreak;\n \t\t\t}\n \t\t\telse if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n \t\t\t\tselectedMediaType = MediaType.APPLICATION_OCTET_STREAM;\n \t\t\t\tbreak;\n \t\t\t}\n \t\t}\n \n \t\tif (selectedMediaType != null) {\n \t\t\tselectedMediaType = selectedMediaType.removeQualityValue();\n \t\t\tfor (HttpMessageConverter<?> messageConverter : this.messageConverters) {\n \t\t\t\tif (messageConverter instanceof GenericHttpMessageConverter) {\n \t\t\t\t\tif (((GenericHttpMessageConverter) messageConverter).canWrite(\n \t\t\t\t\t\t\tdeclaredType, valueType, selectedMediaType)) {\n \t\t\t\t\t\toutputValue = (T) getAdvice().beforeBodyWrite(outputValue, returnType, selectedMediaType,\n \t\t\t\t\t\t\t\t(Class<? extends HttpMessageConverter<?>>) messageConverter.getClass(),\n \t\t\t\t\t\t\t\tinputMessage, outputMessage);\n \t\t\t\t\t\tif (outputValue != null) {\n \t\t\t\t\t\t\taddContentDispositionHeader(inputMessage, outputMessage);\n \t\t\t\t\t\t\t((GenericHttpMessageConverter) messageConverter).write(\n \t\t\t\t\t\t\t\t\toutputValue, declaredType, selectedMediaType, outputMessage);\n \t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\t\t\tlogger.debug(\"Written [\" + outputValue + \"] as \\\"\" + selectedMediaType +\n \t\t\t\t\t\t\t\t\t\t\"\\\" using [\" + messageConverter + \"]\");\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t\treturn;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\telse if (messageConverter.canWrite(valueType, selectedMediaType)) {\n \t\t\t\t\toutputValue = (T) getAdvice().beforeBodyWrite(outputValue, returnType, selectedMediaType,\n \t\t\t\t\t\t\t(Class<? extends HttpMessageConverter<?>>) messageConverter.getClass(),\n \t\t\t\t\t\t\tinputMessage, outputMessage);\n \t\t\t\t\tif (outputValue != null) {\n \t\t\t\t\t\taddContentDispositionHeader(inputMessage, outputMessage);\n \t\t\t\t\t\t((HttpMessageConverter) messageConverter).write(outputValue, selectedMediaType, outputMessage);\n \t\t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\t\tlogger.debug(\"Written [\" + outputValue + \"] as \\\"\" + selectedMediaType +\n \t\t\t\t\t\t\t\t\t\"\\\" using [\" + messageConverter + \"]\");\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\treturn;\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\tif (outputValue != null) {\n \t\t\tthrow new HttpMediaTypeNotAcceptableException(this.allSupportedMediaTypes);\n \t\t}\n \t}\n\\ No newline at end of file\n",
					"extendedDetails": {
						"oldValue": "[value-T, returnType-MethodParameter, inputMessage-ServletServerHttpRequest, outputMessage-ServletServerHttpResponse]",
						"newValue": "[value-T(annotations-@Nullable), returnType-MethodParameter, inputMessage-ServletServerHttpRequest, outputMessage-ServletServerHttpResponse]"
					}
				}
			]
		},
		"00d2606b000f9bdafbd7f4a16b6599fb51b53fa4": {
			"type": "Ybodychange",
			"commitMessage": "Explicit type can be replaced by <>\n\nIssue: SPR-13188\n",
			"commitDate": "2016-07-05, 8:00 AM",
			"commitName": "00d2606b000f9bdafbd7f4a16b6599fb51b53fa4",
			"commitAuthor": "Stephane Nicoll",
			"commitDateOld": "2016-07-02, 5:48 AM",
			"commitNameOld": "b204437cef0976f5af0e1c5290e77e266b306a51",
			"commitAuthorOld": "Juergen Hoeller",
			"daysBetweenCommits": 3.09,
			"commitsBetweenForRepo": 36,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,99 +1,99 @@\n \tprotected <T> void writeWithMessageConverters(T value, MethodParameter returnType,\n \t\t\tServletServerHttpRequest inputMessage, ServletServerHttpResponse outputMessage)\n \t\t\tthrows IOException, HttpMediaTypeNotAcceptableException, HttpMessageNotWritableException {\n \n \t\tObject outputValue;\n \t\tClass<?> valueType;\n \t\tType declaredType;\n \n \t\tif (value instanceof CharSequence) {\n \t\t\toutputValue = value.toString();\n \t\t\tvalueType = String.class;\n \t\t\tdeclaredType = String.class;\n \t\t}\n \t\telse {\n \t\t\toutputValue = value;\n \t\t\tvalueType = getReturnValueType(outputValue, returnType);\n \t\t\tdeclaredType = getGenericType(returnType);\n \t\t}\n \n \t\tHttpServletRequest request = inputMessage.getServletRequest();\n \t\tList<MediaType> requestedMediaTypes = getAcceptableMediaTypes(request);\n \t\tList<MediaType> producibleMediaTypes = getProducibleMediaTypes(request, valueType, declaredType);\n \n \t\tif (outputValue != null && producibleMediaTypes.isEmpty()) {\n \t\t\tthrow new IllegalArgumentException(\"No converter found for return value of type: \" + valueType);\n \t\t}\n \n-\t\tSet<MediaType> compatibleMediaTypes = new LinkedHashSet<MediaType>();\n+\t\tSet<MediaType> compatibleMediaTypes = new LinkedHashSet<>();\n \t\tfor (MediaType requestedType : requestedMediaTypes) {\n \t\t\tfor (MediaType producibleType : producibleMediaTypes) {\n \t\t\t\tif (requestedType.isCompatibleWith(producibleType)) {\n \t\t\t\t\tcompatibleMediaTypes.add(getMostSpecificMediaType(requestedType, producibleType));\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\tif (compatibleMediaTypes.isEmpty()) {\n \t\t\tif (outputValue != null) {\n \t\t\t\tthrow new HttpMediaTypeNotAcceptableException(producibleMediaTypes);\n \t\t\t}\n \t\t\treturn;\n \t\t}\n \n-\t\tList<MediaType> mediaTypes = new ArrayList<MediaType>(compatibleMediaTypes);\n+\t\tList<MediaType> mediaTypes = new ArrayList<>(compatibleMediaTypes);\n \t\tMediaType.sortBySpecificityAndQuality(mediaTypes);\n \n \t\tMediaType selectedMediaType = null;\n \t\tfor (MediaType mediaType : mediaTypes) {\n \t\t\tif (mediaType.isConcrete()) {\n \t\t\t\tselectedMediaType = mediaType;\n \t\t\t\tbreak;\n \t\t\t}\n \t\t\telse if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n \t\t\t\tselectedMediaType = MediaType.APPLICATION_OCTET_STREAM;\n \t\t\t\tbreak;\n \t\t\t}\n \t\t}\n \n \t\tif (selectedMediaType != null) {\n \t\t\tselectedMediaType = selectedMediaType.removeQualityValue();\n \t\t\tfor (HttpMessageConverter<?> messageConverter : this.messageConverters) {\n \t\t\t\tif (messageConverter instanceof GenericHttpMessageConverter) {\n \t\t\t\t\tif (((GenericHttpMessageConverter) messageConverter).canWrite(\n \t\t\t\t\t\t\tdeclaredType, valueType, selectedMediaType)) {\n \t\t\t\t\t\toutputValue = (T) getAdvice().beforeBodyWrite(outputValue, returnType, selectedMediaType,\n \t\t\t\t\t\t\t\t(Class<? extends HttpMessageConverter<?>>) messageConverter.getClass(),\n \t\t\t\t\t\t\t\tinputMessage, outputMessage);\n \t\t\t\t\t\tif (outputValue != null) {\n \t\t\t\t\t\t\taddContentDispositionHeader(inputMessage, outputMessage);\n \t\t\t\t\t\t\t((GenericHttpMessageConverter) messageConverter).write(\n \t\t\t\t\t\t\t\t\toutputValue, declaredType, selectedMediaType, outputMessage);\n \t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\t\t\tlogger.debug(\"Written [\" + outputValue + \"] as \\\"\" + selectedMediaType +\n \t\t\t\t\t\t\t\t\t\t\"\\\" using [\" + messageConverter + \"]\");\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t\treturn;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\telse if (messageConverter.canWrite(valueType, selectedMediaType)) {\n \t\t\t\t\toutputValue = (T) getAdvice().beforeBodyWrite(outputValue, returnType, selectedMediaType,\n \t\t\t\t\t\t\t(Class<? extends HttpMessageConverter<?>>) messageConverter.getClass(),\n \t\t\t\t\t\t\tinputMessage, outputMessage);\n \t\t\t\t\tif (outputValue != null) {\n \t\t\t\t\t\taddContentDispositionHeader(inputMessage, outputMessage);\n \t\t\t\t\t\t((HttpMessageConverter) messageConverter).write(outputValue, selectedMediaType, outputMessage);\n \t\t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\t\tlogger.debug(\"Written [\" + outputValue + \"] as \\\"\" + selectedMediaType +\n \t\t\t\t\t\t\t\t\t\"\\\" using [\" + messageConverter + \"]\");\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\treturn;\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\tif (outputValue != null) {\n \t\t\tthrow new HttpMediaTypeNotAcceptableException(this.allSupportedMediaTypes);\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"b204437cef0976f5af0e1c5290e77e266b306a51": {
			"type": "Ybodychange",
			"commitMessage": "Polishing\n",
			"commitDate": "2016-07-02, 5:48 AM",
			"commitName": "b204437cef0976f5af0e1c5290e77e266b306a51",
			"commitAuthor": "Juergen Hoeller",
			"commitDateOld": "2016-07-02, 4:02 AM",
			"commitNameOld": "e7a53e37fb1a0131f2c753fd83c1d161e21b1105",
			"commitAuthorOld": "Juergen Hoeller",
			"daysBetweenCommits": 0.07,
			"commitsBetweenForRepo": 2,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,94 +1,99 @@\n \tprotected <T> void writeWithMessageConverters(T value, MethodParameter returnType,\n \t\t\tServletServerHttpRequest inputMessage, ServletServerHttpResponse outputMessage)\n \t\t\tthrows IOException, HttpMediaTypeNotAcceptableException, HttpMessageNotWritableException {\n \n-\t\tClass<?> clazz = getReturnValueType(value, returnType);\n-\t\tType type = getGenericType(returnType);\n+\t\tObject outputValue;\n+\t\tClass<?> valueType;\n+\t\tType declaredType;\n \n-\t\tif (value != null && value instanceof CharSequence) {\n-\t\t\tclazz = String.class;\n-\t\t\ttype = String.class;\n-\t\t\tvalue = (T) value.toString();\n+\t\tif (value instanceof CharSequence) {\n+\t\t\toutputValue = value.toString();\n+\t\t\tvalueType = String.class;\n+\t\t\tdeclaredType = String.class;\n+\t\t}\n+\t\telse {\n+\t\t\toutputValue = value;\n+\t\t\tvalueType = getReturnValueType(outputValue, returnType);\n+\t\t\tdeclaredType = getGenericType(returnType);\n \t\t}\n \n-\t\tHttpServletRequest servletRequest = inputMessage.getServletRequest();\n-\t\tList<MediaType> requestedMediaTypes = getAcceptableMediaTypes(servletRequest);\n-\t\tList<MediaType> producibleMediaTypes = getProducibleMediaTypes(servletRequest, clazz, type);\n+\t\tHttpServletRequest request = inputMessage.getServletRequest();\n+\t\tList<MediaType> requestedMediaTypes = getAcceptableMediaTypes(request);\n+\t\tList<MediaType> producibleMediaTypes = getProducibleMediaTypes(request, valueType, declaredType);\n \n-\t\tif (value != null && producibleMediaTypes.isEmpty()) {\n-\t\t\tthrow new IllegalArgumentException(\"No converter found for return value of type: \" + clazz);\n+\t\tif (outputValue != null && producibleMediaTypes.isEmpty()) {\n+\t\t\tthrow new IllegalArgumentException(\"No converter found for return value of type: \" + valueType);\n \t\t}\n \n \t\tSet<MediaType> compatibleMediaTypes = new LinkedHashSet<MediaType>();\n \t\tfor (MediaType requestedType : requestedMediaTypes) {\n \t\t\tfor (MediaType producibleType : producibleMediaTypes) {\n \t\t\t\tif (requestedType.isCompatibleWith(producibleType)) {\n \t\t\t\t\tcompatibleMediaTypes.add(getMostSpecificMediaType(requestedType, producibleType));\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\tif (compatibleMediaTypes.isEmpty()) {\n-\t\t\tif (value != null) {\n+\t\t\tif (outputValue != null) {\n \t\t\t\tthrow new HttpMediaTypeNotAcceptableException(producibleMediaTypes);\n \t\t\t}\n \t\t\treturn;\n \t\t}\n \n \t\tList<MediaType> mediaTypes = new ArrayList<MediaType>(compatibleMediaTypes);\n \t\tMediaType.sortBySpecificityAndQuality(mediaTypes);\n \n \t\tMediaType selectedMediaType = null;\n \t\tfor (MediaType mediaType : mediaTypes) {\n \t\t\tif (mediaType.isConcrete()) {\n \t\t\t\tselectedMediaType = mediaType;\n \t\t\t\tbreak;\n \t\t\t}\n \t\t\telse if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n \t\t\t\tselectedMediaType = MediaType.APPLICATION_OCTET_STREAM;\n \t\t\t\tbreak;\n \t\t\t}\n \t\t}\n \n \t\tif (selectedMediaType != null) {\n \t\t\tselectedMediaType = selectedMediaType.removeQualityValue();\n \t\t\tfor (HttpMessageConverter<?> messageConverter : this.messageConverters) {\n \t\t\t\tif (messageConverter instanceof GenericHttpMessageConverter) {\n-\t\t\t\t\tif (((GenericHttpMessageConverter<T>) messageConverter).canWrite(type,\n-\t\t\t\t\t\t\tclazz, selectedMediaType)) {\n-\t\t\t\t\t\tvalue = (T) getAdvice().beforeBodyWrite(value, returnType, selectedMediaType,\n+\t\t\t\t\tif (((GenericHttpMessageConverter) messageConverter).canWrite(\n+\t\t\t\t\t\t\tdeclaredType, valueType, selectedMediaType)) {\n+\t\t\t\t\t\toutputValue = (T) getAdvice().beforeBodyWrite(outputValue, returnType, selectedMediaType,\n \t\t\t\t\t\t\t\t(Class<? extends HttpMessageConverter<?>>) messageConverter.getClass(),\n \t\t\t\t\t\t\t\tinputMessage, outputMessage);\n-\t\t\t\t\t\tif (value != null) {\n+\t\t\t\t\t\tif (outputValue != null) {\n \t\t\t\t\t\t\taddContentDispositionHeader(inputMessage, outputMessage);\n-\t\t\t\t\t\t\t((GenericHttpMessageConverter<T>) messageConverter).write(value,\n-\t\t\t\t\t\t\t\t\ttype, selectedMediaType, outputMessage);\n+\t\t\t\t\t\t\t((GenericHttpMessageConverter) messageConverter).write(\n+\t\t\t\t\t\t\t\t\toutputValue, declaredType, selectedMediaType, outputMessage);\n \t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n-\t\t\t\t\t\t\t\tlogger.debug(\"Written [\" + value + \"] as \\\"\" +\n-\t\t\t\t\t\t\t\t\t\tselectedMediaType + \"\\\" using [\" + messageConverter + \"]\");\n+\t\t\t\t\t\t\t\tlogger.debug(\"Written [\" + outputValue + \"] as \\\"\" + selectedMediaType +\n+\t\t\t\t\t\t\t\t\t\t\"\\\" using [\" + messageConverter + \"]\");\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t\treturn;\n \t\t\t\t\t}\n \t\t\t\t}\n-\t\t\t\telse if (messageConverter.canWrite(clazz, selectedMediaType)) {\n-\t\t\t\t\tvalue = (T) getAdvice().beforeBodyWrite(value, returnType, selectedMediaType,\n+\t\t\t\telse if (messageConverter.canWrite(valueType, selectedMediaType)) {\n+\t\t\t\t\toutputValue = (T) getAdvice().beforeBodyWrite(outputValue, returnType, selectedMediaType,\n \t\t\t\t\t\t\t(Class<? extends HttpMessageConverter<?>>) messageConverter.getClass(),\n \t\t\t\t\t\t\tinputMessage, outputMessage);\n-\t\t\t\t\tif (value != null) {\n+\t\t\t\t\tif (outputValue != null) {\n \t\t\t\t\t\taddContentDispositionHeader(inputMessage, outputMessage);\n-\t\t\t\t\t\t((HttpMessageConverter<T>) messageConverter).write(value,\n-\t\t\t\t\t\t\t\tselectedMediaType, outputMessage);\n+\t\t\t\t\t\t((HttpMessageConverter) messageConverter).write(outputValue, selectedMediaType, outputMessage);\n \t\t\t\t\t\tif (logger.isDebugEnabled()) {\n-\t\t\t\t\t\t\tlogger.debug(\"Written [\" + value + \"] as \\\"\" +\n-\t\t\t\t\t\t\t\t\tselectedMediaType + \"\\\" using [\" + messageConverter + \"]\");\n+\t\t\t\t\t\t\tlogger.debug(\"Written [\" + outputValue + \"] as \\\"\" + selectedMediaType +\n+\t\t\t\t\t\t\t\t\t\"\\\" using [\" + messageConverter + \"]\");\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\treturn;\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n-\t\tif (value != null) {\n+\t\tif (outputValue != null) {\n \t\t\tthrow new HttpMediaTypeNotAcceptableException(this.allSupportedMediaTypes);\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"7756feacd877093ad925d222c8bb911b6bb7c381": {
			"type": "Ymultichange(Yparameterchange,Ybodychange)",
			"commitMessage": "Polish\n",
			"commitDate": "2016-02-04, 9:04 PM",
			"commitName": "7756feacd877093ad925d222c8bb911b6bb7c381",
			"commitAuthor": "Rossen Stoyanchev",
			"subchanges": [
				{
					"type": "Yparameterchange",
					"commitMessage": "Polish\n",
					"commitDate": "2016-02-04, 9:04 PM",
					"commitName": "7756feacd877093ad925d222c8bb911b6bb7c381",
					"commitAuthor": "Rossen Stoyanchev",
					"commitDateOld": "2016-02-04, 8:55 PM",
					"commitNameOld": "1291d6e1bd5ba6524c3fb68813aad807d123c2e1",
					"commitAuthorOld": "Rossen Stoyanchev",
					"daysBetweenCommits": 0.01,
					"commitsBetweenForRepo": 1,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,94 +1,94 @@\n-\tprotected <T> void writeWithMessageConverters(T returnValue, MethodParameter returnType,\n+\tprotected <T> void writeWithMessageConverters(T value, MethodParameter returnType,\n \t\t\tServletServerHttpRequest inputMessage, ServletServerHttpResponse outputMessage)\n \t\t\tthrows IOException, HttpMediaTypeNotAcceptableException, HttpMessageNotWritableException {\n \n-\t\tClass<?> returnValueClass = getReturnValueType(returnValue, returnType);\n-\t\tType returnValueType = getGenericType(returnType);\n+\t\tClass<?> clazz = getReturnValueType(value, returnType);\n+\t\tType type = getGenericType(returnType);\n \n-\t\tif (returnValue != null && returnValue instanceof CharSequence) {\n-\t\t\treturnValueClass = String.class;\n-\t\t\treturnValueType = String.class;\n-\t\t\treturnValue = (T) returnValue.toString();\n+\t\tif (value != null && value instanceof CharSequence) {\n+\t\t\tclazz = String.class;\n+\t\t\ttype = String.class;\n+\t\t\tvalue = (T) value.toString();\n \t\t}\n \n \t\tHttpServletRequest servletRequest = inputMessage.getServletRequest();\n \t\tList<MediaType> requestedMediaTypes = getAcceptableMediaTypes(servletRequest);\n-\t\tList<MediaType> producibleMediaTypes = getProducibleMediaTypes(servletRequest, returnValueClass, returnValueType);\n+\t\tList<MediaType> producibleMediaTypes = getProducibleMediaTypes(servletRequest, clazz, type);\n \n-\t\tif (returnValue != null && producibleMediaTypes.isEmpty()) {\n-\t\t\tthrow new IllegalArgumentException(\"No converter found for return value of type: \" + returnValueClass);\n+\t\tif (value != null && producibleMediaTypes.isEmpty()) {\n+\t\t\tthrow new IllegalArgumentException(\"No converter found for return value of type: \" + clazz);\n \t\t}\n \n \t\tSet<MediaType> compatibleMediaTypes = new LinkedHashSet<MediaType>();\n \t\tfor (MediaType requestedType : requestedMediaTypes) {\n \t\t\tfor (MediaType producibleType : producibleMediaTypes) {\n \t\t\t\tif (requestedType.isCompatibleWith(producibleType)) {\n \t\t\t\t\tcompatibleMediaTypes.add(getMostSpecificMediaType(requestedType, producibleType));\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\tif (compatibleMediaTypes.isEmpty()) {\n-\t\t\tif (returnValue != null) {\n+\t\t\tif (value != null) {\n \t\t\t\tthrow new HttpMediaTypeNotAcceptableException(producibleMediaTypes);\n \t\t\t}\n \t\t\treturn;\n \t\t}\n \n \t\tList<MediaType> mediaTypes = new ArrayList<MediaType>(compatibleMediaTypes);\n \t\tMediaType.sortBySpecificityAndQuality(mediaTypes);\n \n \t\tMediaType selectedMediaType = null;\n \t\tfor (MediaType mediaType : mediaTypes) {\n \t\t\tif (mediaType.isConcrete()) {\n \t\t\t\tselectedMediaType = mediaType;\n \t\t\t\tbreak;\n \t\t\t}\n \t\t\telse if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n \t\t\t\tselectedMediaType = MediaType.APPLICATION_OCTET_STREAM;\n \t\t\t\tbreak;\n \t\t\t}\n \t\t}\n \n \t\tif (selectedMediaType != null) {\n \t\t\tselectedMediaType = selectedMediaType.removeQualityValue();\n \t\t\tfor (HttpMessageConverter<?> messageConverter : this.messageConverters) {\n \t\t\t\tif (messageConverter instanceof GenericHttpMessageConverter) {\n-\t\t\t\t\tif (((GenericHttpMessageConverter<T>) messageConverter).canWrite(returnValueType,\n-\t\t\t\t\t\t\treturnValueClass, selectedMediaType)) {\n-\t\t\t\t\t\treturnValue = (T) getAdvice().beforeBodyWrite(returnValue, returnType, selectedMediaType,\n+\t\t\t\t\tif (((GenericHttpMessageConverter<T>) messageConverter).canWrite(type,\n+\t\t\t\t\t\t\tclazz, selectedMediaType)) {\n+\t\t\t\t\t\tvalue = (T) getAdvice().beforeBodyWrite(value, returnType, selectedMediaType,\n \t\t\t\t\t\t\t\t(Class<? extends HttpMessageConverter<?>>) messageConverter.getClass(),\n \t\t\t\t\t\t\t\tinputMessage, outputMessage);\n-\t\t\t\t\t\tif (returnValue != null) {\n+\t\t\t\t\t\tif (value != null) {\n \t\t\t\t\t\t\taddContentDispositionHeader(inputMessage, outputMessage);\n-\t\t\t\t\t\t\t((GenericHttpMessageConverter<T>) messageConverter).write(returnValue,\n-\t\t\t\t\t\t\t\t\treturnValueType, selectedMediaType, outputMessage);\n+\t\t\t\t\t\t\t((GenericHttpMessageConverter<T>) messageConverter).write(value,\n+\t\t\t\t\t\t\t\t\ttype, selectedMediaType, outputMessage);\n \t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n-\t\t\t\t\t\t\t\tlogger.debug(\"Written [\" + returnValue + \"] as \\\"\" +\n+\t\t\t\t\t\t\t\tlogger.debug(\"Written [\" + value + \"] as \\\"\" +\n \t\t\t\t\t\t\t\t\t\tselectedMediaType + \"\\\" using [\" + messageConverter + \"]\");\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t\treturn;\n \t\t\t\t\t}\n \t\t\t\t}\n-\t\t\t\telse if (messageConverter.canWrite(returnValueClass, selectedMediaType)) {\n-\t\t\t\t\treturnValue = (T) getAdvice().beforeBodyWrite(returnValue, returnType, selectedMediaType,\n+\t\t\t\telse if (messageConverter.canWrite(clazz, selectedMediaType)) {\n+\t\t\t\t\tvalue = (T) getAdvice().beforeBodyWrite(value, returnType, selectedMediaType,\n \t\t\t\t\t\t\t(Class<? extends HttpMessageConverter<?>>) messageConverter.getClass(),\n \t\t\t\t\t\t\tinputMessage, outputMessage);\n-\t\t\t\t\tif (returnValue != null) {\n+\t\t\t\t\tif (value != null) {\n \t\t\t\t\t\taddContentDispositionHeader(inputMessage, outputMessage);\n-\t\t\t\t\t\t((HttpMessageConverter<T>) messageConverter).write(returnValue,\n+\t\t\t\t\t\t((HttpMessageConverter<T>) messageConverter).write(value,\n \t\t\t\t\t\t\t\tselectedMediaType, outputMessage);\n \t\t\t\t\t\tif (logger.isDebugEnabled()) {\n-\t\t\t\t\t\t\tlogger.debug(\"Written [\" + returnValue + \"] as \\\"\" +\n+\t\t\t\t\t\t\tlogger.debug(\"Written [\" + value + \"] as \\\"\" +\n \t\t\t\t\t\t\t\t\tselectedMediaType + \"\\\" using [\" + messageConverter + \"]\");\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\treturn;\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n-\t\tif (returnValue != null) {\n+\t\tif (value != null) {\n \t\t\tthrow new HttpMediaTypeNotAcceptableException(this.allSupportedMediaTypes);\n \t\t}\n \t}\n\\ No newline at end of file\n",
					"extendedDetails": {
						"oldValue": "[returnValue-T, returnType-MethodParameter, inputMessage-ServletServerHttpRequest, outputMessage-ServletServerHttpResponse]",
						"newValue": "[value-T, returnType-MethodParameter, inputMessage-ServletServerHttpRequest, outputMessage-ServletServerHttpResponse]"
					}
				},
				{
					"type": "Ybodychange",
					"commitMessage": "Polish\n",
					"commitDate": "2016-02-04, 9:04 PM",
					"commitName": "7756feacd877093ad925d222c8bb911b6bb7c381",
					"commitAuthor": "Rossen Stoyanchev",
					"commitDateOld": "2016-02-04, 8:55 PM",
					"commitNameOld": "1291d6e1bd5ba6524c3fb68813aad807d123c2e1",
					"commitAuthorOld": "Rossen Stoyanchev",
					"daysBetweenCommits": 0.01,
					"commitsBetweenForRepo": 1,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,94 +1,94 @@\n-\tprotected <T> void writeWithMessageConverters(T returnValue, MethodParameter returnType,\n+\tprotected <T> void writeWithMessageConverters(T value, MethodParameter returnType,\n \t\t\tServletServerHttpRequest inputMessage, ServletServerHttpResponse outputMessage)\n \t\t\tthrows IOException, HttpMediaTypeNotAcceptableException, HttpMessageNotWritableException {\n \n-\t\tClass<?> returnValueClass = getReturnValueType(returnValue, returnType);\n-\t\tType returnValueType = getGenericType(returnType);\n+\t\tClass<?> clazz = getReturnValueType(value, returnType);\n+\t\tType type = getGenericType(returnType);\n \n-\t\tif (returnValue != null && returnValue instanceof CharSequence) {\n-\t\t\treturnValueClass = String.class;\n-\t\t\treturnValueType = String.class;\n-\t\t\treturnValue = (T) returnValue.toString();\n+\t\tif (value != null && value instanceof CharSequence) {\n+\t\t\tclazz = String.class;\n+\t\t\ttype = String.class;\n+\t\t\tvalue = (T) value.toString();\n \t\t}\n \n \t\tHttpServletRequest servletRequest = inputMessage.getServletRequest();\n \t\tList<MediaType> requestedMediaTypes = getAcceptableMediaTypes(servletRequest);\n-\t\tList<MediaType> producibleMediaTypes = getProducibleMediaTypes(servletRequest, returnValueClass, returnValueType);\n+\t\tList<MediaType> producibleMediaTypes = getProducibleMediaTypes(servletRequest, clazz, type);\n \n-\t\tif (returnValue != null && producibleMediaTypes.isEmpty()) {\n-\t\t\tthrow new IllegalArgumentException(\"No converter found for return value of type: \" + returnValueClass);\n+\t\tif (value != null && producibleMediaTypes.isEmpty()) {\n+\t\t\tthrow new IllegalArgumentException(\"No converter found for return value of type: \" + clazz);\n \t\t}\n \n \t\tSet<MediaType> compatibleMediaTypes = new LinkedHashSet<MediaType>();\n \t\tfor (MediaType requestedType : requestedMediaTypes) {\n \t\t\tfor (MediaType producibleType : producibleMediaTypes) {\n \t\t\t\tif (requestedType.isCompatibleWith(producibleType)) {\n \t\t\t\t\tcompatibleMediaTypes.add(getMostSpecificMediaType(requestedType, producibleType));\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\tif (compatibleMediaTypes.isEmpty()) {\n-\t\t\tif (returnValue != null) {\n+\t\t\tif (value != null) {\n \t\t\t\tthrow new HttpMediaTypeNotAcceptableException(producibleMediaTypes);\n \t\t\t}\n \t\t\treturn;\n \t\t}\n \n \t\tList<MediaType> mediaTypes = new ArrayList<MediaType>(compatibleMediaTypes);\n \t\tMediaType.sortBySpecificityAndQuality(mediaTypes);\n \n \t\tMediaType selectedMediaType = null;\n \t\tfor (MediaType mediaType : mediaTypes) {\n \t\t\tif (mediaType.isConcrete()) {\n \t\t\t\tselectedMediaType = mediaType;\n \t\t\t\tbreak;\n \t\t\t}\n \t\t\telse if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n \t\t\t\tselectedMediaType = MediaType.APPLICATION_OCTET_STREAM;\n \t\t\t\tbreak;\n \t\t\t}\n \t\t}\n \n \t\tif (selectedMediaType != null) {\n \t\t\tselectedMediaType = selectedMediaType.removeQualityValue();\n \t\t\tfor (HttpMessageConverter<?> messageConverter : this.messageConverters) {\n \t\t\t\tif (messageConverter instanceof GenericHttpMessageConverter) {\n-\t\t\t\t\tif (((GenericHttpMessageConverter<T>) messageConverter).canWrite(returnValueType,\n-\t\t\t\t\t\t\treturnValueClass, selectedMediaType)) {\n-\t\t\t\t\t\treturnValue = (T) getAdvice().beforeBodyWrite(returnValue, returnType, selectedMediaType,\n+\t\t\t\t\tif (((GenericHttpMessageConverter<T>) messageConverter).canWrite(type,\n+\t\t\t\t\t\t\tclazz, selectedMediaType)) {\n+\t\t\t\t\t\tvalue = (T) getAdvice().beforeBodyWrite(value, returnType, selectedMediaType,\n \t\t\t\t\t\t\t\t(Class<? extends HttpMessageConverter<?>>) messageConverter.getClass(),\n \t\t\t\t\t\t\t\tinputMessage, outputMessage);\n-\t\t\t\t\t\tif (returnValue != null) {\n+\t\t\t\t\t\tif (value != null) {\n \t\t\t\t\t\t\taddContentDispositionHeader(inputMessage, outputMessage);\n-\t\t\t\t\t\t\t((GenericHttpMessageConverter<T>) messageConverter).write(returnValue,\n-\t\t\t\t\t\t\t\t\treturnValueType, selectedMediaType, outputMessage);\n+\t\t\t\t\t\t\t((GenericHttpMessageConverter<T>) messageConverter).write(value,\n+\t\t\t\t\t\t\t\t\ttype, selectedMediaType, outputMessage);\n \t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n-\t\t\t\t\t\t\t\tlogger.debug(\"Written [\" + returnValue + \"] as \\\"\" +\n+\t\t\t\t\t\t\t\tlogger.debug(\"Written [\" + value + \"] as \\\"\" +\n \t\t\t\t\t\t\t\t\t\tselectedMediaType + \"\\\" using [\" + messageConverter + \"]\");\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t\treturn;\n \t\t\t\t\t}\n \t\t\t\t}\n-\t\t\t\telse if (messageConverter.canWrite(returnValueClass, selectedMediaType)) {\n-\t\t\t\t\treturnValue = (T) getAdvice().beforeBodyWrite(returnValue, returnType, selectedMediaType,\n+\t\t\t\telse if (messageConverter.canWrite(clazz, selectedMediaType)) {\n+\t\t\t\t\tvalue = (T) getAdvice().beforeBodyWrite(value, returnType, selectedMediaType,\n \t\t\t\t\t\t\t(Class<? extends HttpMessageConverter<?>>) messageConverter.getClass(),\n \t\t\t\t\t\t\tinputMessage, outputMessage);\n-\t\t\t\t\tif (returnValue != null) {\n+\t\t\t\t\tif (value != null) {\n \t\t\t\t\t\taddContentDispositionHeader(inputMessage, outputMessage);\n-\t\t\t\t\t\t((HttpMessageConverter<T>) messageConverter).write(returnValue,\n+\t\t\t\t\t\t((HttpMessageConverter<T>) messageConverter).write(value,\n \t\t\t\t\t\t\t\tselectedMediaType, outputMessage);\n \t\t\t\t\t\tif (logger.isDebugEnabled()) {\n-\t\t\t\t\t\t\tlogger.debug(\"Written [\" + returnValue + \"] as \\\"\" +\n+\t\t\t\t\t\t\tlogger.debug(\"Written [\" + value + \"] as \\\"\" +\n \t\t\t\t\t\t\t\t\tselectedMediaType + \"\\\" using [\" + messageConverter + \"]\");\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\treturn;\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n-\t\tif (returnValue != null) {\n+\t\tif (value != null) {\n \t\t\tthrow new HttpMediaTypeNotAcceptableException(this.allSupportedMediaTypes);\n \t\t}\n \t}\n\\ No newline at end of file\n",
					"extendedDetails": {}
				}
			]
		},
		"1291d6e1bd5ba6524c3fb68813aad807d123c2e1": {
			"type": "Ybodychange",
			"commitMessage": "Support CharSequence for response body\n\nIssue: SPR-13423\n",
			"commitDate": "2016-02-04, 8:55 PM",
			"commitName": "1291d6e1bd5ba6524c3fb68813aad807d123c2e1",
			"commitAuthor": "Rossen Stoyanchev",
			"commitDateOld": "2015-11-11, 2:14 PM",
			"commitNameOld": "3a919a48d6941622ae1b08034630b0f565d0554b",
			"commitAuthorOld": "Rossen Stoyanchev",
			"daysBetweenCommits": 85.28,
			"commitsBetweenForRepo": 317,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,87 +1,94 @@\n \tprotected <T> void writeWithMessageConverters(T returnValue, MethodParameter returnType,\n \t\t\tServletServerHttpRequest inputMessage, ServletServerHttpResponse outputMessage)\n \t\t\tthrows IOException, HttpMediaTypeNotAcceptableException, HttpMessageNotWritableException {\n \n \t\tClass<?> returnValueClass = getReturnValueType(returnValue, returnType);\n \t\tType returnValueType = getGenericType(returnType);\n+\n+\t\tif (returnValue != null && returnValue instanceof CharSequence) {\n+\t\t\treturnValueClass = String.class;\n+\t\t\treturnValueType = String.class;\n+\t\t\treturnValue = (T) returnValue.toString();\n+\t\t}\n+\n \t\tHttpServletRequest servletRequest = inputMessage.getServletRequest();\n \t\tList<MediaType> requestedMediaTypes = getAcceptableMediaTypes(servletRequest);\n \t\tList<MediaType> producibleMediaTypes = getProducibleMediaTypes(servletRequest, returnValueClass, returnValueType);\n \n \t\tif (returnValue != null && producibleMediaTypes.isEmpty()) {\n \t\t\tthrow new IllegalArgumentException(\"No converter found for return value of type: \" + returnValueClass);\n \t\t}\n \n \t\tSet<MediaType> compatibleMediaTypes = new LinkedHashSet<MediaType>();\n \t\tfor (MediaType requestedType : requestedMediaTypes) {\n \t\t\tfor (MediaType producibleType : producibleMediaTypes) {\n \t\t\t\tif (requestedType.isCompatibleWith(producibleType)) {\n \t\t\t\t\tcompatibleMediaTypes.add(getMostSpecificMediaType(requestedType, producibleType));\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\tif (compatibleMediaTypes.isEmpty()) {\n \t\t\tif (returnValue != null) {\n \t\t\t\tthrow new HttpMediaTypeNotAcceptableException(producibleMediaTypes);\n \t\t\t}\n \t\t\treturn;\n \t\t}\n \n \t\tList<MediaType> mediaTypes = new ArrayList<MediaType>(compatibleMediaTypes);\n \t\tMediaType.sortBySpecificityAndQuality(mediaTypes);\n \n \t\tMediaType selectedMediaType = null;\n \t\tfor (MediaType mediaType : mediaTypes) {\n \t\t\tif (mediaType.isConcrete()) {\n \t\t\t\tselectedMediaType = mediaType;\n \t\t\t\tbreak;\n \t\t\t}\n \t\t\telse if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n \t\t\t\tselectedMediaType = MediaType.APPLICATION_OCTET_STREAM;\n \t\t\t\tbreak;\n \t\t\t}\n \t\t}\n \n \t\tif (selectedMediaType != null) {\n \t\t\tselectedMediaType = selectedMediaType.removeQualityValue();\n \t\t\tfor (HttpMessageConverter<?> messageConverter : this.messageConverters) {\n \t\t\t\tif (messageConverter instanceof GenericHttpMessageConverter) {\n \t\t\t\t\tif (((GenericHttpMessageConverter<T>) messageConverter).canWrite(returnValueType,\n \t\t\t\t\t\t\treturnValueClass, selectedMediaType)) {\n \t\t\t\t\t\treturnValue = (T) getAdvice().beforeBodyWrite(returnValue, returnType, selectedMediaType,\n \t\t\t\t\t\t\t\t(Class<? extends HttpMessageConverter<?>>) messageConverter.getClass(),\n \t\t\t\t\t\t\t\tinputMessage, outputMessage);\n \t\t\t\t\t\tif (returnValue != null) {\n \t\t\t\t\t\t\taddContentDispositionHeader(inputMessage, outputMessage);\n \t\t\t\t\t\t\t((GenericHttpMessageConverter<T>) messageConverter).write(returnValue,\n \t\t\t\t\t\t\t\t\treturnValueType, selectedMediaType, outputMessage);\n \t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\t\t\tlogger.debug(\"Written [\" + returnValue + \"] as \\\"\" +\n \t\t\t\t\t\t\t\t\t\tselectedMediaType + \"\\\" using [\" + messageConverter + \"]\");\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t\treturn;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\telse if (messageConverter.canWrite(returnValueClass, selectedMediaType)) {\n \t\t\t\t\treturnValue = (T) getAdvice().beforeBodyWrite(returnValue, returnType, selectedMediaType,\n \t\t\t\t\t\t\t(Class<? extends HttpMessageConverter<?>>) messageConverter.getClass(),\n \t\t\t\t\t\t\tinputMessage, outputMessage);\n \t\t\t\t\tif (returnValue != null) {\n \t\t\t\t\t\taddContentDispositionHeader(inputMessage, outputMessage);\n \t\t\t\t\t\t((HttpMessageConverter<T>) messageConverter).write(returnValue,\n \t\t\t\t\t\t\t\tselectedMediaType, outputMessage);\n \t\t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\t\tlogger.debug(\"Written [\" + returnValue + \"] as \\\"\" +\n \t\t\t\t\t\t\t\t\tselectedMediaType + \"\\\" using [\" + messageConverter + \"]\");\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\treturn;\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\tif (returnValue != null) {\n \t\t\tthrow new HttpMediaTypeNotAcceptableException(this.allSupportedMediaTypes);\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"2bd1daa75ee0b8ec33608ca6ab065ef3e1815543": {
			"type": "Ybodychange",
			"commitMessage": "Protect against RFD exploits\n\nIssue: SPR-13548\n",
			"commitDate": "2015-10-15, 1:33 AM",
			"commitName": "2bd1daa75ee0b8ec33608ca6ab065ef3e1815543",
			"commitAuthor": "Rossen Stoyanchev",
			"commitDateOld": "2015-09-04, 5:38 AM",
			"commitNameOld": "667fc7e4a9d9daf15110339af3659404ace6adba",
			"commitAuthorOld": "Juergen Hoeller",
			"daysBetweenCommits": 40.83,
			"commitsBetweenForRepo": 140,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,85 +1,87 @@\n \tprotected <T> void writeWithMessageConverters(T returnValue, MethodParameter returnType,\n \t\t\tServletServerHttpRequest inputMessage, ServletServerHttpResponse outputMessage)\n \t\t\tthrows IOException, HttpMediaTypeNotAcceptableException, HttpMessageNotWritableException {\n \n \t\tClass<?> returnValueClass = getReturnValueType(returnValue, returnType);\n \t\tType returnValueType = getGenericType(returnType);\n \t\tHttpServletRequest servletRequest = inputMessage.getServletRequest();\n \t\tList<MediaType> requestedMediaTypes = getAcceptableMediaTypes(servletRequest);\n \t\tList<MediaType> producibleMediaTypes = getProducibleMediaTypes(servletRequest, returnValueClass, returnValueType);\n \n \t\tif (returnValue != null && producibleMediaTypes.isEmpty()) {\n \t\t\tthrow new IllegalArgumentException(\"No converter found for return value of type: \" + returnValueClass);\n \t\t}\n \n \t\tSet<MediaType> compatibleMediaTypes = new LinkedHashSet<MediaType>();\n \t\tfor (MediaType requestedType : requestedMediaTypes) {\n \t\t\tfor (MediaType producibleType : producibleMediaTypes) {\n \t\t\t\tif (requestedType.isCompatibleWith(producibleType)) {\n \t\t\t\t\tcompatibleMediaTypes.add(getMostSpecificMediaType(requestedType, producibleType));\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\tif (compatibleMediaTypes.isEmpty()) {\n \t\t\tif (returnValue != null) {\n \t\t\t\tthrow new HttpMediaTypeNotAcceptableException(producibleMediaTypes);\n \t\t\t}\n \t\t\treturn;\n \t\t}\n \n \t\tList<MediaType> mediaTypes = new ArrayList<MediaType>(compatibleMediaTypes);\n \t\tMediaType.sortBySpecificityAndQuality(mediaTypes);\n \n \t\tMediaType selectedMediaType = null;\n \t\tfor (MediaType mediaType : mediaTypes) {\n \t\t\tif (mediaType.isConcrete()) {\n \t\t\t\tselectedMediaType = mediaType;\n \t\t\t\tbreak;\n \t\t\t}\n \t\t\telse if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n \t\t\t\tselectedMediaType = MediaType.APPLICATION_OCTET_STREAM;\n \t\t\t\tbreak;\n \t\t\t}\n \t\t}\n \n \t\tif (selectedMediaType != null) {\n \t\t\tselectedMediaType = selectedMediaType.removeQualityValue();\n \t\t\tfor (HttpMessageConverter<?> messageConverter : this.messageConverters) {\n \t\t\t\tif (messageConverter instanceof GenericHttpMessageConverter) {\n \t\t\t\t\tif (((GenericHttpMessageConverter<T>) messageConverter).canWrite(returnValueType,\n \t\t\t\t\t\t\treturnValueClass, selectedMediaType)) {\n \t\t\t\t\t\treturnValue = (T) getAdvice().beforeBodyWrite(returnValue, returnType, selectedMediaType,\n \t\t\t\t\t\t\t\t(Class<? extends HttpMessageConverter<?>>) messageConverter.getClass(),\n \t\t\t\t\t\t\t\tinputMessage, outputMessage);\n \t\t\t\t\t\tif (returnValue != null) {\n+\t\t\t\t\t\t\taddContentDispositionHeader(inputMessage, outputMessage);\n \t\t\t\t\t\t\t((GenericHttpMessageConverter<T>) messageConverter).write(returnValue,\n \t\t\t\t\t\t\t\t\treturnValueType, selectedMediaType, outputMessage);\n \t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\t\t\tlogger.debug(\"Written [\" + returnValue + \"] as \\\"\" +\n \t\t\t\t\t\t\t\t\t\tselectedMediaType + \"\\\" using [\" + messageConverter + \"]\");\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t\treturn;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\telse if (messageConverter.canWrite(returnValueClass, selectedMediaType)) {\n \t\t\t\t\treturnValue = (T) getAdvice().beforeBodyWrite(returnValue, returnType, selectedMediaType,\n \t\t\t\t\t\t\t(Class<? extends HttpMessageConverter<?>>) messageConverter.getClass(),\n \t\t\t\t\t\t\tinputMessage, outputMessage);\n \t\t\t\t\tif (returnValue != null) {\n+\t\t\t\t\t\taddContentDispositionHeader(inputMessage, outputMessage);\n \t\t\t\t\t\t((HttpMessageConverter<T>) messageConverter).write(returnValue,\n \t\t\t\t\t\t\t\tselectedMediaType, outputMessage);\n \t\t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\t\tlogger.debug(\"Written [\" + returnValue + \"] as \\\"\" +\n \t\t\t\t\t\t\t\t\tselectedMediaType + \"\\\" using [\" + messageConverter + \"]\");\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\treturn;\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\tif (returnValue != null) {\n \t\t\tthrow new HttpMediaTypeNotAcceptableException(this.allSupportedMediaTypes);\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"667fc7e4a9d9daf15110339af3659404ace6adba": {
			"type": "Ybodychange",
			"commitMessage": "Polishing\n",
			"commitDate": "2015-09-04, 5:38 AM",
			"commitName": "667fc7e4a9d9daf15110339af3659404ace6adba",
			"commitAuthor": "Juergen Hoeller",
			"commitDateOld": "2015-07-28, 3:15 AM",
			"commitNameOld": "d83735694eff6919434e8a4557cfb6dc66e5175d",
			"commitAuthorOld": "Juergen Hoeller",
			"daysBetweenCommits": 38.1,
			"commitsBetweenForRepo": 193,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,84 +1,85 @@\n \tprotected <T> void writeWithMessageConverters(T returnValue, MethodParameter returnType,\n \t\t\tServletServerHttpRequest inputMessage, ServletServerHttpResponse outputMessage)\n \t\t\tthrows IOException, HttpMediaTypeNotAcceptableException, HttpMessageNotWritableException {\n \n \t\tClass<?> returnValueClass = getReturnValueType(returnValue, returnType);\n \t\tType returnValueType = getGenericType(returnType);\n \t\tHttpServletRequest servletRequest = inputMessage.getServletRequest();\n \t\tList<MediaType> requestedMediaTypes = getAcceptableMediaTypes(servletRequest);\n \t\tList<MediaType> producibleMediaTypes = getProducibleMediaTypes(servletRequest, returnValueClass, returnValueType);\n \n-\t\tAssert.isTrue(returnValue == null || !producibleMediaTypes.isEmpty(),\n-\t\t\t\t\"No converter found for return value of type: \" + returnValueClass);\n+\t\tif (returnValue != null && producibleMediaTypes.isEmpty()) {\n+\t\t\tthrow new IllegalArgumentException(\"No converter found for return value of type: \" + returnValueClass);\n+\t\t}\n \n \t\tSet<MediaType> compatibleMediaTypes = new LinkedHashSet<MediaType>();\n \t\tfor (MediaType requestedType : requestedMediaTypes) {\n \t\t\tfor (MediaType producibleType : producibleMediaTypes) {\n \t\t\t\tif (requestedType.isCompatibleWith(producibleType)) {\n \t\t\t\t\tcompatibleMediaTypes.add(getMostSpecificMediaType(requestedType, producibleType));\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\tif (compatibleMediaTypes.isEmpty()) {\n \t\t\tif (returnValue != null) {\n \t\t\t\tthrow new HttpMediaTypeNotAcceptableException(producibleMediaTypes);\n \t\t\t}\n \t\t\treturn;\n \t\t}\n \n \t\tList<MediaType> mediaTypes = new ArrayList<MediaType>(compatibleMediaTypes);\n \t\tMediaType.sortBySpecificityAndQuality(mediaTypes);\n \n \t\tMediaType selectedMediaType = null;\n \t\tfor (MediaType mediaType : mediaTypes) {\n \t\t\tif (mediaType.isConcrete()) {\n \t\t\t\tselectedMediaType = mediaType;\n \t\t\t\tbreak;\n \t\t\t}\n \t\t\telse if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n \t\t\t\tselectedMediaType = MediaType.APPLICATION_OCTET_STREAM;\n \t\t\t\tbreak;\n \t\t\t}\n \t\t}\n \n \t\tif (selectedMediaType != null) {\n \t\t\tselectedMediaType = selectedMediaType.removeQualityValue();\n \t\t\tfor (HttpMessageConverter<?> messageConverter : this.messageConverters) {\n \t\t\t\tif (messageConverter instanceof GenericHttpMessageConverter) {\n \t\t\t\t\tif (((GenericHttpMessageConverter<T>) messageConverter).canWrite(returnValueType,\n \t\t\t\t\t\t\treturnValueClass, selectedMediaType)) {\n \t\t\t\t\t\treturnValue = (T) getAdvice().beforeBodyWrite(returnValue, returnType, selectedMediaType,\n \t\t\t\t\t\t\t\t(Class<? extends HttpMessageConverter<?>>) messageConverter.getClass(),\n \t\t\t\t\t\t\t\tinputMessage, outputMessage);\n \t\t\t\t\t\tif (returnValue != null) {\n \t\t\t\t\t\t\t((GenericHttpMessageConverter<T>) messageConverter).write(returnValue,\n \t\t\t\t\t\t\t\t\treturnValueType, selectedMediaType, outputMessage);\n \t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\t\t\tlogger.debug(\"Written [\" + returnValue + \"] as \\\"\" +\n \t\t\t\t\t\t\t\t\t\tselectedMediaType + \"\\\" using [\" + messageConverter + \"]\");\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t\treturn;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\telse if (messageConverter.canWrite(returnValueClass, selectedMediaType)) {\n \t\t\t\t\treturnValue = (T) getAdvice().beforeBodyWrite(returnValue, returnType, selectedMediaType,\n \t\t\t\t\t\t\t(Class<? extends HttpMessageConverter<?>>) messageConverter.getClass(),\n \t\t\t\t\t\t\tinputMessage, outputMessage);\n \t\t\t\t\tif (returnValue != null) {\n \t\t\t\t\t\t((HttpMessageConverter<T>) messageConverter).write(returnValue,\n \t\t\t\t\t\t\t\tselectedMediaType, outputMessage);\n \t\t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\t\tlogger.debug(\"Written [\" + returnValue + \"] as \\\"\" +\n \t\t\t\t\t\t\t\t\tselectedMediaType + \"\\\" using [\" + messageConverter + \"]\");\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\treturn;\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\tif (returnValue != null) {\n \t\t\tthrow new HttpMediaTypeNotAcceptableException(this.allSupportedMediaTypes);\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"d83735694eff6919434e8a4557cfb6dc66e5175d": {
			"type": "Yexceptionschange",
			"commitMessage": "Polishing\n",
			"commitDate": "2015-07-28, 3:15 AM",
			"commitName": "d83735694eff6919434e8a4557cfb6dc66e5175d",
			"commitAuthor": "Juergen Hoeller",
			"commitDateOld": "2015-06-25, 6:02 AM",
			"commitNameOld": "289f35da3a57bb5e491b30c7351072b4e801c519",
			"commitAuthorOld": "Sebastien Deleuze",
			"daysBetweenCommits": 32.88,
			"commitsBetweenForRepo": 219,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,84 +1,84 @@\n \tprotected <T> void writeWithMessageConverters(T returnValue, MethodParameter returnType,\n \t\t\tServletServerHttpRequest inputMessage, ServletServerHttpResponse outputMessage)\n-\t\t\tthrows IOException, HttpMediaTypeNotAcceptableException {\n+\t\t\tthrows IOException, HttpMediaTypeNotAcceptableException, HttpMessageNotWritableException {\n \n \t\tClass<?> returnValueClass = getReturnValueType(returnValue, returnType);\n \t\tType returnValueType = getGenericType(returnType);\n \t\tHttpServletRequest servletRequest = inputMessage.getServletRequest();\n \t\tList<MediaType> requestedMediaTypes = getAcceptableMediaTypes(servletRequest);\n \t\tList<MediaType> producibleMediaTypes = getProducibleMediaTypes(servletRequest, returnValueClass, returnValueType);\n \n \t\tAssert.isTrue(returnValue == null || !producibleMediaTypes.isEmpty(),\n \t\t\t\t\"No converter found for return value of type: \" + returnValueClass);\n \n \t\tSet<MediaType> compatibleMediaTypes = new LinkedHashSet<MediaType>();\n \t\tfor (MediaType requestedType : requestedMediaTypes) {\n \t\t\tfor (MediaType producibleType : producibleMediaTypes) {\n \t\t\t\tif (requestedType.isCompatibleWith(producibleType)) {\n \t\t\t\t\tcompatibleMediaTypes.add(getMostSpecificMediaType(requestedType, producibleType));\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\tif (compatibleMediaTypes.isEmpty()) {\n \t\t\tif (returnValue != null) {\n \t\t\t\tthrow new HttpMediaTypeNotAcceptableException(producibleMediaTypes);\n \t\t\t}\n \t\t\treturn;\n \t\t}\n \n \t\tList<MediaType> mediaTypes = new ArrayList<MediaType>(compatibleMediaTypes);\n \t\tMediaType.sortBySpecificityAndQuality(mediaTypes);\n \n \t\tMediaType selectedMediaType = null;\n \t\tfor (MediaType mediaType : mediaTypes) {\n \t\t\tif (mediaType.isConcrete()) {\n \t\t\t\tselectedMediaType = mediaType;\n \t\t\t\tbreak;\n \t\t\t}\n \t\t\telse if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n \t\t\t\tselectedMediaType = MediaType.APPLICATION_OCTET_STREAM;\n \t\t\t\tbreak;\n \t\t\t}\n \t\t}\n \n \t\tif (selectedMediaType != null) {\n \t\t\tselectedMediaType = selectedMediaType.removeQualityValue();\n \t\t\tfor (HttpMessageConverter<?> messageConverter : this.messageConverters) {\n \t\t\t\tif (messageConverter instanceof GenericHttpMessageConverter) {\n \t\t\t\t\tif (((GenericHttpMessageConverter<T>) messageConverter).canWrite(returnValueType,\n \t\t\t\t\t\t\treturnValueClass, selectedMediaType)) {\n \t\t\t\t\t\treturnValue = (T) getAdvice().beforeBodyWrite(returnValue, returnType, selectedMediaType,\n \t\t\t\t\t\t\t\t(Class<? extends HttpMessageConverter<?>>) messageConverter.getClass(),\n \t\t\t\t\t\t\t\tinputMessage, outputMessage);\n \t\t\t\t\t\tif (returnValue != null) {\n \t\t\t\t\t\t\t((GenericHttpMessageConverter<T>) messageConverter).write(returnValue,\n \t\t\t\t\t\t\t\t\treturnValueType, selectedMediaType, outputMessage);\n \t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\t\t\tlogger.debug(\"Written [\" + returnValue + \"] as \\\"\" +\n \t\t\t\t\t\t\t\t\t\tselectedMediaType + \"\\\" using [\" + messageConverter + \"]\");\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t\treturn;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\telse if (messageConverter.canWrite(returnValueClass, selectedMediaType)) {\n \t\t\t\t\treturnValue = (T) getAdvice().beforeBodyWrite(returnValue, returnType, selectedMediaType,\n \t\t\t\t\t\t\t(Class<? extends HttpMessageConverter<?>>) messageConverter.getClass(),\n \t\t\t\t\t\t\tinputMessage, outputMessage);\n \t\t\t\t\tif (returnValue != null) {\n \t\t\t\t\t\t((HttpMessageConverter<T>) messageConverter).write(returnValue,\n \t\t\t\t\t\t\t\tselectedMediaType, outputMessage);\n \t\t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\t\tlogger.debug(\"Written [\" + returnValue + \"] as \\\"\" +\n \t\t\t\t\t\t\t\t\tselectedMediaType + \"\\\" using [\" + messageConverter + \"]\");\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\treturn;\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\tif (returnValue != null) {\n \t\t\tthrow new HttpMediaTypeNotAcceptableException(this.allSupportedMediaTypes);\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {
				"oldValue": "[IOException, HttpMediaTypeNotAcceptableException]",
				"newValue": "[IOException, HttpMediaTypeNotAcceptableException, HttpMessageNotWritableException]"
			}
		},
		"289f35da3a57bb5e491b30c7351072b4e801c519": {
			"type": "Ybodychange",
			"commitMessage": "Call type aware canWrite() when using a GenericHttpMessageConverter\n\nThis commit introduces the following changes:\n - In AbstractMessageConverterMethodProcessor, the type aware variant of\n   canWrite() is now called when the converter implements\n   GenericHttpMessageConverter.\n - The Javadoc has been updated in GenericHttpMessageConverter to make it clear\n   that the type aware canRead() and canWrite() methods should perform the same\n   checks than non type aware ones.\n  - AbstractGenericHttpMessageConverter now implements default type aware\n    canRead() and canWrite() methods than just call the non type aware variants.\n    Due to this, if subclasses just override the non type aware variants,\n    they still have the right behavior.\n\nIssue: SPR-13161\n",
			"commitDate": "2015-06-25, 6:02 AM",
			"commitName": "289f35da3a57bb5e491b30c7351072b4e801c519",
			"commitAuthor": "Sebastien Deleuze",
			"commitDateOld": "2015-06-22, 8:05 AM",
			"commitNameOld": "31a5434ea433bdec2283797bf9415c02bb2f41c1",
			"commitAuthorOld": "Sebastien Deleuze",
			"daysBetweenCommits": 2.91,
			"commitsBetweenForRepo": 17,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,78 +1,84 @@\n \tprotected <T> void writeWithMessageConverters(T returnValue, MethodParameter returnType,\n \t\t\tServletServerHttpRequest inputMessage, ServletServerHttpResponse outputMessage)\n \t\t\tthrows IOException, HttpMediaTypeNotAcceptableException {\n \n \t\tClass<?> returnValueClass = getReturnValueType(returnValue, returnType);\n+\t\tType returnValueType = getGenericType(returnType);\n \t\tHttpServletRequest servletRequest = inputMessage.getServletRequest();\n \t\tList<MediaType> requestedMediaTypes = getAcceptableMediaTypes(servletRequest);\n-\t\tList<MediaType> producibleMediaTypes = getProducibleMediaTypes(servletRequest, returnValueClass);\n+\t\tList<MediaType> producibleMediaTypes = getProducibleMediaTypes(servletRequest, returnValueClass, returnValueType);\n \n \t\tAssert.isTrue(returnValue == null || !producibleMediaTypes.isEmpty(),\n \t\t\t\t\"No converter found for return value of type: \" + returnValueClass);\n \n \t\tSet<MediaType> compatibleMediaTypes = new LinkedHashSet<MediaType>();\n \t\tfor (MediaType requestedType : requestedMediaTypes) {\n \t\t\tfor (MediaType producibleType : producibleMediaTypes) {\n \t\t\t\tif (requestedType.isCompatibleWith(producibleType)) {\n \t\t\t\t\tcompatibleMediaTypes.add(getMostSpecificMediaType(requestedType, producibleType));\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\tif (compatibleMediaTypes.isEmpty()) {\n \t\t\tif (returnValue != null) {\n \t\t\t\tthrow new HttpMediaTypeNotAcceptableException(producibleMediaTypes);\n \t\t\t}\n \t\t\treturn;\n \t\t}\n \n \t\tList<MediaType> mediaTypes = new ArrayList<MediaType>(compatibleMediaTypes);\n \t\tMediaType.sortBySpecificityAndQuality(mediaTypes);\n \n \t\tMediaType selectedMediaType = null;\n \t\tfor (MediaType mediaType : mediaTypes) {\n \t\t\tif (mediaType.isConcrete()) {\n \t\t\t\tselectedMediaType = mediaType;\n \t\t\t\tbreak;\n \t\t\t}\n \t\t\telse if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n \t\t\t\tselectedMediaType = MediaType.APPLICATION_OCTET_STREAM;\n \t\t\t\tbreak;\n \t\t\t}\n \t\t}\n \n \t\tif (selectedMediaType != null) {\n \t\t\tselectedMediaType = selectedMediaType.removeQualityValue();\n \t\t\tfor (HttpMessageConverter<?> messageConverter : this.messageConverters) {\n-\t\t\t\tif (messageConverter.canWrite(returnValueClass, selectedMediaType)) {\n+\t\t\t\tif (messageConverter instanceof GenericHttpMessageConverter) {\n+\t\t\t\t\tif (((GenericHttpMessageConverter<T>) messageConverter).canWrite(returnValueType,\n+\t\t\t\t\t\t\treturnValueClass, selectedMediaType)) {\n+\t\t\t\t\t\treturnValue = (T) getAdvice().beforeBodyWrite(returnValue, returnType, selectedMediaType,\n+\t\t\t\t\t\t\t\t(Class<? extends HttpMessageConverter<?>>) messageConverter.getClass(),\n+\t\t\t\t\t\t\t\tinputMessage, outputMessage);\n+\t\t\t\t\t\tif (returnValue != null) {\n+\t\t\t\t\t\t\t((GenericHttpMessageConverter<T>) messageConverter).write(returnValue,\n+\t\t\t\t\t\t\t\t\treturnValueType, selectedMediaType, outputMessage);\n+\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n+\t\t\t\t\t\t\t\tlogger.debug(\"Written [\" + returnValue + \"] as \\\"\" +\n+\t\t\t\t\t\t\t\t\t\tselectedMediaType + \"\\\" using [\" + messageConverter + \"]\");\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\treturn;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\telse if (messageConverter.canWrite(returnValueClass, selectedMediaType)) {\n \t\t\t\t\treturnValue = (T) getAdvice().beforeBodyWrite(returnValue, returnType, selectedMediaType,\n \t\t\t\t\t\t\t(Class<? extends HttpMessageConverter<?>>) messageConverter.getClass(),\n \t\t\t\t\t\t\tinputMessage, outputMessage);\n \t\t\t\t\tif (returnValue != null) {\n-\t\t\t\t\t\tif (messageConverter instanceof GenericHttpMessageConverter) {\n-\t\t\t\t\t\t\tType type;\n-\t\t\t\t\t\t\tif (HttpEntity.class.isAssignableFrom(returnType.getParameterType())) {\n-\t\t\t\t\t\t\t\treturnType.increaseNestingLevel();\n-\t\t\t\t\t\t\t\ttype = returnType.getNestedGenericParameterType();\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\telse {\n-\t\t\t\t\t\t\t\ttype = returnType.getGenericParameterType();\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t((GenericHttpMessageConverter<T>) messageConverter).write(returnValue, type, selectedMediaType, outputMessage);\n-\t\t\t\t\t\t}\n-\t\t\t\t\t\telse {\n-\t\t\t\t\t\t\t((HttpMessageConverter<T>) messageConverter).write(returnValue, selectedMediaType, outputMessage);\n-\t\t\t\t\t\t}\n+\t\t\t\t\t\t((HttpMessageConverter<T>) messageConverter).write(returnValue,\n+\t\t\t\t\t\t\t\tselectedMediaType, outputMessage);\n \t\t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\t\tlogger.debug(\"Written [\" + returnValue + \"] as \\\"\" +\n \t\t\t\t\t\t\t\t\tselectedMediaType + \"\\\" using [\" + messageConverter + \"]\");\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\treturn;\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\tif (returnValue != null) {\n \t\t\tthrow new HttpMediaTypeNotAcceptableException(this.allSupportedMediaTypes);\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"31a5434ea433bdec2283797bf9415c02bb2f41c1": {
			"type": "Ybodychange",
			"commitMessage": "Make @ResponseBody method return type available for message converters\n\nThis commit adds canWrite() and write() methods to the\nGenericHttpMessageConverter interface. These are type aware variants\nof the methods available in HttpMessageConverter, in order to keep\nparametrized type information when serializing objects.\n\nAbstractMessageConverterMethodProcessor now calls those type aware\nmethods when the message converter implements GenericHttpMessageConverter.\n\nAbstractJackson2HttpMessageConverter and GsonHttpMessageConverter uses\nthese new methods to make @ResponseBody method return type available\nfor type resolution instead of just letting the JSON serializer trying\nto guess the type to use from the object to serialize.\n\nIssue: SPR-12811\n",
			"commitDate": "2015-06-22, 8:05 AM",
			"commitName": "31a5434ea433bdec2283797bf9415c02bb2f41c1",
			"commitAuthor": "Sebastien Deleuze",
			"commitDateOld": "2015-06-17, 2:03 PM",
			"commitNameOld": "8d7812b1b6c47c3edef1332639cb57b92327ec46",
			"commitAuthorOld": "Rossen Stoyanchev",
			"daysBetweenCommits": 4.75,
			"commitsBetweenForRepo": 26,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,65 +1,78 @@\n \tprotected <T> void writeWithMessageConverters(T returnValue, MethodParameter returnType,\n \t\t\tServletServerHttpRequest inputMessage, ServletServerHttpResponse outputMessage)\n \t\t\tthrows IOException, HttpMediaTypeNotAcceptableException {\n \n \t\tClass<?> returnValueClass = getReturnValueType(returnValue, returnType);\n \t\tHttpServletRequest servletRequest = inputMessage.getServletRequest();\n \t\tList<MediaType> requestedMediaTypes = getAcceptableMediaTypes(servletRequest);\n \t\tList<MediaType> producibleMediaTypes = getProducibleMediaTypes(servletRequest, returnValueClass);\n \n \t\tAssert.isTrue(returnValue == null || !producibleMediaTypes.isEmpty(),\n \t\t\t\t\"No converter found for return value of type: \" + returnValueClass);\n \n \t\tSet<MediaType> compatibleMediaTypes = new LinkedHashSet<MediaType>();\n \t\tfor (MediaType requestedType : requestedMediaTypes) {\n \t\t\tfor (MediaType producibleType : producibleMediaTypes) {\n \t\t\t\tif (requestedType.isCompatibleWith(producibleType)) {\n \t\t\t\t\tcompatibleMediaTypes.add(getMostSpecificMediaType(requestedType, producibleType));\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\tif (compatibleMediaTypes.isEmpty()) {\n \t\t\tif (returnValue != null) {\n \t\t\t\tthrow new HttpMediaTypeNotAcceptableException(producibleMediaTypes);\n \t\t\t}\n \t\t\treturn;\n \t\t}\n \n \t\tList<MediaType> mediaTypes = new ArrayList<MediaType>(compatibleMediaTypes);\n \t\tMediaType.sortBySpecificityAndQuality(mediaTypes);\n \n \t\tMediaType selectedMediaType = null;\n \t\tfor (MediaType mediaType : mediaTypes) {\n \t\t\tif (mediaType.isConcrete()) {\n \t\t\t\tselectedMediaType = mediaType;\n \t\t\t\tbreak;\n \t\t\t}\n \t\t\telse if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n \t\t\t\tselectedMediaType = MediaType.APPLICATION_OCTET_STREAM;\n \t\t\t\tbreak;\n \t\t\t}\n \t\t}\n \n \t\tif (selectedMediaType != null) {\n \t\t\tselectedMediaType = selectedMediaType.removeQualityValue();\n \t\t\tfor (HttpMessageConverter<?> messageConverter : this.messageConverters) {\n \t\t\t\tif (messageConverter.canWrite(returnValueClass, selectedMediaType)) {\n \t\t\t\t\treturnValue = (T) getAdvice().beforeBodyWrite(returnValue, returnType, selectedMediaType,\n \t\t\t\t\t\t\t(Class<? extends HttpMessageConverter<?>>) messageConverter.getClass(),\n \t\t\t\t\t\t\tinputMessage, outputMessage);\n \t\t\t\t\tif (returnValue != null) {\n-\t\t\t\t\t\t((HttpMessageConverter<T>) messageConverter).write(returnValue, selectedMediaType, outputMessage);\n+\t\t\t\t\t\tif (messageConverter instanceof GenericHttpMessageConverter) {\n+\t\t\t\t\t\t\tType type;\n+\t\t\t\t\t\t\tif (HttpEntity.class.isAssignableFrom(returnType.getParameterType())) {\n+\t\t\t\t\t\t\t\treturnType.increaseNestingLevel();\n+\t\t\t\t\t\t\t\ttype = returnType.getNestedGenericParameterType();\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\telse {\n+\t\t\t\t\t\t\t\ttype = returnType.getGenericParameterType();\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t((GenericHttpMessageConverter<T>) messageConverter).write(returnValue, type, selectedMediaType, outputMessage);\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\telse {\n+\t\t\t\t\t\t\t((HttpMessageConverter<T>) messageConverter).write(returnValue, selectedMediaType, outputMessage);\n+\t\t\t\t\t\t}\n \t\t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\t\tlogger.debug(\"Written [\" + returnValue + \"] as \\\"\" +\n \t\t\t\t\t\t\t\t\tselectedMediaType + \"\\\" using [\" + messageConverter + \"]\");\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\treturn;\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\tif (returnValue != null) {\n \t\t\tthrow new HttpMediaTypeNotAcceptableException(this.allSupportedMediaTypes);\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"8d7812b1b6c47c3edef1332639cb57b92327ec46": {
			"type": "Ybodychange",
			"commitMessage": "Raise IAE when no converter matches return type\n\nBefore this change the AbstractMessageConverterMethodProcessor always\nraised a 406 if it couldn't find a converter. However if the reason\nfor not finding it is because there is simply no converter for the\nreturn value type (i.e. programming error) and doesn't have anything to\ndo with content negotiation, then we should raise a 500 instead and\nmake it easier to figure out what's wrong.\n\nIssue: SPR-13135\n",
			"commitDate": "2015-06-17, 2:03 PM",
			"commitName": "8d7812b1b6c47c3edef1332639cb57b92327ec46",
			"commitAuthor": "Rossen Stoyanchev",
			"commitDateOld": "2015-03-29, 6:42 PM",
			"commitNameOld": "0556ed4f161cddf992cc49960ba0181a564a8667",
			"commitAuthorOld": "Rossen Stoyanchev",
			"daysBetweenCommits": 79.81,
			"commitsBetweenForRepo": 481,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,62 +1,65 @@\n \tprotected <T> void writeWithMessageConverters(T returnValue, MethodParameter returnType,\n \t\t\tServletServerHttpRequest inputMessage, ServletServerHttpResponse outputMessage)\n \t\t\tthrows IOException, HttpMediaTypeNotAcceptableException {\n \n \t\tClass<?> returnValueClass = getReturnValueType(returnValue, returnType);\n \t\tHttpServletRequest servletRequest = inputMessage.getServletRequest();\n \t\tList<MediaType> requestedMediaTypes = getAcceptableMediaTypes(servletRequest);\n \t\tList<MediaType> producibleMediaTypes = getProducibleMediaTypes(servletRequest, returnValueClass);\n \n+\t\tAssert.isTrue(returnValue == null || !producibleMediaTypes.isEmpty(),\n+\t\t\t\t\"No converter found for return value of type: \" + returnValueClass);\n+\n \t\tSet<MediaType> compatibleMediaTypes = new LinkedHashSet<MediaType>();\n \t\tfor (MediaType requestedType : requestedMediaTypes) {\n \t\t\tfor (MediaType producibleType : producibleMediaTypes) {\n \t\t\t\tif (requestedType.isCompatibleWith(producibleType)) {\n \t\t\t\t\tcompatibleMediaTypes.add(getMostSpecificMediaType(requestedType, producibleType));\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\tif (compatibleMediaTypes.isEmpty()) {\n \t\t\tif (returnValue != null) {\n \t\t\t\tthrow new HttpMediaTypeNotAcceptableException(producibleMediaTypes);\n \t\t\t}\n \t\t\treturn;\n \t\t}\n \n \t\tList<MediaType> mediaTypes = new ArrayList<MediaType>(compatibleMediaTypes);\n \t\tMediaType.sortBySpecificityAndQuality(mediaTypes);\n \n \t\tMediaType selectedMediaType = null;\n \t\tfor (MediaType mediaType : mediaTypes) {\n \t\t\tif (mediaType.isConcrete()) {\n \t\t\t\tselectedMediaType = mediaType;\n \t\t\t\tbreak;\n \t\t\t}\n \t\t\telse if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n \t\t\t\tselectedMediaType = MediaType.APPLICATION_OCTET_STREAM;\n \t\t\t\tbreak;\n \t\t\t}\n \t\t}\n \n \t\tif (selectedMediaType != null) {\n \t\t\tselectedMediaType = selectedMediaType.removeQualityValue();\n \t\t\tfor (HttpMessageConverter<?> messageConverter : this.messageConverters) {\n \t\t\t\tif (messageConverter.canWrite(returnValueClass, selectedMediaType)) {\n \t\t\t\t\treturnValue = (T) getAdvice().beforeBodyWrite(returnValue, returnType, selectedMediaType,\n \t\t\t\t\t\t\t(Class<? extends HttpMessageConverter<?>>) messageConverter.getClass(),\n \t\t\t\t\t\t\tinputMessage, outputMessage);\n \t\t\t\t\tif (returnValue != null) {\n \t\t\t\t\t\t((HttpMessageConverter<T>) messageConverter).write(returnValue, selectedMediaType, outputMessage);\n \t\t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\t\tlogger.debug(\"Written [\" + returnValue + \"] as \\\"\" +\n \t\t\t\t\t\t\t\t\tselectedMediaType + \"\\\" using [\" + messageConverter + \"]\");\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\treturn;\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\tif (returnValue != null) {\n \t\t\tthrow new HttpMediaTypeNotAcceptableException(this.allSupportedMediaTypes);\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"0556ed4f161cddf992cc49960ba0181a564a8667": {
			"type": "Ybodychange",
			"commitMessage": "Add RequestBodyAdvice\n\nRequestBodyAdvice is analogous to ResponseBodyAdvice (added in 4.1)\nbut for intercepting for reading the request with an\nHttpMessageConverter for resolving an @RequestBody or an HttpEntity\nmethod argument.\n\nIssue: SPR-12501\n",
			"commitDate": "2015-03-29, 6:42 PM",
			"commitName": "0556ed4f161cddf992cc49960ba0181a564a8667",
			"commitAuthor": "Rossen Stoyanchev",
			"commitDateOld": "2014-10-17, 10:21 AM",
			"commitNameOld": "c5e360d886931f761c2be5ff4b31d5df2042d415",
			"commitAuthorOld": "Rossen Stoyanchev",
			"daysBetweenCommits": 163.35,
			"commitsBetweenForRepo": 605,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,61 +1,62 @@\n \tprotected <T> void writeWithMessageConverters(T returnValue, MethodParameter returnType,\n \t\t\tServletServerHttpRequest inputMessage, ServletServerHttpResponse outputMessage)\n \t\t\tthrows IOException, HttpMediaTypeNotAcceptableException {\n \n \t\tClass<?> returnValueClass = getReturnValueType(returnValue, returnType);\n \t\tHttpServletRequest servletRequest = inputMessage.getServletRequest();\n \t\tList<MediaType> requestedMediaTypes = getAcceptableMediaTypes(servletRequest);\n \t\tList<MediaType> producibleMediaTypes = getProducibleMediaTypes(servletRequest, returnValueClass);\n \n \t\tSet<MediaType> compatibleMediaTypes = new LinkedHashSet<MediaType>();\n \t\tfor (MediaType requestedType : requestedMediaTypes) {\n \t\t\tfor (MediaType producibleType : producibleMediaTypes) {\n \t\t\t\tif (requestedType.isCompatibleWith(producibleType)) {\n \t\t\t\t\tcompatibleMediaTypes.add(getMostSpecificMediaType(requestedType, producibleType));\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\tif (compatibleMediaTypes.isEmpty()) {\n \t\t\tif (returnValue != null) {\n \t\t\t\tthrow new HttpMediaTypeNotAcceptableException(producibleMediaTypes);\n \t\t\t}\n \t\t\treturn;\n \t\t}\n \n \t\tList<MediaType> mediaTypes = new ArrayList<MediaType>(compatibleMediaTypes);\n \t\tMediaType.sortBySpecificityAndQuality(mediaTypes);\n \n \t\tMediaType selectedMediaType = null;\n \t\tfor (MediaType mediaType : mediaTypes) {\n \t\t\tif (mediaType.isConcrete()) {\n \t\t\t\tselectedMediaType = mediaType;\n \t\t\t\tbreak;\n \t\t\t}\n \t\t\telse if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n \t\t\t\tselectedMediaType = MediaType.APPLICATION_OCTET_STREAM;\n \t\t\t\tbreak;\n \t\t\t}\n \t\t}\n \n \t\tif (selectedMediaType != null) {\n \t\t\tselectedMediaType = selectedMediaType.removeQualityValue();\n \t\t\tfor (HttpMessageConverter<?> messageConverter : this.messageConverters) {\n \t\t\t\tif (messageConverter.canWrite(returnValueClass, selectedMediaType)) {\n-\t\t\t\t\treturnValue = this.adviceChain.invoke(returnValue, returnType, selectedMediaType,\n-\t\t\t\t\t\t\t(Class<HttpMessageConverter<?>>) messageConverter.getClass(), inputMessage, outputMessage);\n+\t\t\t\t\treturnValue = (T) getAdvice().beforeBodyWrite(returnValue, returnType, selectedMediaType,\n+\t\t\t\t\t\t\t(Class<? extends HttpMessageConverter<?>>) messageConverter.getClass(),\n+\t\t\t\t\t\t\tinputMessage, outputMessage);\n \t\t\t\t\tif (returnValue != null) {\n \t\t\t\t\t\t((HttpMessageConverter<T>) messageConverter).write(returnValue, selectedMediaType, outputMessage);\n \t\t\t\t\t\tif (logger.isDebugEnabled()) {\n-\t\t\t\t\t\t\tlogger.debug(\"Written [\" + returnValue + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" +\n-\t\t\t\t\t\t\t\t\tmessageConverter + \"]\");\n+\t\t\t\t\t\t\tlogger.debug(\"Written [\" + returnValue + \"] as \\\"\" +\n+\t\t\t\t\t\t\t\t\tselectedMediaType + \"\\\" using [\" + messageConverter + \"]\");\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\treturn;\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\tif (returnValue != null) {\n \t\t\tthrow new HttpMediaTypeNotAcceptableException(this.allSupportedMediaTypes);\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"c5e360d886931f761c2be5ff4b31d5df2042d415": {
			"type": "Ybodychange",
			"commitMessage": "Fix regression with raw ResponseEntity type\n\nThis fix addresses a 4.1.1 regression where a raw ResponseEntity return\nvalue (used to return potentially a different kind of body) caused an\nexception.\n\nThe regression came from the fact we now try to render a null body in\norder to give ResponseBodyAdvice a chance to substitute a different\nvalue. That in turn means we have to try to determine the body type\nfrom the method signature.\n\nThis change improves the logic for extracting the generic parameter\ntype to accommodate a raw ResponseEntity class. Also we avoid raising\nHttpMediaTypeNotAcceptableException if the value to be rendered is\nnull.\n\nIssue: SPR-12287\n",
			"commitDate": "2014-10-17, 10:21 AM",
			"commitName": "c5e360d886931f761c2be5ff4b31d5df2042d415",
			"commitAuthor": "Rossen Stoyanchev",
			"commitDateOld": "2014-10-15, 2:06 PM",
			"commitNameOld": "8cce40469631327e0afdd5d41393248313819270",
			"commitAuthorOld": "Rossen Stoyanchev",
			"daysBetweenCommits": 1.84,
			"commitsBetweenForRepo": 9,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,59 +1,61 @@\n \tprotected <T> void writeWithMessageConverters(T returnValue, MethodParameter returnType,\n \t\t\tServletServerHttpRequest inputMessage, ServletServerHttpResponse outputMessage)\n \t\t\tthrows IOException, HttpMediaTypeNotAcceptableException {\n \n \t\tClass<?> returnValueClass = getReturnValueType(returnValue, returnType);\n-\t\tif (returnValue == null && Void.class.equals(returnValueClass)) {\n-\t\t\treturn;\n-\t\t}\n-\n \t\tHttpServletRequest servletRequest = inputMessage.getServletRequest();\n \t\tList<MediaType> requestedMediaTypes = getAcceptableMediaTypes(servletRequest);\n \t\tList<MediaType> producibleMediaTypes = getProducibleMediaTypes(servletRequest, returnValueClass);\n \n \t\tSet<MediaType> compatibleMediaTypes = new LinkedHashSet<MediaType>();\n \t\tfor (MediaType requestedType : requestedMediaTypes) {\n \t\t\tfor (MediaType producibleType : producibleMediaTypes) {\n \t\t\t\tif (requestedType.isCompatibleWith(producibleType)) {\n \t\t\t\t\tcompatibleMediaTypes.add(getMostSpecificMediaType(requestedType, producibleType));\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\tif (compatibleMediaTypes.isEmpty()) {\n-\t\t\tthrow new HttpMediaTypeNotAcceptableException(producibleMediaTypes);\n+\t\t\tif (returnValue != null) {\n+\t\t\t\tthrow new HttpMediaTypeNotAcceptableException(producibleMediaTypes);\n+\t\t\t}\n+\t\t\treturn;\n \t\t}\n \n \t\tList<MediaType> mediaTypes = new ArrayList<MediaType>(compatibleMediaTypes);\n \t\tMediaType.sortBySpecificityAndQuality(mediaTypes);\n \n \t\tMediaType selectedMediaType = null;\n \t\tfor (MediaType mediaType : mediaTypes) {\n \t\t\tif (mediaType.isConcrete()) {\n \t\t\t\tselectedMediaType = mediaType;\n \t\t\t\tbreak;\n \t\t\t}\n \t\t\telse if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n \t\t\t\tselectedMediaType = MediaType.APPLICATION_OCTET_STREAM;\n \t\t\t\tbreak;\n \t\t\t}\n \t\t}\n \n \t\tif (selectedMediaType != null) {\n \t\t\tselectedMediaType = selectedMediaType.removeQualityValue();\n \t\t\tfor (HttpMessageConverter<?> messageConverter : this.messageConverters) {\n \t\t\t\tif (messageConverter.canWrite(returnValueClass, selectedMediaType)) {\n \t\t\t\t\treturnValue = this.adviceChain.invoke(returnValue, returnType, selectedMediaType,\n \t\t\t\t\t\t\t(Class<HttpMessageConverter<?>>) messageConverter.getClass(), inputMessage, outputMessage);\n \t\t\t\t\tif (returnValue != null) {\n \t\t\t\t\t\t((HttpMessageConverter<T>) messageConverter).write(returnValue, selectedMediaType, outputMessage);\n \t\t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\t\tlogger.debug(\"Written [\" + returnValue + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" +\n \t\t\t\t\t\t\t\t\tmessageConverter + \"]\");\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\treturn;\n \t\t\t\t}\n \t\t\t}\n \t\t}\n-\t\tthrow new HttpMediaTypeNotAcceptableException(this.allSupportedMediaTypes);\n+\n+\t\tif (returnValue != null) {\n+\t\t\tthrow new HttpMediaTypeNotAcceptableException(this.allSupportedMediaTypes);\n+\t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"8cce40469631327e0afdd5d41393248313819270": {
			"type": "Ybodychange",
			"commitMessage": "Add check for ResponseEntity<void> with null return value\n\nIssue: SPR-12287\n",
			"commitDate": "2014-10-15, 2:06 PM",
			"commitName": "8cce40469631327e0afdd5d41393248313819270",
			"commitAuthor": "Rossen Stoyanchev",
			"commitDateOld": "2014-09-19, 11:57 AM",
			"commitNameOld": "a9b2a12491aa2259851b93824b7e560b3dbd1902",
			"commitAuthorOld": "Rossen Stoyanchev",
			"daysBetweenCommits": 26.09,
			"commitsBetweenForRepo": 153,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,55 +1,59 @@\n \tprotected <T> void writeWithMessageConverters(T returnValue, MethodParameter returnType,\n \t\t\tServletServerHttpRequest inputMessage, ServletServerHttpResponse outputMessage)\n \t\t\tthrows IOException, HttpMediaTypeNotAcceptableException {\n \n \t\tClass<?> returnValueClass = getReturnValueType(returnValue, returnType);\n+\t\tif (returnValue == null && Void.class.equals(returnValueClass)) {\n+\t\t\treturn;\n+\t\t}\n+\n \t\tHttpServletRequest servletRequest = inputMessage.getServletRequest();\n \t\tList<MediaType> requestedMediaTypes = getAcceptableMediaTypes(servletRequest);\n \t\tList<MediaType> producibleMediaTypes = getProducibleMediaTypes(servletRequest, returnValueClass);\n \n \t\tSet<MediaType> compatibleMediaTypes = new LinkedHashSet<MediaType>();\n \t\tfor (MediaType requestedType : requestedMediaTypes) {\n \t\t\tfor (MediaType producibleType : producibleMediaTypes) {\n \t\t\t\tif (requestedType.isCompatibleWith(producibleType)) {\n \t\t\t\t\tcompatibleMediaTypes.add(getMostSpecificMediaType(requestedType, producibleType));\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\tif (compatibleMediaTypes.isEmpty()) {\n \t\t\tthrow new HttpMediaTypeNotAcceptableException(producibleMediaTypes);\n \t\t}\n \n \t\tList<MediaType> mediaTypes = new ArrayList<MediaType>(compatibleMediaTypes);\n \t\tMediaType.sortBySpecificityAndQuality(mediaTypes);\n \n \t\tMediaType selectedMediaType = null;\n \t\tfor (MediaType mediaType : mediaTypes) {\n \t\t\tif (mediaType.isConcrete()) {\n \t\t\t\tselectedMediaType = mediaType;\n \t\t\t\tbreak;\n \t\t\t}\n \t\t\telse if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n \t\t\t\tselectedMediaType = MediaType.APPLICATION_OCTET_STREAM;\n \t\t\t\tbreak;\n \t\t\t}\n \t\t}\n \n \t\tif (selectedMediaType != null) {\n \t\t\tselectedMediaType = selectedMediaType.removeQualityValue();\n \t\t\tfor (HttpMessageConverter<?> messageConverter : this.messageConverters) {\n \t\t\t\tif (messageConverter.canWrite(returnValueClass, selectedMediaType)) {\n \t\t\t\t\treturnValue = this.adviceChain.invoke(returnValue, returnType, selectedMediaType,\n \t\t\t\t\t\t\t(Class<HttpMessageConverter<?>>) messageConverter.getClass(), inputMessage, outputMessage);\n \t\t\t\t\tif (returnValue != null) {\n \t\t\t\t\t\t((HttpMessageConverter<T>) messageConverter).write(returnValue, selectedMediaType, outputMessage);\n \t\t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\t\tlogger.debug(\"Written [\" + returnValue + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" +\n \t\t\t\t\t\t\t\t\tmessageConverter + \"]\");\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\treturn;\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\tthrow new HttpMediaTypeNotAcceptableException(this.allSupportedMediaTypes);\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"a9b2a12491aa2259851b93824b7e560b3dbd1902": {
			"type": "Ybodychange",
			"commitMessage": "Allow ResponseBodyAdvice to modify null return values\n\nThis change defers determination of whether to invoke a message\nconverter in case of a null @ResponseBody value (or ResponseEntity with\na null body) until after the invocation of the ResponseBodyAdvice\nchain. This allows a ResponseBodyAdvice to handle null values\npotentially turning them into non-null value.s\n\nIssue: SPR-12152\n",
			"commitDate": "2014-09-19, 11:57 AM",
			"commitName": "a9b2a12491aa2259851b93824b7e560b3dbd1902",
			"commitAuthor": "Rossen Stoyanchev",
			"commitDateOld": "2014-05-30, 2:02 PM",
			"commitNameOld": "c9d0ebd730953ef693edf275b57cfeeb9bf15af9",
			"commitAuthorOld": "Rossen Stoyanchev",
			"daysBetweenCommits": 111.91,
			"commitsBetweenForRepo": 627,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,53 +1,55 @@\n \tprotected <T> void writeWithMessageConverters(T returnValue, MethodParameter returnType,\n \t\t\tServletServerHttpRequest inputMessage, ServletServerHttpResponse outputMessage)\n \t\t\tthrows IOException, HttpMediaTypeNotAcceptableException {\n \n-\t\tClass<?> returnValueClass = returnValue.getClass();\n+\t\tClass<?> returnValueClass = getReturnValueType(returnValue, returnType);\n \t\tHttpServletRequest servletRequest = inputMessage.getServletRequest();\n \t\tList<MediaType> requestedMediaTypes = getAcceptableMediaTypes(servletRequest);\n \t\tList<MediaType> producibleMediaTypes = getProducibleMediaTypes(servletRequest, returnValueClass);\n \n \t\tSet<MediaType> compatibleMediaTypes = new LinkedHashSet<MediaType>();\n \t\tfor (MediaType requestedType : requestedMediaTypes) {\n \t\t\tfor (MediaType producibleType : producibleMediaTypes) {\n \t\t\t\tif (requestedType.isCompatibleWith(producibleType)) {\n \t\t\t\t\tcompatibleMediaTypes.add(getMostSpecificMediaType(requestedType, producibleType));\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\tif (compatibleMediaTypes.isEmpty()) {\n \t\t\tthrow new HttpMediaTypeNotAcceptableException(producibleMediaTypes);\n \t\t}\n \n \t\tList<MediaType> mediaTypes = new ArrayList<MediaType>(compatibleMediaTypes);\n \t\tMediaType.sortBySpecificityAndQuality(mediaTypes);\n \n \t\tMediaType selectedMediaType = null;\n \t\tfor (MediaType mediaType : mediaTypes) {\n \t\t\tif (mediaType.isConcrete()) {\n \t\t\t\tselectedMediaType = mediaType;\n \t\t\t\tbreak;\n \t\t\t}\n \t\t\telse if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n \t\t\t\tselectedMediaType = MediaType.APPLICATION_OCTET_STREAM;\n \t\t\t\tbreak;\n \t\t\t}\n \t\t}\n \n \t\tif (selectedMediaType != null) {\n \t\t\tselectedMediaType = selectedMediaType.removeQualityValue();\n \t\t\tfor (HttpMessageConverter<?> messageConverter : this.messageConverters) {\n \t\t\t\tif (messageConverter.canWrite(returnValueClass, selectedMediaType)) {\n \t\t\t\t\treturnValue = this.adviceChain.invoke(returnValue, returnType, selectedMediaType,\n \t\t\t\t\t\t\t(Class<HttpMessageConverter<?>>) messageConverter.getClass(), inputMessage, outputMessage);\n-\t\t\t\t\t((HttpMessageConverter<T>) messageConverter).write(returnValue, selectedMediaType, outputMessage);\n-\t\t\t\t\tif (logger.isDebugEnabled()) {\n-\t\t\t\t\t\tlogger.debug(\"Written [\" + returnValue + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" +\n-\t\t\t\t\t\t\t\tmessageConverter + \"]\");\n+\t\t\t\t\tif (returnValue != null) {\n+\t\t\t\t\t\t((HttpMessageConverter<T>) messageConverter).write(returnValue, selectedMediaType, outputMessage);\n+\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n+\t\t\t\t\t\t\tlogger.debug(\"Written [\" + returnValue + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" +\n+\t\t\t\t\t\t\t\t\tmessageConverter + \"]\");\n+\t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\treturn;\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\tthrow new HttpMediaTypeNotAcceptableException(this.allSupportedMediaTypes);\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"c9d0ebd730953ef693edf275b57cfeeb9bf15af9": {
			"type": "Ybodychange",
			"commitMessage": "Rename ResponseBodyInterceptor to ResponseBodyAdvice\n\nIssue: SPR-10859\n",
			"commitDate": "2014-05-30, 2:02 PM",
			"commitName": "c9d0ebd730953ef693edf275b57cfeeb9bf15af9",
			"commitAuthor": "Rossen Stoyanchev",
			"commitDateOld": "2014-05-30, 2:02 PM",
			"commitNameOld": "2655c507e041fb3c245d550b33ba7f1b21fc341e",
			"commitAuthorOld": "Rossen Stoyanchev",
			"daysBetweenCommits": 0,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,53 +1,53 @@\n \tprotected <T> void writeWithMessageConverters(T returnValue, MethodParameter returnType,\n \t\t\tServletServerHttpRequest inputMessage, ServletServerHttpResponse outputMessage)\n \t\t\tthrows IOException, HttpMediaTypeNotAcceptableException {\n \n \t\tClass<?> returnValueClass = returnValue.getClass();\n \t\tHttpServletRequest servletRequest = inputMessage.getServletRequest();\n \t\tList<MediaType> requestedMediaTypes = getAcceptableMediaTypes(servletRequest);\n \t\tList<MediaType> producibleMediaTypes = getProducibleMediaTypes(servletRequest, returnValueClass);\n \n \t\tSet<MediaType> compatibleMediaTypes = new LinkedHashSet<MediaType>();\n \t\tfor (MediaType requestedType : requestedMediaTypes) {\n \t\t\tfor (MediaType producibleType : producibleMediaTypes) {\n \t\t\t\tif (requestedType.isCompatibleWith(producibleType)) {\n \t\t\t\t\tcompatibleMediaTypes.add(getMostSpecificMediaType(requestedType, producibleType));\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\tif (compatibleMediaTypes.isEmpty()) {\n \t\t\tthrow new HttpMediaTypeNotAcceptableException(producibleMediaTypes);\n \t\t}\n \n \t\tList<MediaType> mediaTypes = new ArrayList<MediaType>(compatibleMediaTypes);\n \t\tMediaType.sortBySpecificityAndQuality(mediaTypes);\n \n \t\tMediaType selectedMediaType = null;\n \t\tfor (MediaType mediaType : mediaTypes) {\n \t\t\tif (mediaType.isConcrete()) {\n \t\t\t\tselectedMediaType = mediaType;\n \t\t\t\tbreak;\n \t\t\t}\n \t\t\telse if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n \t\t\t\tselectedMediaType = MediaType.APPLICATION_OCTET_STREAM;\n \t\t\t\tbreak;\n \t\t\t}\n \t\t}\n \n \t\tif (selectedMediaType != null) {\n \t\t\tselectedMediaType = selectedMediaType.removeQualityValue();\n \t\t\tfor (HttpMessageConverter<?> messageConverter : this.messageConverters) {\n \t\t\t\tif (messageConverter.canWrite(returnValueClass, selectedMediaType)) {\n-\t\t\t\t\treturnValue = this.interceptorChain.invoke(returnValue, returnType, selectedMediaType,\n+\t\t\t\t\treturnValue = this.adviceChain.invoke(returnValue, returnType, selectedMediaType,\n \t\t\t\t\t\t\t(Class<HttpMessageConverter<?>>) messageConverter.getClass(), inputMessage, outputMessage);\n \t\t\t\t\t((HttpMessageConverter<T>) messageConverter).write(returnValue, selectedMediaType, outputMessage);\n \t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\tlogger.debug(\"Written [\" + returnValue + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" +\n \t\t\t\t\t\t\t\tmessageConverter + \"]\");\n \t\t\t\t\t}\n \t\t\t\t\treturn;\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\tthrow new HttpMediaTypeNotAcceptableException(this.allSupportedMediaTypes);\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"2655c507e041fb3c245d550b33ba7f1b21fc341e": {
			"type": "Ybodychange",
			"commitMessage": "Parameterize ResponseBodyInterceptor on the type level\n\nIssue: SPR-10859\n",
			"commitDate": "2014-05-30, 2:02 PM",
			"commitName": "2655c507e041fb3c245d550b33ba7f1b21fc341e",
			"commitAuthor": "Rossen Stoyanchev",
			"commitDateOld": "2014-05-19, 12:47 PM",
			"commitNameOld": "51fc3b4aaf01a3d8f8f0f9ec98f5e5c1215cc096",
			"commitAuthorOld": "Rossen Stoyanchev",
			"daysBetweenCommits": 11.05,
			"commitsBetweenForRepo": 44,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,54 +1,53 @@\n \tprotected <T> void writeWithMessageConverters(T returnValue, MethodParameter returnType,\n \t\t\tServletServerHttpRequest inputMessage, ServletServerHttpResponse outputMessage)\n \t\t\tthrows IOException, HttpMediaTypeNotAcceptableException {\n \n \t\tClass<?> returnValueClass = returnValue.getClass();\n \t\tHttpServletRequest servletRequest = inputMessage.getServletRequest();\n \t\tList<MediaType> requestedMediaTypes = getAcceptableMediaTypes(servletRequest);\n \t\tList<MediaType> producibleMediaTypes = getProducibleMediaTypes(servletRequest, returnValueClass);\n \n \t\tSet<MediaType> compatibleMediaTypes = new LinkedHashSet<MediaType>();\n \t\tfor (MediaType requestedType : requestedMediaTypes) {\n \t\t\tfor (MediaType producibleType : producibleMediaTypes) {\n \t\t\t\tif (requestedType.isCompatibleWith(producibleType)) {\n \t\t\t\t\tcompatibleMediaTypes.add(getMostSpecificMediaType(requestedType, producibleType));\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\tif (compatibleMediaTypes.isEmpty()) {\n \t\t\tthrow new HttpMediaTypeNotAcceptableException(producibleMediaTypes);\n \t\t}\n \n \t\tList<MediaType> mediaTypes = new ArrayList<MediaType>(compatibleMediaTypes);\n \t\tMediaType.sortBySpecificityAndQuality(mediaTypes);\n \n \t\tMediaType selectedMediaType = null;\n \t\tfor (MediaType mediaType : mediaTypes) {\n \t\t\tif (mediaType.isConcrete()) {\n \t\t\t\tselectedMediaType = mediaType;\n \t\t\t\tbreak;\n \t\t\t}\n \t\t\telse if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n \t\t\t\tselectedMediaType = MediaType.APPLICATION_OCTET_STREAM;\n \t\t\t\tbreak;\n \t\t\t}\n \t\t}\n \n \t\tif (selectedMediaType != null) {\n \t\t\tselectedMediaType = selectedMediaType.removeQualityValue();\n \t\t\tfor (HttpMessageConverter<?> messageConverter : this.messageConverters) {\n \t\t\t\tif (messageConverter.canWrite(returnValueClass, selectedMediaType)) {\n-\t\t\t\t\treturnValue = this.interceptorChain.invoke(returnValue, selectedMediaType,\n-\t\t\t\t\t\t\t(Class<HttpMessageConverter<T>>) messageConverter.getClass(),\n-\t\t\t\t\t\t\treturnType, inputMessage, outputMessage);\n+\t\t\t\t\treturnValue = this.interceptorChain.invoke(returnValue, returnType, selectedMediaType,\n+\t\t\t\t\t\t\t(Class<HttpMessageConverter<?>>) messageConverter.getClass(), inputMessage, outputMessage);\n \t\t\t\t\t((HttpMessageConverter<T>) messageConverter).write(returnValue, selectedMediaType, outputMessage);\n \t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\tlogger.debug(\"Written [\" + returnValue + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" +\n \t\t\t\t\t\t\t\tmessageConverter + \"]\");\n \t\t\t\t\t}\n \t\t\t\t\treturn;\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\tthrow new HttpMediaTypeNotAcceptableException(this.allSupportedMediaTypes);\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"51fc3b4aaf01a3d8f8f0f9ec98f5e5c1215cc096": {
			"type": "Ybodychange",
			"commitMessage": "Refactor @JsonView support w/ ResponseBodyInterceptor\n\nThe newly added support for ResponseBodyInterceptor is a good fit for\nthe (also recently added) support for the Jackson @JsonView annotation.\n\nThis change refactors the original implementation of @JsonView support\nfor @ResponseBody and ResponseEntity controller methods this time\nimplemented as an ResponseBodyInterceptor.\n\nIssue: SPR-7156\n",
			"commitDate": "2014-05-19, 12:47 PM",
			"commitName": "51fc3b4aaf01a3d8f8f0f9ec98f5e5c1215cc096",
			"commitAuthor": "Rossen Stoyanchev",
			"commitDateOld": "2014-05-19, 12:47 PM",
			"commitNameOld": "96b18c8dc22c0c57605a594b21ceec84ec16ee37",
			"commitAuthorOld": "Rossen Stoyanchev",
			"daysBetweenCommits": 0,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,65 +1,54 @@\n \tprotected <T> void writeWithMessageConverters(T returnValue, MethodParameter returnType,\n \t\t\tServletServerHttpRequest inputMessage, ServletServerHttpResponse outputMessage)\n \t\t\tthrows IOException, HttpMediaTypeNotAcceptableException {\n \n \t\tClass<?> returnValueClass = returnValue.getClass();\n \t\tHttpServletRequest servletRequest = inputMessage.getServletRequest();\n \t\tList<MediaType> requestedMediaTypes = getAcceptableMediaTypes(servletRequest);\n \t\tList<MediaType> producibleMediaTypes = getProducibleMediaTypes(servletRequest, returnValueClass);\n \n \t\tSet<MediaType> compatibleMediaTypes = new LinkedHashSet<MediaType>();\n \t\tfor (MediaType requestedType : requestedMediaTypes) {\n \t\t\tfor (MediaType producibleType : producibleMediaTypes) {\n \t\t\t\tif (requestedType.isCompatibleWith(producibleType)) {\n \t\t\t\t\tcompatibleMediaTypes.add(getMostSpecificMediaType(requestedType, producibleType));\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\tif (compatibleMediaTypes.isEmpty()) {\n \t\t\tthrow new HttpMediaTypeNotAcceptableException(producibleMediaTypes);\n \t\t}\n \n \t\tList<MediaType> mediaTypes = new ArrayList<MediaType>(compatibleMediaTypes);\n \t\tMediaType.sortBySpecificityAndQuality(mediaTypes);\n \n \t\tMediaType selectedMediaType = null;\n \t\tfor (MediaType mediaType : mediaTypes) {\n \t\t\tif (mediaType.isConcrete()) {\n \t\t\t\tselectedMediaType = mediaType;\n \t\t\t\tbreak;\n \t\t\t}\n \t\t\telse if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n \t\t\t\tselectedMediaType = MediaType.APPLICATION_OCTET_STREAM;\n \t\t\t\tbreak;\n \t\t\t}\n \t\t}\n \n \t\tif (selectedMediaType != null) {\n \t\t\tselectedMediaType = selectedMediaType.removeQualityValue();\n \t\t\tfor (HttpMessageConverter<?> messageConverter : this.messageConverters) {\n-\t\t\t\tif (messageConverter instanceof MethodParameterHttpMessageConverter) {\n-\t\t\t\t\tMethodParameterHttpMessageConverter<T> c = (MethodParameterHttpMessageConverter<T>) messageConverter;\n-\t\t\t\t\tif (c.canWrite(returnValueClass, selectedMediaType, returnType)) {\n-\t\t\t\t\t\tc.write(returnValue, selectedMediaType, outputMessage, returnType);\n-\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n-\t\t\t\t\t\t\tlogger.debug(\"Written [\" + returnValue + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" +\n-\t\t\t\t\t\t\t\t\tmessageConverter + \"]\");\n-\t\t\t\t\t\t}\n-\t\t\t\t\t\treturn;\n-\t\t\t\t\t}\n-\t\t\t\t}\n \t\t\t\tif (messageConverter.canWrite(returnValueClass, selectedMediaType)) {\n \t\t\t\t\treturnValue = this.interceptorChain.invoke(returnValue, selectedMediaType,\n \t\t\t\t\t\t\t(Class<HttpMessageConverter<T>>) messageConverter.getClass(),\n \t\t\t\t\t\t\treturnType, inputMessage, outputMessage);\n \t\t\t\t\t((HttpMessageConverter<T>) messageConverter).write(returnValue, selectedMediaType, outputMessage);\n \t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\tlogger.debug(\"Written [\" + returnValue + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" +\n \t\t\t\t\t\t\t\tmessageConverter + \"]\");\n \t\t\t\t\t}\n \t\t\t\t\treturn;\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\tthrow new HttpMediaTypeNotAcceptableException(this.allSupportedMediaTypes);\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"96b18c8dc22c0c57605a594b21ceec84ec16ee37": {
			"type": "Ybodychange",
			"commitMessage": "Add ResponseBodyInterceptor\n\nThis change introduces a new ResponseBodyInterceptor interface that can\nbe used to modify the response after @ResponseBody or ResponseEntity\nmethods but before the body is actually written to the response with the\nselected HttpMessageConverter.\n\nThe RequestMappingHandlerAdapter and ExceptionHandlerExceptionResolver\neach have a property to configure such interceptors. In addition both\nRequestMappingHandlerAdapter and ExceptionHandlerExceptionResolver\ndetect if any @ControllerAdvice bean implements ResponseBodyInterceptor\nand use it accordingly.\n\nIssue: SPR-10859\n",
			"commitDate": "2014-05-19, 12:47 PM",
			"commitName": "96b18c8dc22c0c57605a594b21ceec84ec16ee37",
			"commitAuthor": "Rossen Stoyanchev",
			"commitDateOld": "2014-05-15, 8:03 PM",
			"commitNameOld": "be0b69cbf1377e3fa8d8abc94f24274f4d0945b2",
			"commitAuthorOld": "Sebastien Deleuze",
			"daysBetweenCommits": 3.7,
			"commitsBetweenForRepo": 12,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,62 +1,65 @@\n \tprotected <T> void writeWithMessageConverters(T returnValue, MethodParameter returnType,\n \t\t\tServletServerHttpRequest inputMessage, ServletServerHttpResponse outputMessage)\n \t\t\tthrows IOException, HttpMediaTypeNotAcceptableException {\n \n \t\tClass<?> returnValueClass = returnValue.getClass();\n \t\tHttpServletRequest servletRequest = inputMessage.getServletRequest();\n \t\tList<MediaType> requestedMediaTypes = getAcceptableMediaTypes(servletRequest);\n \t\tList<MediaType> producibleMediaTypes = getProducibleMediaTypes(servletRequest, returnValueClass);\n \n \t\tSet<MediaType> compatibleMediaTypes = new LinkedHashSet<MediaType>();\n \t\tfor (MediaType requestedType : requestedMediaTypes) {\n \t\t\tfor (MediaType producibleType : producibleMediaTypes) {\n \t\t\t\tif (requestedType.isCompatibleWith(producibleType)) {\n \t\t\t\t\tcompatibleMediaTypes.add(getMostSpecificMediaType(requestedType, producibleType));\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\tif (compatibleMediaTypes.isEmpty()) {\n \t\t\tthrow new HttpMediaTypeNotAcceptableException(producibleMediaTypes);\n \t\t}\n \n \t\tList<MediaType> mediaTypes = new ArrayList<MediaType>(compatibleMediaTypes);\n \t\tMediaType.sortBySpecificityAndQuality(mediaTypes);\n \n \t\tMediaType selectedMediaType = null;\n \t\tfor (MediaType mediaType : mediaTypes) {\n \t\t\tif (mediaType.isConcrete()) {\n \t\t\t\tselectedMediaType = mediaType;\n \t\t\t\tbreak;\n \t\t\t}\n \t\t\telse if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n \t\t\t\tselectedMediaType = MediaType.APPLICATION_OCTET_STREAM;\n \t\t\t\tbreak;\n \t\t\t}\n \t\t}\n \n \t\tif (selectedMediaType != null) {\n \t\t\tselectedMediaType = selectedMediaType.removeQualityValue();\n \t\t\tfor (HttpMessageConverter<?> messageConverter : this.messageConverters) {\n \t\t\t\tif (messageConverter instanceof MethodParameterHttpMessageConverter) {\n \t\t\t\t\tMethodParameterHttpMessageConverter<T> c = (MethodParameterHttpMessageConverter<T>) messageConverter;\n \t\t\t\t\tif (c.canWrite(returnValueClass, selectedMediaType, returnType)) {\n \t\t\t\t\t\tc.write(returnValue, selectedMediaType, outputMessage, returnType);\n \t\t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\t\tlogger.debug(\"Written [\" + returnValue + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" +\n \t\t\t\t\t\t\t\t\tmessageConverter + \"]\");\n \t\t\t\t\t\t}\n \t\t\t\t\t\treturn;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tif (messageConverter.canWrite(returnValueClass, selectedMediaType)) {\n+\t\t\t\t\treturnValue = this.interceptorChain.invoke(returnValue, selectedMediaType,\n+\t\t\t\t\t\t\t(Class<HttpMessageConverter<T>>) messageConverter.getClass(),\n+\t\t\t\t\t\t\treturnType, inputMessage, outputMessage);\n \t\t\t\t\t((HttpMessageConverter<T>) messageConverter).write(returnValue, selectedMediaType, outputMessage);\n \t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\tlogger.debug(\"Written [\" + returnValue + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" +\n \t\t\t\t\t\t\t\tmessageConverter + \"]\");\n \t\t\t\t\t}\n \t\t\t\t\treturn;\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\tthrow new HttpMediaTypeNotAcceptableException(this.allSupportedMediaTypes);\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"be0b69cbf1377e3fa8d8abc94f24274f4d0945b2": {
			"type": "Ybodychange",
			"commitMessage": "Add support for Jackson serialization views\n\nSpring MVC now supports Jackon's serialization views for rendering\ndifferent subsets of the same POJO from different controller\nmethods (e.g. detailed page vs summary view).\n\nIssue: SPR-7156\n",
			"commitDate": "2014-05-15, 8:03 PM",
			"commitName": "be0b69cbf1377e3fa8d8abc94f24274f4d0945b2",
			"commitAuthor": "Sebastien Deleuze",
			"commitDateOld": "2014-04-23, 2:03 PM",
			"commitNameOld": "ec7d80b8519332ffb5f0595dddc9ef52de532730",
			"commitAuthorOld": "Juergen Hoeller",
			"daysBetweenCommits": 22.25,
			"commitsBetweenForRepo": 106,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,51 +1,62 @@\n \tprotected <T> void writeWithMessageConverters(T returnValue, MethodParameter returnType,\n \t\t\tServletServerHttpRequest inputMessage, ServletServerHttpResponse outputMessage)\n \t\t\tthrows IOException, HttpMediaTypeNotAcceptableException {\n \n \t\tClass<?> returnValueClass = returnValue.getClass();\n \t\tHttpServletRequest servletRequest = inputMessage.getServletRequest();\n \t\tList<MediaType> requestedMediaTypes = getAcceptableMediaTypes(servletRequest);\n \t\tList<MediaType> producibleMediaTypes = getProducibleMediaTypes(servletRequest, returnValueClass);\n \n \t\tSet<MediaType> compatibleMediaTypes = new LinkedHashSet<MediaType>();\n \t\tfor (MediaType requestedType : requestedMediaTypes) {\n \t\t\tfor (MediaType producibleType : producibleMediaTypes) {\n \t\t\t\tif (requestedType.isCompatibleWith(producibleType)) {\n \t\t\t\t\tcompatibleMediaTypes.add(getMostSpecificMediaType(requestedType, producibleType));\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\tif (compatibleMediaTypes.isEmpty()) {\n \t\t\tthrow new HttpMediaTypeNotAcceptableException(producibleMediaTypes);\n \t\t}\n \n \t\tList<MediaType> mediaTypes = new ArrayList<MediaType>(compatibleMediaTypes);\n \t\tMediaType.sortBySpecificityAndQuality(mediaTypes);\n \n \t\tMediaType selectedMediaType = null;\n \t\tfor (MediaType mediaType : mediaTypes) {\n \t\t\tif (mediaType.isConcrete()) {\n \t\t\t\tselectedMediaType = mediaType;\n \t\t\t\tbreak;\n \t\t\t}\n \t\t\telse if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n \t\t\t\tselectedMediaType = MediaType.APPLICATION_OCTET_STREAM;\n \t\t\t\tbreak;\n \t\t\t}\n \t\t}\n \n \t\tif (selectedMediaType != null) {\n \t\t\tselectedMediaType = selectedMediaType.removeQualityValue();\n \t\t\tfor (HttpMessageConverter<?> messageConverter : this.messageConverters) {\n+\t\t\t\tif (messageConverter instanceof MethodParameterHttpMessageConverter) {\n+\t\t\t\t\tMethodParameterHttpMessageConverter<T> c = (MethodParameterHttpMessageConverter<T>) messageConverter;\n+\t\t\t\t\tif (c.canWrite(returnValueClass, selectedMediaType, returnType)) {\n+\t\t\t\t\t\tc.write(returnValue, selectedMediaType, outputMessage, returnType);\n+\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n+\t\t\t\t\t\t\tlogger.debug(\"Written [\" + returnValue + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" +\n+\t\t\t\t\t\t\t\t\tmessageConverter + \"]\");\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\treturn;\n+\t\t\t\t\t}\n+\t\t\t\t}\n \t\t\t\tif (messageConverter.canWrite(returnValueClass, selectedMediaType)) {\n \t\t\t\t\t((HttpMessageConverter<T>) messageConverter).write(returnValue, selectedMediaType, outputMessage);\n \t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\tlogger.debug(\"Written [\" + returnValue + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" +\n \t\t\t\t\t\t\t\tmessageConverter + \"]\");\n \t\t\t\t\t}\n \t\t\t\t\treturn;\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\tthrow new HttpMediaTypeNotAcceptableException(this.allSupportedMediaTypes);\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"ec7d80b8519332ffb5f0595dddc9ef52de532730": {
			"type": "Ybodychange",
			"commitMessage": "Polishing\n",
			"commitDate": "2014-04-23, 2:03 PM",
			"commitName": "ec7d80b8519332ffb5f0595dddc9ef52de532730",
			"commitAuthor": "Juergen Hoeller",
			"commitDateOld": "2013-01-21, 9:34 AM",
			"commitNameOld": "e4fcad9f936ba492f28ec5f0421eea4b3f76f8aa",
			"commitAuthorOld": "Rossen Stoyanchev",
			"daysBetweenCommits": 457.15,
			"commitsBetweenForRepo": 2032,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,54 +1,51 @@\n-\tprotected <T> void writeWithMessageConverters(T returnValue,\n-\t\t\t\t\t\t\t\t\t\t\t\tMethodParameter returnType,\n-\t\t\t\t\t\t\t\t\t\t\t\tServletServerHttpRequest inputMessage,\n-\t\t\t\t\t\t\t\t\t\t\t\tServletServerHttpResponse outputMessage)\n+\tprotected <T> void writeWithMessageConverters(T returnValue, MethodParameter returnType,\n+\t\t\tServletServerHttpRequest inputMessage, ServletServerHttpResponse outputMessage)\n \t\t\tthrows IOException, HttpMediaTypeNotAcceptableException {\n \n \t\tClass<?> returnValueClass = returnValue.getClass();\n-\n \t\tHttpServletRequest servletRequest = inputMessage.getServletRequest();\n \t\tList<MediaType> requestedMediaTypes = getAcceptableMediaTypes(servletRequest);\n \t\tList<MediaType> producibleMediaTypes = getProducibleMediaTypes(servletRequest, returnValueClass);\n \n \t\tSet<MediaType> compatibleMediaTypes = new LinkedHashSet<MediaType>();\n-\t\tfor (MediaType r : requestedMediaTypes) {\n-\t\t\tfor (MediaType p : producibleMediaTypes) {\n-\t\t\t\tif (r.isCompatibleWith(p)) {\n-\t\t\t\t\tcompatibleMediaTypes.add(getMostSpecificMediaType(r, p));\n+\t\tfor (MediaType requestedType : requestedMediaTypes) {\n+\t\t\tfor (MediaType producibleType : producibleMediaTypes) {\n+\t\t\t\tif (requestedType.isCompatibleWith(producibleType)) {\n+\t\t\t\t\tcompatibleMediaTypes.add(getMostSpecificMediaType(requestedType, producibleType));\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\tif (compatibleMediaTypes.isEmpty()) {\n \t\t\tthrow new HttpMediaTypeNotAcceptableException(producibleMediaTypes);\n \t\t}\n \n \t\tList<MediaType> mediaTypes = new ArrayList<MediaType>(compatibleMediaTypes);\n \t\tMediaType.sortBySpecificityAndQuality(mediaTypes);\n \n \t\tMediaType selectedMediaType = null;\n \t\tfor (MediaType mediaType : mediaTypes) {\n \t\t\tif (mediaType.isConcrete()) {\n \t\t\t\tselectedMediaType = mediaType;\n \t\t\t\tbreak;\n \t\t\t}\n \t\t\telse if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n \t\t\t\tselectedMediaType = MediaType.APPLICATION_OCTET_STREAM;\n \t\t\t\tbreak;\n \t\t\t}\n \t\t}\n \n \t\tif (selectedMediaType != null) {\n \t\t\tselectedMediaType = selectedMediaType.removeQualityValue();\n-\t\t\tfor (HttpMessageConverter<?> messageConverter : messageConverters) {\n+\t\t\tfor (HttpMessageConverter<?> messageConverter : this.messageConverters) {\n \t\t\t\tif (messageConverter.canWrite(returnValueClass, selectedMediaType)) {\n \t\t\t\t\t((HttpMessageConverter<T>) messageConverter).write(returnValue, selectedMediaType, outputMessage);\n \t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\tlogger.debug(\"Written [\" + returnValue + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" +\n \t\t\t\t\t\t\t\tmessageConverter + \"]\");\n \t\t\t\t\t}\n \t\t\t\t\treturn;\n \t\t\t\t}\n \t\t\t}\n \t\t}\n-\t\tthrow new HttpMediaTypeNotAcceptableException(allSupportedMediaTypes);\n+\t\tthrow new HttpMediaTypeNotAcceptableException(this.allSupportedMediaTypes);\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"e4fcad9f936ba492f28ec5f0421eea4b3f76f8aa": {
			"type": "Ybodychange",
			"commitMessage": "Fix exception message about producible media types\n\nIssue: SPR-10175\n",
			"commitDate": "2013-01-21, 9:34 AM",
			"commitName": "e4fcad9f936ba492f28ec5f0421eea4b3f76f8aa",
			"commitAuthor": "Rossen Stoyanchev",
			"commitDateOld": "2012-12-28, 11:49 AM",
			"commitNameOld": "2cf45bad860f560d3a5806eb23ffe1669e907673",
			"commitAuthorOld": "Phillip Webb",
			"daysBetweenCommits": 23.91,
			"commitsBetweenForRepo": 144,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,54 +1,54 @@\n \tprotected <T> void writeWithMessageConverters(T returnValue,\n \t\t\t\t\t\t\t\t\t\t\t\tMethodParameter returnType,\n \t\t\t\t\t\t\t\t\t\t\t\tServletServerHttpRequest inputMessage,\n \t\t\t\t\t\t\t\t\t\t\t\tServletServerHttpResponse outputMessage)\n \t\t\tthrows IOException, HttpMediaTypeNotAcceptableException {\n \n \t\tClass<?> returnValueClass = returnValue.getClass();\n \n \t\tHttpServletRequest servletRequest = inputMessage.getServletRequest();\n \t\tList<MediaType> requestedMediaTypes = getAcceptableMediaTypes(servletRequest);\n \t\tList<MediaType> producibleMediaTypes = getProducibleMediaTypes(servletRequest, returnValueClass);\n \n \t\tSet<MediaType> compatibleMediaTypes = new LinkedHashSet<MediaType>();\n \t\tfor (MediaType r : requestedMediaTypes) {\n \t\t\tfor (MediaType p : producibleMediaTypes) {\n \t\t\t\tif (r.isCompatibleWith(p)) {\n \t\t\t\t\tcompatibleMediaTypes.add(getMostSpecificMediaType(r, p));\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\tif (compatibleMediaTypes.isEmpty()) {\n-\t\t\tthrow new HttpMediaTypeNotAcceptableException(allSupportedMediaTypes);\n+\t\t\tthrow new HttpMediaTypeNotAcceptableException(producibleMediaTypes);\n \t\t}\n \n \t\tList<MediaType> mediaTypes = new ArrayList<MediaType>(compatibleMediaTypes);\n \t\tMediaType.sortBySpecificityAndQuality(mediaTypes);\n \n \t\tMediaType selectedMediaType = null;\n \t\tfor (MediaType mediaType : mediaTypes) {\n \t\t\tif (mediaType.isConcrete()) {\n \t\t\t\tselectedMediaType = mediaType;\n \t\t\t\tbreak;\n \t\t\t}\n \t\t\telse if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n \t\t\t\tselectedMediaType = MediaType.APPLICATION_OCTET_STREAM;\n \t\t\t\tbreak;\n \t\t\t}\n \t\t}\n \n \t\tif (selectedMediaType != null) {\n \t\t\tselectedMediaType = selectedMediaType.removeQualityValue();\n \t\t\tfor (HttpMessageConverter<?> messageConverter : messageConverters) {\n \t\t\t\tif (messageConverter.canWrite(returnValueClass, selectedMediaType)) {\n \t\t\t\t\t((HttpMessageConverter<T>) messageConverter).write(returnValue, selectedMediaType, outputMessage);\n \t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\tlogger.debug(\"Written [\" + returnValue + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" +\n \t\t\t\t\t\t\t\tmessageConverter + \"]\");\n \t\t\t\t\t}\n \t\t\t\t\treturn;\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\tthrow new HttpMediaTypeNotAcceptableException(allSupportedMediaTypes);\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"d4fa5c0331e5a8008dae2f6f0ba157bdddaf122d": {
			"type": "Ybodychange",
			"commitMessage": "Fix NPE in AbstractMessageConverterMethodProcessor\n\nIssue: SPR-9868\n",
			"commitDate": "2012-10-10, 6:00 AM",
			"commitName": "d4fa5c0331e5a8008dae2f6f0ba157bdddaf122d",
			"commitAuthor": "Rossen Stoyanchev",
			"commitDateOld": "2012-06-22, 8:55 AM",
			"commitNameOld": "f05e2bc56f8e03466977d73a5e99c37651248803",
			"commitAuthorOld": "Rossen Stoyanchev",
			"daysBetweenCommits": 109.88,
			"commitsBetweenForRepo": 213,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,55 +1,54 @@\n \tprotected <T> void writeWithMessageConverters(T returnValue,\n \t\t\t\t\t\t\t\t\t\t\t\t  MethodParameter returnType,\n \t\t\t\t\t\t\t\t\t\t\t\t  ServletServerHttpRequest inputMessage,\n \t\t\t\t\t\t\t\t\t\t\t\t  ServletServerHttpResponse outputMessage)\n \t\t\tthrows IOException, HttpMediaTypeNotAcceptableException {\n \n \t\tClass<?> returnValueClass = returnValue.getClass();\n \n \t\tHttpServletRequest servletRequest = inputMessage.getServletRequest();\n \t\tList<MediaType> requestedMediaTypes = getAcceptableMediaTypes(servletRequest);\n \t\tList<MediaType> producibleMediaTypes = getProducibleMediaTypes(servletRequest, returnValueClass);\n \n \t\tSet<MediaType> compatibleMediaTypes = new LinkedHashSet<MediaType>();\n \t\tfor (MediaType r : requestedMediaTypes) {\n \t\t\tfor (MediaType p : producibleMediaTypes) {\n \t\t\t\tif (r.isCompatibleWith(p)) {\n \t\t\t\t\tcompatibleMediaTypes.add(getMostSpecificMediaType(r, p));\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\tif (compatibleMediaTypes.isEmpty()) {\n \t\t\tthrow new HttpMediaTypeNotAcceptableException(allSupportedMediaTypes);\n \t\t}\n \n \t\tList<MediaType> mediaTypes = new ArrayList<MediaType>(compatibleMediaTypes);\n \t\tMediaType.sortBySpecificityAndQuality(mediaTypes);\n \n \t\tMediaType selectedMediaType = null;\n \t\tfor (MediaType mediaType : mediaTypes) {\n \t\t\tif (mediaType.isConcrete()) {\n \t\t\t\tselectedMediaType = mediaType;\n \t\t\t\tbreak;\n \t\t\t}\n \t\t\telse if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n \t\t\t\tselectedMediaType = MediaType.APPLICATION_OCTET_STREAM;\n \t\t\t\tbreak;\n \t\t\t}\n \t\t}\n \n-\t\tselectedMediaType = selectedMediaType.removeQualityValue();\n-\n \t\tif (selectedMediaType != null) {\n+\t\t\tselectedMediaType = selectedMediaType.removeQualityValue();\n \t\t\tfor (HttpMessageConverter<?> messageConverter : messageConverters) {\n \t\t\t\tif (messageConverter.canWrite(returnValueClass, selectedMediaType)) {\n \t\t\t\t\t((HttpMessageConverter<T>) messageConverter).write(returnValue, selectedMediaType, outputMessage);\n \t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\tlogger.debug(\"Written [\" + returnValue + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" +\n \t\t\t\t\t\t\t\tmessageConverter + \"]\");\n \t\t\t\t\t}\n \t\t\t\t\treturn;\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\tthrow new HttpMediaTypeNotAcceptableException(allSupportedMediaTypes);\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"f05e2bc56f8e03466977d73a5e99c37651248803": {
			"type": "Ybodychange",
			"commitMessage": "Add abstractions for content negotiation\n\nIntroduced ContentNeogtiationStrategy for resolving the requested\nmedia types from an incoming request. The available implementations\nare based on path extension, request parameter, 'Accept' header,\nand a fixed default content type. The logic for these implementations\nis based on equivalent options, previously available only in the\nContentNegotiatingViewResolver.\n\nAlso in this commit is ContentNegotiationManager, the central class to\nuse when configuring content negotiation options. It accepts one or\nmore ContentNeogtiationStrategy instances and delegates to them.\n\nThe ContentNeogiationManager can now be used to configure the\nfollowing classes:\n\n- RequestMappingHandlerMappingm\n- RequestMappingHandlerAdapter\n- ExceptionHandlerExceptionResolver\n- ContentNegotiatingViewResolver\n\nIssue: SPR-8410, SPR-8417, SPR-8418,SPR-8416, SPR-8419,SPR-7722\n",
			"commitDate": "2012-06-22, 8:55 AM",
			"commitName": "f05e2bc56f8e03466977d73a5e99c37651248803",
			"commitAuthor": "Rossen Stoyanchev",
			"commitDateOld": "2012-05-11, 11:43 AM",
			"commitNameOld": "982cb2f258a5be1173115044d379f54702dc8c5b",
			"commitAuthorOld": "Rossen Stoyanchev",
			"daysBetweenCommits": 41.88,
			"commitsBetweenForRepo": 117,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,54 +1,55 @@\n \tprotected <T> void writeWithMessageConverters(T returnValue,\n \t\t\t\t\t\t\t\t\t\t\t\t  MethodParameter returnType,\n \t\t\t\t\t\t\t\t\t\t\t\t  ServletServerHttpRequest inputMessage,\n \t\t\t\t\t\t\t\t\t\t\t\t  ServletServerHttpResponse outputMessage)\n \t\t\tthrows IOException, HttpMediaTypeNotAcceptableException {\n \n \t\tClass<?> returnValueClass = returnValue.getClass();\n \n-\t\tList<MediaType> acceptableMediaTypes = getAcceptableMediaTypes(inputMessage);\n-\t\tList<MediaType> producibleMediaTypes = getProducibleMediaTypes(inputMessage.getServletRequest(), returnValueClass);\n+\t\tHttpServletRequest servletRequest = inputMessage.getServletRequest();\n+\t\tList<MediaType> requestedMediaTypes = getAcceptableMediaTypes(servletRequest);\n+\t\tList<MediaType> producibleMediaTypes = getProducibleMediaTypes(servletRequest, returnValueClass);\n \n \t\tSet<MediaType> compatibleMediaTypes = new LinkedHashSet<MediaType>();\n-\t\tfor (MediaType a : acceptableMediaTypes) {\n+\t\tfor (MediaType r : requestedMediaTypes) {\n \t\t\tfor (MediaType p : producibleMediaTypes) {\n-\t\t\t\tif (a.isCompatibleWith(p)) {\n-\t\t\t\t\tcompatibleMediaTypes.add(getMostSpecificMediaType(a, p));\n+\t\t\t\tif (r.isCompatibleWith(p)) {\n+\t\t\t\t\tcompatibleMediaTypes.add(getMostSpecificMediaType(r, p));\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\tif (compatibleMediaTypes.isEmpty()) {\n \t\t\tthrow new HttpMediaTypeNotAcceptableException(allSupportedMediaTypes);\n \t\t}\n \n \t\tList<MediaType> mediaTypes = new ArrayList<MediaType>(compatibleMediaTypes);\n \t\tMediaType.sortBySpecificityAndQuality(mediaTypes);\n \n \t\tMediaType selectedMediaType = null;\n \t\tfor (MediaType mediaType : mediaTypes) {\n \t\t\tif (mediaType.isConcrete()) {\n \t\t\t\tselectedMediaType = mediaType;\n \t\t\t\tbreak;\n \t\t\t}\n \t\t\telse if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n \t\t\t\tselectedMediaType = MediaType.APPLICATION_OCTET_STREAM;\n \t\t\t\tbreak;\n \t\t\t}\n \t\t}\n \n \t\tselectedMediaType = selectedMediaType.removeQualityValue();\n \n \t\tif (selectedMediaType != null) {\n \t\t\tfor (HttpMessageConverter<?> messageConverter : messageConverters) {\n \t\t\t\tif (messageConverter.canWrite(returnValueClass, selectedMediaType)) {\n \t\t\t\t\t((HttpMessageConverter<T>) messageConverter).write(returnValue, selectedMediaType, outputMessage);\n \t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\tlogger.debug(\"Written [\" + returnValue + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" +\n \t\t\t\t\t\t\t\tmessageConverter + \"]\");\n \t\t\t\t\t}\n \t\t\t\t\treturn;\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\tthrow new HttpMediaTypeNotAcceptableException(allSupportedMediaTypes);\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"982cb2f258a5be1173115044d379f54702dc8c5b": {
			"type": "Ybodychange",
			"commitMessage": "Fix content negotiation issue with sort by q-value\n\nBefore this fix the q-value of media types in the Accept header were\nignored when using the new RequestMappingHandlerAdapter in combination\nwith @ResponseBody and HttpMessageConverters.\n\nIssue: SPR-9160\n",
			"commitDate": "2012-05-11, 11:43 AM",
			"commitName": "982cb2f258a5be1173115044d379f54702dc8c5b",
			"commitAuthor": "Rossen Stoyanchev",
			"commitDateOld": "2012-04-02, 2:36 PM",
			"commitNameOld": "ca8b98e94724cd9a2008deb4fe1280aaace6ca8b",
			"commitAuthorOld": "Rossen Stoyanchev",
			"daysBetweenCommits": 38.88,
			"commitsBetweenForRepo": 35,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,52 +1,54 @@\n \tprotected <T> void writeWithMessageConverters(T returnValue,\n \t\t\t\t\t\t\t\t\t\t\t\t  MethodParameter returnType,\n \t\t\t\t\t\t\t\t\t\t\t\t  ServletServerHttpRequest inputMessage,\n \t\t\t\t\t\t\t\t\t\t\t\t  ServletServerHttpResponse outputMessage)\n \t\t\tthrows IOException, HttpMediaTypeNotAcceptableException {\n \n \t\tClass<?> returnValueClass = returnValue.getClass();\n \n \t\tList<MediaType> acceptableMediaTypes = getAcceptableMediaTypes(inputMessage);\n \t\tList<MediaType> producibleMediaTypes = getProducibleMediaTypes(inputMessage.getServletRequest(), returnValueClass);\n \n \t\tSet<MediaType> compatibleMediaTypes = new LinkedHashSet<MediaType>();\n \t\tfor (MediaType a : acceptableMediaTypes) {\n \t\t\tfor (MediaType p : producibleMediaTypes) {\n \t\t\t\tif (a.isCompatibleWith(p)) {\n \t\t\t\t\tcompatibleMediaTypes.add(getMostSpecificMediaType(a, p));\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\tif (compatibleMediaTypes.isEmpty()) {\n \t\t\tthrow new HttpMediaTypeNotAcceptableException(allSupportedMediaTypes);\n \t\t}\n \n \t\tList<MediaType> mediaTypes = new ArrayList<MediaType>(compatibleMediaTypes);\n-\t\tMediaType.sortBySpecificity(mediaTypes);\n+\t\tMediaType.sortBySpecificityAndQuality(mediaTypes);\n \n \t\tMediaType selectedMediaType = null;\n \t\tfor (MediaType mediaType : mediaTypes) {\n \t\t\tif (mediaType.isConcrete()) {\n \t\t\t\tselectedMediaType = mediaType;\n \t\t\t\tbreak;\n \t\t\t}\n \t\t\telse if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n \t\t\t\tselectedMediaType = MediaType.APPLICATION_OCTET_STREAM;\n \t\t\t\tbreak;\n \t\t\t}\n \t\t}\n \n+\t\tselectedMediaType = selectedMediaType.removeQualityValue();\n+\n \t\tif (selectedMediaType != null) {\n \t\t\tfor (HttpMessageConverter<?> messageConverter : messageConverters) {\n \t\t\t\tif (messageConverter.canWrite(returnValueClass, selectedMediaType)) {\n \t\t\t\t\t((HttpMessageConverter<T>) messageConverter).write(returnValue, selectedMediaType, outputMessage);\n \t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\tlogger.debug(\"Written [\" + returnValue + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" +\n \t\t\t\t\t\t\t\tmessageConverter + \"]\");\n \t\t\t\t\t}\n \t\t\t\t\treturn;\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\tthrow new HttpMediaTypeNotAcceptableException(allSupportedMediaTypes);\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"02a4473c62d8240837bec297f0a1f3cb67ef8a7b": {
			"type": "Yfilerename",
			"commitMessage": "Rename modules {org.springframework.*=>spring-*}\n\nThis renaming more intuitively expresses the relationship between\nsubprojects and the JAR artifacts they produce.\n\nTracking history across these renames is possible, but it requires\nuse of the --follow flag to `git log`, for example\n\n    $ git log spring-aop/src/main/java/org/springframework/aop/Advisor.java\n\nwill show history up until the renaming event, where\n\n    $ git log --follow spring-aop/src/main/java/org/springframework/aop/Advisor.java\n\nwill show history for all changes to the file, before and after the\nrenaming.\n\nSee http://chrisbeams.com/git-diff-across-renamed-directories\n",
			"commitDate": "2012-01-31, 5:37 AM",
			"commitName": "02a4473c62d8240837bec297f0a1f3cb67ef8a7b",
			"commitAuthor": "Chris Beams",
			"commitDateOld": "2012-01-31, 5:37 AM",
			"commitNameOld": "b6cb514d383dcef52ba6c609a863f19e1a4c1faf",
			"commitAuthorOld": "Chris Beams",
			"daysBetweenCommits": 0,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "",
			"extendedDetails": {
				"oldPath": "org.springframework.web.servlet/src/main/java/org/springframework/web/servlet/mvc/method/annotation/AbstractMessageConverterMethodProcessor.java",
				"newPath": "spring-webmvc/src/main/java/org/springframework/web/servlet/mvc/method/annotation/AbstractMessageConverterMethodProcessor.java"
			}
		},
		"1c45c51fe10bd3739d4b4c938a288ee3ebbf0f54": {
			"type": "Yfilerename",
			"commitMessage": "overhaul of support package arrangements for handler method processing; added missing package-info files\n",
			"commitDate": "2011-12-12, 3:20 PM",
			"commitName": "1c45c51fe10bd3739d4b4c938a288ee3ebbf0f54",
			"commitAuthor": "Juergen Hoeller",
			"commitDateOld": "2011-12-12, 11:20 AM",
			"commitNameOld": "2065b788c4961e09cbafc4f52d91177db07b9285",
			"commitAuthorOld": "Chris Beams",
			"daysBetweenCommits": 0.17,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "",
			"extendedDetails": {
				"oldPath": "org.springframework.web.servlet/src/main/java/org/springframework/web/servlet/mvc/method/annotation/support/AbstractMessageConverterMethodProcessor.java",
				"newPath": "org.springframework.web.servlet/src/main/java/org/springframework/web/servlet/mvc/method/annotation/AbstractMessageConverterMethodProcessor.java"
			}
		},
		"c5833b192e3f3a280f8c63a9c45ca96776415a6b": {
			"type": "Ybodychange",
			"commitMessage": "SPR-7353 Use canWrite to narrow down list of producible types\n",
			"commitDate": "2011-05-24, 10:22 AM",
			"commitName": "c5833b192e3f3a280f8c63a9c45ca96776415a6b",
			"commitAuthor": "Rossen Stoyanchev",
			"commitDateOld": "2011-05-20, 10:02 AM",
			"commitNameOld": "5fa7f24794cc23cd0a803d8d49024d34f7df328b",
			"commitAuthorOld": "Rossen Stoyanchev",
			"daysBetweenCommits": 4.01,
			"commitsBetweenForRepo": 17,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,50 +1,52 @@\n \tprotected <T> void writeWithMessageConverters(T returnValue,\n \t\t\t\t\t\t\t\t\t\t\t\t  MethodParameter returnType,\n \t\t\t\t\t\t\t\t\t\t\t\t  ServletServerHttpRequest inputMessage,\n \t\t\t\t\t\t\t\t\t\t\t\t  ServletServerHttpResponse outputMessage)\n \t\t\tthrows IOException, HttpMediaTypeNotAcceptableException {\n \n+\t\tClass<?> returnValueClass = returnValue.getClass();\n+\n \t\tList<MediaType> acceptableMediaTypes = getAcceptableMediaTypes(inputMessage);\n-\t\tList<MediaType> producibleMediaTypes = getProducibleMediaTypes(inputMessage.getServletRequest());\n+\t\tList<MediaType> producibleMediaTypes = getProducibleMediaTypes(inputMessage.getServletRequest(), returnValueClass);\n \t\t\n \t\tSet<MediaType> compatibleMediaTypes = new LinkedHashSet<MediaType>();\n \t\tfor (MediaType a : acceptableMediaTypes) {\n \t\t\tfor (MediaType p : producibleMediaTypes) {\n \t\t\t\tif (a.isCompatibleWith(p)) {\n \t\t\t\t\tcompatibleMediaTypes.add(getMostSpecificMediaType(a, p));\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\tif (compatibleMediaTypes.isEmpty()) {\n \t\t\tthrow new HttpMediaTypeNotAcceptableException(allSupportedMediaTypes);\n \t\t}\n \t\t\n \t\tList<MediaType> mediaTypes = new ArrayList<MediaType>(compatibleMediaTypes);\n \t\tMediaType.sortBySpecificity(mediaTypes);\n \t\t\n \t\tMediaType selectedMediaType = null;\n \t\tfor (MediaType mediaType : mediaTypes) {\n \t\t\tif (mediaType.isConcrete()) {\n \t\t\t\tselectedMediaType = mediaType;\n \t\t\t\tbreak;\n \t\t\t}\n \t\t\telse if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n \t\t\t\tselectedMediaType = MediaType.APPLICATION_OCTET_STREAM;\n \t\t\t\tbreak;\n \t\t\t}\n \t\t}\n \t\t\n \t\tif (selectedMediaType != null) {\n \t\t\tfor (HttpMessageConverter<?> messageConverter : messageConverters) {\n-\t\t\t\tif (messageConverter.canWrite(returnValue.getClass(), selectedMediaType)) {\n+\t\t\t\tif (messageConverter.canWrite(returnValueClass, selectedMediaType)) {\n \t\t\t\t\t((HttpMessageConverter<T>) messageConverter).write(returnValue, selectedMediaType, outputMessage);\n \t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\tlogger.debug(\"Written [\" + returnValue + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" +\n \t\t\t\t\t\t\t\tmessageConverter + \"]\");\n \t\t\t\t\t}\n \t\t\t\t\treturn;\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\tthrow new HttpMediaTypeNotAcceptableException(allSupportedMediaTypes);\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"5fa7f24794cc23cd0a803d8d49024d34f7df328b": {
			"type": "Ybodychange",
			"commitMessage": "SPR-7353 Respect 'produces' condition in ContentNegotiatingViewResolver, improve selection of more specific media type in a pair\n",
			"commitDate": "2011-05-20, 10:02 AM",
			"commitName": "5fa7f24794cc23cd0a803d8d49024d34f7df328b",
			"commitAuthor": "Rossen Stoyanchev",
			"commitDateOld": "2011-05-18, 4:34 AM",
			"commitNameOld": "1eaca6572091c014379e453299773e880a7766b9",
			"commitAuthorOld": "Arjen Poutsma",
			"daysBetweenCommits": 2.23,
			"commitsBetweenForRepo": 16,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,47 +1,50 @@\n \tprotected <T> void writeWithMessageConverters(T returnValue,\n \t\t\t\t\t\t\t\t\t\t\t\t  MethodParameter returnType,\n \t\t\t\t\t\t\t\t\t\t\t\t  ServletServerHttpRequest inputMessage,\n \t\t\t\t\t\t\t\t\t\t\t\t  ServletServerHttpResponse outputMessage)\n \t\t\tthrows IOException, HttpMediaTypeNotAcceptableException {\n \n-\n-\t\tSet<MediaType> acceptableMediaTypes = getAcceptableMediaTypes(inputMessage);\n-\t\tSet<MediaType> producibleMediaTypes = getProducibleMediaTypes(inputMessage.getServletRequest());\n-\n-\t\tList<MediaType> mediaTypes = new ArrayList<MediaType>();\n-\t\tfor (MediaType acceptableMediaType : acceptableMediaTypes) {\n-\t\t\tfor (MediaType producibleMediaType : producibleMediaTypes) {\n-\t\t\t\tif (acceptableMediaType.isCompatibleWith(producibleMediaType)) {\n-\t\t\t\t\tmediaTypes.add(getMostSpecificMediaType(acceptableMediaType, producibleMediaType));\n+\t\tList<MediaType> acceptableMediaTypes = getAcceptableMediaTypes(inputMessage);\n+\t\tList<MediaType> producibleMediaTypes = getProducibleMediaTypes(inputMessage.getServletRequest());\n+\t\t\n+\t\tSet<MediaType> compatibleMediaTypes = new LinkedHashSet<MediaType>();\n+\t\tfor (MediaType a : acceptableMediaTypes) {\n+\t\t\tfor (MediaType p : producibleMediaTypes) {\n+\t\t\t\tif (a.isCompatibleWith(p)) {\n+\t\t\t\t\tcompatibleMediaTypes.add(getMostSpecificMediaType(a, p));\n \t\t\t\t}\n \t\t\t}\n \t\t}\n-\t\tif (mediaTypes.isEmpty()) {\n+\t\tif (compatibleMediaTypes.isEmpty()) {\n \t\t\tthrow new HttpMediaTypeNotAcceptableException(allSupportedMediaTypes);\n \t\t}\n+\t\t\n+\t\tList<MediaType> mediaTypes = new ArrayList<MediaType>(compatibleMediaTypes);\n \t\tMediaType.sortBySpecificity(mediaTypes);\n+\t\t\n \t\tMediaType selectedMediaType = null;\n \t\tfor (MediaType mediaType : mediaTypes) {\n \t\t\tif (mediaType.isConcrete()) {\n \t\t\t\tselectedMediaType = mediaType;\n \t\t\t\tbreak;\n \t\t\t}\n \t\t\telse if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n \t\t\t\tselectedMediaType = MediaType.APPLICATION_OCTET_STREAM;\n \t\t\t\tbreak;\n \t\t\t}\n \t\t}\n+\t\t\n \t\tif (selectedMediaType != null) {\n \t\t\tfor (HttpMessageConverter<?> messageConverter : messageConverters) {\n \t\t\t\tif (messageConverter.canWrite(returnValue.getClass(), selectedMediaType)) {\n \t\t\t\t\t((HttpMessageConverter<T>) messageConverter).write(returnValue, selectedMediaType, outputMessage);\n \t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\tlogger.debug(\"Written [\" + returnValue + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" +\n \t\t\t\t\t\t\t\tmessageConverter + \"]\");\n \t\t\t\t\t}\n \t\t\t\t\treturn;\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\tthrow new HttpMediaTypeNotAcceptableException(allSupportedMediaTypes);\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"1eaca6572091c014379e453299773e880a7766b9": {
			"type": "Ymultichange(Yparameterchange,Ybodychange)",
			"commitMessage": "@RequestMapping.consumes() and produces() now default to an empty array, instead of */*\n",
			"commitDate": "2011-05-18, 4:34 AM",
			"commitName": "1eaca6572091c014379e453299773e880a7766b9",
			"commitAuthor": "Arjen Poutsma",
			"subchanges": [
				{
					"type": "Yparameterchange",
					"commitMessage": "@RequestMapping.consumes() and produces() now default to an empty array, instead of */*\n",
					"commitDate": "2011-05-18, 4:34 AM",
					"commitName": "1eaca6572091c014379e453299773e880a7766b9",
					"commitAuthor": "Arjen Poutsma",
					"commitDateOld": "2011-05-17, 6:02 AM",
					"commitNameOld": "af1dfd357743e6f4d5b9589ddb584f472a699e41",
					"commitAuthorOld": "Rossen Stoyanchev",
					"daysBetweenCommits": 0.94,
					"commitsBetweenForRepo": 10,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,44 +1,47 @@\n \tprotected <T> void writeWithMessageConverters(T returnValue,\n \t\t\t\t\t\t\t\t\t\t\t\t  MethodParameter returnType,\n-\t\t\t\t\t\t\t\t\t\t\t\t  HttpInputMessage inputMessage,\n-\t\t\t\t\t\t\t\t\t\t\t\t  HttpOutputMessage outputMessage,\n-\t\t\t\t\t\t\t\t\t\t\t\t  Set<MediaType> producibleMediaTypes)\n+\t\t\t\t\t\t\t\t\t\t\t\t  ServletServerHttpRequest inputMessage,\n+\t\t\t\t\t\t\t\t\t\t\t\t  ServletServerHttpResponse outputMessage)\n \t\t\tthrows IOException, HttpMediaTypeNotAcceptableException {\n \n+\n+\t\tSet<MediaType> acceptableMediaTypes = getAcceptableMediaTypes(inputMessage);\n+\t\tSet<MediaType> producibleMediaTypes = getProducibleMediaTypes(inputMessage.getServletRequest());\n+\n \t\tList<MediaType> mediaTypes = new ArrayList<MediaType>();\n-\t\tfor (MediaType acceptableMediaType : getAcceptableMediaTypes(inputMessage)) {\n+\t\tfor (MediaType acceptableMediaType : acceptableMediaTypes) {\n \t\t\tfor (MediaType producibleMediaType : producibleMediaTypes) {\n \t\t\t\tif (acceptableMediaType.isCompatibleWith(producibleMediaType)) {\n \t\t\t\t\tmediaTypes.add(getMostSpecificMediaType(acceptableMediaType, producibleMediaType));\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\tif (mediaTypes.isEmpty()) {\n \t\t\tthrow new HttpMediaTypeNotAcceptableException(allSupportedMediaTypes);\n \t\t}\n \t\tMediaType.sortBySpecificity(mediaTypes);\n \t\tMediaType selectedMediaType = null;\n \t\tfor (MediaType mediaType : mediaTypes) {\n \t\t\tif (mediaType.isConcrete()) {\n \t\t\t\tselectedMediaType = mediaType;\n \t\t\t\tbreak;\n \t\t\t}\n \t\t\telse if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n \t\t\t\tselectedMediaType = MediaType.APPLICATION_OCTET_STREAM;\n \t\t\t\tbreak;\n \t\t\t}\n \t\t}\n \t\tif (selectedMediaType != null) {\n \t\t\tfor (HttpMessageConverter<?> messageConverter : messageConverters) {\n \t\t\t\tif (messageConverter.canWrite(returnValue.getClass(), selectedMediaType)) {\n \t\t\t\t\t((HttpMessageConverter<T>) messageConverter).write(returnValue, selectedMediaType, outputMessage);\n \t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\tlogger.debug(\"Written [\" + returnValue + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" +\n \t\t\t\t\t\t\t\tmessageConverter + \"]\");\n \t\t\t\t\t}\n \t\t\t\t\treturn;\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\tthrow new HttpMediaTypeNotAcceptableException(allSupportedMediaTypes);\n \t}\n\\ No newline at end of file\n",
					"extendedDetails": {
						"oldValue": "[returnValue-T, returnType-MethodParameter, inputMessage-HttpInputMessage, outputMessage-HttpOutputMessage, producibleMediaTypes-Set<MediaType>]",
						"newValue": "[returnValue-T, returnType-MethodParameter, inputMessage-ServletServerHttpRequest, outputMessage-ServletServerHttpResponse]"
					}
				},
				{
					"type": "Ybodychange",
					"commitMessage": "@RequestMapping.consumes() and produces() now default to an empty array, instead of */*\n",
					"commitDate": "2011-05-18, 4:34 AM",
					"commitName": "1eaca6572091c014379e453299773e880a7766b9",
					"commitAuthor": "Arjen Poutsma",
					"commitDateOld": "2011-05-17, 6:02 AM",
					"commitNameOld": "af1dfd357743e6f4d5b9589ddb584f472a699e41",
					"commitAuthorOld": "Rossen Stoyanchev",
					"daysBetweenCommits": 0.94,
					"commitsBetweenForRepo": 10,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,44 +1,47 @@\n \tprotected <T> void writeWithMessageConverters(T returnValue,\n \t\t\t\t\t\t\t\t\t\t\t\t  MethodParameter returnType,\n-\t\t\t\t\t\t\t\t\t\t\t\t  HttpInputMessage inputMessage,\n-\t\t\t\t\t\t\t\t\t\t\t\t  HttpOutputMessage outputMessage,\n-\t\t\t\t\t\t\t\t\t\t\t\t  Set<MediaType> producibleMediaTypes)\n+\t\t\t\t\t\t\t\t\t\t\t\t  ServletServerHttpRequest inputMessage,\n+\t\t\t\t\t\t\t\t\t\t\t\t  ServletServerHttpResponse outputMessage)\n \t\t\tthrows IOException, HttpMediaTypeNotAcceptableException {\n \n+\n+\t\tSet<MediaType> acceptableMediaTypes = getAcceptableMediaTypes(inputMessage);\n+\t\tSet<MediaType> producibleMediaTypes = getProducibleMediaTypes(inputMessage.getServletRequest());\n+\n \t\tList<MediaType> mediaTypes = new ArrayList<MediaType>();\n-\t\tfor (MediaType acceptableMediaType : getAcceptableMediaTypes(inputMessage)) {\n+\t\tfor (MediaType acceptableMediaType : acceptableMediaTypes) {\n \t\t\tfor (MediaType producibleMediaType : producibleMediaTypes) {\n \t\t\t\tif (acceptableMediaType.isCompatibleWith(producibleMediaType)) {\n \t\t\t\t\tmediaTypes.add(getMostSpecificMediaType(acceptableMediaType, producibleMediaType));\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\tif (mediaTypes.isEmpty()) {\n \t\t\tthrow new HttpMediaTypeNotAcceptableException(allSupportedMediaTypes);\n \t\t}\n \t\tMediaType.sortBySpecificity(mediaTypes);\n \t\tMediaType selectedMediaType = null;\n \t\tfor (MediaType mediaType : mediaTypes) {\n \t\t\tif (mediaType.isConcrete()) {\n \t\t\t\tselectedMediaType = mediaType;\n \t\t\t\tbreak;\n \t\t\t}\n \t\t\telse if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n \t\t\t\tselectedMediaType = MediaType.APPLICATION_OCTET_STREAM;\n \t\t\t\tbreak;\n \t\t\t}\n \t\t}\n \t\tif (selectedMediaType != null) {\n \t\t\tfor (HttpMessageConverter<?> messageConverter : messageConverters) {\n \t\t\t\tif (messageConverter.canWrite(returnValue.getClass(), selectedMediaType)) {\n \t\t\t\t\t((HttpMessageConverter<T>) messageConverter).write(returnValue, selectedMediaType, outputMessage);\n \t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\tlogger.debug(\"Written [\" + returnValue + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" +\n \t\t\t\t\t\t\t\tmessageConverter + \"]\");\n \t\t\t\t\t}\n \t\t\t\t\treturn;\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\tthrow new HttpMediaTypeNotAcceptableException(allSupportedMediaTypes);\n \t}\n\\ No newline at end of file\n",
					"extendedDetails": {}
				}
			]
		},
		"af1dfd357743e6f4d5b9589ddb584f472a699e41": {
			"type": "Ymultichange(Yparameterchange,Ybodychange)",
			"commitMessage": "Use request attribute to check producible media types when writing to the response body\n",
			"commitDate": "2011-05-17, 6:02 AM",
			"commitName": "af1dfd357743e6f4d5b9589ddb584f472a699e41",
			"commitAuthor": "Rossen Stoyanchev",
			"subchanges": [
				{
					"type": "Yparameterchange",
					"commitMessage": "Use request attribute to check producible media types when writing to the response body\n",
					"commitDate": "2011-05-17, 6:02 AM",
					"commitName": "af1dfd357743e6f4d5b9589ddb584f472a699e41",
					"commitAuthor": "Rossen Stoyanchev",
					"commitDateOld": "2011-05-17, 5:22 AM",
					"commitNameOld": "1bbdb0d2ff3f25f3d1e3d43d9fa5d6dbb7da6235",
					"commitAuthorOld": "Arjen Poutsma",
					"daysBetweenCommits": 0.03,
					"commitsBetweenForRepo": 1,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,48 +1,44 @@\n \tprotected <T> void writeWithMessageConverters(T returnValue,\n \t\t\t\t\t\t\t\t\t\t\t\t  MethodParameter returnType,\n \t\t\t\t\t\t\t\t\t\t\t\t  HttpInputMessage inputMessage,\n-\t\t\t\t\t\t\t\t\t\t\t\t  HttpOutputMessage outputMessage)\n+\t\t\t\t\t\t\t\t\t\t\t\t  HttpOutputMessage outputMessage,\n+\t\t\t\t\t\t\t\t\t\t\t\t  Set<MediaType> producibleMediaTypes)\n \t\t\tthrows IOException, HttpMediaTypeNotAcceptableException {\n \n-\t\tSet<MediaType> producibleMediaTypes = getProducibleMediaTypes(returnType.getMethod(), returnValue.getClass());\n-\t\tSet<MediaType> acceptableMediaTypes = getAcceptableMediaTypes(inputMessage);\n-\n \t\tList<MediaType> mediaTypes = new ArrayList<MediaType>();\n-\t\tfor (MediaType acceptableMediaType : acceptableMediaTypes) {\n+\t\tfor (MediaType acceptableMediaType : getAcceptableMediaTypes(inputMessage)) {\n \t\t\tfor (MediaType producibleMediaType : producibleMediaTypes) {\n \t\t\t\tif (acceptableMediaType.isCompatibleWith(producibleMediaType)) {\n \t\t\t\t\tmediaTypes.add(getMostSpecificMediaType(acceptableMediaType, producibleMediaType));\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\tif (mediaTypes.isEmpty()) {\n \t\t\tthrow new HttpMediaTypeNotAcceptableException(allSupportedMediaTypes);\n \t\t}\n \t\tMediaType.sortBySpecificity(mediaTypes);\n \t\tMediaType selectedMediaType = null;\n \t\tfor (MediaType mediaType : mediaTypes) {\n \t\t\tif (mediaType.isConcrete()) {\n \t\t\t\tselectedMediaType = mediaType;\n \t\t\t\tbreak;\n \t\t\t}\n \t\t\telse if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n \t\t\t\tselectedMediaType = MediaType.APPLICATION_OCTET_STREAM;\n \t\t\t\tbreak;\n \t\t\t}\n \t\t}\n \t\tif (selectedMediaType != null) {\n \t\t\tfor (HttpMessageConverter<?> messageConverter : messageConverters) {\n \t\t\t\tif (messageConverter.canWrite(returnValue.getClass(), selectedMediaType)) {\n \t\t\t\t\t((HttpMessageConverter<T>) messageConverter).write(returnValue, selectedMediaType, outputMessage);\n \t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\tlogger.debug(\"Written [\" + returnValue + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" +\n \t\t\t\t\t\t\t\tmessageConverter + \"]\");\n \t\t\t\t\t}\n \t\t\t\t\treturn;\n \t\t\t\t}\n \t\t\t}\n \t\t}\n-\t\telse {\n-\t\t\tthrow new HttpMediaTypeNotAcceptableException(allSupportedMediaTypes);\n-\t\t}\n+\t\tthrow new HttpMediaTypeNotAcceptableException(allSupportedMediaTypes);\n \t}\n\\ No newline at end of file\n",
					"extendedDetails": {
						"oldValue": "[returnValue-T, returnType-MethodParameter, inputMessage-HttpInputMessage, outputMessage-HttpOutputMessage]",
						"newValue": "[returnValue-T, returnType-MethodParameter, inputMessage-HttpInputMessage, outputMessage-HttpOutputMessage, producibleMediaTypes-Set<MediaType>]"
					}
				},
				{
					"type": "Ybodychange",
					"commitMessage": "Use request attribute to check producible media types when writing to the response body\n",
					"commitDate": "2011-05-17, 6:02 AM",
					"commitName": "af1dfd357743e6f4d5b9589ddb584f472a699e41",
					"commitAuthor": "Rossen Stoyanchev",
					"commitDateOld": "2011-05-17, 5:22 AM",
					"commitNameOld": "1bbdb0d2ff3f25f3d1e3d43d9fa5d6dbb7da6235",
					"commitAuthorOld": "Arjen Poutsma",
					"daysBetweenCommits": 0.03,
					"commitsBetweenForRepo": 1,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,48 +1,44 @@\n \tprotected <T> void writeWithMessageConverters(T returnValue,\n \t\t\t\t\t\t\t\t\t\t\t\t  MethodParameter returnType,\n \t\t\t\t\t\t\t\t\t\t\t\t  HttpInputMessage inputMessage,\n-\t\t\t\t\t\t\t\t\t\t\t\t  HttpOutputMessage outputMessage)\n+\t\t\t\t\t\t\t\t\t\t\t\t  HttpOutputMessage outputMessage,\n+\t\t\t\t\t\t\t\t\t\t\t\t  Set<MediaType> producibleMediaTypes)\n \t\t\tthrows IOException, HttpMediaTypeNotAcceptableException {\n \n-\t\tSet<MediaType> producibleMediaTypes = getProducibleMediaTypes(returnType.getMethod(), returnValue.getClass());\n-\t\tSet<MediaType> acceptableMediaTypes = getAcceptableMediaTypes(inputMessage);\n-\n \t\tList<MediaType> mediaTypes = new ArrayList<MediaType>();\n-\t\tfor (MediaType acceptableMediaType : acceptableMediaTypes) {\n+\t\tfor (MediaType acceptableMediaType : getAcceptableMediaTypes(inputMessage)) {\n \t\t\tfor (MediaType producibleMediaType : producibleMediaTypes) {\n \t\t\t\tif (acceptableMediaType.isCompatibleWith(producibleMediaType)) {\n \t\t\t\t\tmediaTypes.add(getMostSpecificMediaType(acceptableMediaType, producibleMediaType));\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\tif (mediaTypes.isEmpty()) {\n \t\t\tthrow new HttpMediaTypeNotAcceptableException(allSupportedMediaTypes);\n \t\t}\n \t\tMediaType.sortBySpecificity(mediaTypes);\n \t\tMediaType selectedMediaType = null;\n \t\tfor (MediaType mediaType : mediaTypes) {\n \t\t\tif (mediaType.isConcrete()) {\n \t\t\t\tselectedMediaType = mediaType;\n \t\t\t\tbreak;\n \t\t\t}\n \t\t\telse if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n \t\t\t\tselectedMediaType = MediaType.APPLICATION_OCTET_STREAM;\n \t\t\t\tbreak;\n \t\t\t}\n \t\t}\n \t\tif (selectedMediaType != null) {\n \t\t\tfor (HttpMessageConverter<?> messageConverter : messageConverters) {\n \t\t\t\tif (messageConverter.canWrite(returnValue.getClass(), selectedMediaType)) {\n \t\t\t\t\t((HttpMessageConverter<T>) messageConverter).write(returnValue, selectedMediaType, outputMessage);\n \t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\tlogger.debug(\"Written [\" + returnValue + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" +\n \t\t\t\t\t\t\t\tmessageConverter + \"]\");\n \t\t\t\t\t}\n \t\t\t\t\treturn;\n \t\t\t\t}\n \t\t\t}\n \t\t}\n-\t\telse {\n-\t\t\tthrow new HttpMediaTypeNotAcceptableException(allSupportedMediaTypes);\n-\t\t}\n+\t\tthrow new HttpMediaTypeNotAcceptableException(allSupportedMediaTypes);\n \t}\n\\ No newline at end of file\n",
					"extendedDetails": {}
				}
			]
		},
		"1bbdb0d2ff3f25f3d1e3d43d9fa5d6dbb7da6235": {
			"type": "Ybodychange",
			"commitMessage": "minor fix.\n",
			"commitDate": "2011-05-17, 5:22 AM",
			"commitName": "1bbdb0d2ff3f25f3d1e3d43d9fa5d6dbb7da6235",
			"commitAuthor": "Arjen Poutsma",
			"commitDateOld": "2011-05-17, 2:45 AM",
			"commitNameOld": "ad2e0d45875651d9a707b514dd3966fa81a9048c",
			"commitAuthorOld": "Arjen Poutsma",
			"daysBetweenCommits": 0.11,
			"commitsBetweenForRepo": 2,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,47 +1,48 @@\n \tprotected <T> void writeWithMessageConverters(T returnValue,\n \t\t\t\t\t\t\t\t\t\t\t\t  MethodParameter returnType,\n \t\t\t\t\t\t\t\t\t\t\t\t  HttpInputMessage inputMessage,\n \t\t\t\t\t\t\t\t\t\t\t\t  HttpOutputMessage outputMessage)\n \t\t\tthrows IOException, HttpMediaTypeNotAcceptableException {\n \n \t\tSet<MediaType> producibleMediaTypes = getProducibleMediaTypes(returnType.getMethod(), returnValue.getClass());\n \t\tSet<MediaType> acceptableMediaTypes = getAcceptableMediaTypes(inputMessage);\n \n \t\tList<MediaType> mediaTypes = new ArrayList<MediaType>();\n \t\tfor (MediaType acceptableMediaType : acceptableMediaTypes) {\n \t\t\tfor (MediaType producibleMediaType : producibleMediaTypes) {\n \t\t\t\tif (acceptableMediaType.isCompatibleWith(producibleMediaType)) {\n \t\t\t\t\tmediaTypes.add(getMostSpecificMediaType(acceptableMediaType, producibleMediaType));\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\tif (mediaTypes.isEmpty()) {\n \t\t\tthrow new HttpMediaTypeNotAcceptableException(allSupportedMediaTypes);\n \t\t}\n \t\tMediaType.sortBySpecificity(mediaTypes);\n \t\tMediaType selectedMediaType = null;\n \t\tfor (MediaType mediaType : mediaTypes) {\n \t\t\tif (mediaType.isConcrete()) {\n \t\t\t\tselectedMediaType = mediaType;\n \t\t\t\tbreak;\n \t\t\t}\n \t\t\telse if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n \t\t\t\tselectedMediaType = MediaType.APPLICATION_OCTET_STREAM;\n+\t\t\t\tbreak;\n \t\t\t}\n \t\t}\n \t\tif (selectedMediaType != null) {\n \t\t\tfor (HttpMessageConverter<?> messageConverter : messageConverters) {\n \t\t\t\tif (messageConverter.canWrite(returnValue.getClass(), selectedMediaType)) {\n \t\t\t\t\t((HttpMessageConverter<T>) messageConverter).write(returnValue, selectedMediaType, outputMessage);\n \t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\tlogger.debug(\"Written [\" + returnValue + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" +\n \t\t\t\t\t\t\t\tmessageConverter + \"]\");\n \t\t\t\t\t}\n \t\t\t\t\treturn;\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\telse {\n \t\t\tthrow new HttpMediaTypeNotAcceptableException(allSupportedMediaTypes);\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"ad2e0d45875651d9a707b514dd3966fa81a9048c": {
			"type": "Ymultichange(Yparameterchange,Ybodychange)",
			"commitMessage": "SPR-7353 - @ResponseBody and returned HttpEntity now respect @RequestMapping.produces()\n\n",
			"commitDate": "2011-05-17, 2:45 AM",
			"commitName": "ad2e0d45875651d9a707b514dd3966fa81a9048c",
			"commitAuthor": "Arjen Poutsma",
			"subchanges": [
				{
					"type": "Yparameterchange",
					"commitMessage": "SPR-7353 - @ResponseBody and returned HttpEntity now respect @RequestMapping.produces()\n\n",
					"commitDate": "2011-05-17, 2:45 AM",
					"commitName": "ad2e0d45875651d9a707b514dd3966fa81a9048c",
					"commitAuthor": "Arjen Poutsma",
					"commitDateOld": "2011-04-13, 4:15 PM",
					"commitNameOld": "aa065e83100ace913de9f46ff38aeb84a4d85229",
					"commitAuthorOld": "Rossen Stoyanchev",
					"daysBetweenCommits": 33.44,
					"commitsBetweenForRepo": 85,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,32 +1,47 @@\n-\tprotected <T> void writeWithMessageConverters(T returnValue, \n-\t\t\t\t\t\t\t\t\t\t\t\t  HttpInputMessage inputMessage, \n+\tprotected <T> void writeWithMessageConverters(T returnValue,\n+\t\t\t\t\t\t\t\t\t\t\t\t  MethodParameter returnType,\n+\t\t\t\t\t\t\t\t\t\t\t\t  HttpInputMessage inputMessage,\n \t\t\t\t\t\t\t\t\t\t\t\t  HttpOutputMessage outputMessage)\n \t\t\tthrows IOException, HttpMediaTypeNotAcceptableException {\n-\t\t\n-\t\tList<MediaType> acceptedMediaTypes = getAcceptedMediaTypes(inputMessage);\n \n-\t\tList<MediaType> allSupportedMediaTypes = new ArrayList<MediaType>();\n-\t\tif (this.messageConverters != null) {\n-\t\t\tfor (MediaType acceptedMediaType : acceptedMediaTypes) {\n-\t\t\t\tfor (HttpMessageConverter<?> messageConverter : this.messageConverters) {\n-\t\t\t\t\tif (!messageConverter.canWrite(returnValue.getClass(), acceptedMediaType)) {\n-\t\t\t\t\t\tcontinue;\n-\t\t\t\t\t}\n-\t\t\t\t\t((HttpMessageConverter<T>) messageConverter).write(returnValue, acceptedMediaType, outputMessage);\n+\t\tSet<MediaType> producibleMediaTypes = getProducibleMediaTypes(returnType.getMethod(), returnValue.getClass());\n+\t\tSet<MediaType> acceptableMediaTypes = getAcceptableMediaTypes(inputMessage);\n+\n+\t\tList<MediaType> mediaTypes = new ArrayList<MediaType>();\n+\t\tfor (MediaType acceptableMediaType : acceptableMediaTypes) {\n+\t\t\tfor (MediaType producibleMediaType : producibleMediaTypes) {\n+\t\t\t\tif (acceptableMediaType.isCompatibleWith(producibleMediaType)) {\n+\t\t\t\t\tmediaTypes.add(getMostSpecificMediaType(acceptableMediaType, producibleMediaType));\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\tif (mediaTypes.isEmpty()) {\n+\t\t\tthrow new HttpMediaTypeNotAcceptableException(allSupportedMediaTypes);\n+\t\t}\n+\t\tMediaType.sortBySpecificity(mediaTypes);\n+\t\tMediaType selectedMediaType = null;\n+\t\tfor (MediaType mediaType : mediaTypes) {\n+\t\t\tif (mediaType.isConcrete()) {\n+\t\t\t\tselectedMediaType = mediaType;\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t\telse if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n+\t\t\t\tselectedMediaType = MediaType.APPLICATION_OCTET_STREAM;\n+\t\t\t}\n+\t\t}\n+\t\tif (selectedMediaType != null) {\n+\t\t\tfor (HttpMessageConverter<?> messageConverter : messageConverters) {\n+\t\t\t\tif (messageConverter.canWrite(returnValue.getClass(), selectedMediaType)) {\n+\t\t\t\t\t((HttpMessageConverter<T>) messageConverter).write(returnValue, selectedMediaType, outputMessage);\n \t\t\t\t\tif (logger.isDebugEnabled()) {\n-\t\t\t\t\t\tMediaType contentType = outputMessage.getHeaders().getContentType();\n-\t\t\t\t\t\tif (contentType == null) {\n-\t\t\t\t\t\t\tcontentType = acceptedMediaType;\n-\t\t\t\t\t\t}\n-\t\t\t\t\t\tlogger.debug(\"Written [\" + returnValue + \"] as \\\"\" + contentType + \"\\\" using [\" +\n+\t\t\t\t\t\tlogger.debug(\"Written [\" + returnValue + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" +\n \t\t\t\t\t\t\t\tmessageConverter + \"]\");\n \t\t\t\t\t}\n \t\t\t\t\treturn;\n \t\t\t\t}\n \t\t\t}\n-\t\t\tfor (HttpMessageConverter<?> messageConverter : messageConverters) {\n-\t\t\t\tallSupportedMediaTypes.addAll(messageConverter.getSupportedMediaTypes());\n-\t\t\t}\n \t\t}\n-\t\tthrow new HttpMediaTypeNotAcceptableException(allSupportedMediaTypes);\n+\t\telse {\n+\t\t\tthrow new HttpMediaTypeNotAcceptableException(allSupportedMediaTypes);\n+\t\t}\n \t}\n\\ No newline at end of file\n",
					"extendedDetails": {
						"oldValue": "[returnValue-T, inputMessage-HttpInputMessage, outputMessage-HttpOutputMessage]",
						"newValue": "[returnValue-T, returnType-MethodParameter, inputMessage-HttpInputMessage, outputMessage-HttpOutputMessage]"
					}
				},
				{
					"type": "Ybodychange",
					"commitMessage": "SPR-7353 - @ResponseBody and returned HttpEntity now respect @RequestMapping.produces()\n\n",
					"commitDate": "2011-05-17, 2:45 AM",
					"commitName": "ad2e0d45875651d9a707b514dd3966fa81a9048c",
					"commitAuthor": "Arjen Poutsma",
					"commitDateOld": "2011-04-13, 4:15 PM",
					"commitNameOld": "aa065e83100ace913de9f46ff38aeb84a4d85229",
					"commitAuthorOld": "Rossen Stoyanchev",
					"daysBetweenCommits": 33.44,
					"commitsBetweenForRepo": 85,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,32 +1,47 @@\n-\tprotected <T> void writeWithMessageConverters(T returnValue, \n-\t\t\t\t\t\t\t\t\t\t\t\t  HttpInputMessage inputMessage, \n+\tprotected <T> void writeWithMessageConverters(T returnValue,\n+\t\t\t\t\t\t\t\t\t\t\t\t  MethodParameter returnType,\n+\t\t\t\t\t\t\t\t\t\t\t\t  HttpInputMessage inputMessage,\n \t\t\t\t\t\t\t\t\t\t\t\t  HttpOutputMessage outputMessage)\n \t\t\tthrows IOException, HttpMediaTypeNotAcceptableException {\n-\t\t\n-\t\tList<MediaType> acceptedMediaTypes = getAcceptedMediaTypes(inputMessage);\n \n-\t\tList<MediaType> allSupportedMediaTypes = new ArrayList<MediaType>();\n-\t\tif (this.messageConverters != null) {\n-\t\t\tfor (MediaType acceptedMediaType : acceptedMediaTypes) {\n-\t\t\t\tfor (HttpMessageConverter<?> messageConverter : this.messageConverters) {\n-\t\t\t\t\tif (!messageConverter.canWrite(returnValue.getClass(), acceptedMediaType)) {\n-\t\t\t\t\t\tcontinue;\n-\t\t\t\t\t}\n-\t\t\t\t\t((HttpMessageConverter<T>) messageConverter).write(returnValue, acceptedMediaType, outputMessage);\n+\t\tSet<MediaType> producibleMediaTypes = getProducibleMediaTypes(returnType.getMethod(), returnValue.getClass());\n+\t\tSet<MediaType> acceptableMediaTypes = getAcceptableMediaTypes(inputMessage);\n+\n+\t\tList<MediaType> mediaTypes = new ArrayList<MediaType>();\n+\t\tfor (MediaType acceptableMediaType : acceptableMediaTypes) {\n+\t\t\tfor (MediaType producibleMediaType : producibleMediaTypes) {\n+\t\t\t\tif (acceptableMediaType.isCompatibleWith(producibleMediaType)) {\n+\t\t\t\t\tmediaTypes.add(getMostSpecificMediaType(acceptableMediaType, producibleMediaType));\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\tif (mediaTypes.isEmpty()) {\n+\t\t\tthrow new HttpMediaTypeNotAcceptableException(allSupportedMediaTypes);\n+\t\t}\n+\t\tMediaType.sortBySpecificity(mediaTypes);\n+\t\tMediaType selectedMediaType = null;\n+\t\tfor (MediaType mediaType : mediaTypes) {\n+\t\t\tif (mediaType.isConcrete()) {\n+\t\t\t\tselectedMediaType = mediaType;\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t\telse if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n+\t\t\t\tselectedMediaType = MediaType.APPLICATION_OCTET_STREAM;\n+\t\t\t}\n+\t\t}\n+\t\tif (selectedMediaType != null) {\n+\t\t\tfor (HttpMessageConverter<?> messageConverter : messageConverters) {\n+\t\t\t\tif (messageConverter.canWrite(returnValue.getClass(), selectedMediaType)) {\n+\t\t\t\t\t((HttpMessageConverter<T>) messageConverter).write(returnValue, selectedMediaType, outputMessage);\n \t\t\t\t\tif (logger.isDebugEnabled()) {\n-\t\t\t\t\t\tMediaType contentType = outputMessage.getHeaders().getContentType();\n-\t\t\t\t\t\tif (contentType == null) {\n-\t\t\t\t\t\t\tcontentType = acceptedMediaType;\n-\t\t\t\t\t\t}\n-\t\t\t\t\t\tlogger.debug(\"Written [\" + returnValue + \"] as \\\"\" + contentType + \"\\\" using [\" +\n+\t\t\t\t\t\tlogger.debug(\"Written [\" + returnValue + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" +\n \t\t\t\t\t\t\t\tmessageConverter + \"]\");\n \t\t\t\t\t}\n \t\t\t\t\treturn;\n \t\t\t\t}\n \t\t\t}\n-\t\t\tfor (HttpMessageConverter<?> messageConverter : messageConverters) {\n-\t\t\t\tallSupportedMediaTypes.addAll(messageConverter.getSupportedMediaTypes());\n-\t\t\t}\n \t\t}\n-\t\tthrow new HttpMediaTypeNotAcceptableException(allSupportedMediaTypes);\n+\t\telse {\n+\t\t\tthrow new HttpMediaTypeNotAcceptableException(allSupportedMediaTypes);\n+\t\t}\n \t}\n\\ No newline at end of file\n",
					"extendedDetails": {}
				}
			]
		},
		"acc75aa4b898a34dce42748df5b54624f8b3e9f2": {
			"type": "Yintroduced",
			"commitMessage": "SPR-8215 Move HandlerMethod code into trunk\n",
			"commitDate": "2011-04-06, 4:30 AM",
			"commitName": "acc75aa4b898a34dce42748df5b54624f8b3e9f2",
			"commitAuthor": "Rossen Stoyanchev",
			"diff": "@@ -0,0 +1,32 @@\n+\tprotected <T> void writeWithMessageConverters(T returnValue, \n+\t\t\t\t\t\t\t\t\t\t\t\t  HttpInputMessage inputMessage, \n+\t\t\t\t\t\t\t\t\t\t\t\t  HttpOutputMessage outputMessage)\n+\t\t\tthrows IOException, HttpMediaTypeNotAcceptableException {\n+\t\t\n+\t\tList<MediaType> acceptedMediaTypes = getAcceptedMediaTypes(inputMessage);\n+\n+\t\tList<MediaType> allSupportedMediaTypes = new ArrayList<MediaType>();\n+\t\tif (this.messageConverters != null) {\n+\t\t\tfor (MediaType acceptedMediaType : acceptedMediaTypes) {\n+\t\t\t\tfor (HttpMessageConverter<?> messageConverter : this.messageConverters) {\n+\t\t\t\t\tif (!messageConverter.canWrite(returnValue.getClass(), acceptedMediaType)) {\n+\t\t\t\t\t\tcontinue;\n+\t\t\t\t\t}\n+\t\t\t\t\t((HttpMessageConverter<T>) messageConverter).write(returnValue, acceptedMediaType, outputMessage);\n+\t\t\t\t\tif (logger.isDebugEnabled()) {\n+\t\t\t\t\t\tMediaType contentType = outputMessage.getHeaders().getContentType();\n+\t\t\t\t\t\tif (contentType == null) {\n+\t\t\t\t\t\t\tcontentType = acceptedMediaType;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tlogger.debug(\"Written [\" + returnValue + \"] as \\\"\" + contentType + \"\\\" using [\" +\n+\t\t\t\t\t\t\t\tmessageConverter + \"]\");\n+\t\t\t\t\t}\n+\t\t\t\t\treturn;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tfor (HttpMessageConverter<?> messageConverter : messageConverters) {\n+\t\t\t\tallSupportedMediaTypes.addAll(messageConverter.getSupportedMediaTypes());\n+\t\t\t}\n+\t\t}\n+\t\tthrow new HttpMediaTypeNotAcceptableException(allSupportedMediaTypes);\n+\t}\n\\ No newline at end of file\n"
		}
	},
	"sha": "b325c74216fd9564a36602158fa1269e2e832874"
}