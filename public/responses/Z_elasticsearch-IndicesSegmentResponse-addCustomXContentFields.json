{
	"repo": "https://github.com/elastic/elasticsearch.git",
	"file": "server/src/main/java/org/elasticsearch/action/admin/indices/segments/IndicesSegmentResponse.java",
	"method": {
		"longName": "protected void addCustomXContentFields(XContentBuilder builder, Params params);",
		"startLine": 105,
		"methodName": "addCustomXContentFields",
		"isStatic": false,
		"isAbstract": false,
		"visibility": "protected"
	},
	"history": {
		"b4c78019b02313bd1eaa61e0752ef3c2cf34f5a4": {
			"type": "Ybodychange",
			"commitMessage": "Remove all dependencies from XContentBuilder (#29225)\n\n* Remove all dependencies from XContentBuilder\r\n\r\nThis commit removes all of the non-JDK dependencies from XContentBuilder, with\r\nthe exception of `CollectionUtils.ensureNoSelfReferences`. It adds a third\r\nextension point around dealing with time-based fields and formatters to work\r\naround the Joda dependency.\r\n\r\nThis decoupling allows us to be able to move XContentBuilder to a separate lib\r\nso it can be available for things like the high level rest client.\r\n\r\nRelates to #28504",
			"commitDate": "2018-03-27, 11:58 AM",
			"commitName": "b4c78019b02313bd1eaa61e0752ef3c2cf34f5a4",
			"commitAuthor": "Lee Hinman",
			"commitDateOld": "2018-03-23, 2:53 AM",
			"commitNameOld": "4a8099c6962da1e68309e0e382d0e6198a3937c2",
			"commitAuthorOld": "Yu",
			"daysBetweenCommits": 4.38,
			"commitsBetweenForRepo": 25,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,71 +1,71 @@\n     protected void addCustomXContentFields(XContentBuilder builder, Params params) throws IOException {\n         builder.startObject(Fields.INDICES);\n \n         for (IndexSegments indexSegments : getIndices().values()) {\n             builder.startObject(indexSegments.getIndex());\n \n             builder.startObject(Fields.SHARDS);\n             for (IndexShardSegments indexSegment : indexSegments) {\n                 builder.startArray(Integer.toString(indexSegment.getShardId().id()));\n                 for (ShardSegments shardSegments : indexSegment) {\n                     builder.startObject();\n \n                     builder.startObject(Fields.ROUTING);\n                     builder.field(Fields.STATE, shardSegments.getShardRouting().state());\n                     builder.field(Fields.PRIMARY, shardSegments.getShardRouting().primary());\n                     builder.field(Fields.NODE, shardSegments.getShardRouting().currentNodeId());\n                     if (shardSegments.getShardRouting().relocatingNodeId() != null) {\n                         builder.field(Fields.RELOCATING_NODE, shardSegments.getShardRouting().relocatingNodeId());\n                     }\n                     builder.endObject();\n \n                     builder.field(Fields.NUM_COMMITTED_SEGMENTS, shardSegments.getNumberOfCommitted());\n                     builder.field(Fields.NUM_SEARCH_SEGMENTS, shardSegments.getNumberOfSearch());\n \n                     builder.startObject(Fields.SEGMENTS);\n                     for (Segment segment : shardSegments) {\n                         builder.startObject(segment.getName());\n                         builder.field(Fields.GENERATION, segment.getGeneration());\n                         builder.field(Fields.NUM_DOCS, segment.getNumDocs());\n                         builder.field(Fields.DELETED_DOCS, segment.getDeletedDocs());\n-                        builder.byteSizeField(Fields.SIZE_IN_BYTES, Fields.SIZE, segment.getSizeInBytes());\n-                        builder.byteSizeField(Fields.MEMORY_IN_BYTES, Fields.MEMORY, segment.getMemoryInBytes());\n+                        builder.humanReadableField(Fields.SIZE_IN_BYTES, Fields.SIZE, segment.getSize());\n+                        builder.humanReadableField(Fields.MEMORY_IN_BYTES, Fields.MEMORY, new ByteSizeValue(segment.getMemoryInBytes()));\n                         builder.field(Fields.COMMITTED, segment.isCommitted());\n                         builder.field(Fields.SEARCH, segment.isSearch());\n                         if (segment.getVersion() != null) {\n                             builder.field(Fields.VERSION, segment.getVersion());\n                         }\n                         if (segment.isCompound() != null) {\n                             builder.field(Fields.COMPOUND, segment.isCompound());\n                         }\n                         if (segment.getMergeId() != null) {\n                             builder.field(Fields.MERGE_ID, segment.getMergeId());\n                         }\n                         if (segment.getSegmentSort() != null) {\n                             toXContent(builder, segment.getSegmentSort());\n                         }\n                         if (segment.ramTree != null) {\n                             builder.startArray(Fields.RAM_TREE);\n                             for (Accountable child : segment.ramTree.getChildResources()) {\n                                 toXContent(builder, child);\n                             }\n                             builder.endArray();\n                         }\n                         if (segment.attributes != null && segment.attributes.isEmpty() == false) {\n                             builder.field(\"attributes\", segment.attributes);\n                         }\n                         builder.endObject();\n                     }\n                     builder.endObject();\n \n                     builder.endObject();\n                 }\n                 builder.endArray();\n             }\n             builder.endObject();\n \n             builder.endObject();\n         }\n \n         builder.endObject();\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"4a8099c6962da1e68309e0e382d0e6198a3937c2": {
			"type": "Ymultichange(Yrename,Yreturntypechange,Ymodifierchange,Ybodychange)",
			"commitMessage": "Change BroadcastResponse from ToXContentFragment to ToXContentObject (#28878)\n\nWhile working on #27799, we find that it might make sense to change BroadcastResponse from ToXContentFragment to ToXContentObject, seeing that it's rather a complete XContent object and also the other Responses are normally ToXContentObject.\r\n\r\nBy doing this, we can also move the XContent build logic of BroadcastResponse's subclasses, from Rest Layer to the concrete classes themselves.\r\n\r\nRelates to #3889",
			"commitDate": "2018-03-23, 2:53 AM",
			"commitName": "4a8099c6962da1e68309e0e382d0e6198a3937c2",
			"commitAuthor": "Yu",
			"subchanges": [
				{
					"type": "Yrename",
					"commitMessage": "Change BroadcastResponse from ToXContentFragment to ToXContentObject (#28878)\n\nWhile working on #27799, we find that it might make sense to change BroadcastResponse from ToXContentFragment to ToXContentObject, seeing that it's rather a complete XContent object and also the other Responses are normally ToXContentObject.\r\n\r\nBy doing this, we can also move the XContent build logic of BroadcastResponse's subclasses, from Rest Layer to the concrete classes themselves.\r\n\r\nRelates to #3889",
					"commitDate": "2018-03-23, 2:53 AM",
					"commitName": "4a8099c6962da1e68309e0e382d0e6198a3937c2",
					"commitAuthor": "Yu",
					"commitDateOld": "2018-03-20, 10:39 AM",
					"commitNameOld": "4bd217c94f4cea806b1ab41b359908355ac2984c",
					"commitAuthorOld": "Lee Hinman",
					"daysBetweenCommits": 2.68,
					"commitsBetweenForRepo": 25,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,72 +1,71 @@\n-    public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n+    protected void addCustomXContentFields(XContentBuilder builder, Params params) throws IOException {\n         builder.startObject(Fields.INDICES);\n \n         for (IndexSegments indexSegments : getIndices().values()) {\n             builder.startObject(indexSegments.getIndex());\n \n             builder.startObject(Fields.SHARDS);\n             for (IndexShardSegments indexSegment : indexSegments) {\n                 builder.startArray(Integer.toString(indexSegment.getShardId().id()));\n                 for (ShardSegments shardSegments : indexSegment) {\n                     builder.startObject();\n \n                     builder.startObject(Fields.ROUTING);\n                     builder.field(Fields.STATE, shardSegments.getShardRouting().state());\n                     builder.field(Fields.PRIMARY, shardSegments.getShardRouting().primary());\n                     builder.field(Fields.NODE, shardSegments.getShardRouting().currentNodeId());\n                     if (shardSegments.getShardRouting().relocatingNodeId() != null) {\n                         builder.field(Fields.RELOCATING_NODE, shardSegments.getShardRouting().relocatingNodeId());\n                     }\n                     builder.endObject();\n \n                     builder.field(Fields.NUM_COMMITTED_SEGMENTS, shardSegments.getNumberOfCommitted());\n                     builder.field(Fields.NUM_SEARCH_SEGMENTS, shardSegments.getNumberOfSearch());\n \n                     builder.startObject(Fields.SEGMENTS);\n                     for (Segment segment : shardSegments) {\n                         builder.startObject(segment.getName());\n                         builder.field(Fields.GENERATION, segment.getGeneration());\n                         builder.field(Fields.NUM_DOCS, segment.getNumDocs());\n                         builder.field(Fields.DELETED_DOCS, segment.getDeletedDocs());\n                         builder.byteSizeField(Fields.SIZE_IN_BYTES, Fields.SIZE, segment.getSizeInBytes());\n                         builder.byteSizeField(Fields.MEMORY_IN_BYTES, Fields.MEMORY, segment.getMemoryInBytes());\n                         builder.field(Fields.COMMITTED, segment.isCommitted());\n                         builder.field(Fields.SEARCH, segment.isSearch());\n                         if (segment.getVersion() != null) {\n                             builder.field(Fields.VERSION, segment.getVersion());\n                         }\n                         if (segment.isCompound() != null) {\n                             builder.field(Fields.COMPOUND, segment.isCompound());\n                         }\n                         if (segment.getMergeId() != null) {\n                             builder.field(Fields.MERGE_ID, segment.getMergeId());\n                         }\n                         if (segment.getSegmentSort() != null) {\n                             toXContent(builder, segment.getSegmentSort());\n                         }\n                         if (segment.ramTree != null) {\n                             builder.startArray(Fields.RAM_TREE);\n                             for (Accountable child : segment.ramTree.getChildResources()) {\n                                 toXContent(builder, child);\n                             }\n                             builder.endArray();\n                         }\n                         if (segment.attributes != null && segment.attributes.isEmpty() == false) {\n                             builder.field(\"attributes\", segment.attributes);\n                         }\n                         builder.endObject();\n                     }\n                     builder.endObject();\n \n                     builder.endObject();\n                 }\n                 builder.endArray();\n             }\n             builder.endObject();\n \n             builder.endObject();\n         }\n \n         builder.endObject();\n-        return builder;\n     }\n\\ No newline at end of file\n",
					"extendedDetails": {
						"oldValue": "toXContent",
						"newValue": "addCustomXContentFields"
					}
				},
				{
					"type": "Yreturntypechange",
					"commitMessage": "Change BroadcastResponse from ToXContentFragment to ToXContentObject (#28878)\n\nWhile working on #27799, we find that it might make sense to change BroadcastResponse from ToXContentFragment to ToXContentObject, seeing that it's rather a complete XContent object and also the other Responses are normally ToXContentObject.\r\n\r\nBy doing this, we can also move the XContent build logic of BroadcastResponse's subclasses, from Rest Layer to the concrete classes themselves.\r\n\r\nRelates to #3889",
					"commitDate": "2018-03-23, 2:53 AM",
					"commitName": "4a8099c6962da1e68309e0e382d0e6198a3937c2",
					"commitAuthor": "Yu",
					"commitDateOld": "2018-03-20, 10:39 AM",
					"commitNameOld": "4bd217c94f4cea806b1ab41b359908355ac2984c",
					"commitAuthorOld": "Lee Hinman",
					"daysBetweenCommits": 2.68,
					"commitsBetweenForRepo": 25,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,72 +1,71 @@\n-    public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n+    protected void addCustomXContentFields(XContentBuilder builder, Params params) throws IOException {\n         builder.startObject(Fields.INDICES);\n \n         for (IndexSegments indexSegments : getIndices().values()) {\n             builder.startObject(indexSegments.getIndex());\n \n             builder.startObject(Fields.SHARDS);\n             for (IndexShardSegments indexSegment : indexSegments) {\n                 builder.startArray(Integer.toString(indexSegment.getShardId().id()));\n                 for (ShardSegments shardSegments : indexSegment) {\n                     builder.startObject();\n \n                     builder.startObject(Fields.ROUTING);\n                     builder.field(Fields.STATE, shardSegments.getShardRouting().state());\n                     builder.field(Fields.PRIMARY, shardSegments.getShardRouting().primary());\n                     builder.field(Fields.NODE, shardSegments.getShardRouting().currentNodeId());\n                     if (shardSegments.getShardRouting().relocatingNodeId() != null) {\n                         builder.field(Fields.RELOCATING_NODE, shardSegments.getShardRouting().relocatingNodeId());\n                     }\n                     builder.endObject();\n \n                     builder.field(Fields.NUM_COMMITTED_SEGMENTS, shardSegments.getNumberOfCommitted());\n                     builder.field(Fields.NUM_SEARCH_SEGMENTS, shardSegments.getNumberOfSearch());\n \n                     builder.startObject(Fields.SEGMENTS);\n                     for (Segment segment : shardSegments) {\n                         builder.startObject(segment.getName());\n                         builder.field(Fields.GENERATION, segment.getGeneration());\n                         builder.field(Fields.NUM_DOCS, segment.getNumDocs());\n                         builder.field(Fields.DELETED_DOCS, segment.getDeletedDocs());\n                         builder.byteSizeField(Fields.SIZE_IN_BYTES, Fields.SIZE, segment.getSizeInBytes());\n                         builder.byteSizeField(Fields.MEMORY_IN_BYTES, Fields.MEMORY, segment.getMemoryInBytes());\n                         builder.field(Fields.COMMITTED, segment.isCommitted());\n                         builder.field(Fields.SEARCH, segment.isSearch());\n                         if (segment.getVersion() != null) {\n                             builder.field(Fields.VERSION, segment.getVersion());\n                         }\n                         if (segment.isCompound() != null) {\n                             builder.field(Fields.COMPOUND, segment.isCompound());\n                         }\n                         if (segment.getMergeId() != null) {\n                             builder.field(Fields.MERGE_ID, segment.getMergeId());\n                         }\n                         if (segment.getSegmentSort() != null) {\n                             toXContent(builder, segment.getSegmentSort());\n                         }\n                         if (segment.ramTree != null) {\n                             builder.startArray(Fields.RAM_TREE);\n                             for (Accountable child : segment.ramTree.getChildResources()) {\n                                 toXContent(builder, child);\n                             }\n                             builder.endArray();\n                         }\n                         if (segment.attributes != null && segment.attributes.isEmpty() == false) {\n                             builder.field(\"attributes\", segment.attributes);\n                         }\n                         builder.endObject();\n                     }\n                     builder.endObject();\n \n                     builder.endObject();\n                 }\n                 builder.endArray();\n             }\n             builder.endObject();\n \n             builder.endObject();\n         }\n \n         builder.endObject();\n-        return builder;\n     }\n\\ No newline at end of file\n",
					"extendedDetails": {
						"oldValue": "XContentBuilder",
						"newValue": "void"
					}
				},
				{
					"type": "Ymodifierchange",
					"commitMessage": "Change BroadcastResponse from ToXContentFragment to ToXContentObject (#28878)\n\nWhile working on #27799, we find that it might make sense to change BroadcastResponse from ToXContentFragment to ToXContentObject, seeing that it's rather a complete XContent object and also the other Responses are normally ToXContentObject.\r\n\r\nBy doing this, we can also move the XContent build logic of BroadcastResponse's subclasses, from Rest Layer to the concrete classes themselves.\r\n\r\nRelates to #3889",
					"commitDate": "2018-03-23, 2:53 AM",
					"commitName": "4a8099c6962da1e68309e0e382d0e6198a3937c2",
					"commitAuthor": "Yu",
					"commitDateOld": "2018-03-20, 10:39 AM",
					"commitNameOld": "4bd217c94f4cea806b1ab41b359908355ac2984c",
					"commitAuthorOld": "Lee Hinman",
					"daysBetweenCommits": 2.68,
					"commitsBetweenForRepo": 25,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,72 +1,71 @@\n-    public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n+    protected void addCustomXContentFields(XContentBuilder builder, Params params) throws IOException {\n         builder.startObject(Fields.INDICES);\n \n         for (IndexSegments indexSegments : getIndices().values()) {\n             builder.startObject(indexSegments.getIndex());\n \n             builder.startObject(Fields.SHARDS);\n             for (IndexShardSegments indexSegment : indexSegments) {\n                 builder.startArray(Integer.toString(indexSegment.getShardId().id()));\n                 for (ShardSegments shardSegments : indexSegment) {\n                     builder.startObject();\n \n                     builder.startObject(Fields.ROUTING);\n                     builder.field(Fields.STATE, shardSegments.getShardRouting().state());\n                     builder.field(Fields.PRIMARY, shardSegments.getShardRouting().primary());\n                     builder.field(Fields.NODE, shardSegments.getShardRouting().currentNodeId());\n                     if (shardSegments.getShardRouting().relocatingNodeId() != null) {\n                         builder.field(Fields.RELOCATING_NODE, shardSegments.getShardRouting().relocatingNodeId());\n                     }\n                     builder.endObject();\n \n                     builder.field(Fields.NUM_COMMITTED_SEGMENTS, shardSegments.getNumberOfCommitted());\n                     builder.field(Fields.NUM_SEARCH_SEGMENTS, shardSegments.getNumberOfSearch());\n \n                     builder.startObject(Fields.SEGMENTS);\n                     for (Segment segment : shardSegments) {\n                         builder.startObject(segment.getName());\n                         builder.field(Fields.GENERATION, segment.getGeneration());\n                         builder.field(Fields.NUM_DOCS, segment.getNumDocs());\n                         builder.field(Fields.DELETED_DOCS, segment.getDeletedDocs());\n                         builder.byteSizeField(Fields.SIZE_IN_BYTES, Fields.SIZE, segment.getSizeInBytes());\n                         builder.byteSizeField(Fields.MEMORY_IN_BYTES, Fields.MEMORY, segment.getMemoryInBytes());\n                         builder.field(Fields.COMMITTED, segment.isCommitted());\n                         builder.field(Fields.SEARCH, segment.isSearch());\n                         if (segment.getVersion() != null) {\n                             builder.field(Fields.VERSION, segment.getVersion());\n                         }\n                         if (segment.isCompound() != null) {\n                             builder.field(Fields.COMPOUND, segment.isCompound());\n                         }\n                         if (segment.getMergeId() != null) {\n                             builder.field(Fields.MERGE_ID, segment.getMergeId());\n                         }\n                         if (segment.getSegmentSort() != null) {\n                             toXContent(builder, segment.getSegmentSort());\n                         }\n                         if (segment.ramTree != null) {\n                             builder.startArray(Fields.RAM_TREE);\n                             for (Accountable child : segment.ramTree.getChildResources()) {\n                                 toXContent(builder, child);\n                             }\n                             builder.endArray();\n                         }\n                         if (segment.attributes != null && segment.attributes.isEmpty() == false) {\n                             builder.field(\"attributes\", segment.attributes);\n                         }\n                         builder.endObject();\n                     }\n                     builder.endObject();\n \n                     builder.endObject();\n                 }\n                 builder.endArray();\n             }\n             builder.endObject();\n \n             builder.endObject();\n         }\n \n         builder.endObject();\n-        return builder;\n     }\n\\ No newline at end of file\n",
					"extendedDetails": {
						"oldValue": "[public]",
						"newValue": "[protected]"
					}
				},
				{
					"type": "Ybodychange",
					"commitMessage": "Change BroadcastResponse from ToXContentFragment to ToXContentObject (#28878)\n\nWhile working on #27799, we find that it might make sense to change BroadcastResponse from ToXContentFragment to ToXContentObject, seeing that it's rather a complete XContent object and also the other Responses are normally ToXContentObject.\r\n\r\nBy doing this, we can also move the XContent build logic of BroadcastResponse's subclasses, from Rest Layer to the concrete classes themselves.\r\n\r\nRelates to #3889",
					"commitDate": "2018-03-23, 2:53 AM",
					"commitName": "4a8099c6962da1e68309e0e382d0e6198a3937c2",
					"commitAuthor": "Yu",
					"commitDateOld": "2018-03-20, 10:39 AM",
					"commitNameOld": "4bd217c94f4cea806b1ab41b359908355ac2984c",
					"commitAuthorOld": "Lee Hinman",
					"daysBetweenCommits": 2.68,
					"commitsBetweenForRepo": 25,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,72 +1,71 @@\n-    public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n+    protected void addCustomXContentFields(XContentBuilder builder, Params params) throws IOException {\n         builder.startObject(Fields.INDICES);\n \n         for (IndexSegments indexSegments : getIndices().values()) {\n             builder.startObject(indexSegments.getIndex());\n \n             builder.startObject(Fields.SHARDS);\n             for (IndexShardSegments indexSegment : indexSegments) {\n                 builder.startArray(Integer.toString(indexSegment.getShardId().id()));\n                 for (ShardSegments shardSegments : indexSegment) {\n                     builder.startObject();\n \n                     builder.startObject(Fields.ROUTING);\n                     builder.field(Fields.STATE, shardSegments.getShardRouting().state());\n                     builder.field(Fields.PRIMARY, shardSegments.getShardRouting().primary());\n                     builder.field(Fields.NODE, shardSegments.getShardRouting().currentNodeId());\n                     if (shardSegments.getShardRouting().relocatingNodeId() != null) {\n                         builder.field(Fields.RELOCATING_NODE, shardSegments.getShardRouting().relocatingNodeId());\n                     }\n                     builder.endObject();\n \n                     builder.field(Fields.NUM_COMMITTED_SEGMENTS, shardSegments.getNumberOfCommitted());\n                     builder.field(Fields.NUM_SEARCH_SEGMENTS, shardSegments.getNumberOfSearch());\n \n                     builder.startObject(Fields.SEGMENTS);\n                     for (Segment segment : shardSegments) {\n                         builder.startObject(segment.getName());\n                         builder.field(Fields.GENERATION, segment.getGeneration());\n                         builder.field(Fields.NUM_DOCS, segment.getNumDocs());\n                         builder.field(Fields.DELETED_DOCS, segment.getDeletedDocs());\n                         builder.byteSizeField(Fields.SIZE_IN_BYTES, Fields.SIZE, segment.getSizeInBytes());\n                         builder.byteSizeField(Fields.MEMORY_IN_BYTES, Fields.MEMORY, segment.getMemoryInBytes());\n                         builder.field(Fields.COMMITTED, segment.isCommitted());\n                         builder.field(Fields.SEARCH, segment.isSearch());\n                         if (segment.getVersion() != null) {\n                             builder.field(Fields.VERSION, segment.getVersion());\n                         }\n                         if (segment.isCompound() != null) {\n                             builder.field(Fields.COMPOUND, segment.isCompound());\n                         }\n                         if (segment.getMergeId() != null) {\n                             builder.field(Fields.MERGE_ID, segment.getMergeId());\n                         }\n                         if (segment.getSegmentSort() != null) {\n                             toXContent(builder, segment.getSegmentSort());\n                         }\n                         if (segment.ramTree != null) {\n                             builder.startArray(Fields.RAM_TREE);\n                             for (Accountable child : segment.ramTree.getChildResources()) {\n                                 toXContent(builder, child);\n                             }\n                             builder.endArray();\n                         }\n                         if (segment.attributes != null && segment.attributes.isEmpty() == false) {\n                             builder.field(\"attributes\", segment.attributes);\n                         }\n                         builder.endObject();\n                     }\n                     builder.endObject();\n \n                     builder.endObject();\n                 }\n                 builder.endArray();\n             }\n             builder.endObject();\n \n             builder.endObject();\n         }\n \n         builder.endObject();\n-        return builder;\n     }\n\\ No newline at end of file\n",
					"extendedDetails": {}
				}
			]
		},
		"99f88f15c5febbca2d13b5b5fda27b844153bf1a": {
			"type": "Yfilerename",
			"commitMessage": "Rename core module to server (#28180)\n\nThis is related to #27933. It renames the core module to server. This is\r\nthe first step towards introducing an elasticsearch-core jar.",
			"commitDate": "2018-01-11, 10:30 AM",
			"commitName": "99f88f15c5febbca2d13b5b5fda27b844153bf1a",
			"commitAuthor": "Tim Brooks",
			"commitDateOld": "2018-01-11, 8:31 AM",
			"commitNameOld": "7d0eb3292b8f8ba27ef50dbbf38783dc68c70728",
			"commitAuthorOld": "Martijn van Groningen",
			"daysBetweenCommits": 0.08,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "",
			"extendedDetails": {
				"oldPath": "core/src/main/java/org/elasticsearch/action/admin/indices/segments/IndicesSegmentResponse.java",
				"newPath": "server/src/main/java/org/elasticsearch/action/admin/indices/segments/IndicesSegmentResponse.java"
			}
		},
		"22292e8d964d2b7239f0fc306ea91692bdbc8b1e": {
			"type": "Ybodychange",
			"commitMessage": "Add segment attributes to the `_segments` API. (#26157)\n\nThis contains information about whether high compression was enabled for instance.\r\n\r\nCloses #26130",
			"commitDate": "2017-08-16, 10:01 AM",
			"commitName": "22292e8d964d2b7239f0fc306ea91692bdbc8b1e",
			"commitAuthor": "Adrien Grand",
			"commitDateOld": "2017-08-09, 7:53 AM",
			"commitNameOld": "dfbaf90951c5eaa7fd40a956f24b042aa11a2e23",
			"commitAuthorOld": "Colin Goodheart-Smithe",
			"daysBetweenCommits": 7.09,
			"commitsBetweenForRepo": 63,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,69 +1,72 @@\n     public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n         builder.startObject(Fields.INDICES);\n \n         for (IndexSegments indexSegments : getIndices().values()) {\n             builder.startObject(indexSegments.getIndex());\n \n             builder.startObject(Fields.SHARDS);\n             for (IndexShardSegments indexSegment : indexSegments) {\n                 builder.startArray(Integer.toString(indexSegment.getShardId().id()));\n                 for (ShardSegments shardSegments : indexSegment) {\n                     builder.startObject();\n \n                     builder.startObject(Fields.ROUTING);\n                     builder.field(Fields.STATE, shardSegments.getShardRouting().state());\n                     builder.field(Fields.PRIMARY, shardSegments.getShardRouting().primary());\n                     builder.field(Fields.NODE, shardSegments.getShardRouting().currentNodeId());\n                     if (shardSegments.getShardRouting().relocatingNodeId() != null) {\n                         builder.field(Fields.RELOCATING_NODE, shardSegments.getShardRouting().relocatingNodeId());\n                     }\n                     builder.endObject();\n \n                     builder.field(Fields.NUM_COMMITTED_SEGMENTS, shardSegments.getNumberOfCommitted());\n                     builder.field(Fields.NUM_SEARCH_SEGMENTS, shardSegments.getNumberOfSearch());\n \n                     builder.startObject(Fields.SEGMENTS);\n                     for (Segment segment : shardSegments) {\n                         builder.startObject(segment.getName());\n                         builder.field(Fields.GENERATION, segment.getGeneration());\n                         builder.field(Fields.NUM_DOCS, segment.getNumDocs());\n                         builder.field(Fields.DELETED_DOCS, segment.getDeletedDocs());\n                         builder.byteSizeField(Fields.SIZE_IN_BYTES, Fields.SIZE, segment.getSizeInBytes());\n                         builder.byteSizeField(Fields.MEMORY_IN_BYTES, Fields.MEMORY, segment.getMemoryInBytes());\n                         builder.field(Fields.COMMITTED, segment.isCommitted());\n                         builder.field(Fields.SEARCH, segment.isSearch());\n                         if (segment.getVersion() != null) {\n                             builder.field(Fields.VERSION, segment.getVersion());\n                         }\n                         if (segment.isCompound() != null) {\n                             builder.field(Fields.COMPOUND, segment.isCompound());\n                         }\n                         if (segment.getMergeId() != null) {\n                             builder.field(Fields.MERGE_ID, segment.getMergeId());\n                         }\n                         if (segment.getSegmentSort() != null) {\n                             toXContent(builder, segment.getSegmentSort());\n                         }\n                         if (segment.ramTree != null) {\n                             builder.startArray(Fields.RAM_TREE);\n                             for (Accountable child : segment.ramTree.getChildResources()) {\n                                 toXContent(builder, child);\n                             }\n                             builder.endArray();\n                         }\n+                        if (segment.attributes != null && segment.attributes.isEmpty() == false) {\n+                            builder.field(\"attributes\", segment.attributes);\n+                        }\n                         builder.endObject();\n                     }\n                     builder.endObject();\n \n                     builder.endObject();\n                 }\n                 builder.endArray();\n             }\n             builder.endObject();\n \n             builder.endObject();\n         }\n \n         builder.endObject();\n         return builder;\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"f05af0a382a995cb254a851d2306f12c3da2cd1b": {
			"type": "Ybodychange",
			"commitMessage": "Enable index-time sorting (#24055)\n\nThis change adds an index setting to define how the documents should be sorted inside each Segment.\r\nIt allows any numeric, date, boolean or keyword field inside a mapping to be used to sort the index on disk.\r\nIt is not allowed to use a `nested` fields inside an index that defines an index sorting since `nested` fields relies on the original sort of the index.\r\nThis change does not add early termination capabilities in the search layer. This will be added in a follow up.\r\n\r\nRelates #6720",
			"commitDate": "2017-04-19, 5:36 AM",
			"commitName": "f05af0a382a995cb254a851d2306f12c3da2cd1b",
			"commitAuthor": "Jim Ferenczi",
			"commitDateOld": "2016-04-18, 2:32 PM",
			"commitNameOld": "523b071836be9c9b954c9e45a026311c83483c05",
			"commitAuthorOld": "Ryan Ernst",
			"daysBetweenCommits": 365.63,
			"commitsBetweenForRepo": 4978,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,66 +1,69 @@\n     public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n         builder.startObject(Fields.INDICES);\n \n         for (IndexSegments indexSegments : getIndices().values()) {\n             builder.startObject(indexSegments.getIndex());\n \n             builder.startObject(Fields.SHARDS);\n             for (IndexShardSegments indexSegment : indexSegments) {\n                 builder.startArray(Integer.toString(indexSegment.getShardId().id()));\n                 for (ShardSegments shardSegments : indexSegment) {\n                     builder.startObject();\n \n                     builder.startObject(Fields.ROUTING);\n                     builder.field(Fields.STATE, shardSegments.getShardRouting().state());\n                     builder.field(Fields.PRIMARY, shardSegments.getShardRouting().primary());\n                     builder.field(Fields.NODE, shardSegments.getShardRouting().currentNodeId());\n                     if (shardSegments.getShardRouting().relocatingNodeId() != null) {\n                         builder.field(Fields.RELOCATING_NODE, shardSegments.getShardRouting().relocatingNodeId());\n                     }\n                     builder.endObject();\n \n                     builder.field(Fields.NUM_COMMITTED_SEGMENTS, shardSegments.getNumberOfCommitted());\n                     builder.field(Fields.NUM_SEARCH_SEGMENTS, shardSegments.getNumberOfSearch());\n \n                     builder.startObject(Fields.SEGMENTS);\n                     for (Segment segment : shardSegments) {\n                         builder.startObject(segment.getName());\n                         builder.field(Fields.GENERATION, segment.getGeneration());\n                         builder.field(Fields.NUM_DOCS, segment.getNumDocs());\n                         builder.field(Fields.DELETED_DOCS, segment.getDeletedDocs());\n                         builder.byteSizeField(Fields.SIZE_IN_BYTES, Fields.SIZE, segment.getSizeInBytes());\n                         builder.byteSizeField(Fields.MEMORY_IN_BYTES, Fields.MEMORY, segment.getMemoryInBytes());\n                         builder.field(Fields.COMMITTED, segment.isCommitted());\n                         builder.field(Fields.SEARCH, segment.isSearch());\n                         if (segment.getVersion() != null) {\n                             builder.field(Fields.VERSION, segment.getVersion());\n                         }\n                         if (segment.isCompound() != null) {\n                             builder.field(Fields.COMPOUND, segment.isCompound());\n                         }\n                         if (segment.getMergeId() != null) {\n                             builder.field(Fields.MERGE_ID, segment.getMergeId());\n                         }\n+                        if (segment.getSegmentSort() != null) {\n+                            toXContent(builder, segment.getSegmentSort());\n+                        }\n                         if (segment.ramTree != null) {\n                             builder.startArray(Fields.RAM_TREE);\n                             for (Accountable child : segment.ramTree.getChildResources()) {\n                                 toXContent(builder, child);\n                             }\n                             builder.endArray();\n                         }\n                         builder.endObject();\n                     }\n                     builder.endObject();\n \n                     builder.endObject();\n                 }\n                 builder.endArray();\n             }\n             builder.endObject();\n \n             builder.endObject();\n         }\n \n         builder.endObject();\n         return builder;\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"88dd6ba430e729d473432076a6eba1f6cb85c136": {
			"type": "Ybodychange",
			"commitMessage": "Rest: Remove 'case' parameter from rest apis\n\nThe current api allows for choosing which \"case\" response json keys are\nwritten in. This has the options of camelCase or underscore. camelCase\nis going to be deprecated from the query apis. However, with the case\napi, it is not necessary to deprecate, as users who were using it in 2.x\ncan transition completely on 2.x before upgrading by simply using\nthe underscore option.\n\nThis change removes the 'case' option from rest apis.\n\nsee #8988\n",
			"commitDate": "2016-04-14, 11:07 PM",
			"commitName": "88dd6ba430e729d473432076a6eba1f6cb85c136",
			"commitAuthor": "Ryan Ernst",
			"commitDateOld": "2016-01-27, 11:40 PM",
			"commitNameOld": "2a137b554825a5f848cfaff6311d7c298fd76fe7",
			"commitAuthorOld": "Boaz Leskes",
			"daysBetweenCommits": 77.94,
			"commitsBetweenForRepo": 1398,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,66 +1,66 @@\n     public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n         builder.startObject(Fields.INDICES);\n \n         for (IndexSegments indexSegments : getIndices().values()) {\n-            builder.startObject(indexSegments.getIndex(), XContentBuilder.FieldCaseConversion.NONE);\n+            builder.startObject(indexSegments.getIndex());\n \n             builder.startObject(Fields.SHARDS);\n             for (IndexShardSegments indexSegment : indexSegments) {\n                 builder.startArray(Integer.toString(indexSegment.getShardId().id()));\n                 for (ShardSegments shardSegments : indexSegment) {\n                     builder.startObject();\n \n                     builder.startObject(Fields.ROUTING);\n                     builder.field(Fields.STATE, shardSegments.getShardRouting().state());\n                     builder.field(Fields.PRIMARY, shardSegments.getShardRouting().primary());\n                     builder.field(Fields.NODE, shardSegments.getShardRouting().currentNodeId());\n                     if (shardSegments.getShardRouting().relocatingNodeId() != null) {\n                         builder.field(Fields.RELOCATING_NODE, shardSegments.getShardRouting().relocatingNodeId());\n                     }\n                     builder.endObject();\n \n                     builder.field(Fields.NUM_COMMITTED_SEGMENTS, shardSegments.getNumberOfCommitted());\n                     builder.field(Fields.NUM_SEARCH_SEGMENTS, shardSegments.getNumberOfSearch());\n \n                     builder.startObject(Fields.SEGMENTS);\n                     for (Segment segment : shardSegments) {\n                         builder.startObject(segment.getName());\n                         builder.field(Fields.GENERATION, segment.getGeneration());\n                         builder.field(Fields.NUM_DOCS, segment.getNumDocs());\n                         builder.field(Fields.DELETED_DOCS, segment.getDeletedDocs());\n                         builder.byteSizeField(Fields.SIZE_IN_BYTES, Fields.SIZE, segment.getSizeInBytes());\n                         builder.byteSizeField(Fields.MEMORY_IN_BYTES, Fields.MEMORY, segment.getMemoryInBytes());\n                         builder.field(Fields.COMMITTED, segment.isCommitted());\n                         builder.field(Fields.SEARCH, segment.isSearch());\n                         if (segment.getVersion() != null) {\n                             builder.field(Fields.VERSION, segment.getVersion());\n                         }\n                         if (segment.isCompound() != null) {\n                             builder.field(Fields.COMPOUND, segment.isCompound());\n                         }\n                         if (segment.getMergeId() != null) {\n                             builder.field(Fields.MERGE_ID, segment.getMergeId());\n                         }\n                         if (segment.ramTree != null) {\n                             builder.startArray(Fields.RAM_TREE);\n                             for (Accountable child : segment.ramTree.getChildResources()) {\n                                 toXContent(builder, child);\n                             }\n                             builder.endArray();\n                         }\n                         builder.endObject();\n                     }\n                     builder.endObject();\n \n                     builder.endObject();\n                 }\n                 builder.endArray();\n             }\n             builder.endObject();\n \n             builder.endObject();\n         }\n \n         builder.endObject();\n         return builder;\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"15a62448343fd24f8e63f43b1e4b16f50005e4a5": {
			"type": "Yfilerename",
			"commitMessage": "create core module\n",
			"commitDate": "2015-06-05, 4:12 AM",
			"commitName": "15a62448343fd24f8e63f43b1e4b16f50005e4a5",
			"commitAuthor": "Simon Willnauer",
			"commitDateOld": "2015-06-05, 4:11 AM",
			"commitNameOld": "7ccc193a666e2ae888e7ac93d677a2143e5e07c3",
			"commitAuthorOld": "Simon Willnauer",
			"daysBetweenCommits": 0,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "",
			"extendedDetails": {
				"oldPath": "src/main/java/org/elasticsearch/action/admin/indices/segments/IndicesSegmentResponse.java",
				"newPath": "core/src/main/java/org/elasticsearch/action/admin/indices/segments/IndicesSegmentResponse.java"
			}
		},
		"f7f99b8dbfe4cc10612faceec8f82e03884f0d6d": {
			"type": "Ybodychange",
			"commitMessage": "Stats: Added verbose option to segments api, with full ram tree as first\nadditional element per segment.\n\nThis commit adds a verbose flag to the _segments api.  Currently the\nonly additional information returned when set to true is the full\nram tree from lucene for each segment.\n",
			"commitDate": "2015-01-06, 10:04 AM",
			"commitName": "f7f99b8dbfe4cc10612faceec8f82e03884f0d6d",
			"commitAuthor": "Ryan Ernst",
			"commitDateOld": "2014-01-07, 2:22 AM",
			"commitNameOld": "10ec2e948a2f1426a5058ca3b2c2e39952f141d8",
			"commitAuthorOld": "Simon Willnauer",
			"daysBetweenCommits": 364.32,
			"commitsBetweenForRepo": 3611,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,59 +1,66 @@\n     public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n         builder.startObject(Fields.INDICES);\n \n         for (IndexSegments indexSegments : getIndices().values()) {\n             builder.startObject(indexSegments.getIndex(), XContentBuilder.FieldCaseConversion.NONE);\n \n             builder.startObject(Fields.SHARDS);\n             for (IndexShardSegments indexSegment : indexSegments) {\n                 builder.startArray(Integer.toString(indexSegment.getShardId().id()));\n                 for (ShardSegments shardSegments : indexSegment) {\n                     builder.startObject();\n \n                     builder.startObject(Fields.ROUTING);\n                     builder.field(Fields.STATE, shardSegments.getShardRouting().state());\n                     builder.field(Fields.PRIMARY, shardSegments.getShardRouting().primary());\n                     builder.field(Fields.NODE, shardSegments.getShardRouting().currentNodeId());\n                     if (shardSegments.getShardRouting().relocatingNodeId() != null) {\n                         builder.field(Fields.RELOCATING_NODE, shardSegments.getShardRouting().relocatingNodeId());\n                     }\n                     builder.endObject();\n \n                     builder.field(Fields.NUM_COMMITTED_SEGMENTS, shardSegments.getNumberOfCommitted());\n                     builder.field(Fields.NUM_SEARCH_SEGMENTS, shardSegments.getNumberOfSearch());\n \n                     builder.startObject(Fields.SEGMENTS);\n                     for (Segment segment : shardSegments) {\n                         builder.startObject(segment.getName());\n                         builder.field(Fields.GENERATION, segment.getGeneration());\n                         builder.field(Fields.NUM_DOCS, segment.getNumDocs());\n                         builder.field(Fields.DELETED_DOCS, segment.getDeletedDocs());\n                         builder.byteSizeField(Fields.SIZE_IN_BYTES, Fields.SIZE, segment.getSizeInBytes());\n                         builder.byteSizeField(Fields.MEMORY_IN_BYTES, Fields.MEMORY, segment.getMemoryInBytes());\n                         builder.field(Fields.COMMITTED, segment.isCommitted());\n                         builder.field(Fields.SEARCH, segment.isSearch());\n                         if (segment.getVersion() != null) {\n                             builder.field(Fields.VERSION, segment.getVersion());\n                         }\n                         if (segment.isCompound() != null) {\n                             builder.field(Fields.COMPOUND, segment.isCompound());\n                         }\n                         if (segment.getMergeId() != null) {\n                             builder.field(Fields.MERGE_ID, segment.getMergeId());\n                         }\n+                        if (segment.ramTree != null) {\n+                            builder.startArray(Fields.RAM_TREE);\n+                            for (Accountable child : segment.ramTree.getChildResources()) {\n+                                toXContent(builder, child);\n+                            }\n+                            builder.endArray();\n+                        }\n                         builder.endObject();\n                     }\n                     builder.endObject();\n \n                     builder.endObject();\n                 }\n                 builder.endArray();\n             }\n             builder.endObject();\n \n             builder.endObject();\n         }\n \n         builder.endObject();\n         return builder;\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"95ca06cf0945233686e92ccdb3354522ff05863c": {
			"type": "Ybodychange",
			"commitMessage": "Add the memory used on segment/segments stats\nThe memory used for the Lucene index (term dict, bloom filter, ...) can now be reported per segment using the segments API, and on the segments flag on node/indices stats\ncloses #4512\n",
			"commitDate": "2013-12-18, 1:21 PM",
			"commitName": "95ca06cf0945233686e92ccdb3354522ff05863c",
			"commitAuthor": "Shay Banon",
			"commitDateOld": "2013-10-14, 2:04 AM",
			"commitNameOld": "c093e90d517a3652d8b8f46c61a48097132a8cef",
			"commitAuthorOld": "Shay Banon",
			"daysBetweenCommits": 65.51,
			"commitsBetweenForRepo": 579,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,58 +1,59 @@\n     public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n         builder.startObject(Fields.INDICES);\n \n         for (IndexSegments indexSegments : getIndices().values()) {\n             builder.startObject(indexSegments.getIndex(), XContentBuilder.FieldCaseConversion.NONE);\n \n             builder.startObject(Fields.SHARDS);\n             for (IndexShardSegments indexSegment : indexSegments) {\n                 builder.startArray(Integer.toString(indexSegment.getShardId().id()));\n                 for (ShardSegments shardSegments : indexSegment) {\n                     builder.startObject();\n \n                     builder.startObject(Fields.ROUTING);\n                     builder.field(Fields.STATE, shardSegments.getShardRouting().state());\n                     builder.field(Fields.PRIMARY, shardSegments.getShardRouting().primary());\n                     builder.field(Fields.NODE, shardSegments.getShardRouting().currentNodeId());\n                     if (shardSegments.getShardRouting().relocatingNodeId() != null) {\n                         builder.field(Fields.RELOCATING_NODE, shardSegments.getShardRouting().relocatingNodeId());\n                     }\n                     builder.endObject();\n \n                     builder.field(Fields.NUM_COMMITTED_SEGMENTS, shardSegments.getNumberOfCommitted());\n                     builder.field(Fields.NUM_SEARCH_SEGMENTS, shardSegments.getNumberOfSearch());\n \n                     builder.startObject(Fields.SEGMENTS);\n                     for (Segment segment : shardSegments) {\n                         builder.startObject(segment.getName());\n                         builder.field(Fields.GENERATION, segment.getGeneration());\n                         builder.field(Fields.NUM_DOCS, segment.getNumDocs());\n                         builder.field(Fields.DELETED_DOCS, segment.getDeletedDocs());\n                         builder.byteSizeField(Fields.SIZE_IN_BYTES, Fields.SIZE, segment.getSizeInBytes());\n+                        builder.byteSizeField(Fields.MEMORY_IN_BYTES, Fields.MEMORY, segment.getMemoryInBytes());\n                         builder.field(Fields.COMMITTED, segment.isCommitted());\n                         builder.field(Fields.SEARCH, segment.isSearch());\n                         if (segment.getVersion() != null) {\n                             builder.field(Fields.VERSION, segment.getVersion());\n                         }\n                         if (segment.isCompound() != null) {\n                             builder.field(Fields.COMPOUND, segment.isCompound());\n                         }\n                         if (segment.getMergeId() != null) {\n                             builder.field(Fields.MERGE_ID, segment.getMergeId());\n                         }\n                         builder.endObject();\n                     }\n                     builder.endObject();\n \n                     builder.endObject();\n                 }\n                 builder.endArray();\n             }\n             builder.endObject();\n \n             builder.endObject();\n         }\n \n         builder.endObject();\n         return builder;\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"c093e90d517a3652d8b8f46c61a48097132a8cef": {
			"type": "Ybodychange",
			"commitMessage": "Segments API: Support merge id on segments (groups segments being merged)\nReturn a merge_id element in each segment of the segments API, allowing to group segments that are being merged as part of a single merge and indicate which ones are being merged now.\ncloses #3904\n",
			"commitDate": "2013-10-14, 2:04 AM",
			"commitName": "c093e90d517a3652d8b8f46c61a48097132a8cef",
			"commitAuthor": "Shay Banon",
			"commitDateOld": "2013-08-27, 2:48 AM",
			"commitNameOld": "6e19ca808056e3c69545a837180d23faa863fec7",
			"commitAuthorOld": "Luca Cavanna",
			"daysBetweenCommits": 47.97,
			"commitsBetweenForRepo": 416,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,55 +1,58 @@\n     public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n         builder.startObject(Fields.INDICES);\n \n         for (IndexSegments indexSegments : getIndices().values()) {\n             builder.startObject(indexSegments.getIndex(), XContentBuilder.FieldCaseConversion.NONE);\n \n             builder.startObject(Fields.SHARDS);\n             for (IndexShardSegments indexSegment : indexSegments) {\n                 builder.startArray(Integer.toString(indexSegment.getShardId().id()));\n                 for (ShardSegments shardSegments : indexSegment) {\n                     builder.startObject();\n \n                     builder.startObject(Fields.ROUTING);\n                     builder.field(Fields.STATE, shardSegments.getShardRouting().state());\n                     builder.field(Fields.PRIMARY, shardSegments.getShardRouting().primary());\n                     builder.field(Fields.NODE, shardSegments.getShardRouting().currentNodeId());\n                     if (shardSegments.getShardRouting().relocatingNodeId() != null) {\n                         builder.field(Fields.RELOCATING_NODE, shardSegments.getShardRouting().relocatingNodeId());\n                     }\n                     builder.endObject();\n \n                     builder.field(Fields.NUM_COMMITTED_SEGMENTS, shardSegments.getNumberOfCommitted());\n                     builder.field(Fields.NUM_SEARCH_SEGMENTS, shardSegments.getNumberOfSearch());\n \n                     builder.startObject(Fields.SEGMENTS);\n                     for (Segment segment : shardSegments) {\n                         builder.startObject(segment.getName());\n                         builder.field(Fields.GENERATION, segment.getGeneration());\n                         builder.field(Fields.NUM_DOCS, segment.getNumDocs());\n                         builder.field(Fields.DELETED_DOCS, segment.getDeletedDocs());\n                         builder.byteSizeField(Fields.SIZE_IN_BYTES, Fields.SIZE, segment.getSizeInBytes());\n                         builder.field(Fields.COMMITTED, segment.isCommitted());\n                         builder.field(Fields.SEARCH, segment.isSearch());\n                         if (segment.getVersion() != null) {\n                             builder.field(Fields.VERSION, segment.getVersion());\n                         }\n                         if (segment.isCompound() != null) {\n                             builder.field(Fields.COMPOUND, segment.isCompound());\n                         }\n+                        if (segment.getMergeId() != null) {\n+                            builder.field(Fields.MERGE_ID, segment.getMergeId());\n+                        }\n                         builder.endObject();\n                     }\n                     builder.endObject();\n \n                     builder.endObject();\n                 }\n                 builder.endArray();\n             }\n             builder.endObject();\n \n             builder.endObject();\n         }\n \n         builder.endObject();\n         return builder;\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"6e19ca808056e3c69545a837180d23faa863fec7": {
			"type": "Ybodychange",
			"commitMessage": "Fixed order of parameters when calling byteSizeField and timeValueField methods (introduced with #3432 - support for human readable flag)\n",
			"commitDate": "2013-08-27, 2:48 AM",
			"commitName": "6e19ca808056e3c69545a837180d23faa863fec7",
			"commitAuthor": "Luca Cavanna",
			"commitDateOld": "2013-08-06, 7:08 AM",
			"commitNameOld": "a3071540d7f245db5a55d30133bebe067ac9f7d4",
			"commitAuthorOld": "Luca Cavanna",
			"daysBetweenCommits": 20.82,
			"commitsBetweenForRepo": 180,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,55 +1,55 @@\n     public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n         builder.startObject(Fields.INDICES);\n \n         for (IndexSegments indexSegments : getIndices().values()) {\n             builder.startObject(indexSegments.getIndex(), XContentBuilder.FieldCaseConversion.NONE);\n \n             builder.startObject(Fields.SHARDS);\n             for (IndexShardSegments indexSegment : indexSegments) {\n                 builder.startArray(Integer.toString(indexSegment.getShardId().id()));\n                 for (ShardSegments shardSegments : indexSegment) {\n                     builder.startObject();\n \n                     builder.startObject(Fields.ROUTING);\n                     builder.field(Fields.STATE, shardSegments.getShardRouting().state());\n                     builder.field(Fields.PRIMARY, shardSegments.getShardRouting().primary());\n                     builder.field(Fields.NODE, shardSegments.getShardRouting().currentNodeId());\n                     if (shardSegments.getShardRouting().relocatingNodeId() != null) {\n                         builder.field(Fields.RELOCATING_NODE, shardSegments.getShardRouting().relocatingNodeId());\n                     }\n                     builder.endObject();\n \n                     builder.field(Fields.NUM_COMMITTED_SEGMENTS, shardSegments.getNumberOfCommitted());\n                     builder.field(Fields.NUM_SEARCH_SEGMENTS, shardSegments.getNumberOfSearch());\n \n                     builder.startObject(Fields.SEGMENTS);\n                     for (Segment segment : shardSegments) {\n                         builder.startObject(segment.getName());\n                         builder.field(Fields.GENERATION, segment.getGeneration());\n                         builder.field(Fields.NUM_DOCS, segment.getNumDocs());\n                         builder.field(Fields.DELETED_DOCS, segment.getDeletedDocs());\n-                        builder.byteSizeField(Fields.SIZE, Fields.SIZE_IN_BYTES, segment.getSizeInBytes());\n+                        builder.byteSizeField(Fields.SIZE_IN_BYTES, Fields.SIZE, segment.getSizeInBytes());\n                         builder.field(Fields.COMMITTED, segment.isCommitted());\n                         builder.field(Fields.SEARCH, segment.isSearch());\n                         if (segment.getVersion() != null) {\n                             builder.field(Fields.VERSION, segment.getVersion());\n                         }\n                         if (segment.isCompound() != null) {\n                             builder.field(Fields.COMPOUND, segment.isCompound());\n                         }\n                         builder.endObject();\n                     }\n                     builder.endObject();\n \n                     builder.endObject();\n                 }\n                 builder.endArray();\n             }\n             builder.endObject();\n \n             builder.endObject();\n         }\n \n         builder.endObject();\n         return builder;\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"a3071540d7f245db5a55d30133bebe067ac9f7d4": {
			"type": "Ybodychange",
			"commitMessage": "Added support for readable_format parameter when printing out time and size values\n\nThe following are the API affected by this change and support now the readable_format flag (default false when not specified):\n- indices segments\n- indices stats\n- indices status\n- cluster nodes stats\n- cluster nodes info\n\nCloses #3432\n",
			"commitDate": "2013-08-06, 7:08 AM",
			"commitName": "a3071540d7f245db5a55d30133bebe067ac9f7d4",
			"commitAuthor": "Luca Cavanna",
			"commitDateOld": "2013-03-28, 7:34 AM",
			"commitNameOld": "1fc37e59547ba544ab1a4677f2622c9e39b26313",
			"commitAuthorOld": "Shay Banon",
			"daysBetweenCommits": 130.98,
			"commitsBetweenForRepo": 575,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,56 +1,55 @@\n     public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n         builder.startObject(Fields.INDICES);\n \n         for (IndexSegments indexSegments : getIndices().values()) {\n             builder.startObject(indexSegments.getIndex(), XContentBuilder.FieldCaseConversion.NONE);\n \n             builder.startObject(Fields.SHARDS);\n             for (IndexShardSegments indexSegment : indexSegments) {\n                 builder.startArray(Integer.toString(indexSegment.getShardId().id()));\n                 for (ShardSegments shardSegments : indexSegment) {\n                     builder.startObject();\n \n                     builder.startObject(Fields.ROUTING);\n                     builder.field(Fields.STATE, shardSegments.getShardRouting().state());\n                     builder.field(Fields.PRIMARY, shardSegments.getShardRouting().primary());\n                     builder.field(Fields.NODE, shardSegments.getShardRouting().currentNodeId());\n                     if (shardSegments.getShardRouting().relocatingNodeId() != null) {\n                         builder.field(Fields.RELOCATING_NODE, shardSegments.getShardRouting().relocatingNodeId());\n                     }\n                     builder.endObject();\n \n                     builder.field(Fields.NUM_COMMITTED_SEGMENTS, shardSegments.getNumberOfCommitted());\n                     builder.field(Fields.NUM_SEARCH_SEGMENTS, shardSegments.getNumberOfSearch());\n \n                     builder.startObject(Fields.SEGMENTS);\n                     for (Segment segment : shardSegments) {\n                         builder.startObject(segment.getName());\n                         builder.field(Fields.GENERATION, segment.getGeneration());\n                         builder.field(Fields.NUM_DOCS, segment.getNumDocs());\n                         builder.field(Fields.DELETED_DOCS, segment.getDeletedDocs());\n-                        builder.field(Fields.SIZE, segment.getSize().toString());\n-                        builder.field(Fields.SIZE_IN_BYTES, segment.getSizeInBytes());\n+                        builder.byteSizeField(Fields.SIZE, Fields.SIZE_IN_BYTES, segment.getSizeInBytes());\n                         builder.field(Fields.COMMITTED, segment.isCommitted());\n                         builder.field(Fields.SEARCH, segment.isSearch());\n                         if (segment.getVersion() != null) {\n                             builder.field(Fields.VERSION, segment.getVersion());\n                         }\n                         if (segment.isCompound() != null) {\n                             builder.field(Fields.COMPOUND, segment.isCompound());\n                         }\n                         builder.endObject();\n                     }\n                     builder.endObject();\n \n                     builder.endObject();\n                 }\n                 builder.endArray();\n             }\n             builder.endObject();\n \n             builder.endObject();\n         }\n \n         builder.endObject();\n         return builder;\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"1fc37e59547ba544ab1a4677f2622c9e39b26313": {
			"type": "Ybodychange",
			"commitMessage": "Segments API: Add version & compound for each segment\ncloses #2823\n",
			"commitDate": "2013-03-28, 7:34 AM",
			"commitName": "1fc37e59547ba544ab1a4677f2622c9e39b26313",
			"commitAuthor": "Shay Banon",
			"commitDateOld": "2013-02-18, 8:09 AM",
			"commitNameOld": "cc83c2f848be69a77f1275fe1ff5363dcdd4c955",
			"commitAuthorOld": "David Pilato",
			"daysBetweenCommits": 37.93,
			"commitsBetweenForRepo": 178,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,50 +1,56 @@\n     public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n         builder.startObject(Fields.INDICES);\n \n         for (IndexSegments indexSegments : getIndices().values()) {\n             builder.startObject(indexSegments.getIndex(), XContentBuilder.FieldCaseConversion.NONE);\n \n             builder.startObject(Fields.SHARDS);\n             for (IndexShardSegments indexSegment : indexSegments) {\n                 builder.startArray(Integer.toString(indexSegment.getShardId().id()));\n                 for (ShardSegments shardSegments : indexSegment) {\n                     builder.startObject();\n \n                     builder.startObject(Fields.ROUTING);\n                     builder.field(Fields.STATE, shardSegments.getShardRouting().state());\n                     builder.field(Fields.PRIMARY, shardSegments.getShardRouting().primary());\n                     builder.field(Fields.NODE, shardSegments.getShardRouting().currentNodeId());\n                     if (shardSegments.getShardRouting().relocatingNodeId() != null) {\n                         builder.field(Fields.RELOCATING_NODE, shardSegments.getShardRouting().relocatingNodeId());\n                     }\n                     builder.endObject();\n \n                     builder.field(Fields.NUM_COMMITTED_SEGMENTS, shardSegments.getNumberOfCommitted());\n                     builder.field(Fields.NUM_SEARCH_SEGMENTS, shardSegments.getNumberOfSearch());\n \n                     builder.startObject(Fields.SEGMENTS);\n                     for (Segment segment : shardSegments) {\n-                        builder.startObject(segment.name());\n-                        builder.field(Fields.GENERATION, segment.generation());\n-                        builder.field(Fields.NUM_DOCS, segment.numDocs());\n-                        builder.field(Fields.DELETED_DOCS, segment.deletedDocs());\n-                        builder.field(Fields.SIZE, segment.size().toString());\n-                        builder.field(Fields.SIZE_IN_BYTES, segment.sizeInBytes());\n-                        builder.field(Fields.COMMITTED, segment.committed());\n-                        builder.field(Fields.SEARCH, segment.search());\n+                        builder.startObject(segment.getName());\n+                        builder.field(Fields.GENERATION, segment.getGeneration());\n+                        builder.field(Fields.NUM_DOCS, segment.getNumDocs());\n+                        builder.field(Fields.DELETED_DOCS, segment.getDeletedDocs());\n+                        builder.field(Fields.SIZE, segment.getSize().toString());\n+                        builder.field(Fields.SIZE_IN_BYTES, segment.getSizeInBytes());\n+                        builder.field(Fields.COMMITTED, segment.isCommitted());\n+                        builder.field(Fields.SEARCH, segment.isSearch());\n+                        if (segment.getVersion() != null) {\n+                            builder.field(Fields.VERSION, segment.getVersion());\n+                        }\n+                        if (segment.isCompound() != null) {\n+                            builder.field(Fields.COMPOUND, segment.isCompound());\n+                        }\n                         builder.endObject();\n                     }\n                     builder.endObject();\n \n                     builder.endObject();\n                 }\n                 builder.endArray();\n             }\n             builder.endObject();\n \n             builder.endObject();\n         }\n \n         builder.endObject();\n         return builder;\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"cc83c2f848be69a77f1275fe1ff5363dcdd4c955": {
			"type": "Ybodychange",
			"commitMessage": "refactoring getter/setters\n\nFixes #2657\n",
			"commitDate": "2013-02-18, 8:09 AM",
			"commitName": "cc83c2f848be69a77f1275fe1ff5363dcdd4c955",
			"commitAuthor": "David Pilato",
			"commitDateOld": "2011-12-05, 4:43 PM",
			"commitNameOld": "6a71eab51f6d7e7a436d8986df3685c7e0774bd3",
			"commitAuthorOld": "Shay Banon",
			"daysBetweenCommits": 440.64,
			"commitsBetweenForRepo": 1362,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,50 +1,50 @@\n     public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n         builder.startObject(Fields.INDICES);\n \n-        for (IndexSegments indexSegments : indices().values()) {\n-            builder.startObject(indexSegments.index(), XContentBuilder.FieldCaseConversion.NONE);\n+        for (IndexSegments indexSegments : getIndices().values()) {\n+            builder.startObject(indexSegments.getIndex(), XContentBuilder.FieldCaseConversion.NONE);\n \n             builder.startObject(Fields.SHARDS);\n             for (IndexShardSegments indexSegment : indexSegments) {\n-                builder.startArray(Integer.toString(indexSegment.shardId().id()));\n+                builder.startArray(Integer.toString(indexSegment.getShardId().id()));\n                 for (ShardSegments shardSegments : indexSegment) {\n                     builder.startObject();\n \n                     builder.startObject(Fields.ROUTING);\n-                    builder.field(Fields.STATE, shardSegments.shardRouting().state());\n-                    builder.field(Fields.PRIMARY, shardSegments.shardRouting().primary());\n-                    builder.field(Fields.NODE, shardSegments.shardRouting().currentNodeId());\n-                    if (shardSegments.shardRouting().relocatingNodeId() != null) {\n-                        builder.field(Fields.RELOCATING_NODE, shardSegments.shardRouting().relocatingNodeId());\n+                    builder.field(Fields.STATE, shardSegments.getShardRouting().state());\n+                    builder.field(Fields.PRIMARY, shardSegments.getShardRouting().primary());\n+                    builder.field(Fields.NODE, shardSegments.getShardRouting().currentNodeId());\n+                    if (shardSegments.getShardRouting().relocatingNodeId() != null) {\n+                        builder.field(Fields.RELOCATING_NODE, shardSegments.getShardRouting().relocatingNodeId());\n                     }\n                     builder.endObject();\n \n-                    builder.field(Fields.NUM_COMMITTED_SEGMENTS, shardSegments.numberOfCommitted());\n-                    builder.field(Fields.NUM_SEARCH_SEGMENTS, shardSegments.numberOfSearch());\n+                    builder.field(Fields.NUM_COMMITTED_SEGMENTS, shardSegments.getNumberOfCommitted());\n+                    builder.field(Fields.NUM_SEARCH_SEGMENTS, shardSegments.getNumberOfSearch());\n \n                     builder.startObject(Fields.SEGMENTS);\n                     for (Segment segment : shardSegments) {\n                         builder.startObject(segment.name());\n                         builder.field(Fields.GENERATION, segment.generation());\n                         builder.field(Fields.NUM_DOCS, segment.numDocs());\n                         builder.field(Fields.DELETED_DOCS, segment.deletedDocs());\n                         builder.field(Fields.SIZE, segment.size().toString());\n                         builder.field(Fields.SIZE_IN_BYTES, segment.sizeInBytes());\n                         builder.field(Fields.COMMITTED, segment.committed());\n                         builder.field(Fields.SEARCH, segment.search());\n                         builder.endObject();\n                     }\n                     builder.endObject();\n \n                     builder.endObject();\n                 }\n                 builder.endArray();\n             }\n             builder.endObject();\n \n             builder.endObject();\n         }\n \n         builder.endObject();\n         return builder;\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"a8fd2d48b8f3f17d68ed27c3104e2c9e2eb6cc9c": {
			"type": "Yfilerename",
			"commitMessage": "first cleanup phase, move to single src\n",
			"commitDate": "2011-12-05, 2:59 PM",
			"commitName": "a8fd2d48b8f3f17d68ed27c3104e2c9e2eb6cc9c",
			"commitAuthor": "Shay Banon",
			"commitDateOld": "2011-12-05, 11:00 AM",
			"commitNameOld": "473b0f4dff504690754acc0f00967c275bf322a8",
			"commitAuthorOld": "Shay Banon",
			"daysBetweenCommits": 0.17,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "",
			"extendedDetails": {
				"oldPath": "modules/elasticsearch/src/main/java/org/elasticsearch/action/admin/indices/segments/IndicesSegmentResponse.java",
				"newPath": "src/main/java/org/elasticsearch/action/admin/indices/segments/IndicesSegmentResponse.java"
			}
		},
		"3eaf73a380000acef6b971fe09a7d1f38aa748d1": {
			"type": "Ybodychange",
			"commitMessage": "Add number of committed and number of search segments to the segments API response\n",
			"commitDate": "2011-09-14, 10:48 AM",
			"commitName": "3eaf73a380000acef6b971fe09a7d1f38aa748d1",
			"commitAuthor": "Shay Banon",
			"commitDateOld": "2011-06-25, 2:20 PM",
			"commitNameOld": "b670a7f2a345aa2507714c1e8b61906c679c1107",
			"commitAuthorOld": "kimchy",
			"daysBetweenCommits": 80.85,
			"commitsBetweenForRepo": 367,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,47 +1,50 @@\n     @Override public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n         builder.startObject(Fields.INDICES);\n \n         for (IndexSegments indexSegments : indices().values()) {\n             builder.startObject(indexSegments.index(), XContentBuilder.FieldCaseConversion.NONE);\n \n             builder.startObject(Fields.SHARDS);\n             for (IndexShardSegments indexSegment : indexSegments) {\n                 builder.startArray(Integer.toString(indexSegment.shardId().id()));\n                 for (ShardSegments shardSegments : indexSegment) {\n                     builder.startObject();\n \n                     builder.startObject(Fields.ROUTING);\n                     builder.field(Fields.STATE, shardSegments.shardRouting().state());\n                     builder.field(Fields.PRIMARY, shardSegments.shardRouting().primary());\n                     builder.field(Fields.NODE, shardSegments.shardRouting().currentNodeId());\n                     if (shardSegments.shardRouting().relocatingNodeId() != null) {\n                         builder.field(Fields.RELOCATING_NODE, shardSegments.shardRouting().relocatingNodeId());\n                     }\n                     builder.endObject();\n \n+                    builder.field(Fields.NUM_COMMITTED_SEGMENTS, shardSegments.numberOfCommitted());\n+                    builder.field(Fields.NUM_SEARCH_SEGMENTS, shardSegments.numberOfSearch());\n+\n                     builder.startObject(Fields.SEGMENTS);\n                     for (Segment segment : shardSegments) {\n                         builder.startObject(segment.name());\n                         builder.field(Fields.GENERATION, segment.generation());\n                         builder.field(Fields.NUM_DOCS, segment.numDocs());\n                         builder.field(Fields.DELETED_DOCS, segment.deletedDocs());\n                         builder.field(Fields.SIZE, segment.size().toString());\n                         builder.field(Fields.SIZE_IN_BYTES, segment.sizeInBytes());\n                         builder.field(Fields.COMMITTED, segment.committed());\n                         builder.field(Fields.SEARCH, segment.search());\n                         builder.endObject();\n                     }\n                     builder.endObject();\n \n                     builder.endObject();\n                 }\n                 builder.endArray();\n             }\n             builder.endObject();\n \n             builder.endObject();\n         }\n \n         builder.endObject();\n         return builder;\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"b670a7f2a345aa2507714c1e8b61906c679c1107": {
			"type": "Yintroduced",
			"commitMessage": "Indices Segments API: Internal segments info of shard level Lucene indices, closes #1064.\n",
			"commitDate": "2011-06-25, 2:20 PM",
			"commitName": "b670a7f2a345aa2507714c1e8b61906c679c1107",
			"commitAuthor": "kimchy",
			"diff": "@@ -0,0 +1,47 @@\n+    @Override public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n+        builder.startObject(Fields.INDICES);\n+\n+        for (IndexSegments indexSegments : indices().values()) {\n+            builder.startObject(indexSegments.index(), XContentBuilder.FieldCaseConversion.NONE);\n+\n+            builder.startObject(Fields.SHARDS);\n+            for (IndexShardSegments indexSegment : indexSegments) {\n+                builder.startArray(Integer.toString(indexSegment.shardId().id()));\n+                for (ShardSegments shardSegments : indexSegment) {\n+                    builder.startObject();\n+\n+                    builder.startObject(Fields.ROUTING);\n+                    builder.field(Fields.STATE, shardSegments.shardRouting().state());\n+                    builder.field(Fields.PRIMARY, shardSegments.shardRouting().primary());\n+                    builder.field(Fields.NODE, shardSegments.shardRouting().currentNodeId());\n+                    if (shardSegments.shardRouting().relocatingNodeId() != null) {\n+                        builder.field(Fields.RELOCATING_NODE, shardSegments.shardRouting().relocatingNodeId());\n+                    }\n+                    builder.endObject();\n+\n+                    builder.startObject(Fields.SEGMENTS);\n+                    for (Segment segment : shardSegments) {\n+                        builder.startObject(segment.name());\n+                        builder.field(Fields.GENERATION, segment.generation());\n+                        builder.field(Fields.NUM_DOCS, segment.numDocs());\n+                        builder.field(Fields.DELETED_DOCS, segment.deletedDocs());\n+                        builder.field(Fields.SIZE, segment.size().toString());\n+                        builder.field(Fields.SIZE_IN_BYTES, segment.sizeInBytes());\n+                        builder.field(Fields.COMMITTED, segment.committed());\n+                        builder.field(Fields.SEARCH, segment.search());\n+                        builder.endObject();\n+                    }\n+                    builder.endObject();\n+\n+                    builder.endObject();\n+                }\n+                builder.endArray();\n+            }\n+            builder.endObject();\n+\n+            builder.endObject();\n+        }\n+\n+        builder.endObject();\n+        return builder;\n+    }\n\\ No newline at end of file\n"
		}
	},
	"sha": "767c69593c67befb843686de8ea51b7bc87728c9"
}