{
	"repo": "https://github.com/hibernate/hibernate-orm.git",
	"file": "hibernate-core/src/main/java/org/hibernate/cfg/AnnotationBinder.java",
	"method": {
		"longName": "public void bindClass(XClass clazzToProcess, Map<XClass, InheritanceState> inheritanceStatePerClass, MetadataBuildingContext context);",
		"startLine": 524,
		"methodName": "bindClass",
		"isStatic": true,
		"isAbstract": false,
		"visibility": "public"
	},
	"history": {
		"ebca36a76851c9b0b7ea406e1b1428225891de2f": {
			"type": "Ybodychange",
			"commitMessage": "HHH-12654 - Throw MappingException if both @Inheritance and @AttributeOverride are used\n",
			"commitDate": "2018-06-20, 7:03 AM",
			"commitName": "ebca36a76851c9b0b7ea406e1b1428225891de2f",
			"commitAuthor": "Vlad Mihalcea",
			"commitDateOld": "2018-04-16, 7:47 AM",
			"commitNameOld": "6cefa865b0635a71eb85e20f6255491439ecb6da",
			"commitAuthorOld": "Andrea Boriero",
			"daysBetweenCommits": 64.97,
			"commitsBetweenForRepo": 224,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,302 +1,311 @@\n \tpublic static void bindClass(\n \t\t\tXClass clazzToProcess,\n \t\t\tMap<XClass, InheritanceState> inheritanceStatePerClass,\n \t\t\tMetadataBuildingContext context) throws MappingException {\n \t\t//@Entity and @MappedSuperclass on the same class leads to a NPE down the road\n \t\tif ( clazzToProcess.isAnnotationPresent( Entity.class )\n \t\t\t\t&&  clazzToProcess.isAnnotationPresent( MappedSuperclass.class ) ) {\n \t\t\tthrow new AnnotationException( \"An entity cannot be annotated with both @Entity and @MappedSuperclass: \"\n \t\t\t\t\t+ clazzToProcess.getName() );\n \t\t}\n \n \t\t//TODO: be more strict with secondarytable allowance (not for ids, not for secondary table join columns etc)\n \t\tInheritanceState inheritanceState = inheritanceStatePerClass.get( clazzToProcess );\n \t\tAnnotatedClassType classType = context.getMetadataCollector().getClassType( clazzToProcess );\n \n \t\t//Queries declared in MappedSuperclass should be usable in Subclasses\n \t\tif ( AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals( classType ) ) {\n \t\t\tbindQueries( clazzToProcess, context );\n \t\t\tbindTypeDefs( clazzToProcess, context );\n \t\t\tbindFilterDefs( clazzToProcess, context );\n \t\t}\n \n \t\tif ( !isEntityClassType( clazzToProcess, classType ) ) {\n \t\t\treturn;\n \t\t}\n \n \t\tif ( LOG.isDebugEnabled() ) {\n \t\t\tLOG.debugf( \"Binding entity from annotated class: %s\", clazzToProcess.getName() );\n \t\t}\n \n \t\tPersistentClass superEntity = getSuperEntity(\n \t\t\t\tclazzToProcess,\n \t\t\t\tinheritanceStatePerClass,\n \t\t\t\tcontext,\n \t\t\t\tinheritanceState\n \t\t);\n \n+\t\tif(superEntity != null && (\n+\t\t\t\tclazzToProcess.getAnnotation( AttributeOverride.class ) != null ||\n+\t\t\t\tclazzToProcess.getAnnotation( AttributeOverrides.class ) != null ) ) {\n+\t\t\tthrow new AnnotationException(\n+\t\t\t\t\t\"An entity annotated with @Inheritance cannot use @AttributeOverride or @AttributeOverrides: \" +\n+\t\t\t\t\t\t\tclazzToProcess.getName()\n+\t\t\t);\n+\t\t}\n+\n \t\tPersistentClass persistentClass = makePersistentClass( inheritanceState, superEntity, context );\n \t\tEntity entityAnn = clazzToProcess.getAnnotation( Entity.class );\n \t\torg.hibernate.annotations.Entity hibEntityAnn = clazzToProcess.getAnnotation(\n \t\t\t\torg.hibernate.annotations.Entity.class\n \t\t);\n \t\tEntityBinder entityBinder = new EntityBinder(\n \t\t\t\tentityAnn,\n \t\t\t\thibEntityAnn,\n \t\t\t\tclazzToProcess,\n \t\t\t\tpersistentClass,\n \t\t\t\tcontext\n \t\t);\n \t\tentityBinder.setInheritanceState( inheritanceState );\n \n \t\tbindQueries( clazzToProcess, context );\n \t\tbindFilterDefs( clazzToProcess, context );\n \t\tbindTypeDefs( clazzToProcess, context );\n \t\tbindFetchProfiles( clazzToProcess, context );\n \t\tBinderHelper.bindAnyMetaDefs( clazzToProcess, context );\n \n \t\tString schema = \"\";\n \t\tString table = \"\"; //might be no @Table annotation on the annotated class\n \t\tString catalog = \"\";\n \t\tList<UniqueConstraintHolder> uniqueConstraints = new ArrayList<>();\n \t\tjavax.persistence.Table tabAnn = null;\n \t\tif ( clazzToProcess.isAnnotationPresent( javax.persistence.Table.class ) ) {\n \t\t\ttabAnn = clazzToProcess.getAnnotation( javax.persistence.Table.class );\n \t\t\ttable = tabAnn.name();\n \t\t\tschema = tabAnn.schema();\n \t\t\tcatalog = tabAnn.catalog();\n \t\t\tuniqueConstraints = TableBinder.buildUniqueConstraintHolders( tabAnn.uniqueConstraints() );\n \t\t}\n \n \t\tEjb3JoinColumn[] inheritanceJoinedColumns = makeInheritanceJoinColumns(\n \t\t\t\tclazzToProcess,\n \t\t\t\tcontext,\n \t\t\t\tinheritanceState,\n \t\t\t\tsuperEntity\n \t\t);\n \n \t\tfinal Ejb3DiscriminatorColumn discriminatorColumn;\n \t\tif ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.getType() ) ) {\n \t\t\tdiscriminatorColumn = processSingleTableDiscriminatorProperties(\n \t\t\t\t\tclazzToProcess,\n \t\t\t\t\tcontext,\n \t\t\t\t\tinheritanceState,\n \t\t\t\t\tentityBinder\n \t\t\t);\n \t\t}\n \t\telse if ( InheritanceType.JOINED.equals( inheritanceState.getType() ) ) {\n \t\t\tdiscriminatorColumn = processJoinedDiscriminatorProperties(\n \t\t\t\t\tclazzToProcess,\n \t\t\t\t\tcontext,\n \t\t\t\t\tinheritanceState,\n \t\t\t\t\tentityBinder\n \t\t\t);\n \t\t}\n \t\telse {\n \t\t\tdiscriminatorColumn = null;\n \t\t}\n \n \t\tentityBinder.setProxy( clazzToProcess.getAnnotation( Proxy.class ) );\n \t\tentityBinder.setBatchSize( clazzToProcess.getAnnotation( BatchSize.class ) );\n \t\tentityBinder.setWhere( clazzToProcess.getAnnotation( Where.class ) );\n \t\tapplyCacheSettings( entityBinder, clazzToProcess, context );\n \n \t\tbindFilters( clazzToProcess, entityBinder, context );\n \n \t\tentityBinder.bindEntity();\n \n \t\tif ( inheritanceState.hasTable() ) {\n \t\t\tCheck checkAnn = clazzToProcess.getAnnotation( Check.class );\n \t\t\tString constraints = checkAnn == null\n \t\t\t\t\t? null\n \t\t\t\t\t: checkAnn.constraints();\n \n \t\t\tEntityTableXref denormalizedTableXref = inheritanceState.hasDenormalizedTable()\n \t\t\t\t\t? context.getMetadataCollector().getEntityTableXref( superEntity.getEntityName() )\n \t\t\t\t\t: null;\n \n \t\t\tentityBinder.bindTable(\n \t\t\t\t\tschema,\n \t\t\t\t\tcatalog,\n \t\t\t\t\ttable,\n \t\t\t\t\tuniqueConstraints,\n \t\t\t\t\tconstraints,\n \t\t\t\t\tdenormalizedTableXref\n \t\t\t);\n \t\t}\n \t\telse {\n \t\t\tif ( clazzToProcess.isAnnotationPresent( Table.class ) ) {\n \t\t\t\tLOG.invalidTableAnnotation( clazzToProcess.getName() );\n \t\t\t}\n \n \t\t\tif ( inheritanceState.getType() == InheritanceType.SINGLE_TABLE ) {\n \t\t\t\t// we at least need to properly set up the EntityTableXref\n \t\t\t\tentityBinder.bindTableForDiscriminatedSubclass(\n \t\t\t\t\t\tcontext.getMetadataCollector().getEntityTableXref( superEntity.getEntityName() )\n \t\t\t\t);\n \t\t\t}\n \t\t}\n \n \n \t\tPropertyHolder propertyHolder = PropertyHolderBuilder.buildPropertyHolder(\n \t\t\t\tclazzToProcess,\n \t\t\t\tpersistentClass,\n \t\t\t\tentityBinder,\n \t\t\t\tcontext,\n \t\t\t\tinheritanceStatePerClass\n \t\t);\n \n \t\tjavax.persistence.SecondaryTable secTabAnn = clazzToProcess.getAnnotation(\n \t\t\t\tjavax.persistence.SecondaryTable.class\n \t\t);\n \t\tjavax.persistence.SecondaryTables secTabsAnn = clazzToProcess.getAnnotation(\n \t\t\t\tjavax.persistence.SecondaryTables.class\n \t\t);\n \t\tentityBinder.firstLevelSecondaryTablesBinding( secTabAnn, secTabsAnn );\n \n \t\tOnDelete onDeleteAnn = clazzToProcess.getAnnotation( OnDelete.class );\n \t\tboolean onDeleteAppropriate = false;\n \n \t\t// todo : sucks that this is separate from RootClass distinction\n \t\tfinal boolean isInheritanceRoot = !inheritanceState.hasParents();\n \t\tfinal boolean hasSubclasses = inheritanceState.hasSiblings();\n \n \t\tif ( InheritanceType.JOINED.equals( inheritanceState.getType() ) ) {\n \t\t\tif ( inheritanceState.hasParents() ) {\n \t\t\t\tonDeleteAppropriate = true;\n \t\t\t\tfinal JoinedSubclass jsc = ( JoinedSubclass ) persistentClass;\n \t\t\t\tSimpleValue key = new DependantValue( context, jsc.getTable(), jsc.getIdentifier() );\n \t\t\t\tjsc.setKey( key );\n \t\t\t\tForeignKey fk = clazzToProcess.getAnnotation( ForeignKey.class );\n \t\t\t\tif ( fk != null && !BinderHelper.isEmptyAnnotationValue( fk.name() ) ) {\n \t\t\t\t\tkey.setForeignKeyName( fk.name() );\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tfinal PrimaryKeyJoinColumn pkJoinColumn = clazzToProcess.getAnnotation( PrimaryKeyJoinColumn.class );\n \t\t\t\t\tfinal PrimaryKeyJoinColumns pkJoinColumns = clazzToProcess.getAnnotation( PrimaryKeyJoinColumns.class );\n \n \t\t\t\t\tif ( pkJoinColumns != null && pkJoinColumns.foreignKey().value() == ConstraintMode.NO_CONSTRAINT ) {\n \t\t\t\t\t\t// don't apply a constraint based on ConstraintMode\n \t\t\t\t\t\tkey.setForeignKeyName( \"none\" );\n \t\t\t\t\t}\n \t\t\t\t\telse if ( pkJoinColumns != null && !StringHelper.isEmpty( pkJoinColumns.foreignKey().name() ) ) {\n \t\t\t\t\t\tkey.setForeignKeyName( pkJoinColumns.foreignKey().name() );\n \t\t\t\t\t}\n \t\t\t\t\telse if ( pkJoinColumn != null && pkJoinColumn.foreignKey().value() == ConstraintMode.NO_CONSTRAINT ) {\n \t\t\t\t\t\t// don't apply a constraint based on ConstraintMode\n \t\t\t\t\t\tkey.setForeignKeyName( \"none\" );\n \t\t\t\t\t}\n \t\t\t\t\telse if ( pkJoinColumn != null && !StringHelper.isEmpty( pkJoinColumn.foreignKey().name() ) ) {\n \t\t\t\t\t\tkey.setForeignKeyName( pkJoinColumn.foreignKey().name() );\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tif ( onDeleteAnn != null ) {\n \t\t\t\t\tkey.setCascadeDeleteEnabled( OnDeleteAction.CASCADE.equals( onDeleteAnn.action() ) );\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tkey.setCascadeDeleteEnabled( false );\n \t\t\t\t}\n \t\t\t\t//we are never in a second pass at that stage, so queue it\n \t\t\t\tcontext.getMetadataCollector().addSecondPass( new JoinedSubclassFkSecondPass( jsc, inheritanceJoinedColumns, key, context ) );\n \t\t\t\tcontext.getMetadataCollector().addSecondPass( new CreateKeySecondPass( jsc ) );\n \t\t\t}\n \n \t\t\tif ( isInheritanceRoot ) {\n \t\t\t\t// the class we are processing is the root of the hierarchy, see if we had a discriminator column\n \t\t\t\t// (it is perfectly valid for joined subclasses to not have discriminators).\n \t\t\t\tif ( discriminatorColumn != null ) {\n \t\t\t\t\t// we have a discriminator column\n \t\t\t\t\tif ( hasSubclasses || !discriminatorColumn.isImplicit() ) {\n \t\t\t\t\t\tbindDiscriminatorColumnToRootPersistentClass(\n \t\t\t\t\t\t\t\t(RootClass) persistentClass,\n \t\t\t\t\t\t\t\tdiscriminatorColumn,\n \t\t\t\t\t\t\t\tentityBinder.getSecondaryTables(),\n \t\t\t\t\t\t\t\tpropertyHolder,\n \t\t\t\t\t\t\t\tcontext\n \t\t\t\t\t\t);\n \t\t\t\t\t\t//bind it again since the type might have changed\n \t\t\t\t\t\tentityBinder.bindDiscriminatorValue();\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\telse if ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.getType() ) ) {\n \t\t\tif ( isInheritanceRoot ) {\n \t\t\t\tif ( hasSubclasses || !discriminatorColumn.isImplicit() ) {\n \t\t\t\t\tbindDiscriminatorColumnToRootPersistentClass(\n \t\t\t\t\t\t\t(RootClass) persistentClass,\n \t\t\t\t\t\t\tdiscriminatorColumn,\n \t\t\t\t\t\t\tentityBinder.getSecondaryTables(),\n \t\t\t\t\t\t\tpropertyHolder,\n \t\t\t\t\t\t\tcontext\n \t\t\t\t\t);\n \t\t\t\t\t//bind it again since the type might have changed\n \t\t\t\t\tentityBinder.bindDiscriminatorValue();\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\tif ( onDeleteAnn != null && !onDeleteAppropriate ) {\n \t\t\tLOG.invalidOnDeleteAnnotation(propertyHolder.getEntityName());\n \t\t}\n \n \t\t// try to find class level generators\n \t\tHashMap<String, IdentifierGeneratorDefinition> classGenerators = buildGenerators( clazzToProcess, context );\n \t\t// check properties\n \t\tfinal InheritanceState.ElementsToProcess elementsToProcess = inheritanceState.getElementsToProcess();\n \t\tinheritanceState.postProcess( persistentClass, entityBinder );\n \n \t\tfinal boolean subclassAndSingleTableStrategy = inheritanceState.getType() == InheritanceType.SINGLE_TABLE\n \t\t\t\t&& inheritanceState.hasParents();\n \t\tSet<String> idPropertiesIfIdClass = new HashSet<>();\n \t\tboolean isIdClass = mapAsIdClass(\n \t\t\t\tinheritanceStatePerClass,\n \t\t\t\tinheritanceState,\n \t\t\t\tpersistentClass,\n \t\t\t\tentityBinder,\n \t\t\t\tpropertyHolder,\n \t\t\t\telementsToProcess,\n \t\t\t\tidPropertiesIfIdClass,\n \t\t\t\tcontext\n \t\t);\n \n \t\tif ( !isIdClass ) {\n \t\t\tentityBinder.setWrapIdsInEmbeddedComponents( elementsToProcess.getIdPropertyCount() > 1 );\n \t\t}\n \n \t\tprocessIdPropertiesIfNotAlready(\n \t\t\t\tinheritanceStatePerClass,\n \t\t\t\tcontext,\n \t\t\t\tpersistentClass,\n \t\t\t\tentityBinder,\n \t\t\t\tpropertyHolder,\n \t\t\t\tclassGenerators,\n \t\t\t\telementsToProcess,\n \t\t\t\tsubclassAndSingleTableStrategy,\n \t\t\t\tidPropertiesIfIdClass\n \t\t);\n \n \t\tif ( !inheritanceState.hasParents() ) {\n \t\t\tfinal RootClass rootClass = ( RootClass ) persistentClass;\n \t\t\tcontext.getMetadataCollector().addSecondPass( new CreateKeySecondPass( rootClass ) );\n \t\t}\n \t\telse {\n \t\t\tsuperEntity.addSubclass( ( Subclass ) persistentClass );\n \t\t}\n \n \t\tcontext.getMetadataCollector().addEntityBinding( persistentClass );\n \n \t\t//Process secondary tables and complementary definitions (ie o.h.a.Table)\n \t\tcontext.getMetadataCollector().addSecondPass(\n \t\t\t\tnew SecondaryTableSecondPass(\n \t\t\t\t\t\tentityBinder,\n \t\t\t\t\t\tpropertyHolder,\n \t\t\t\t\t\tclazzToProcess\n \t\t\t\t)\n \t\t);\n \n \t\t//add process complementary Table definition (index & all)\n \t\tentityBinder.processComplementaryTableDefinitions( clazzToProcess.getAnnotation( org.hibernate.annotations.Table.class ) );\n \t\tentityBinder.processComplementaryTableDefinitions( clazzToProcess.getAnnotation( org.hibernate.annotations.Tables.class ) );\n \t\tentityBinder.processComplementaryTableDefinitions( tabAnn );\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"8f889e95d76f47945c9ec072fd08cb045767578c": {
			"type": "Ybodychange",
			"commitMessage": "HHH-12444 - Introduce BootstrapContext\nHHH-12443 - Introduce TypeConfiguration\n",
			"commitDate": "2018-03-28, 3:43 PM",
			"commitName": "8f889e95d76f47945c9ec072fd08cb045767578c",
			"commitAuthor": "Andrea Boriero",
			"commitDateOld": "2018-03-14, 5:17 AM",
			"commitNameOld": "8b11d5ecf9a71ae70e3f7c837ed3de1b55ec096d",
			"commitAuthorOld": "Roland Illig",
			"daysBetweenCommits": 14.43,
			"commitsBetweenForRepo": 73,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,302 +1,302 @@\n \tpublic static void bindClass(\n \t\t\tXClass clazzToProcess,\n \t\t\tMap<XClass, InheritanceState> inheritanceStatePerClass,\n \t\t\tMetadataBuildingContext context) throws MappingException {\n \t\t//@Entity and @MappedSuperclass on the same class leads to a NPE down the road\n \t\tif ( clazzToProcess.isAnnotationPresent( Entity.class )\n \t\t\t\t&&  clazzToProcess.isAnnotationPresent( MappedSuperclass.class ) ) {\n \t\t\tthrow new AnnotationException( \"An entity cannot be annotated with both @Entity and @MappedSuperclass: \"\n \t\t\t\t\t+ clazzToProcess.getName() );\n \t\t}\n \n \t\t//TODO: be more strict with secondarytable allowance (not for ids, not for secondary table join columns etc)\n \t\tInheritanceState inheritanceState = inheritanceStatePerClass.get( clazzToProcess );\n \t\tAnnotatedClassType classType = context.getMetadataCollector().getClassType( clazzToProcess );\n \n \t\t//Queries declared in MappedSuperclass should be usable in Subclasses\n \t\tif ( AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals( classType ) ) {\n \t\t\tbindQueries( clazzToProcess, context );\n \t\t\tbindTypeDefs( clazzToProcess, context );\n \t\t\tbindFilterDefs( clazzToProcess, context );\n \t\t}\n \n \t\tif ( !isEntityClassType( clazzToProcess, classType ) ) {\n \t\t\treturn;\n \t\t}\n \n \t\tif ( LOG.isDebugEnabled() ) {\n \t\t\tLOG.debugf( \"Binding entity from annotated class: %s\", clazzToProcess.getName() );\n \t\t}\n \n \t\tPersistentClass superEntity = getSuperEntity(\n \t\t\t\tclazzToProcess,\n \t\t\t\tinheritanceStatePerClass,\n \t\t\t\tcontext,\n \t\t\t\tinheritanceState\n \t\t);\n \n \t\tPersistentClass persistentClass = makePersistentClass( inheritanceState, superEntity, context );\n \t\tEntity entityAnn = clazzToProcess.getAnnotation( Entity.class );\n \t\torg.hibernate.annotations.Entity hibEntityAnn = clazzToProcess.getAnnotation(\n \t\t\t\torg.hibernate.annotations.Entity.class\n \t\t);\n \t\tEntityBinder entityBinder = new EntityBinder(\n \t\t\t\tentityAnn,\n \t\t\t\thibEntityAnn,\n \t\t\t\tclazzToProcess,\n \t\t\t\tpersistentClass,\n \t\t\t\tcontext\n \t\t);\n \t\tentityBinder.setInheritanceState( inheritanceState );\n \n \t\tbindQueries( clazzToProcess, context );\n \t\tbindFilterDefs( clazzToProcess, context );\n \t\tbindTypeDefs( clazzToProcess, context );\n \t\tbindFetchProfiles( clazzToProcess, context );\n \t\tBinderHelper.bindAnyMetaDefs( clazzToProcess, context );\n \n \t\tString schema = \"\";\n \t\tString table = \"\"; //might be no @Table annotation on the annotated class\n \t\tString catalog = \"\";\n-\t\tList<UniqueConstraintHolder> uniqueConstraints = new ArrayList<UniqueConstraintHolder>();\n+\t\tList<UniqueConstraintHolder> uniqueConstraints = new ArrayList<>();\n \t\tjavax.persistence.Table tabAnn = null;\n \t\tif ( clazzToProcess.isAnnotationPresent( javax.persistence.Table.class ) ) {\n \t\t\ttabAnn = clazzToProcess.getAnnotation( javax.persistence.Table.class );\n \t\t\ttable = tabAnn.name();\n \t\t\tschema = tabAnn.schema();\n \t\t\tcatalog = tabAnn.catalog();\n \t\t\tuniqueConstraints = TableBinder.buildUniqueConstraintHolders( tabAnn.uniqueConstraints() );\n \t\t}\n \n \t\tEjb3JoinColumn[] inheritanceJoinedColumns = makeInheritanceJoinColumns(\n \t\t\t\tclazzToProcess,\n \t\t\t\tcontext,\n \t\t\t\tinheritanceState,\n \t\t\t\tsuperEntity\n \t\t);\n \n \t\tfinal Ejb3DiscriminatorColumn discriminatorColumn;\n \t\tif ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.getType() ) ) {\n \t\t\tdiscriminatorColumn = processSingleTableDiscriminatorProperties(\n \t\t\t\t\tclazzToProcess,\n \t\t\t\t\tcontext,\n \t\t\t\t\tinheritanceState,\n \t\t\t\t\tentityBinder\n \t\t\t);\n \t\t}\n \t\telse if ( InheritanceType.JOINED.equals( inheritanceState.getType() ) ) {\n \t\t\tdiscriminatorColumn = processJoinedDiscriminatorProperties(\n \t\t\t\t\tclazzToProcess,\n \t\t\t\t\tcontext,\n \t\t\t\t\tinheritanceState,\n \t\t\t\t\tentityBinder\n \t\t\t);\n \t\t}\n \t\telse {\n \t\t\tdiscriminatorColumn = null;\n \t\t}\n \n \t\tentityBinder.setProxy( clazzToProcess.getAnnotation( Proxy.class ) );\n \t\tentityBinder.setBatchSize( clazzToProcess.getAnnotation( BatchSize.class ) );\n \t\tentityBinder.setWhere( clazzToProcess.getAnnotation( Where.class ) );\n \t\tapplyCacheSettings( entityBinder, clazzToProcess, context );\n \n \t\tbindFilters( clazzToProcess, entityBinder, context );\n \n \t\tentityBinder.bindEntity();\n \n \t\tif ( inheritanceState.hasTable() ) {\n \t\t\tCheck checkAnn = clazzToProcess.getAnnotation( Check.class );\n \t\t\tString constraints = checkAnn == null\n \t\t\t\t\t? null\n \t\t\t\t\t: checkAnn.constraints();\n \n \t\t\tEntityTableXref denormalizedTableXref = inheritanceState.hasDenormalizedTable()\n \t\t\t\t\t? context.getMetadataCollector().getEntityTableXref( superEntity.getEntityName() )\n \t\t\t\t\t: null;\n \n \t\t\tentityBinder.bindTable(\n \t\t\t\t\tschema,\n \t\t\t\t\tcatalog,\n \t\t\t\t\ttable,\n \t\t\t\t\tuniqueConstraints,\n \t\t\t\t\tconstraints,\n \t\t\t\t\tdenormalizedTableXref\n \t\t\t);\n \t\t}\n \t\telse {\n \t\t\tif ( clazzToProcess.isAnnotationPresent( Table.class ) ) {\n \t\t\t\tLOG.invalidTableAnnotation( clazzToProcess.getName() );\n \t\t\t}\n \n \t\t\tif ( inheritanceState.getType() == InheritanceType.SINGLE_TABLE ) {\n \t\t\t\t// we at least need to properly set up the EntityTableXref\n \t\t\t\tentityBinder.bindTableForDiscriminatedSubclass(\n \t\t\t\t\t\tcontext.getMetadataCollector().getEntityTableXref( superEntity.getEntityName() )\n \t\t\t\t);\n \t\t\t}\n \t\t}\n \n \n \t\tPropertyHolder propertyHolder = PropertyHolderBuilder.buildPropertyHolder(\n \t\t\t\tclazzToProcess,\n \t\t\t\tpersistentClass,\n \t\t\t\tentityBinder,\n \t\t\t\tcontext,\n \t\t\t\tinheritanceStatePerClass\n \t\t);\n \n \t\tjavax.persistence.SecondaryTable secTabAnn = clazzToProcess.getAnnotation(\n \t\t\t\tjavax.persistence.SecondaryTable.class\n \t\t);\n \t\tjavax.persistence.SecondaryTables secTabsAnn = clazzToProcess.getAnnotation(\n \t\t\t\tjavax.persistence.SecondaryTables.class\n \t\t);\n \t\tentityBinder.firstLevelSecondaryTablesBinding( secTabAnn, secTabsAnn );\n \n \t\tOnDelete onDeleteAnn = clazzToProcess.getAnnotation( OnDelete.class );\n \t\tboolean onDeleteAppropriate = false;\n \n \t\t// todo : sucks that this is separate from RootClass distinction\n \t\tfinal boolean isInheritanceRoot = !inheritanceState.hasParents();\n \t\tfinal boolean hasSubclasses = inheritanceState.hasSiblings();\n \n \t\tif ( InheritanceType.JOINED.equals( inheritanceState.getType() ) ) {\n \t\t\tif ( inheritanceState.hasParents() ) {\n \t\t\t\tonDeleteAppropriate = true;\n \t\t\t\tfinal JoinedSubclass jsc = ( JoinedSubclass ) persistentClass;\n-\t\t\t\tSimpleValue key = new DependantValue( context.getMetadataCollector(), jsc.getTable(), jsc.getIdentifier() );\n+\t\t\t\tSimpleValue key = new DependantValue( context, jsc.getTable(), jsc.getIdentifier() );\n \t\t\t\tjsc.setKey( key );\n \t\t\t\tForeignKey fk = clazzToProcess.getAnnotation( ForeignKey.class );\n \t\t\t\tif ( fk != null && !BinderHelper.isEmptyAnnotationValue( fk.name() ) ) {\n \t\t\t\t\tkey.setForeignKeyName( fk.name() );\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tfinal PrimaryKeyJoinColumn pkJoinColumn = clazzToProcess.getAnnotation( PrimaryKeyJoinColumn.class );\n \t\t\t\t\tfinal PrimaryKeyJoinColumns pkJoinColumns = clazzToProcess.getAnnotation( PrimaryKeyJoinColumns.class );\n \n \t\t\t\t\tif ( pkJoinColumns != null && pkJoinColumns.foreignKey().value() == ConstraintMode.NO_CONSTRAINT ) {\n \t\t\t\t\t\t// don't apply a constraint based on ConstraintMode\n \t\t\t\t\t\tkey.setForeignKeyName( \"none\" );\n \t\t\t\t\t}\n \t\t\t\t\telse if ( pkJoinColumns != null && !StringHelper.isEmpty( pkJoinColumns.foreignKey().name() ) ) {\n \t\t\t\t\t\tkey.setForeignKeyName( pkJoinColumns.foreignKey().name() );\n \t\t\t\t\t}\n \t\t\t\t\telse if ( pkJoinColumn != null && pkJoinColumn.foreignKey().value() == ConstraintMode.NO_CONSTRAINT ) {\n \t\t\t\t\t\t// don't apply a constraint based on ConstraintMode\n \t\t\t\t\t\tkey.setForeignKeyName( \"none\" );\n \t\t\t\t\t}\n \t\t\t\t\telse if ( pkJoinColumn != null && !StringHelper.isEmpty( pkJoinColumn.foreignKey().name() ) ) {\n \t\t\t\t\t\tkey.setForeignKeyName( pkJoinColumn.foreignKey().name() );\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tif ( onDeleteAnn != null ) {\n \t\t\t\t\tkey.setCascadeDeleteEnabled( OnDeleteAction.CASCADE.equals( onDeleteAnn.action() ) );\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tkey.setCascadeDeleteEnabled( false );\n \t\t\t\t}\n \t\t\t\t//we are never in a second pass at that stage, so queue it\n \t\t\t\tcontext.getMetadataCollector().addSecondPass( new JoinedSubclassFkSecondPass( jsc, inheritanceJoinedColumns, key, context ) );\n \t\t\t\tcontext.getMetadataCollector().addSecondPass( new CreateKeySecondPass( jsc ) );\n \t\t\t}\n \n \t\t\tif ( isInheritanceRoot ) {\n \t\t\t\t// the class we are processing is the root of the hierarchy, see if we had a discriminator column\n \t\t\t\t// (it is perfectly valid for joined subclasses to not have discriminators).\n \t\t\t\tif ( discriminatorColumn != null ) {\n \t\t\t\t\t// we have a discriminator column\n \t\t\t\t\tif ( hasSubclasses || !discriminatorColumn.isImplicit() ) {\n \t\t\t\t\t\tbindDiscriminatorColumnToRootPersistentClass(\n \t\t\t\t\t\t\t\t(RootClass) persistentClass,\n \t\t\t\t\t\t\t\tdiscriminatorColumn,\n \t\t\t\t\t\t\t\tentityBinder.getSecondaryTables(),\n \t\t\t\t\t\t\t\tpropertyHolder,\n \t\t\t\t\t\t\t\tcontext\n \t\t\t\t\t\t);\n \t\t\t\t\t\t//bind it again since the type might have changed\n \t\t\t\t\t\tentityBinder.bindDiscriminatorValue();\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\telse if ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.getType() ) ) {\n \t\t\tif ( isInheritanceRoot ) {\n \t\t\t\tif ( hasSubclasses || !discriminatorColumn.isImplicit() ) {\n \t\t\t\t\tbindDiscriminatorColumnToRootPersistentClass(\n \t\t\t\t\t\t\t(RootClass) persistentClass,\n \t\t\t\t\t\t\tdiscriminatorColumn,\n \t\t\t\t\t\t\tentityBinder.getSecondaryTables(),\n \t\t\t\t\t\t\tpropertyHolder,\n \t\t\t\t\t\t\tcontext\n \t\t\t\t\t);\n \t\t\t\t\t//bind it again since the type might have changed\n \t\t\t\t\tentityBinder.bindDiscriminatorValue();\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\tif ( onDeleteAnn != null && !onDeleteAppropriate ) {\n \t\t\tLOG.invalidOnDeleteAnnotation(propertyHolder.getEntityName());\n \t\t}\n \n \t\t// try to find class level generators\n \t\tHashMap<String, IdentifierGeneratorDefinition> classGenerators = buildGenerators( clazzToProcess, context );\n \t\t// check properties\n \t\tfinal InheritanceState.ElementsToProcess elementsToProcess = inheritanceState.getElementsToProcess();\n \t\tinheritanceState.postProcess( persistentClass, entityBinder );\n \n \t\tfinal boolean subclassAndSingleTableStrategy = inheritanceState.getType() == InheritanceType.SINGLE_TABLE\n \t\t\t\t&& inheritanceState.hasParents();\n \t\tSet<String> idPropertiesIfIdClass = new HashSet<>();\n \t\tboolean isIdClass = mapAsIdClass(\n \t\t\t\tinheritanceStatePerClass,\n \t\t\t\tinheritanceState,\n \t\t\t\tpersistentClass,\n \t\t\t\tentityBinder,\n \t\t\t\tpropertyHolder,\n \t\t\t\telementsToProcess,\n \t\t\t\tidPropertiesIfIdClass,\n \t\t\t\tcontext\n \t\t);\n \n \t\tif ( !isIdClass ) {\n \t\t\tentityBinder.setWrapIdsInEmbeddedComponents( elementsToProcess.getIdPropertyCount() > 1 );\n \t\t}\n \n \t\tprocessIdPropertiesIfNotAlready(\n \t\t\t\tinheritanceStatePerClass,\n \t\t\t\tcontext,\n \t\t\t\tpersistentClass,\n \t\t\t\tentityBinder,\n \t\t\t\tpropertyHolder,\n \t\t\t\tclassGenerators,\n \t\t\t\telementsToProcess,\n \t\t\t\tsubclassAndSingleTableStrategy,\n \t\t\t\tidPropertiesIfIdClass\n \t\t);\n \n \t\tif ( !inheritanceState.hasParents() ) {\n \t\t\tfinal RootClass rootClass = ( RootClass ) persistentClass;\n \t\t\tcontext.getMetadataCollector().addSecondPass( new CreateKeySecondPass( rootClass ) );\n \t\t}\n \t\telse {\n \t\t\tsuperEntity.addSubclass( ( Subclass ) persistentClass );\n \t\t}\n \n \t\tcontext.getMetadataCollector().addEntityBinding( persistentClass );\n \n \t\t//Process secondary tables and complementary definitions (ie o.h.a.Table)\n \t\tcontext.getMetadataCollector().addSecondPass(\n \t\t\t\tnew SecondaryTableSecondPass(\n \t\t\t\t\t\tentityBinder,\n \t\t\t\t\t\tpropertyHolder,\n \t\t\t\t\t\tclazzToProcess\n \t\t\t\t)\n \t\t);\n \n \t\t//add process complementary Table definition (index & all)\n \t\tentityBinder.processComplementaryTableDefinitions( clazzToProcess.getAnnotation( org.hibernate.annotations.Table.class ) );\n \t\tentityBinder.processComplementaryTableDefinitions( clazzToProcess.getAnnotation( org.hibernate.annotations.Tables.class ) );\n \t\tentityBinder.processComplementaryTableDefinitions( tabAnn );\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"b1a9c816a7e1159d6ae75898a8f455e425f94d4e": {
			"type": "Ybodychange",
			"commitMessage": "HHH-12157 - TableGenerator defined on one class is not visible on another\n\n(cherry picked from commit 8ae3dc4078597c69588ca8237591f1eab64c6bd7)\n",
			"commitDate": "2017-12-13, 7:38 AM",
			"commitName": "b1a9c816a7e1159d6ae75898a8f455e425f94d4e",
			"commitAuthor": "Andrea Boriero",
			"commitDateOld": "2017-12-13, 4:19 AM",
			"commitNameOld": "59c3baae3271247bed516fe50952b65be1a27e5b",
			"commitAuthorOld": "Steve Ebersole",
			"daysBetweenCommits": 0.14,
			"commitsBetweenForRepo": 5,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,303 +1,302 @@\n \tpublic static void bindClass(\n \t\t\tXClass clazzToProcess,\n \t\t\tMap<XClass, InheritanceState> inheritanceStatePerClass,\n \t\t\tMetadataBuildingContext context) throws MappingException {\n \t\t//@Entity and @MappedSuperclass on the same class leads to a NPE down the road\n \t\tif ( clazzToProcess.isAnnotationPresent( Entity.class )\n \t\t\t\t&&  clazzToProcess.isAnnotationPresent( MappedSuperclass.class ) ) {\n \t\t\tthrow new AnnotationException( \"An entity cannot be annotated with both @Entity and @MappedSuperclass: \"\n \t\t\t\t\t+ clazzToProcess.getName() );\n \t\t}\n \n \t\t//TODO: be more strict with secondarytable allowance (not for ids, not for secondary table join columns etc)\n \t\tInheritanceState inheritanceState = inheritanceStatePerClass.get( clazzToProcess );\n \t\tAnnotatedClassType classType = context.getMetadataCollector().getClassType( clazzToProcess );\n \n \t\t//Queries declared in MappedSuperclass should be usable in Subclasses\n \t\tif ( AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals( classType ) ) {\n \t\t\tbindQueries( clazzToProcess, context );\n \t\t\tbindTypeDefs( clazzToProcess, context );\n \t\t\tbindFilterDefs( clazzToProcess, context );\n \t\t}\n \n \t\tif ( !isEntityClassType( clazzToProcess, classType ) ) {\n \t\t\treturn;\n \t\t}\n \n \t\tif ( LOG.isDebugEnabled() ) {\n \t\t\tLOG.debugf( \"Binding entity from annotated class: %s\", clazzToProcess.getName() );\n \t\t}\n \n \t\tPersistentClass superEntity = getSuperEntity(\n \t\t\t\tclazzToProcess,\n \t\t\t\tinheritanceStatePerClass,\n \t\t\t\tcontext,\n \t\t\t\tinheritanceState\n \t\t);\n \n \t\tPersistentClass persistentClass = makePersistentClass( inheritanceState, superEntity, context );\n \t\tEntity entityAnn = clazzToProcess.getAnnotation( Entity.class );\n \t\torg.hibernate.annotations.Entity hibEntityAnn = clazzToProcess.getAnnotation(\n \t\t\t\torg.hibernate.annotations.Entity.class\n \t\t);\n \t\tEntityBinder entityBinder = new EntityBinder(\n \t\t\t\tentityAnn,\n \t\t\t\thibEntityAnn,\n \t\t\t\tclazzToProcess,\n \t\t\t\tpersistentClass,\n \t\t\t\tcontext\n \t\t);\n \t\tentityBinder.setInheritanceState( inheritanceState );\n \n \t\tbindQueries( clazzToProcess, context );\n \t\tbindFilterDefs( clazzToProcess, context );\n \t\tbindTypeDefs( clazzToProcess, context );\n \t\tbindFetchProfiles( clazzToProcess, context );\n \t\tBinderHelper.bindAnyMetaDefs( clazzToProcess, context );\n \n \t\tString schema = \"\";\n \t\tString table = \"\"; //might be no @Table annotation on the annotated class\n \t\tString catalog = \"\";\n \t\tList<UniqueConstraintHolder> uniqueConstraints = new ArrayList<UniqueConstraintHolder>();\n \t\tjavax.persistence.Table tabAnn = null;\n \t\tif ( clazzToProcess.isAnnotationPresent( javax.persistence.Table.class ) ) {\n \t\t\ttabAnn = clazzToProcess.getAnnotation( javax.persistence.Table.class );\n \t\t\ttable = tabAnn.name();\n \t\t\tschema = tabAnn.schema();\n \t\t\tcatalog = tabAnn.catalog();\n \t\t\tuniqueConstraints = TableBinder.buildUniqueConstraintHolders( tabAnn.uniqueConstraints() );\n \t\t}\n \n \t\tEjb3JoinColumn[] inheritanceJoinedColumns = makeInheritanceJoinColumns(\n \t\t\t\tclazzToProcess,\n \t\t\t\tcontext,\n \t\t\t\tinheritanceState,\n \t\t\t\tsuperEntity\n \t\t);\n \n \t\tfinal Ejb3DiscriminatorColumn discriminatorColumn;\n \t\tif ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.getType() ) ) {\n \t\t\tdiscriminatorColumn = processSingleTableDiscriminatorProperties(\n \t\t\t\t\tclazzToProcess,\n \t\t\t\t\tcontext,\n \t\t\t\t\tinheritanceState,\n \t\t\t\t\tentityBinder\n \t\t\t);\n \t\t}\n \t\telse if ( InheritanceType.JOINED.equals( inheritanceState.getType() ) ) {\n \t\t\tdiscriminatorColumn = processJoinedDiscriminatorProperties(\n \t\t\t\t\tclazzToProcess,\n \t\t\t\t\tcontext,\n \t\t\t\t\tinheritanceState,\n \t\t\t\t\tentityBinder\n \t\t\t);\n \t\t}\n \t\telse {\n \t\t\tdiscriminatorColumn = null;\n \t\t}\n \n \t\tentityBinder.setProxy( clazzToProcess.getAnnotation( Proxy.class ) );\n \t\tentityBinder.setBatchSize( clazzToProcess.getAnnotation( BatchSize.class ) );\n \t\tentityBinder.setWhere( clazzToProcess.getAnnotation( Where.class ) );\n \t\tapplyCacheSettings( entityBinder, clazzToProcess, context );\n \n \t\tbindFilters( clazzToProcess, entityBinder, context );\n \n \t\tentityBinder.bindEntity();\n \n \t\tif ( inheritanceState.hasTable() ) {\n \t\t\tCheck checkAnn = clazzToProcess.getAnnotation( Check.class );\n \t\t\tString constraints = checkAnn == null\n \t\t\t\t\t? null\n \t\t\t\t\t: checkAnn.constraints();\n \n \t\t\tEntityTableXref denormalizedTableXref = inheritanceState.hasDenormalizedTable()\n \t\t\t\t\t? context.getMetadataCollector().getEntityTableXref( superEntity.getEntityName() )\n \t\t\t\t\t: null;\n \n \t\t\tentityBinder.bindTable(\n \t\t\t\t\tschema,\n \t\t\t\t\tcatalog,\n \t\t\t\t\ttable,\n \t\t\t\t\tuniqueConstraints,\n \t\t\t\t\tconstraints,\n \t\t\t\t\tdenormalizedTableXref\n \t\t\t);\n \t\t}\n \t\telse {\n \t\t\tif ( clazzToProcess.isAnnotationPresent( Table.class ) ) {\n \t\t\t\tLOG.invalidTableAnnotation( clazzToProcess.getName() );\n \t\t\t}\n \n \t\t\tif ( inheritanceState.getType() == InheritanceType.SINGLE_TABLE ) {\n \t\t\t\t// we at least need to properly set up the EntityTableXref\n \t\t\t\tentityBinder.bindTableForDiscriminatedSubclass(\n \t\t\t\t\t\tcontext.getMetadataCollector().getEntityTableXref( superEntity.getEntityName() )\n \t\t\t\t);\n \t\t\t}\n \t\t}\n \n \n \t\tPropertyHolder propertyHolder = PropertyHolderBuilder.buildPropertyHolder(\n \t\t\t\tclazzToProcess,\n \t\t\t\tpersistentClass,\n \t\t\t\tentityBinder,\n \t\t\t\tcontext,\n \t\t\t\tinheritanceStatePerClass\n \t\t);\n \n \t\tjavax.persistence.SecondaryTable secTabAnn = clazzToProcess.getAnnotation(\n \t\t\t\tjavax.persistence.SecondaryTable.class\n \t\t);\n \t\tjavax.persistence.SecondaryTables secTabsAnn = clazzToProcess.getAnnotation(\n \t\t\t\tjavax.persistence.SecondaryTables.class\n \t\t);\n \t\tentityBinder.firstLevelSecondaryTablesBinding( secTabAnn, secTabsAnn );\n \n \t\tOnDelete onDeleteAnn = clazzToProcess.getAnnotation( OnDelete.class );\n \t\tboolean onDeleteAppropriate = false;\n \n \t\t// todo : sucks that this is separate from RootClass distinction\n \t\tfinal boolean isInheritanceRoot = !inheritanceState.hasParents();\n \t\tfinal boolean hasSubclasses = inheritanceState.hasSiblings();\n \n \t\tif ( InheritanceType.JOINED.equals( inheritanceState.getType() ) ) {\n \t\t\tif ( inheritanceState.hasParents() ) {\n \t\t\t\tonDeleteAppropriate = true;\n \t\t\t\tfinal JoinedSubclass jsc = ( JoinedSubclass ) persistentClass;\n \t\t\t\tSimpleValue key = new DependantValue( context.getMetadataCollector(), jsc.getTable(), jsc.getIdentifier() );\n \t\t\t\tjsc.setKey( key );\n \t\t\t\tForeignKey fk = clazzToProcess.getAnnotation( ForeignKey.class );\n \t\t\t\tif ( fk != null && !BinderHelper.isEmptyAnnotationValue( fk.name() ) ) {\n \t\t\t\t\tkey.setForeignKeyName( fk.name() );\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tfinal PrimaryKeyJoinColumn pkJoinColumn = clazzToProcess.getAnnotation( PrimaryKeyJoinColumn.class );\n \t\t\t\t\tfinal PrimaryKeyJoinColumns pkJoinColumns = clazzToProcess.getAnnotation( PrimaryKeyJoinColumns.class );\n \n \t\t\t\t\tif ( pkJoinColumns != null && pkJoinColumns.foreignKey().value() == ConstraintMode.NO_CONSTRAINT ) {\n \t\t\t\t\t\t// don't apply a constraint based on ConstraintMode\n \t\t\t\t\t\tkey.setForeignKeyName( \"none\" );\n \t\t\t\t\t}\n \t\t\t\t\telse if ( pkJoinColumns != null && !StringHelper.isEmpty( pkJoinColumns.foreignKey().name() ) ) {\n \t\t\t\t\t\tkey.setForeignKeyName( pkJoinColumns.foreignKey().name() );\n \t\t\t\t\t}\n \t\t\t\t\telse if ( pkJoinColumn != null && pkJoinColumn.foreignKey().value() == ConstraintMode.NO_CONSTRAINT ) {\n \t\t\t\t\t\t// don't apply a constraint based on ConstraintMode\n \t\t\t\t\t\tkey.setForeignKeyName( \"none\" );\n \t\t\t\t\t}\n \t\t\t\t\telse if ( pkJoinColumn != null && !StringHelper.isEmpty( pkJoinColumn.foreignKey().name() ) ) {\n \t\t\t\t\t\tkey.setForeignKeyName( pkJoinColumn.foreignKey().name() );\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tif ( onDeleteAnn != null ) {\n \t\t\t\t\tkey.setCascadeDeleteEnabled( OnDeleteAction.CASCADE.equals( onDeleteAnn.action() ) );\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tkey.setCascadeDeleteEnabled( false );\n \t\t\t\t}\n \t\t\t\t//we are never in a second pass at that stage, so queue it\n \t\t\t\tcontext.getMetadataCollector().addSecondPass( new JoinedSubclassFkSecondPass( jsc, inheritanceJoinedColumns, key, context ) );\n \t\t\t\tcontext.getMetadataCollector().addSecondPass( new CreateKeySecondPass( jsc ) );\n \t\t\t}\n \n \t\t\tif ( isInheritanceRoot ) {\n \t\t\t\t// the class we are processing is the root of the hierarchy, see if we had a discriminator column\n \t\t\t\t// (it is perfectly valid for joined subclasses to not have discriminators).\n \t\t\t\tif ( discriminatorColumn != null ) {\n \t\t\t\t\t// we have a discriminator column\n \t\t\t\t\tif ( hasSubclasses || !discriminatorColumn.isImplicit() ) {\n \t\t\t\t\t\tbindDiscriminatorColumnToRootPersistentClass(\n \t\t\t\t\t\t\t\t(RootClass) persistentClass,\n \t\t\t\t\t\t\t\tdiscriminatorColumn,\n \t\t\t\t\t\t\t\tentityBinder.getSecondaryTables(),\n \t\t\t\t\t\t\t\tpropertyHolder,\n \t\t\t\t\t\t\t\tcontext\n \t\t\t\t\t\t);\n \t\t\t\t\t\t//bind it again since the type might have changed\n \t\t\t\t\t\tentityBinder.bindDiscriminatorValue();\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\telse if ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.getType() ) ) {\n \t\t\tif ( isInheritanceRoot ) {\n \t\t\t\tif ( hasSubclasses || !discriminatorColumn.isImplicit() ) {\n \t\t\t\t\tbindDiscriminatorColumnToRootPersistentClass(\n \t\t\t\t\t\t\t(RootClass) persistentClass,\n \t\t\t\t\t\t\tdiscriminatorColumn,\n \t\t\t\t\t\t\tentityBinder.getSecondaryTables(),\n \t\t\t\t\t\t\tpropertyHolder,\n \t\t\t\t\t\t\tcontext\n \t\t\t\t\t);\n \t\t\t\t\t//bind it again since the type might have changed\n \t\t\t\t\tentityBinder.bindDiscriminatorValue();\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\tif ( onDeleteAnn != null && !onDeleteAppropriate ) {\n \t\t\tLOG.invalidOnDeleteAnnotation(propertyHolder.getEntityName());\n \t\t}\n \n \t\t// try to find class level generators\n-\t\tHashMap<String, IdentifierGeneratorDefinition> classGenerators = buildLocalGenerators( clazzToProcess, context );\n-\n+\t\tHashMap<String, IdentifierGeneratorDefinition> classGenerators = buildGenerators( clazzToProcess, context );\n \t\t// check properties\n \t\tfinal InheritanceState.ElementsToProcess elementsToProcess = inheritanceState.getElementsToProcess();\n \t\tinheritanceState.postProcess( persistentClass, entityBinder );\n \n \t\tfinal boolean subclassAndSingleTableStrategy = inheritanceState.getType() == InheritanceType.SINGLE_TABLE\n \t\t\t\t&& inheritanceState.hasParents();\n-\t\tSet<String> idPropertiesIfIdClass = new HashSet<String>();\n+\t\tSet<String> idPropertiesIfIdClass = new HashSet<>();\n \t\tboolean isIdClass = mapAsIdClass(\n \t\t\t\tinheritanceStatePerClass,\n \t\t\t\tinheritanceState,\n \t\t\t\tpersistentClass,\n \t\t\t\tentityBinder,\n \t\t\t\tpropertyHolder,\n \t\t\t\telementsToProcess,\n \t\t\t\tidPropertiesIfIdClass,\n \t\t\t\tcontext\n \t\t);\n \n \t\tif ( !isIdClass ) {\n \t\t\tentityBinder.setWrapIdsInEmbeddedComponents( elementsToProcess.getIdPropertyCount() > 1 );\n \t\t}\n \n \t\tprocessIdPropertiesIfNotAlready(\n \t\t\t\tinheritanceStatePerClass,\n \t\t\t\tcontext,\n \t\t\t\tpersistentClass,\n \t\t\t\tentityBinder,\n \t\t\t\tpropertyHolder,\n \t\t\t\tclassGenerators,\n \t\t\t\telementsToProcess,\n \t\t\t\tsubclassAndSingleTableStrategy,\n \t\t\t\tidPropertiesIfIdClass\n \t\t);\n \n \t\tif ( !inheritanceState.hasParents() ) {\n \t\t\tfinal RootClass rootClass = ( RootClass ) persistentClass;\n \t\t\tcontext.getMetadataCollector().addSecondPass( new CreateKeySecondPass( rootClass ) );\n \t\t}\n \t\telse {\n \t\t\tsuperEntity.addSubclass( ( Subclass ) persistentClass );\n \t\t}\n \n \t\tcontext.getMetadataCollector().addEntityBinding( persistentClass );\n \n \t\t//Process secondary tables and complementary definitions (ie o.h.a.Table)\n \t\tcontext.getMetadataCollector().addSecondPass(\n \t\t\t\tnew SecondaryTableSecondPass(\n \t\t\t\t\t\tentityBinder,\n \t\t\t\t\t\tpropertyHolder,\n \t\t\t\t\t\tclazzToProcess\n \t\t\t\t)\n \t\t);\n \n \t\t//add process complementary Table definition (index & all)\n \t\tentityBinder.processComplementaryTableDefinitions( clazzToProcess.getAnnotation( org.hibernate.annotations.Table.class ) );\n \t\tentityBinder.processComplementaryTableDefinitions( clazzToProcess.getAnnotation( org.hibernate.annotations.Tables.class ) );\n \t\tentityBinder.processComplementaryTableDefinitions( tabAnn );\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"59c3baae3271247bed516fe50952b65be1a27e5b": {
			"type": "Ybodychange",
			"commitMessage": "HHH-12146  - Support enabling caching at any level within a mapped hierarchy\n",
			"commitDate": "2017-12-13, 4:19 AM",
			"commitName": "59c3baae3271247bed516fe50952b65be1a27e5b",
			"commitAuthor": "Steve Ebersole",
			"commitDateOld": "2017-12-13, 4:19 AM",
			"commitNameOld": "6818275376639c2a0d64674c4bd0320d64e86d89",
			"commitAuthorOld": "Andrea Boriero",
			"daysBetweenCommits": 0,
			"commitsBetweenForRepo": 12,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,304 +1,303 @@\n \tpublic static void bindClass(\n \t\t\tXClass clazzToProcess,\n \t\t\tMap<XClass, InheritanceState> inheritanceStatePerClass,\n \t\t\tMetadataBuildingContext context) throws MappingException {\n \t\t//@Entity and @MappedSuperclass on the same class leads to a NPE down the road\n \t\tif ( clazzToProcess.isAnnotationPresent( Entity.class )\n \t\t\t\t&&  clazzToProcess.isAnnotationPresent( MappedSuperclass.class ) ) {\n \t\t\tthrow new AnnotationException( \"An entity cannot be annotated with both @Entity and @MappedSuperclass: \"\n \t\t\t\t\t+ clazzToProcess.getName() );\n \t\t}\n \n \t\t//TODO: be more strict with secondarytable allowance (not for ids, not for secondary table join columns etc)\n \t\tInheritanceState inheritanceState = inheritanceStatePerClass.get( clazzToProcess );\n \t\tAnnotatedClassType classType = context.getMetadataCollector().getClassType( clazzToProcess );\n \n \t\t//Queries declared in MappedSuperclass should be usable in Subclasses\n \t\tif ( AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals( classType ) ) {\n \t\t\tbindQueries( clazzToProcess, context );\n \t\t\tbindTypeDefs( clazzToProcess, context );\n \t\t\tbindFilterDefs( clazzToProcess, context );\n \t\t}\n \n \t\tif ( !isEntityClassType( clazzToProcess, classType ) ) {\n \t\t\treturn;\n \t\t}\n \n \t\tif ( LOG.isDebugEnabled() ) {\n \t\t\tLOG.debugf( \"Binding entity from annotated class: %s\", clazzToProcess.getName() );\n \t\t}\n \n \t\tPersistentClass superEntity = getSuperEntity(\n \t\t\t\tclazzToProcess,\n \t\t\t\tinheritanceStatePerClass,\n \t\t\t\tcontext,\n \t\t\t\tinheritanceState\n \t\t);\n \n \t\tPersistentClass persistentClass = makePersistentClass( inheritanceState, superEntity, context );\n \t\tEntity entityAnn = clazzToProcess.getAnnotation( Entity.class );\n \t\torg.hibernate.annotations.Entity hibEntityAnn = clazzToProcess.getAnnotation(\n \t\t\t\torg.hibernate.annotations.Entity.class\n \t\t);\n \t\tEntityBinder entityBinder = new EntityBinder(\n \t\t\t\tentityAnn,\n \t\t\t\thibEntityAnn,\n \t\t\t\tclazzToProcess,\n \t\t\t\tpersistentClass,\n \t\t\t\tcontext\n \t\t);\n \t\tentityBinder.setInheritanceState( inheritanceState );\n \n \t\tbindQueries( clazzToProcess, context );\n \t\tbindFilterDefs( clazzToProcess, context );\n \t\tbindTypeDefs( clazzToProcess, context );\n \t\tbindFetchProfiles( clazzToProcess, context );\n \t\tBinderHelper.bindAnyMetaDefs( clazzToProcess, context );\n \n \t\tString schema = \"\";\n \t\tString table = \"\"; //might be no @Table annotation on the annotated class\n \t\tString catalog = \"\";\n \t\tList<UniqueConstraintHolder> uniqueConstraints = new ArrayList<UniqueConstraintHolder>();\n \t\tjavax.persistence.Table tabAnn = null;\n \t\tif ( clazzToProcess.isAnnotationPresent( javax.persistence.Table.class ) ) {\n \t\t\ttabAnn = clazzToProcess.getAnnotation( javax.persistence.Table.class );\n \t\t\ttable = tabAnn.name();\n \t\t\tschema = tabAnn.schema();\n \t\t\tcatalog = tabAnn.catalog();\n \t\t\tuniqueConstraints = TableBinder.buildUniqueConstraintHolders( tabAnn.uniqueConstraints() );\n \t\t}\n \n \t\tEjb3JoinColumn[] inheritanceJoinedColumns = makeInheritanceJoinColumns(\n \t\t\t\tclazzToProcess,\n \t\t\t\tcontext,\n \t\t\t\tinheritanceState,\n \t\t\t\tsuperEntity\n \t\t);\n \n \t\tfinal Ejb3DiscriminatorColumn discriminatorColumn;\n \t\tif ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.getType() ) ) {\n \t\t\tdiscriminatorColumn = processSingleTableDiscriminatorProperties(\n \t\t\t\t\tclazzToProcess,\n \t\t\t\t\tcontext,\n \t\t\t\t\tinheritanceState,\n \t\t\t\t\tentityBinder\n \t\t\t);\n \t\t}\n \t\telse if ( InheritanceType.JOINED.equals( inheritanceState.getType() ) ) {\n \t\t\tdiscriminatorColumn = processJoinedDiscriminatorProperties(\n \t\t\t\t\tclazzToProcess,\n \t\t\t\t\tcontext,\n \t\t\t\t\tinheritanceState,\n \t\t\t\t\tentityBinder\n \t\t\t);\n \t\t}\n \t\telse {\n \t\t\tdiscriminatorColumn = null;\n \t\t}\n \n \t\tentityBinder.setProxy( clazzToProcess.getAnnotation( Proxy.class ) );\n \t\tentityBinder.setBatchSize( clazzToProcess.getAnnotation( BatchSize.class ) );\n \t\tentityBinder.setWhere( clazzToProcess.getAnnotation( Where.class ) );\n-\t\tentityBinder.setCache( determineCacheSettings( clazzToProcess, context ) );\n-\t\tentityBinder.setNaturalIdCache( clazzToProcess, clazzToProcess.getAnnotation( NaturalIdCache.class ) );\n+\t\tapplyCacheSettings( entityBinder, clazzToProcess, context );\n \n \t\tbindFilters( clazzToProcess, entityBinder, context );\n \n \t\tentityBinder.bindEntity();\n \n \t\tif ( inheritanceState.hasTable() ) {\n \t\t\tCheck checkAnn = clazzToProcess.getAnnotation( Check.class );\n \t\t\tString constraints = checkAnn == null\n \t\t\t\t\t? null\n \t\t\t\t\t: checkAnn.constraints();\n \n \t\t\tEntityTableXref denormalizedTableXref = inheritanceState.hasDenormalizedTable()\n \t\t\t\t\t? context.getMetadataCollector().getEntityTableXref( superEntity.getEntityName() )\n \t\t\t\t\t: null;\n \n \t\t\tentityBinder.bindTable(\n \t\t\t\t\tschema,\n \t\t\t\t\tcatalog,\n \t\t\t\t\ttable,\n \t\t\t\t\tuniqueConstraints,\n \t\t\t\t\tconstraints,\n \t\t\t\t\tdenormalizedTableXref\n \t\t\t);\n \t\t}\n \t\telse {\n \t\t\tif ( clazzToProcess.isAnnotationPresent( Table.class ) ) {\n \t\t\t\tLOG.invalidTableAnnotation( clazzToProcess.getName() );\n \t\t\t}\n \n \t\t\tif ( inheritanceState.getType() == InheritanceType.SINGLE_TABLE ) {\n \t\t\t\t// we at least need to properly set up the EntityTableXref\n \t\t\t\tentityBinder.bindTableForDiscriminatedSubclass(\n \t\t\t\t\t\tcontext.getMetadataCollector().getEntityTableXref( superEntity.getEntityName() )\n \t\t\t\t);\n \t\t\t}\n \t\t}\n \n \n \t\tPropertyHolder propertyHolder = PropertyHolderBuilder.buildPropertyHolder(\n \t\t\t\tclazzToProcess,\n \t\t\t\tpersistentClass,\n \t\t\t\tentityBinder,\n \t\t\t\tcontext,\n \t\t\t\tinheritanceStatePerClass\n \t\t);\n \n \t\tjavax.persistence.SecondaryTable secTabAnn = clazzToProcess.getAnnotation(\n \t\t\t\tjavax.persistence.SecondaryTable.class\n \t\t);\n \t\tjavax.persistence.SecondaryTables secTabsAnn = clazzToProcess.getAnnotation(\n \t\t\t\tjavax.persistence.SecondaryTables.class\n \t\t);\n \t\tentityBinder.firstLevelSecondaryTablesBinding( secTabAnn, secTabsAnn );\n \n \t\tOnDelete onDeleteAnn = clazzToProcess.getAnnotation( OnDelete.class );\n \t\tboolean onDeleteAppropriate = false;\n \n \t\t// todo : sucks that this is separate from RootClass distinction\n \t\tfinal boolean isInheritanceRoot = !inheritanceState.hasParents();\n \t\tfinal boolean hasSubclasses = inheritanceState.hasSiblings();\n \n \t\tif ( InheritanceType.JOINED.equals( inheritanceState.getType() ) ) {\n \t\t\tif ( inheritanceState.hasParents() ) {\n \t\t\t\tonDeleteAppropriate = true;\n \t\t\t\tfinal JoinedSubclass jsc = ( JoinedSubclass ) persistentClass;\n \t\t\t\tSimpleValue key = new DependantValue( context.getMetadataCollector(), jsc.getTable(), jsc.getIdentifier() );\n \t\t\t\tjsc.setKey( key );\n \t\t\t\tForeignKey fk = clazzToProcess.getAnnotation( ForeignKey.class );\n \t\t\t\tif ( fk != null && !BinderHelper.isEmptyAnnotationValue( fk.name() ) ) {\n \t\t\t\t\tkey.setForeignKeyName( fk.name() );\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tfinal PrimaryKeyJoinColumn pkJoinColumn = clazzToProcess.getAnnotation( PrimaryKeyJoinColumn.class );\n \t\t\t\t\tfinal PrimaryKeyJoinColumns pkJoinColumns = clazzToProcess.getAnnotation( PrimaryKeyJoinColumns.class );\n \n \t\t\t\t\tif ( pkJoinColumns != null && pkJoinColumns.foreignKey().value() == ConstraintMode.NO_CONSTRAINT ) {\n \t\t\t\t\t\t// don't apply a constraint based on ConstraintMode\n \t\t\t\t\t\tkey.setForeignKeyName( \"none\" );\n \t\t\t\t\t}\n \t\t\t\t\telse if ( pkJoinColumns != null && !StringHelper.isEmpty( pkJoinColumns.foreignKey().name() ) ) {\n \t\t\t\t\t\tkey.setForeignKeyName( pkJoinColumns.foreignKey().name() );\n \t\t\t\t\t}\n \t\t\t\t\telse if ( pkJoinColumn != null && pkJoinColumn.foreignKey().value() == ConstraintMode.NO_CONSTRAINT ) {\n \t\t\t\t\t\t// don't apply a constraint based on ConstraintMode\n \t\t\t\t\t\tkey.setForeignKeyName( \"none\" );\n \t\t\t\t\t}\n \t\t\t\t\telse if ( pkJoinColumn != null && !StringHelper.isEmpty( pkJoinColumn.foreignKey().name() ) ) {\n \t\t\t\t\t\tkey.setForeignKeyName( pkJoinColumn.foreignKey().name() );\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tif ( onDeleteAnn != null ) {\n \t\t\t\t\tkey.setCascadeDeleteEnabled( OnDeleteAction.CASCADE.equals( onDeleteAnn.action() ) );\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tkey.setCascadeDeleteEnabled( false );\n \t\t\t\t}\n \t\t\t\t//we are never in a second pass at that stage, so queue it\n \t\t\t\tcontext.getMetadataCollector().addSecondPass( new JoinedSubclassFkSecondPass( jsc, inheritanceJoinedColumns, key, context ) );\n \t\t\t\tcontext.getMetadataCollector().addSecondPass( new CreateKeySecondPass( jsc ) );\n \t\t\t}\n \n \t\t\tif ( isInheritanceRoot ) {\n \t\t\t\t// the class we are processing is the root of the hierarchy, see if we had a discriminator column\n \t\t\t\t// (it is perfectly valid for joined subclasses to not have discriminators).\n \t\t\t\tif ( discriminatorColumn != null ) {\n \t\t\t\t\t// we have a discriminator column\n \t\t\t\t\tif ( hasSubclasses || !discriminatorColumn.isImplicit() ) {\n \t\t\t\t\t\tbindDiscriminatorColumnToRootPersistentClass(\n \t\t\t\t\t\t\t\t(RootClass) persistentClass,\n \t\t\t\t\t\t\t\tdiscriminatorColumn,\n \t\t\t\t\t\t\t\tentityBinder.getSecondaryTables(),\n \t\t\t\t\t\t\t\tpropertyHolder,\n \t\t\t\t\t\t\t\tcontext\n \t\t\t\t\t\t);\n \t\t\t\t\t\t//bind it again since the type might have changed\n \t\t\t\t\t\tentityBinder.bindDiscriminatorValue();\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\telse if ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.getType() ) ) {\n \t\t\tif ( isInheritanceRoot ) {\n \t\t\t\tif ( hasSubclasses || !discriminatorColumn.isImplicit() ) {\n \t\t\t\t\tbindDiscriminatorColumnToRootPersistentClass(\n \t\t\t\t\t\t\t(RootClass) persistentClass,\n \t\t\t\t\t\t\tdiscriminatorColumn,\n \t\t\t\t\t\t\tentityBinder.getSecondaryTables(),\n \t\t\t\t\t\t\tpropertyHolder,\n \t\t\t\t\t\t\tcontext\n \t\t\t\t\t);\n \t\t\t\t\t//bind it again since the type might have changed\n \t\t\t\t\tentityBinder.bindDiscriminatorValue();\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\tif ( onDeleteAnn != null && !onDeleteAppropriate ) {\n \t\t\tLOG.invalidOnDeleteAnnotation(propertyHolder.getEntityName());\n \t\t}\n \n \t\t// try to find class level generators\n \t\tHashMap<String, IdentifierGeneratorDefinition> classGenerators = buildLocalGenerators( clazzToProcess, context );\n \n \t\t// check properties\n \t\tfinal InheritanceState.ElementsToProcess elementsToProcess = inheritanceState.getElementsToProcess();\n \t\tinheritanceState.postProcess( persistentClass, entityBinder );\n \n \t\tfinal boolean subclassAndSingleTableStrategy = inheritanceState.getType() == InheritanceType.SINGLE_TABLE\n \t\t\t\t&& inheritanceState.hasParents();\n \t\tSet<String> idPropertiesIfIdClass = new HashSet<String>();\n \t\tboolean isIdClass = mapAsIdClass(\n \t\t\t\tinheritanceStatePerClass,\n \t\t\t\tinheritanceState,\n \t\t\t\tpersistentClass,\n \t\t\t\tentityBinder,\n \t\t\t\tpropertyHolder,\n \t\t\t\telementsToProcess,\n \t\t\t\tidPropertiesIfIdClass,\n \t\t\t\tcontext\n \t\t);\n \n \t\tif ( !isIdClass ) {\n \t\t\tentityBinder.setWrapIdsInEmbeddedComponents( elementsToProcess.getIdPropertyCount() > 1 );\n \t\t}\n \n \t\tprocessIdPropertiesIfNotAlready(\n \t\t\t\tinheritanceStatePerClass,\n \t\t\t\tcontext,\n \t\t\t\tpersistentClass,\n \t\t\t\tentityBinder,\n \t\t\t\tpropertyHolder,\n \t\t\t\tclassGenerators,\n \t\t\t\telementsToProcess,\n \t\t\t\tsubclassAndSingleTableStrategy,\n \t\t\t\tidPropertiesIfIdClass\n \t\t);\n \n \t\tif ( !inheritanceState.hasParents() ) {\n \t\t\tfinal RootClass rootClass = ( RootClass ) persistentClass;\n \t\t\tcontext.getMetadataCollector().addSecondPass( new CreateKeySecondPass( rootClass ) );\n \t\t}\n \t\telse {\n \t\t\tsuperEntity.addSubclass( ( Subclass ) persistentClass );\n \t\t}\n \n \t\tcontext.getMetadataCollector().addEntityBinding( persistentClass );\n \n \t\t//Process secondary tables and complementary definitions (ie o.h.a.Table)\n \t\tcontext.getMetadataCollector().addSecondPass(\n \t\t\t\tnew SecondaryTableSecondPass(\n \t\t\t\t\t\tentityBinder,\n \t\t\t\t\t\tpropertyHolder,\n \t\t\t\t\t\tclazzToProcess\n \t\t\t\t)\n \t\t);\n \n \t\t//add process complementary Table definition (index & all)\n \t\tentityBinder.processComplementaryTableDefinitions( clazzToProcess.getAnnotation( org.hibernate.annotations.Table.class ) );\n \t\tentityBinder.processComplementaryTableDefinitions( clazzToProcess.getAnnotation( org.hibernate.annotations.Tables.class ) );\n \t\tentityBinder.processComplementaryTableDefinitions( tabAnn );\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"aeb3aee62603f4e3613ed4037f2727c817a11016": {
			"type": "Ybodychange",
			"commitMessage": "HHH-11180 - JPA @ForeignKey still not consistently applied from annotation binding\n\n- Fix ForeignKey support for PrimaryKeyJoinColumn / PrimaryKeyJoinColumns\n- Fix ForeignKey support for JoinColumn / JoinColumns\n- Fix ForeignKey support for JoinTable when applying value NO_CONSTRAINT.\n- Fix ForeignKey support for MapKeyJoinColumn / MapKeyJoinColumns\n- Fix ForeignKey support for AssociationOverride / AssociationOverrides\n",
			"commitDate": "2017-02-15, 4:08 AM",
			"commitName": "aeb3aee62603f4e3613ed4037f2727c817a11016",
			"commitAuthor": "Christian Beikov",
			"commitDateOld": "2016-12-06, 4:50 AM",
			"commitNameOld": "b1c7615904e7dd3c03bbe77af8bda2fbce6a3624",
			"commitAuthorOld": "Vlad Mihalcea",
			"daysBetweenCommits": 70.97,
			"commitsBetweenForRepo": 183,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,292 +1,304 @@\n \tpublic static void bindClass(\n \t\t\tXClass clazzToProcess,\n \t\t\tMap<XClass, InheritanceState> inheritanceStatePerClass,\n \t\t\tMetadataBuildingContext context) throws MappingException {\n \t\t//@Entity and @MappedSuperclass on the same class leads to a NPE down the road\n \t\tif ( clazzToProcess.isAnnotationPresent( Entity.class )\n \t\t\t\t&&  clazzToProcess.isAnnotationPresent( MappedSuperclass.class ) ) {\n \t\t\tthrow new AnnotationException( \"An entity cannot be annotated with both @Entity and @MappedSuperclass: \"\n \t\t\t\t\t+ clazzToProcess.getName() );\n \t\t}\n \n \t\t//TODO: be more strict with secondarytable allowance (not for ids, not for secondary table join columns etc)\n \t\tInheritanceState inheritanceState = inheritanceStatePerClass.get( clazzToProcess );\n \t\tAnnotatedClassType classType = context.getMetadataCollector().getClassType( clazzToProcess );\n \n \t\t//Queries declared in MappedSuperclass should be usable in Subclasses\n \t\tif ( AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals( classType ) ) {\n \t\t\tbindQueries( clazzToProcess, context );\n \t\t\tbindTypeDefs( clazzToProcess, context );\n \t\t\tbindFilterDefs( clazzToProcess, context );\n \t\t}\n \n \t\tif ( !isEntityClassType( clazzToProcess, classType ) ) {\n \t\t\treturn;\n \t\t}\n \n \t\tif ( LOG.isDebugEnabled() ) {\n \t\t\tLOG.debugf( \"Binding entity from annotated class: %s\", clazzToProcess.getName() );\n \t\t}\n \n \t\tPersistentClass superEntity = getSuperEntity(\n \t\t\t\tclazzToProcess,\n \t\t\t\tinheritanceStatePerClass,\n \t\t\t\tcontext,\n \t\t\t\tinheritanceState\n \t\t);\n \n \t\tPersistentClass persistentClass = makePersistentClass( inheritanceState, superEntity, context );\n \t\tEntity entityAnn = clazzToProcess.getAnnotation( Entity.class );\n \t\torg.hibernate.annotations.Entity hibEntityAnn = clazzToProcess.getAnnotation(\n \t\t\t\torg.hibernate.annotations.Entity.class\n \t\t);\n \t\tEntityBinder entityBinder = new EntityBinder(\n \t\t\t\tentityAnn,\n \t\t\t\thibEntityAnn,\n \t\t\t\tclazzToProcess,\n \t\t\t\tpersistentClass,\n \t\t\t\tcontext\n \t\t);\n \t\tentityBinder.setInheritanceState( inheritanceState );\n \n \t\tbindQueries( clazzToProcess, context );\n \t\tbindFilterDefs( clazzToProcess, context );\n \t\tbindTypeDefs( clazzToProcess, context );\n \t\tbindFetchProfiles( clazzToProcess, context );\n \t\tBinderHelper.bindAnyMetaDefs( clazzToProcess, context );\n \n \t\tString schema = \"\";\n \t\tString table = \"\"; //might be no @Table annotation on the annotated class\n \t\tString catalog = \"\";\n \t\tList<UniqueConstraintHolder> uniqueConstraints = new ArrayList<UniqueConstraintHolder>();\n \t\tjavax.persistence.Table tabAnn = null;\n \t\tif ( clazzToProcess.isAnnotationPresent( javax.persistence.Table.class ) ) {\n \t\t\ttabAnn = clazzToProcess.getAnnotation( javax.persistence.Table.class );\n \t\t\ttable = tabAnn.name();\n \t\t\tschema = tabAnn.schema();\n \t\t\tcatalog = tabAnn.catalog();\n \t\t\tuniqueConstraints = TableBinder.buildUniqueConstraintHolders( tabAnn.uniqueConstraints() );\n \t\t}\n \n \t\tEjb3JoinColumn[] inheritanceJoinedColumns = makeInheritanceJoinColumns(\n \t\t\t\tclazzToProcess,\n \t\t\t\tcontext,\n \t\t\t\tinheritanceState,\n \t\t\t\tsuperEntity\n \t\t);\n \n \t\tfinal Ejb3DiscriminatorColumn discriminatorColumn;\n \t\tif ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.getType() ) ) {\n \t\t\tdiscriminatorColumn = processSingleTableDiscriminatorProperties(\n \t\t\t\t\tclazzToProcess,\n \t\t\t\t\tcontext,\n \t\t\t\t\tinheritanceState,\n \t\t\t\t\tentityBinder\n \t\t\t);\n \t\t}\n \t\telse if ( InheritanceType.JOINED.equals( inheritanceState.getType() ) ) {\n \t\t\tdiscriminatorColumn = processJoinedDiscriminatorProperties(\n \t\t\t\t\tclazzToProcess,\n \t\t\t\t\tcontext,\n \t\t\t\t\tinheritanceState,\n \t\t\t\t\tentityBinder\n \t\t\t);\n \t\t}\n \t\telse {\n \t\t\tdiscriminatorColumn = null;\n \t\t}\n \n \t\tentityBinder.setProxy( clazzToProcess.getAnnotation( Proxy.class ) );\n \t\tentityBinder.setBatchSize( clazzToProcess.getAnnotation( BatchSize.class ) );\n \t\tentityBinder.setWhere( clazzToProcess.getAnnotation( Where.class ) );\n \t\tentityBinder.setCache( determineCacheSettings( clazzToProcess, context ) );\n \t\tentityBinder.setNaturalIdCache( clazzToProcess, clazzToProcess.getAnnotation( NaturalIdCache.class ) );\n \n \t\tbindFilters( clazzToProcess, entityBinder, context );\n \n \t\tentityBinder.bindEntity();\n \n \t\tif ( inheritanceState.hasTable() ) {\n \t\t\tCheck checkAnn = clazzToProcess.getAnnotation( Check.class );\n \t\t\tString constraints = checkAnn == null\n \t\t\t\t\t? null\n \t\t\t\t\t: checkAnn.constraints();\n \n \t\t\tEntityTableXref denormalizedTableXref = inheritanceState.hasDenormalizedTable()\n \t\t\t\t\t? context.getMetadataCollector().getEntityTableXref( superEntity.getEntityName() )\n \t\t\t\t\t: null;\n \n \t\t\tentityBinder.bindTable(\n \t\t\t\t\tschema,\n \t\t\t\t\tcatalog,\n \t\t\t\t\ttable,\n \t\t\t\t\tuniqueConstraints,\n \t\t\t\t\tconstraints,\n \t\t\t\t\tdenormalizedTableXref\n \t\t\t);\n \t\t}\n \t\telse {\n \t\t\tif ( clazzToProcess.isAnnotationPresent( Table.class ) ) {\n \t\t\t\tLOG.invalidTableAnnotation( clazzToProcess.getName() );\n \t\t\t}\n \n \t\t\tif ( inheritanceState.getType() == InheritanceType.SINGLE_TABLE ) {\n \t\t\t\t// we at least need to properly set up the EntityTableXref\n \t\t\t\tentityBinder.bindTableForDiscriminatedSubclass(\n \t\t\t\t\t\tcontext.getMetadataCollector().getEntityTableXref( superEntity.getEntityName() )\n \t\t\t\t);\n \t\t\t}\n \t\t}\n \n \n \t\tPropertyHolder propertyHolder = PropertyHolderBuilder.buildPropertyHolder(\n \t\t\t\tclazzToProcess,\n \t\t\t\tpersistentClass,\n \t\t\t\tentityBinder,\n \t\t\t\tcontext,\n \t\t\t\tinheritanceStatePerClass\n \t\t);\n \n \t\tjavax.persistence.SecondaryTable secTabAnn = clazzToProcess.getAnnotation(\n \t\t\t\tjavax.persistence.SecondaryTable.class\n \t\t);\n \t\tjavax.persistence.SecondaryTables secTabsAnn = clazzToProcess.getAnnotation(\n \t\t\t\tjavax.persistence.SecondaryTables.class\n \t\t);\n \t\tentityBinder.firstLevelSecondaryTablesBinding( secTabAnn, secTabsAnn );\n \n \t\tOnDelete onDeleteAnn = clazzToProcess.getAnnotation( OnDelete.class );\n \t\tboolean onDeleteAppropriate = false;\n \n \t\t// todo : sucks that this is separate from RootClass distinction\n \t\tfinal boolean isInheritanceRoot = !inheritanceState.hasParents();\n \t\tfinal boolean hasSubclasses = inheritanceState.hasSiblings();\n \n \t\tif ( InheritanceType.JOINED.equals( inheritanceState.getType() ) ) {\n \t\t\tif ( inheritanceState.hasParents() ) {\n \t\t\t\tonDeleteAppropriate = true;\n \t\t\t\tfinal JoinedSubclass jsc = ( JoinedSubclass ) persistentClass;\n \t\t\t\tSimpleValue key = new DependantValue( context.getMetadataCollector(), jsc.getTable(), jsc.getIdentifier() );\n \t\t\t\tjsc.setKey( key );\n \t\t\t\tForeignKey fk = clazzToProcess.getAnnotation( ForeignKey.class );\n \t\t\t\tif ( fk != null && !BinderHelper.isEmptyAnnotationValue( fk.name() ) ) {\n \t\t\t\t\tkey.setForeignKeyName( fk.name() );\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tfinal PrimaryKeyJoinColumn pkJoinColumn = clazzToProcess.getAnnotation( PrimaryKeyJoinColumn.class );\n-\t\t\t\t\tif ( pkJoinColumn != null && pkJoinColumn.foreignKey() != null\n-\t\t\t\t\t\t\t&& !StringHelper.isEmpty( pkJoinColumn.foreignKey().name() ) ) {\n+\t\t\t\t\tfinal PrimaryKeyJoinColumns pkJoinColumns = clazzToProcess.getAnnotation( PrimaryKeyJoinColumns.class );\n+\n+\t\t\t\t\tif ( pkJoinColumns != null && pkJoinColumns.foreignKey().value() == ConstraintMode.NO_CONSTRAINT ) {\n+\t\t\t\t\t\t// don't apply a constraint based on ConstraintMode\n+\t\t\t\t\t\tkey.setForeignKeyName( \"none\" );\n+\t\t\t\t\t}\n+\t\t\t\t\telse if ( pkJoinColumns != null && !StringHelper.isEmpty( pkJoinColumns.foreignKey().name() ) ) {\n+\t\t\t\t\t\tkey.setForeignKeyName( pkJoinColumns.foreignKey().name() );\n+\t\t\t\t\t}\n+\t\t\t\t\telse if ( pkJoinColumn != null && pkJoinColumn.foreignKey().value() == ConstraintMode.NO_CONSTRAINT ) {\n+\t\t\t\t\t\t// don't apply a constraint based on ConstraintMode\n+\t\t\t\t\t\tkey.setForeignKeyName( \"none\" );\n+\t\t\t\t\t}\n+\t\t\t\t\telse if ( pkJoinColumn != null && !StringHelper.isEmpty( pkJoinColumn.foreignKey().name() ) ) {\n \t\t\t\t\t\tkey.setForeignKeyName( pkJoinColumn.foreignKey().name() );\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tif ( onDeleteAnn != null ) {\n \t\t\t\t\tkey.setCascadeDeleteEnabled( OnDeleteAction.CASCADE.equals( onDeleteAnn.action() ) );\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tkey.setCascadeDeleteEnabled( false );\n \t\t\t\t}\n \t\t\t\t//we are never in a second pass at that stage, so queue it\n \t\t\t\tcontext.getMetadataCollector().addSecondPass( new JoinedSubclassFkSecondPass( jsc, inheritanceJoinedColumns, key, context ) );\n \t\t\t\tcontext.getMetadataCollector().addSecondPass( new CreateKeySecondPass( jsc ) );\n \t\t\t}\n \n \t\t\tif ( isInheritanceRoot ) {\n \t\t\t\t// the class we are processing is the root of the hierarchy, see if we had a discriminator column\n \t\t\t\t// (it is perfectly valid for joined subclasses to not have discriminators).\n \t\t\t\tif ( discriminatorColumn != null ) {\n \t\t\t\t\t// we have a discriminator column\n \t\t\t\t\tif ( hasSubclasses || !discriminatorColumn.isImplicit() ) {\n \t\t\t\t\t\tbindDiscriminatorColumnToRootPersistentClass(\n \t\t\t\t\t\t\t\t(RootClass) persistentClass,\n \t\t\t\t\t\t\t\tdiscriminatorColumn,\n \t\t\t\t\t\t\t\tentityBinder.getSecondaryTables(),\n \t\t\t\t\t\t\t\tpropertyHolder,\n \t\t\t\t\t\t\t\tcontext\n \t\t\t\t\t\t);\n \t\t\t\t\t\t//bind it again since the type might have changed\n \t\t\t\t\t\tentityBinder.bindDiscriminatorValue();\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\telse if ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.getType() ) ) {\n \t\t\tif ( isInheritanceRoot ) {\n \t\t\t\tif ( hasSubclasses || !discriminatorColumn.isImplicit() ) {\n \t\t\t\t\tbindDiscriminatorColumnToRootPersistentClass(\n \t\t\t\t\t\t\t(RootClass) persistentClass,\n \t\t\t\t\t\t\tdiscriminatorColumn,\n \t\t\t\t\t\t\tentityBinder.getSecondaryTables(),\n \t\t\t\t\t\t\tpropertyHolder,\n \t\t\t\t\t\t\tcontext\n \t\t\t\t\t);\n \t\t\t\t\t//bind it again since the type might have changed\n \t\t\t\t\tentityBinder.bindDiscriminatorValue();\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\tif ( onDeleteAnn != null && !onDeleteAppropriate ) {\n \t\t\tLOG.invalidOnDeleteAnnotation(propertyHolder.getEntityName());\n \t\t}\n \n \t\t// try to find class level generators\n \t\tHashMap<String, IdentifierGeneratorDefinition> classGenerators = buildLocalGenerators( clazzToProcess, context );\n \n \t\t// check properties\n \t\tfinal InheritanceState.ElementsToProcess elementsToProcess = inheritanceState.getElementsToProcess();\n \t\tinheritanceState.postProcess( persistentClass, entityBinder );\n \n \t\tfinal boolean subclassAndSingleTableStrategy = inheritanceState.getType() == InheritanceType.SINGLE_TABLE\n \t\t\t\t&& inheritanceState.hasParents();\n \t\tSet<String> idPropertiesIfIdClass = new HashSet<String>();\n \t\tboolean isIdClass = mapAsIdClass(\n \t\t\t\tinheritanceStatePerClass,\n \t\t\t\tinheritanceState,\n \t\t\t\tpersistentClass,\n \t\t\t\tentityBinder,\n \t\t\t\tpropertyHolder,\n \t\t\t\telementsToProcess,\n \t\t\t\tidPropertiesIfIdClass,\n \t\t\t\tcontext\n \t\t);\n \n \t\tif ( !isIdClass ) {\n \t\t\tentityBinder.setWrapIdsInEmbeddedComponents( elementsToProcess.getIdPropertyCount() > 1 );\n \t\t}\n \n \t\tprocessIdPropertiesIfNotAlready(\n \t\t\t\tinheritanceStatePerClass,\n \t\t\t\tcontext,\n \t\t\t\tpersistentClass,\n \t\t\t\tentityBinder,\n \t\t\t\tpropertyHolder,\n \t\t\t\tclassGenerators,\n \t\t\t\telementsToProcess,\n \t\t\t\tsubclassAndSingleTableStrategy,\n \t\t\t\tidPropertiesIfIdClass\n \t\t);\n \n \t\tif ( !inheritanceState.hasParents() ) {\n \t\t\tfinal RootClass rootClass = ( RootClass ) persistentClass;\n \t\t\tcontext.getMetadataCollector().addSecondPass( new CreateKeySecondPass( rootClass ) );\n \t\t}\n \t\telse {\n \t\t\tsuperEntity.addSubclass( ( Subclass ) persistentClass );\n \t\t}\n \n \t\tcontext.getMetadataCollector().addEntityBinding( persistentClass );\n \n \t\t//Process secondary tables and complementary definitions (ie o.h.a.Table)\n \t\tcontext.getMetadataCollector().addSecondPass(\n \t\t\t\tnew SecondaryTableSecondPass(\n \t\t\t\t\t\tentityBinder,\n \t\t\t\t\t\tpropertyHolder,\n \t\t\t\t\t\tclazzToProcess\n \t\t\t\t)\n \t\t);\n \n \t\t//add process complementary Table definition (index & all)\n \t\tentityBinder.processComplementaryTableDefinitions( clazzToProcess.getAnnotation( org.hibernate.annotations.Table.class ) );\n \t\tentityBinder.processComplementaryTableDefinitions( clazzToProcess.getAnnotation( org.hibernate.annotations.Tables.class ) );\n \t\tentityBinder.processComplementaryTableDefinitions( tabAnn );\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"2ea122aedd0c32e5ab1c68e90dd8dd4ed33d2021": {
			"type": "Ybodychange",
			"commitMessage": "HHH-10352 - Fix HBM2DDL does not use described name for foreign key in join inheritance\n",
			"commitDate": "2016-06-13, 4:58 PM",
			"commitName": "2ea122aedd0c32e5ab1c68e90dd8dd4ed33d2021",
			"commitAuthor": "Andrea Boriero",
			"commitDateOld": "2016-06-07, 1:36 AM",
			"commitNameOld": "78de650efec58367a4196eb41c1d5f99b291f036",
			"commitAuthorOld": "Matthias Kurz",
			"daysBetweenCommits": 6.64,
			"commitsBetweenForRepo": 31,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,285 +1,292 @@\n \tpublic static void bindClass(\n \t\t\tXClass clazzToProcess,\n \t\t\tMap<XClass, InheritanceState> inheritanceStatePerClass,\n \t\t\tMetadataBuildingContext context) throws MappingException {\n \t\t//@Entity and @MappedSuperclass on the same class leads to a NPE down the road\n \t\tif ( clazzToProcess.isAnnotationPresent( Entity.class )\n \t\t\t\t&&  clazzToProcess.isAnnotationPresent( MappedSuperclass.class ) ) {\n \t\t\tthrow new AnnotationException( \"An entity cannot be annotated with both @Entity and @MappedSuperclass: \"\n \t\t\t\t\t+ clazzToProcess.getName() );\n \t\t}\n \n \t\t//TODO: be more strict with secondarytable allowance (not for ids, not for secondary table join columns etc)\n \t\tInheritanceState inheritanceState = inheritanceStatePerClass.get( clazzToProcess );\n \t\tAnnotatedClassType classType = context.getMetadataCollector().getClassType( clazzToProcess );\n \n \t\t//Queries declared in MappedSuperclass should be usable in Subclasses\n \t\tif ( AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals( classType ) ) {\n \t\t\tbindQueries( clazzToProcess, context );\n \t\t\tbindTypeDefs( clazzToProcess, context );\n \t\t\tbindFilterDefs( clazzToProcess, context );\n \t\t}\n \n \t\tif ( !isEntityClassType( clazzToProcess, classType ) ) {\n \t\t\treturn;\n \t\t}\n \n \t\tif ( LOG.isDebugEnabled() ) {\n \t\t\tLOG.debugf( \"Binding entity from annotated class: %s\", clazzToProcess.getName() );\n \t\t}\n \n \t\tPersistentClass superEntity = getSuperEntity(\n \t\t\t\tclazzToProcess,\n \t\t\t\tinheritanceStatePerClass,\n \t\t\t\tcontext,\n \t\t\t\tinheritanceState\n \t\t);\n \n \t\tPersistentClass persistentClass = makePersistentClass( inheritanceState, superEntity, context );\n \t\tEntity entityAnn = clazzToProcess.getAnnotation( Entity.class );\n \t\torg.hibernate.annotations.Entity hibEntityAnn = clazzToProcess.getAnnotation(\n \t\t\t\torg.hibernate.annotations.Entity.class\n \t\t);\n \t\tEntityBinder entityBinder = new EntityBinder(\n \t\t\t\tentityAnn,\n \t\t\t\thibEntityAnn,\n \t\t\t\tclazzToProcess,\n \t\t\t\tpersistentClass,\n \t\t\t\tcontext\n \t\t);\n \t\tentityBinder.setInheritanceState( inheritanceState );\n \n \t\tbindQueries( clazzToProcess, context );\n \t\tbindFilterDefs( clazzToProcess, context );\n \t\tbindTypeDefs( clazzToProcess, context );\n \t\tbindFetchProfiles( clazzToProcess, context );\n \t\tBinderHelper.bindAnyMetaDefs( clazzToProcess, context );\n \n \t\tString schema = \"\";\n \t\tString table = \"\"; //might be no @Table annotation on the annotated class\n \t\tString catalog = \"\";\n \t\tList<UniqueConstraintHolder> uniqueConstraints = new ArrayList<UniqueConstraintHolder>();\n \t\tjavax.persistence.Table tabAnn = null;\n \t\tif ( clazzToProcess.isAnnotationPresent( javax.persistence.Table.class ) ) {\n \t\t\ttabAnn = clazzToProcess.getAnnotation( javax.persistence.Table.class );\n \t\t\ttable = tabAnn.name();\n \t\t\tschema = tabAnn.schema();\n \t\t\tcatalog = tabAnn.catalog();\n \t\t\tuniqueConstraints = TableBinder.buildUniqueConstraintHolders( tabAnn.uniqueConstraints() );\n \t\t}\n \n \t\tEjb3JoinColumn[] inheritanceJoinedColumns = makeInheritanceJoinColumns(\n \t\t\t\tclazzToProcess,\n \t\t\t\tcontext,\n \t\t\t\tinheritanceState,\n \t\t\t\tsuperEntity\n \t\t);\n \n \t\tfinal Ejb3DiscriminatorColumn discriminatorColumn;\n \t\tif ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.getType() ) ) {\n \t\t\tdiscriminatorColumn = processSingleTableDiscriminatorProperties(\n \t\t\t\t\tclazzToProcess,\n \t\t\t\t\tcontext,\n \t\t\t\t\tinheritanceState,\n \t\t\t\t\tentityBinder\n \t\t\t);\n \t\t}\n \t\telse if ( InheritanceType.JOINED.equals( inheritanceState.getType() ) ) {\n \t\t\tdiscriminatorColumn = processJoinedDiscriminatorProperties(\n \t\t\t\t\tclazzToProcess,\n \t\t\t\t\tcontext,\n \t\t\t\t\tinheritanceState,\n \t\t\t\t\tentityBinder\n \t\t\t);\n \t\t}\n \t\telse {\n \t\t\tdiscriminatorColumn = null;\n \t\t}\n \n \t\tentityBinder.setProxy( clazzToProcess.getAnnotation( Proxy.class ) );\n \t\tentityBinder.setBatchSize( clazzToProcess.getAnnotation( BatchSize.class ) );\n \t\tentityBinder.setWhere( clazzToProcess.getAnnotation( Where.class ) );\n \t\tentityBinder.setCache( determineCacheSettings( clazzToProcess, context ) );\n \t\tentityBinder.setNaturalIdCache( clazzToProcess, clazzToProcess.getAnnotation( NaturalIdCache.class ) );\n \n \t\tbindFilters( clazzToProcess, entityBinder, context );\n \n \t\tentityBinder.bindEntity();\n \n \t\tif ( inheritanceState.hasTable() ) {\n \t\t\tCheck checkAnn = clazzToProcess.getAnnotation( Check.class );\n \t\t\tString constraints = checkAnn == null\n \t\t\t\t\t? null\n \t\t\t\t\t: checkAnn.constraints();\n \n \t\t\tEntityTableXref denormalizedTableXref = inheritanceState.hasDenormalizedTable()\n \t\t\t\t\t? context.getMetadataCollector().getEntityTableXref( superEntity.getEntityName() )\n \t\t\t\t\t: null;\n \n \t\t\tentityBinder.bindTable(\n \t\t\t\t\tschema,\n \t\t\t\t\tcatalog,\n \t\t\t\t\ttable,\n \t\t\t\t\tuniqueConstraints,\n \t\t\t\t\tconstraints,\n \t\t\t\t\tdenormalizedTableXref\n \t\t\t);\n \t\t}\n \t\telse {\n \t\t\tif ( clazzToProcess.isAnnotationPresent( Table.class ) ) {\n \t\t\t\tLOG.invalidTableAnnotation( clazzToProcess.getName() );\n \t\t\t}\n \n \t\t\tif ( inheritanceState.getType() == InheritanceType.SINGLE_TABLE ) {\n \t\t\t\t// we at least need to properly set up the EntityTableXref\n \t\t\t\tentityBinder.bindTableForDiscriminatedSubclass(\n \t\t\t\t\t\tcontext.getMetadataCollector().getEntityTableXref( superEntity.getEntityName() )\n \t\t\t\t);\n \t\t\t}\n \t\t}\n \n \n \t\tPropertyHolder propertyHolder = PropertyHolderBuilder.buildPropertyHolder(\n \t\t\t\tclazzToProcess,\n \t\t\t\tpersistentClass,\n \t\t\t\tentityBinder,\n \t\t\t\tcontext,\n \t\t\t\tinheritanceStatePerClass\n \t\t);\n \n \t\tjavax.persistence.SecondaryTable secTabAnn = clazzToProcess.getAnnotation(\n \t\t\t\tjavax.persistence.SecondaryTable.class\n \t\t);\n \t\tjavax.persistence.SecondaryTables secTabsAnn = clazzToProcess.getAnnotation(\n \t\t\t\tjavax.persistence.SecondaryTables.class\n \t\t);\n \t\tentityBinder.firstLevelSecondaryTablesBinding( secTabAnn, secTabsAnn );\n \n \t\tOnDelete onDeleteAnn = clazzToProcess.getAnnotation( OnDelete.class );\n \t\tboolean onDeleteAppropriate = false;\n \n \t\t// todo : sucks that this is separate from RootClass distinction\n \t\tfinal boolean isInheritanceRoot = !inheritanceState.hasParents();\n \t\tfinal boolean hasSubclasses = inheritanceState.hasSiblings();\n \n \t\tif ( InheritanceType.JOINED.equals( inheritanceState.getType() ) ) {\n \t\t\tif ( inheritanceState.hasParents() ) {\n \t\t\t\tonDeleteAppropriate = true;\n \t\t\t\tfinal JoinedSubclass jsc = ( JoinedSubclass ) persistentClass;\n \t\t\t\tSimpleValue key = new DependantValue( context.getMetadataCollector(), jsc.getTable(), jsc.getIdentifier() );\n \t\t\t\tjsc.setKey( key );\n \t\t\t\tForeignKey fk = clazzToProcess.getAnnotation( ForeignKey.class );\n \t\t\t\tif ( fk != null && !BinderHelper.isEmptyAnnotationValue( fk.name() ) ) {\n \t\t\t\t\tkey.setForeignKeyName( fk.name() );\n \t\t\t\t}\n+\t\t\t\telse {\n+\t\t\t\t\tfinal PrimaryKeyJoinColumn pkJoinColumn = clazzToProcess.getAnnotation( PrimaryKeyJoinColumn.class );\n+\t\t\t\t\tif ( pkJoinColumn != null && pkJoinColumn.foreignKey() != null\n+\t\t\t\t\t\t\t&& !StringHelper.isEmpty( pkJoinColumn.foreignKey().name() ) ) {\n+\t\t\t\t\t\tkey.setForeignKeyName( pkJoinColumn.foreignKey().name() );\n+\t\t\t\t\t}\n+\t\t\t\t}\n \t\t\t\tif ( onDeleteAnn != null ) {\n \t\t\t\t\tkey.setCascadeDeleteEnabled( OnDeleteAction.CASCADE.equals( onDeleteAnn.action() ) );\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tkey.setCascadeDeleteEnabled( false );\n \t\t\t\t}\n \t\t\t\t//we are never in a second pass at that stage, so queue it\n \t\t\t\tcontext.getMetadataCollector().addSecondPass( new JoinedSubclassFkSecondPass( jsc, inheritanceJoinedColumns, key, context ) );\n \t\t\t\tcontext.getMetadataCollector().addSecondPass( new CreateKeySecondPass( jsc ) );\n \t\t\t}\n \n \t\t\tif ( isInheritanceRoot ) {\n \t\t\t\t// the class we are processing is the root of the hierarchy, see if we had a discriminator column\n \t\t\t\t// (it is perfectly valid for joined subclasses to not have discriminators).\n \t\t\t\tif ( discriminatorColumn != null ) {\n \t\t\t\t\t// we have a discriminator column\n \t\t\t\t\tif ( hasSubclasses || !discriminatorColumn.isImplicit() ) {\n \t\t\t\t\t\tbindDiscriminatorColumnToRootPersistentClass(\n \t\t\t\t\t\t\t\t(RootClass) persistentClass,\n \t\t\t\t\t\t\t\tdiscriminatorColumn,\n \t\t\t\t\t\t\t\tentityBinder.getSecondaryTables(),\n \t\t\t\t\t\t\t\tpropertyHolder,\n \t\t\t\t\t\t\t\tcontext\n \t\t\t\t\t\t);\n \t\t\t\t\t\t//bind it again since the type might have changed\n \t\t\t\t\t\tentityBinder.bindDiscriminatorValue();\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\telse if ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.getType() ) ) {\n \t\t\tif ( isInheritanceRoot ) {\n \t\t\t\tif ( hasSubclasses || !discriminatorColumn.isImplicit() ) {\n \t\t\t\t\tbindDiscriminatorColumnToRootPersistentClass(\n \t\t\t\t\t\t\t(RootClass) persistentClass,\n \t\t\t\t\t\t\tdiscriminatorColumn,\n \t\t\t\t\t\t\tentityBinder.getSecondaryTables(),\n \t\t\t\t\t\t\tpropertyHolder,\n \t\t\t\t\t\t\tcontext\n \t\t\t\t\t);\n \t\t\t\t\t//bind it again since the type might have changed\n \t\t\t\t\tentityBinder.bindDiscriminatorValue();\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\tif ( onDeleteAnn != null && !onDeleteAppropriate ) {\n \t\t\tLOG.invalidOnDeleteAnnotation(propertyHolder.getEntityName());\n \t\t}\n \n \t\t// try to find class level generators\n \t\tHashMap<String, IdentifierGeneratorDefinition> classGenerators = buildLocalGenerators( clazzToProcess, context );\n \n \t\t// check properties\n \t\tfinal InheritanceState.ElementsToProcess elementsToProcess = inheritanceState.getElementsToProcess();\n \t\tinheritanceState.postProcess( persistentClass, entityBinder );\n \n \t\tfinal boolean subclassAndSingleTableStrategy = inheritanceState.getType() == InheritanceType.SINGLE_TABLE\n \t\t\t\t&& inheritanceState.hasParents();\n \t\tSet<String> idPropertiesIfIdClass = new HashSet<String>();\n \t\tboolean isIdClass = mapAsIdClass(\n \t\t\t\tinheritanceStatePerClass,\n \t\t\t\tinheritanceState,\n \t\t\t\tpersistentClass,\n \t\t\t\tentityBinder,\n \t\t\t\tpropertyHolder,\n \t\t\t\telementsToProcess,\n \t\t\t\tidPropertiesIfIdClass,\n \t\t\t\tcontext\n \t\t);\n \n \t\tif ( !isIdClass ) {\n \t\t\tentityBinder.setWrapIdsInEmbeddedComponents( elementsToProcess.getIdPropertyCount() > 1 );\n \t\t}\n \n \t\tprocessIdPropertiesIfNotAlready(\n \t\t\t\tinheritanceStatePerClass,\n \t\t\t\tcontext,\n \t\t\t\tpersistentClass,\n \t\t\t\tentityBinder,\n \t\t\t\tpropertyHolder,\n \t\t\t\tclassGenerators,\n \t\t\t\telementsToProcess,\n \t\t\t\tsubclassAndSingleTableStrategy,\n \t\t\t\tidPropertiesIfIdClass\n \t\t);\n \n \t\tif ( !inheritanceState.hasParents() ) {\n \t\t\tfinal RootClass rootClass = ( RootClass ) persistentClass;\n \t\t\tcontext.getMetadataCollector().addSecondPass( new CreateKeySecondPass( rootClass ) );\n \t\t}\n \t\telse {\n \t\t\tsuperEntity.addSubclass( ( Subclass ) persistentClass );\n \t\t}\n \n \t\tcontext.getMetadataCollector().addEntityBinding( persistentClass );\n \n \t\t//Process secondary tables and complementary definitions (ie o.h.a.Table)\n \t\tcontext.getMetadataCollector().addSecondPass(\n \t\t\t\tnew SecondaryTableSecondPass(\n \t\t\t\t\t\tentityBinder,\n \t\t\t\t\t\tpropertyHolder,\n \t\t\t\t\t\tclazzToProcess\n \t\t\t\t)\n \t\t);\n \n \t\t//add process complementary Table definition (index & all)\n \t\tentityBinder.processComplementaryTableDefinitions( clazzToProcess.getAnnotation( org.hibernate.annotations.Table.class ) );\n \t\tentityBinder.processComplementaryTableDefinitions( clazzToProcess.getAnnotation( org.hibernate.annotations.Tables.class ) );\n \t\tentityBinder.processComplementaryTableDefinitions( tabAnn );\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"9e063ffa2577f06d98a9e912bb16d20424df8d6d": {
			"type": "Ybodychange",
			"commitMessage": "HHH-9837 - Remove reliance during annotation binding on org.hibernate.internal.util.ClassLoaderHelper\nHHH-9841 - Redesign org.hibernate.property.PropertyAccessorFactory\n",
			"commitDate": "2015-06-04, 12:12 PM",
			"commitName": "9e063ffa2577f06d98a9e912bb16d20424df8d6d",
			"commitAuthor": "Steve Ebersole",
			"commitDateOld": "2015-05-18, 9:25 PM",
			"commitNameOld": "bd256e4783219f4a765219cf625bb658fcb5fde1",
			"commitAuthorOld": "Steve Ebersole",
			"daysBetweenCommits": 16.62,
			"commitsBetweenForRepo": 39,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,285 +1,285 @@\n \tpublic static void bindClass(\n \t\t\tXClass clazzToProcess,\n \t\t\tMap<XClass, InheritanceState> inheritanceStatePerClass,\n \t\t\tMetadataBuildingContext context) throws MappingException {\n \t\t//@Entity and @MappedSuperclass on the same class leads to a NPE down the road\n \t\tif ( clazzToProcess.isAnnotationPresent( Entity.class )\n \t\t\t\t&&  clazzToProcess.isAnnotationPresent( MappedSuperclass.class ) ) {\n \t\t\tthrow new AnnotationException( \"An entity cannot be annotated with both @Entity and @MappedSuperclass: \"\n \t\t\t\t\t+ clazzToProcess.getName() );\n \t\t}\n \n \t\t//TODO: be more strict with secondarytable allowance (not for ids, not for secondary table join columns etc)\n \t\tInheritanceState inheritanceState = inheritanceStatePerClass.get( clazzToProcess );\n \t\tAnnotatedClassType classType = context.getMetadataCollector().getClassType( clazzToProcess );\n \n \t\t//Queries declared in MappedSuperclass should be usable in Subclasses\n \t\tif ( AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals( classType ) ) {\n \t\t\tbindQueries( clazzToProcess, context );\n \t\t\tbindTypeDefs( clazzToProcess, context );\n \t\t\tbindFilterDefs( clazzToProcess, context );\n \t\t}\n \n \t\tif ( !isEntityClassType( clazzToProcess, classType ) ) {\n \t\t\treturn;\n \t\t}\n \n \t\tif ( LOG.isDebugEnabled() ) {\n \t\t\tLOG.debugf( \"Binding entity from annotated class: %s\", clazzToProcess.getName() );\n \t\t}\n \n \t\tPersistentClass superEntity = getSuperEntity(\n \t\t\t\tclazzToProcess,\n \t\t\t\tinheritanceStatePerClass,\n \t\t\t\tcontext,\n \t\t\t\tinheritanceState\n \t\t);\n \n-\t\tPersistentClass persistentClass = makePersistentClass( inheritanceState, superEntity );\n+\t\tPersistentClass persistentClass = makePersistentClass( inheritanceState, superEntity, context );\n \t\tEntity entityAnn = clazzToProcess.getAnnotation( Entity.class );\n \t\torg.hibernate.annotations.Entity hibEntityAnn = clazzToProcess.getAnnotation(\n \t\t\t\torg.hibernate.annotations.Entity.class\n \t\t);\n \t\tEntityBinder entityBinder = new EntityBinder(\n \t\t\t\tentityAnn,\n \t\t\t\thibEntityAnn,\n \t\t\t\tclazzToProcess,\n \t\t\t\tpersistentClass,\n \t\t\t\tcontext\n \t\t);\n \t\tentityBinder.setInheritanceState( inheritanceState );\n \n \t\tbindQueries( clazzToProcess, context );\n \t\tbindFilterDefs( clazzToProcess, context );\n \t\tbindTypeDefs( clazzToProcess, context );\n \t\tbindFetchProfiles( clazzToProcess, context );\n \t\tBinderHelper.bindAnyMetaDefs( clazzToProcess, context );\n \n \t\tString schema = \"\";\n \t\tString table = \"\"; //might be no @Table annotation on the annotated class\n \t\tString catalog = \"\";\n \t\tList<UniqueConstraintHolder> uniqueConstraints = new ArrayList<UniqueConstraintHolder>();\n \t\tjavax.persistence.Table tabAnn = null;\n \t\tif ( clazzToProcess.isAnnotationPresent( javax.persistence.Table.class ) ) {\n \t\t\ttabAnn = clazzToProcess.getAnnotation( javax.persistence.Table.class );\n \t\t\ttable = tabAnn.name();\n \t\t\tschema = tabAnn.schema();\n \t\t\tcatalog = tabAnn.catalog();\n \t\t\tuniqueConstraints = TableBinder.buildUniqueConstraintHolders( tabAnn.uniqueConstraints() );\n \t\t}\n \n \t\tEjb3JoinColumn[] inheritanceJoinedColumns = makeInheritanceJoinColumns(\n \t\t\t\tclazzToProcess,\n \t\t\t\tcontext,\n \t\t\t\tinheritanceState,\n \t\t\t\tsuperEntity\n \t\t);\n \n \t\tfinal Ejb3DiscriminatorColumn discriminatorColumn;\n \t\tif ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.getType() ) ) {\n \t\t\tdiscriminatorColumn = processSingleTableDiscriminatorProperties(\n \t\t\t\t\tclazzToProcess,\n \t\t\t\t\tcontext,\n \t\t\t\t\tinheritanceState,\n \t\t\t\t\tentityBinder\n \t\t\t);\n \t\t}\n \t\telse if ( InheritanceType.JOINED.equals( inheritanceState.getType() ) ) {\n \t\t\tdiscriminatorColumn = processJoinedDiscriminatorProperties(\n \t\t\t\t\tclazzToProcess,\n \t\t\t\t\tcontext,\n \t\t\t\t\tinheritanceState,\n \t\t\t\t\tentityBinder\n \t\t\t);\n \t\t}\n \t\telse {\n \t\t\tdiscriminatorColumn = null;\n \t\t}\n \n \t\tentityBinder.setProxy( clazzToProcess.getAnnotation( Proxy.class ) );\n \t\tentityBinder.setBatchSize( clazzToProcess.getAnnotation( BatchSize.class ) );\n \t\tentityBinder.setWhere( clazzToProcess.getAnnotation( Where.class ) );\n \t    entityBinder.setCache( determineCacheSettings( clazzToProcess, context ) );\n \t    entityBinder.setNaturalIdCache( clazzToProcess, clazzToProcess.getAnnotation( NaturalIdCache.class ) );\n \n \t\tbindFilters( clazzToProcess, entityBinder, context );\n \n \t\tentityBinder.bindEntity();\n \n \t\tif ( inheritanceState.hasTable() ) {\n \t\t\tCheck checkAnn = clazzToProcess.getAnnotation( Check.class );\n \t\t\tString constraints = checkAnn == null\n \t\t\t\t\t? null\n \t\t\t\t\t: checkAnn.constraints();\n \n \t\t\tEntityTableXref denormalizedTableXref = inheritanceState.hasDenormalizedTable()\n \t\t\t\t\t? context.getMetadataCollector().getEntityTableXref( superEntity.getEntityName() )\n \t\t\t\t\t: null;\n \n \t\t\tentityBinder.bindTable(\n \t\t\t\t\tschema,\n \t\t\t\t\tcatalog,\n \t\t\t\t\ttable,\n \t\t\t\t\tuniqueConstraints,\n \t\t\t\t\tconstraints,\n \t\t\t\t\tdenormalizedTableXref\n \t\t\t);\n \t\t}\n \t\telse {\n \t\t\tif ( clazzToProcess.isAnnotationPresent( Table.class ) ) {\n \t\t\t\tLOG.invalidTableAnnotation( clazzToProcess.getName() );\n \t\t\t}\n \n \t\t\tif ( inheritanceState.getType() == InheritanceType.SINGLE_TABLE ) {\n \t\t\t\t// we at least need to properly set up the EntityTableXref\n \t\t\t\tentityBinder.bindTableForDiscriminatedSubclass(\n \t\t\t\t\t\tcontext.getMetadataCollector().getEntityTableXref( superEntity.getEntityName() )\n \t\t\t\t);\n \t\t\t}\n \t\t}\n \n \n \t\tPropertyHolder propertyHolder = PropertyHolderBuilder.buildPropertyHolder(\n \t\t\t\tclazzToProcess,\n \t\t\t\tpersistentClass,\n \t\t\t\tentityBinder,\n \t\t\t\tcontext,\n \t\t\t\tinheritanceStatePerClass\n \t\t);\n \n \t\tjavax.persistence.SecondaryTable secTabAnn = clazzToProcess.getAnnotation(\n \t\t\t\tjavax.persistence.SecondaryTable.class\n \t\t);\n \t\tjavax.persistence.SecondaryTables secTabsAnn = clazzToProcess.getAnnotation(\n \t\t\t\tjavax.persistence.SecondaryTables.class\n \t\t);\n \t\tentityBinder.firstLevelSecondaryTablesBinding( secTabAnn, secTabsAnn );\n \n \t\tOnDelete onDeleteAnn = clazzToProcess.getAnnotation( OnDelete.class );\n \t\tboolean onDeleteAppropriate = false;\n \n \t\t// todo : sucks that this is separate from RootClass distinction\n \t\tfinal boolean isInheritanceRoot = !inheritanceState.hasParents();\n \t\tfinal boolean hasSubclasses = inheritanceState.hasSiblings();\n \n \t\tif ( InheritanceType.JOINED.equals( inheritanceState.getType() ) ) {\n \t\t\tif ( inheritanceState.hasParents() ) {\n \t\t\t\tonDeleteAppropriate = true;\n \t\t\t\tfinal JoinedSubclass jsc = ( JoinedSubclass ) persistentClass;\n \t\t\t\tSimpleValue key = new DependantValue( context.getMetadataCollector(), jsc.getTable(), jsc.getIdentifier() );\n \t\t\t\tjsc.setKey( key );\n \t\t\t\tForeignKey fk = clazzToProcess.getAnnotation( ForeignKey.class );\n \t\t\t\tif ( fk != null && !BinderHelper.isEmptyAnnotationValue( fk.name() ) ) {\n \t\t\t\t\tkey.setForeignKeyName( fk.name() );\n \t\t\t\t}\n \t\t\t\tif ( onDeleteAnn != null ) {\n \t\t\t\t\tkey.setCascadeDeleteEnabled( OnDeleteAction.CASCADE.equals( onDeleteAnn.action() ) );\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tkey.setCascadeDeleteEnabled( false );\n \t\t\t\t}\n \t\t\t\t//we are never in a second pass at that stage, so queue it\n \t\t\t\tcontext.getMetadataCollector().addSecondPass( new JoinedSubclassFkSecondPass( jsc, inheritanceJoinedColumns, key, context ) );\n \t\t\t\tcontext.getMetadataCollector().addSecondPass( new CreateKeySecondPass( jsc ) );\n \t\t\t}\n \n \t\t\tif ( isInheritanceRoot ) {\n \t\t\t\t// the class we are processing is the root of the hierarchy, see if we had a discriminator column\n \t\t\t\t// (it is perfectly valid for joined subclasses to not have discriminators).\n \t\t\t\tif ( discriminatorColumn != null ) {\n \t\t\t\t\t// we have a discriminator column\n \t\t\t\t\tif ( hasSubclasses || !discriminatorColumn.isImplicit() ) {\n \t\t\t\t\t\tbindDiscriminatorColumnToRootPersistentClass(\n \t\t\t\t\t\t\t\t(RootClass) persistentClass,\n \t\t\t\t\t\t\t\tdiscriminatorColumn,\n \t\t\t\t\t\t\t\tentityBinder.getSecondaryTables(),\n \t\t\t\t\t\t\t\tpropertyHolder,\n \t\t\t\t\t\t\t\tcontext\n \t\t\t\t\t\t);\n \t\t\t\t\t\t//bind it again since the type might have changed\n \t\t\t\t\t\tentityBinder.bindDiscriminatorValue();\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\telse if ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.getType() ) ) {\n \t\t\tif ( isInheritanceRoot ) {\n \t\t\t\tif ( hasSubclasses || !discriminatorColumn.isImplicit() ) {\n \t\t\t\t\tbindDiscriminatorColumnToRootPersistentClass(\n \t\t\t\t\t\t\t(RootClass) persistentClass,\n \t\t\t\t\t\t\tdiscriminatorColumn,\n \t\t\t\t\t\t\tentityBinder.getSecondaryTables(),\n \t\t\t\t\t\t\tpropertyHolder,\n \t\t\t\t\t\t\tcontext\n \t\t\t\t\t);\n \t\t\t\t\t//bind it again since the type might have changed\n \t\t\t\t\tentityBinder.bindDiscriminatorValue();\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n         if ( onDeleteAnn != null && !onDeleteAppropriate ) {\n \t\t\tLOG.invalidOnDeleteAnnotation(propertyHolder.getEntityName());\n \t\t}\n \n \t\t// try to find class level generators\n \t\tHashMap<String, IdentifierGeneratorDefinition> classGenerators = buildLocalGenerators( clazzToProcess, context );\n \n \t\t// check properties\n \t\tfinal InheritanceState.ElementsToProcess elementsToProcess = inheritanceState.getElementsToProcess();\n \t\tinheritanceState.postProcess( persistentClass, entityBinder );\n \n \t\tfinal boolean subclassAndSingleTableStrategy = inheritanceState.getType() == InheritanceType.SINGLE_TABLE\n \t\t\t\t&& inheritanceState.hasParents();\n \t\tSet<String> idPropertiesIfIdClass = new HashSet<String>();\n \t\tboolean isIdClass = mapAsIdClass(\n \t\t\t\tinheritanceStatePerClass,\n \t\t\t\tinheritanceState,\n \t\t\t\tpersistentClass,\n \t\t\t\tentityBinder,\n \t\t\t\tpropertyHolder,\n \t\t\t\telementsToProcess,\n \t\t\t\tidPropertiesIfIdClass,\n \t\t\t\tcontext\n \t\t);\n \n \t\tif ( !isIdClass ) {\n \t\t\tentityBinder.setWrapIdsInEmbeddedComponents( elementsToProcess.getIdPropertyCount() > 1 );\n \t\t}\n \n \t\tprocessIdPropertiesIfNotAlready(\n \t\t\t\tinheritanceStatePerClass,\n \t\t\t\tcontext,\n \t\t\t\tpersistentClass,\n \t\t\t\tentityBinder,\n \t\t\t\tpropertyHolder,\n \t\t\t\tclassGenerators,\n \t\t\t\telementsToProcess,\n \t\t\t\tsubclassAndSingleTableStrategy,\n \t\t\t\tidPropertiesIfIdClass\n \t\t);\n \n \t\tif ( !inheritanceState.hasParents() ) {\n \t\t\tfinal RootClass rootClass = ( RootClass ) persistentClass;\n \t\t\tcontext.getMetadataCollector().addSecondPass( new CreateKeySecondPass( rootClass ) );\n \t\t}\n \t\telse {\n \t\t\tsuperEntity.addSubclass( ( Subclass ) persistentClass );\n \t\t}\n \n \t\tcontext.getMetadataCollector().addEntityBinding( persistentClass );\n \n \t\t//Process secondary tables and complementary definitions (ie o.h.a.Table)\n \t\tcontext.getMetadataCollector().addSecondPass(\n \t\t\t\tnew SecondaryTableSecondPass(\n \t\t\t\t\t\tentityBinder,\n \t\t\t\t\t\tpropertyHolder,\n \t\t\t\t\t\tclazzToProcess\n \t\t\t\t)\n \t\t);\n \n \t\t//add process complementary Table definition (index & all)\n \t\tentityBinder.processComplementaryTableDefinitions( clazzToProcess.getAnnotation( org.hibernate.annotations.Table.class ) );\n \t\tentityBinder.processComplementaryTableDefinitions( clazzToProcess.getAnnotation( org.hibernate.annotations.Tables.class ) );\n \t\tentityBinder.processComplementaryTableDefinitions( tabAnn );\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"9caca0ce37d5a2763d476c6fa2471addcca710ca": {
			"type": "Ymultichange(Yparameterchange,Ybodychange)",
			"commitMessage": "HHH-9490 - Migrate from dom4j to jaxb for XML processing;\nHHH-9492 - Migrate to new bootstrap API (MetadataSources, etc);\nHHH-7078 - Split NamingStrategy into ImplicitNamingStrategy/PhysicalNamingStrategy;\nHHH-6005 - Better handling of implicit column naming with @ElementCollection of @Embeddables;\nHHH-9633 - Add tests that explicitly test the \"main\" NamingStrategy impls\n",
			"commitDate": "2015-03-10, 2:53 PM",
			"commitName": "9caca0ce37d5a2763d476c6fa2471addcca710ca",
			"commitAuthor": "Steve Ebersole",
			"subchanges": [
				{
					"type": "Yparameterchange",
					"commitMessage": "HHH-9490 - Migrate from dom4j to jaxb for XML processing;\nHHH-9492 - Migrate to new bootstrap API (MetadataSources, etc);\nHHH-7078 - Split NamingStrategy into ImplicitNamingStrategy/PhysicalNamingStrategy;\nHHH-6005 - Better handling of implicit column naming with @ElementCollection of @Embeddables;\nHHH-9633 - Add tests that explicitly test the \"main\" NamingStrategy impls\n",
					"commitDate": "2015-03-10, 2:53 PM",
					"commitName": "9caca0ce37d5a2763d476c6fa2471addcca710ca",
					"commitAuthor": "Steve Ebersole",
					"commitDateOld": "2014-09-30, 7:40 AM",
					"commitNameOld": "83f29d1e1a3d0655d4f402636bc191ff05ad74ea",
					"commitAuthorOld": "Maxim Frolov",
					"daysBetweenCommits": 161.3,
					"commitsBetweenForRepo": 61,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,252 +1,285 @@\n \tpublic static void bindClass(\n \t\t\tXClass clazzToProcess,\n \t\t\tMap<XClass, InheritanceState> inheritanceStatePerClass,\n-\t\t\tMappings mappings) throws MappingException {\n+\t\t\tMetadataBuildingContext context) throws MappingException {\n \t\t//@Entity and @MappedSuperclass on the same class leads to a NPE down the road\n \t\tif ( clazzToProcess.isAnnotationPresent( Entity.class )\n \t\t\t\t&&  clazzToProcess.isAnnotationPresent( MappedSuperclass.class ) ) {\n \t\t\tthrow new AnnotationException( \"An entity cannot be annotated with both @Entity and @MappedSuperclass: \"\n \t\t\t\t\t+ clazzToProcess.getName() );\n \t\t}\n \n \t\t//TODO: be more strict with secondarytable allowance (not for ids, not for secondary table join columns etc)\n \t\tInheritanceState inheritanceState = inheritanceStatePerClass.get( clazzToProcess );\n-\t\tAnnotatedClassType classType = mappings.getClassType( clazzToProcess );\n+\t\tAnnotatedClassType classType = context.getMetadataCollector().getClassType( clazzToProcess );\n \n \t\t//Queries declared in MappedSuperclass should be usable in Subclasses\n \t\tif ( AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals( classType ) ) {\n-\t\t\tbindQueries( clazzToProcess, mappings );\n-\t\t\tbindTypeDefs( clazzToProcess, mappings );\n-\t\t\tbindFilterDefs( clazzToProcess, mappings );\n+\t\t\tbindQueries( clazzToProcess, context );\n+\t\t\tbindTypeDefs( clazzToProcess, context );\n+\t\t\tbindFilterDefs( clazzToProcess, context );\n \t\t}\n \n \t\tif ( !isEntityClassType( clazzToProcess, classType ) ) {\n \t\t\treturn;\n \t\t}\n \n \t\tif ( LOG.isDebugEnabled() ) {\n \t\t\tLOG.debugf( \"Binding entity from annotated class: %s\", clazzToProcess.getName() );\n \t\t}\n \n \t\tPersistentClass superEntity = getSuperEntity(\n-\t\t\t\tclazzToProcess, inheritanceStatePerClass, mappings, inheritanceState\n+\t\t\t\tclazzToProcess,\n+\t\t\t\tinheritanceStatePerClass,\n+\t\t\t\tcontext,\n+\t\t\t\tinheritanceState\n \t\t);\n \n \t\tPersistentClass persistentClass = makePersistentClass( inheritanceState, superEntity );\n \t\tEntity entityAnn = clazzToProcess.getAnnotation( Entity.class );\n \t\torg.hibernate.annotations.Entity hibEntityAnn = clazzToProcess.getAnnotation(\n \t\t\t\torg.hibernate.annotations.Entity.class\n \t\t);\n \t\tEntityBinder entityBinder = new EntityBinder(\n-\t\t\t\tentityAnn, hibEntityAnn, clazzToProcess, persistentClass, mappings\n+\t\t\t\tentityAnn,\n+\t\t\t\thibEntityAnn,\n+\t\t\t\tclazzToProcess,\n+\t\t\t\tpersistentClass,\n+\t\t\t\tcontext\n \t\t);\n \t\tentityBinder.setInheritanceState( inheritanceState );\n \n-\t\tbindQueries( clazzToProcess, mappings );\n-\t\tbindFilterDefs( clazzToProcess, mappings );\n-\t\tbindTypeDefs( clazzToProcess, mappings );\n-\t\tbindFetchProfiles( clazzToProcess, mappings );\n-\t\tBinderHelper.bindAnyMetaDefs( clazzToProcess, mappings );\n+\t\tbindQueries( clazzToProcess, context );\n+\t\tbindFilterDefs( clazzToProcess, context );\n+\t\tbindTypeDefs( clazzToProcess, context );\n+\t\tbindFetchProfiles( clazzToProcess, context );\n+\t\tBinderHelper.bindAnyMetaDefs( clazzToProcess, context );\n \n \t\tString schema = \"\";\n \t\tString table = \"\"; //might be no @Table annotation on the annotated class\n \t\tString catalog = \"\";\n \t\tList<UniqueConstraintHolder> uniqueConstraints = new ArrayList<UniqueConstraintHolder>();\n \t\tjavax.persistence.Table tabAnn = null;\n \t\tif ( clazzToProcess.isAnnotationPresent( javax.persistence.Table.class ) ) {\n \t\t\ttabAnn = clazzToProcess.getAnnotation( javax.persistence.Table.class );\n \t\t\ttable = tabAnn.name();\n \t\t\tschema = tabAnn.schema();\n \t\t\tcatalog = tabAnn.catalog();\n \t\t\tuniqueConstraints = TableBinder.buildUniqueConstraintHolders( tabAnn.uniqueConstraints() );\n \t\t}\n \n \t\tEjb3JoinColumn[] inheritanceJoinedColumns = makeInheritanceJoinColumns(\n-\t\t\t\tclazzToProcess, mappings, inheritanceState, superEntity\n+\t\t\t\tclazzToProcess,\n+\t\t\t\tcontext,\n+\t\t\t\tinheritanceState,\n+\t\t\t\tsuperEntity\n \t\t);\n \n \t\tfinal Ejb3DiscriminatorColumn discriminatorColumn;\n \t\tif ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.getType() ) ) {\n \t\t\tdiscriminatorColumn = processSingleTableDiscriminatorProperties(\n \t\t\t\t\tclazzToProcess,\n-\t\t\t\t\tmappings,\n+\t\t\t\t\tcontext,\n \t\t\t\t\tinheritanceState,\n \t\t\t\t\tentityBinder\n \t\t\t);\n \t\t}\n \t\telse if ( InheritanceType.JOINED.equals( inheritanceState.getType() ) ) {\n \t\t\tdiscriminatorColumn = processJoinedDiscriminatorProperties(\n \t\t\t\t\tclazzToProcess,\n-\t\t\t\t\tmappings,\n+\t\t\t\t\tcontext,\n \t\t\t\t\tinheritanceState,\n \t\t\t\t\tentityBinder\n \t\t\t);\n \t\t}\n \t\telse {\n \t\t\tdiscriminatorColumn = null;\n \t\t}\n \n \t\tentityBinder.setProxy( clazzToProcess.getAnnotation( Proxy.class ) );\n \t\tentityBinder.setBatchSize( clazzToProcess.getAnnotation( BatchSize.class ) );\n \t\tentityBinder.setWhere( clazzToProcess.getAnnotation( Where.class ) );\n-\t    entityBinder.setCache( determineCacheSettings( clazzToProcess, mappings ) );\n+\t    entityBinder.setCache( determineCacheSettings( clazzToProcess, context ) );\n \t    entityBinder.setNaturalIdCache( clazzToProcess, clazzToProcess.getAnnotation( NaturalIdCache.class ) );\n \n-\t\tbindFilters( clazzToProcess, entityBinder, mappings );\n+\t\tbindFilters( clazzToProcess, entityBinder, context );\n \n \t\tentityBinder.bindEntity();\n \n \t\tif ( inheritanceState.hasTable() ) {\n \t\t\tCheck checkAnn = clazzToProcess.getAnnotation( Check.class );\n-\t\t\tString constraints = checkAnn == null ?\n-\t\t\t\t\tnull :\n-\t\t\t\t\tcheckAnn.constraints();\n+\t\t\tString constraints = checkAnn == null\n+\t\t\t\t\t? null\n+\t\t\t\t\t: checkAnn.constraints();\n+\n+\t\t\tEntityTableXref denormalizedTableXref = inheritanceState.hasDenormalizedTable()\n+\t\t\t\t\t? context.getMetadataCollector().getEntityTableXref( superEntity.getEntityName() )\n+\t\t\t\t\t: null;\n+\n \t\t\tentityBinder.bindTable(\n-\t\t\t\t\tschema, catalog, table, uniqueConstraints,\n-\t\t\t\t\tconstraints, inheritanceState.hasDenormalizedTable() ?\n-\t\t\t\t\t\t\tsuperEntity.getTable() :\n-\t\t\t\t\t\t\tnull\n+\t\t\t\t\tschema,\n+\t\t\t\t\tcatalog,\n+\t\t\t\t\ttable,\n+\t\t\t\t\tuniqueConstraints,\n+\t\t\t\t\tconstraints,\n+\t\t\t\t\tdenormalizedTableXref\n \t\t\t);\n \t\t}\n-\t\telse if ( clazzToProcess.isAnnotationPresent( Table.class ) ) {\n-\t\t\tLOG.invalidTableAnnotation( clazzToProcess.getName() );\n+\t\telse {\n+\t\t\tif ( clazzToProcess.isAnnotationPresent( Table.class ) ) {\n+\t\t\t\tLOG.invalidTableAnnotation( clazzToProcess.getName() );\n+\t\t\t}\n+\n+\t\t\tif ( inheritanceState.getType() == InheritanceType.SINGLE_TABLE ) {\n+\t\t\t\t// we at least need to properly set up the EntityTableXref\n+\t\t\t\tentityBinder.bindTableForDiscriminatedSubclass(\n+\t\t\t\t\t\tcontext.getMetadataCollector().getEntityTableXref( superEntity.getEntityName() )\n+\t\t\t\t);\n+\t\t\t}\n \t\t}\n \n \n \t\tPropertyHolder propertyHolder = PropertyHolderBuilder.buildPropertyHolder(\n \t\t\t\tclazzToProcess,\n \t\t\t\tpersistentClass,\n-\t\t\t\tentityBinder, mappings, inheritanceStatePerClass\n+\t\t\t\tentityBinder,\n+\t\t\t\tcontext,\n+\t\t\t\tinheritanceStatePerClass\n \t\t);\n \n \t\tjavax.persistence.SecondaryTable secTabAnn = clazzToProcess.getAnnotation(\n \t\t\t\tjavax.persistence.SecondaryTable.class\n \t\t);\n \t\tjavax.persistence.SecondaryTables secTabsAnn = clazzToProcess.getAnnotation(\n \t\t\t\tjavax.persistence.SecondaryTables.class\n \t\t);\n \t\tentityBinder.firstLevelSecondaryTablesBinding( secTabAnn, secTabsAnn );\n \n \t\tOnDelete onDeleteAnn = clazzToProcess.getAnnotation( OnDelete.class );\n \t\tboolean onDeleteAppropriate = false;\n \n \t\t// todo : sucks that this is separate from RootClass distinction\n \t\tfinal boolean isInheritanceRoot = !inheritanceState.hasParents();\n \t\tfinal boolean hasSubclasses = inheritanceState.hasSiblings();\n \n \t\tif ( InheritanceType.JOINED.equals( inheritanceState.getType() ) ) {\n \t\t\tif ( inheritanceState.hasParents() ) {\n \t\t\t\tonDeleteAppropriate = true;\n \t\t\t\tfinal JoinedSubclass jsc = ( JoinedSubclass ) persistentClass;\n-\t\t\t\tSimpleValue key = new DependantValue( mappings, jsc.getTable(), jsc.getIdentifier() );\n+\t\t\t\tSimpleValue key = new DependantValue( context.getMetadataCollector(), jsc.getTable(), jsc.getIdentifier() );\n \t\t\t\tjsc.setKey( key );\n \t\t\t\tForeignKey fk = clazzToProcess.getAnnotation( ForeignKey.class );\n \t\t\t\tif ( fk != null && !BinderHelper.isEmptyAnnotationValue( fk.name() ) ) {\n \t\t\t\t\tkey.setForeignKeyName( fk.name() );\n \t\t\t\t}\n \t\t\t\tif ( onDeleteAnn != null ) {\n \t\t\t\t\tkey.setCascadeDeleteEnabled( OnDeleteAction.CASCADE.equals( onDeleteAnn.action() ) );\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tkey.setCascadeDeleteEnabled( false );\n \t\t\t\t}\n \t\t\t\t//we are never in a second pass at that stage, so queue it\n-\t\t\t\tSecondPass sp = new JoinedSubclassFkSecondPass( jsc, inheritanceJoinedColumns, key, mappings );\n-\t\t\t\tmappings.addSecondPass( sp );\n-\t\t\t\tmappings.addSecondPass( new CreateKeySecondPass( jsc ) );\n+\t\t\t\tcontext.getMetadataCollector().addSecondPass( new JoinedSubclassFkSecondPass( jsc, inheritanceJoinedColumns, key, context ) );\n+\t\t\t\tcontext.getMetadataCollector().addSecondPass( new CreateKeySecondPass( jsc ) );\n \t\t\t}\n \n \t\t\tif ( isInheritanceRoot ) {\n \t\t\t\t// the class we are processing is the root of the hierarchy, see if we had a discriminator column\n \t\t\t\t// (it is perfectly valid for joined subclasses to not have discriminators).\n \t\t\t\tif ( discriminatorColumn != null ) {\n \t\t\t\t\t// we have a discriminator column\n \t\t\t\t\tif ( hasSubclasses || !discriminatorColumn.isImplicit() ) {\n \t\t\t\t\t\tbindDiscriminatorColumnToRootPersistentClass(\n \t\t\t\t\t\t\t\t(RootClass) persistentClass,\n \t\t\t\t\t\t\t\tdiscriminatorColumn,\n \t\t\t\t\t\t\t\tentityBinder.getSecondaryTables(),\n \t\t\t\t\t\t\t\tpropertyHolder,\n-\t\t\t\t\t\t\t\tmappings\n+\t\t\t\t\t\t\t\tcontext\n \t\t\t\t\t\t);\n \t\t\t\t\t\t//bind it again since the type might have changed\n \t\t\t\t\t\tentityBinder.bindDiscriminatorValue();\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\telse if ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.getType() ) ) {\n \t\t\tif ( isInheritanceRoot ) {\n \t\t\t\tif ( hasSubclasses || !discriminatorColumn.isImplicit() ) {\n \t\t\t\t\tbindDiscriminatorColumnToRootPersistentClass(\n \t\t\t\t\t\t\t(RootClass) persistentClass,\n \t\t\t\t\t\t\tdiscriminatorColumn,\n \t\t\t\t\t\t\tentityBinder.getSecondaryTables(),\n \t\t\t\t\t\t\tpropertyHolder,\n-\t\t\t\t\t\t\tmappings\n+\t\t\t\t\t\t\tcontext\n \t\t\t\t\t);\n \t\t\t\t\t//bind it again since the type might have changed\n \t\t\t\t\tentityBinder.bindDiscriminatorValue();\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n         if ( onDeleteAnn != null && !onDeleteAppropriate ) {\n \t\t\tLOG.invalidOnDeleteAnnotation(propertyHolder.getEntityName());\n \t\t}\n \n \t\t// try to find class level generators\n-\t\tHashMap<String, IdGenerator> classGenerators = buildLocalGenerators( clazzToProcess, mappings );\n+\t\tHashMap<String, IdentifierGeneratorDefinition> classGenerators = buildLocalGenerators( clazzToProcess, context );\n \n \t\t// check properties\n \t\tfinal InheritanceState.ElementsToProcess elementsToProcess = inheritanceState.getElementsToProcess();\n \t\tinheritanceState.postProcess( persistentClass, entityBinder );\n \n \t\tfinal boolean subclassAndSingleTableStrategy = inheritanceState.getType() == InheritanceType.SINGLE_TABLE\n \t\t\t\t&& inheritanceState.hasParents();\n \t\tSet<String> idPropertiesIfIdClass = new HashSet<String>();\n \t\tboolean isIdClass = mapAsIdClass(\n \t\t\t\tinheritanceStatePerClass,\n \t\t\t\tinheritanceState,\n \t\t\t\tpersistentClass,\n \t\t\t\tentityBinder,\n \t\t\t\tpropertyHolder,\n \t\t\t\telementsToProcess,\n \t\t\t\tidPropertiesIfIdClass,\n-\t\t\t\tmappings\n+\t\t\t\tcontext\n \t\t);\n \n \t\tif ( !isIdClass ) {\n \t\t\tentityBinder.setWrapIdsInEmbeddedComponents( elementsToProcess.getIdPropertyCount() > 1 );\n \t\t}\n \n \t\tprocessIdPropertiesIfNotAlready(\n \t\t\t\tinheritanceStatePerClass,\n-\t\t\t\tmappings,\n+\t\t\t\tcontext,\n \t\t\t\tpersistentClass,\n \t\t\t\tentityBinder,\n \t\t\t\tpropertyHolder,\n \t\t\t\tclassGenerators,\n \t\t\t\telementsToProcess,\n \t\t\t\tsubclassAndSingleTableStrategy,\n \t\t\t\tidPropertiesIfIdClass\n \t\t);\n \n \t\tif ( !inheritanceState.hasParents() ) {\n \t\t\tfinal RootClass rootClass = ( RootClass ) persistentClass;\n-\t\t\tmappings.addSecondPass( new CreateKeySecondPass( rootClass ) );\n+\t\t\tcontext.getMetadataCollector().addSecondPass( new CreateKeySecondPass( rootClass ) );\n \t\t}\n \t\telse {\n \t\t\tsuperEntity.addSubclass( ( Subclass ) persistentClass );\n \t\t}\n \n-\t\tmappings.addClass( persistentClass );\n+\t\tcontext.getMetadataCollector().addEntityBinding( persistentClass );\n \n \t\t//Process secondary tables and complementary definitions (ie o.h.a.Table)\n-\t\tmappings.addSecondPass( new SecondaryTableSecondPass( entityBinder, propertyHolder, clazzToProcess ) );\n+\t\tcontext.getMetadataCollector().addSecondPass(\n+\t\t\t\tnew SecondaryTableSecondPass(\n+\t\t\t\t\t\tentityBinder,\n+\t\t\t\t\t\tpropertyHolder,\n+\t\t\t\t\t\tclazzToProcess\n+\t\t\t\t)\n+\t\t);\n \n \t\t//add process complementary Table definition (index & all)\n \t\tentityBinder.processComplementaryTableDefinitions( clazzToProcess.getAnnotation( org.hibernate.annotations.Table.class ) );\n \t\tentityBinder.processComplementaryTableDefinitions( clazzToProcess.getAnnotation( org.hibernate.annotations.Tables.class ) );\n \t\tentityBinder.processComplementaryTableDefinitions( tabAnn );\n \t}\n\\ No newline at end of file\n",
					"extendedDetails": {
						"oldValue": "[clazzToProcess-XClass, inheritanceStatePerClass-Map<XClass,InheritanceState>, mappings-Mappings]",
						"newValue": "[clazzToProcess-XClass, inheritanceStatePerClass-Map<XClass,InheritanceState>, context-MetadataBuildingContext]"
					}
				},
				{
					"type": "Ybodychange",
					"commitMessage": "HHH-9490 - Migrate from dom4j to jaxb for XML processing;\nHHH-9492 - Migrate to new bootstrap API (MetadataSources, etc);\nHHH-7078 - Split NamingStrategy into ImplicitNamingStrategy/PhysicalNamingStrategy;\nHHH-6005 - Better handling of implicit column naming with @ElementCollection of @Embeddables;\nHHH-9633 - Add tests that explicitly test the \"main\" NamingStrategy impls\n",
					"commitDate": "2015-03-10, 2:53 PM",
					"commitName": "9caca0ce37d5a2763d476c6fa2471addcca710ca",
					"commitAuthor": "Steve Ebersole",
					"commitDateOld": "2014-09-30, 7:40 AM",
					"commitNameOld": "83f29d1e1a3d0655d4f402636bc191ff05ad74ea",
					"commitAuthorOld": "Maxim Frolov",
					"daysBetweenCommits": 161.3,
					"commitsBetweenForRepo": 61,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,252 +1,285 @@\n \tpublic static void bindClass(\n \t\t\tXClass clazzToProcess,\n \t\t\tMap<XClass, InheritanceState> inheritanceStatePerClass,\n-\t\t\tMappings mappings) throws MappingException {\n+\t\t\tMetadataBuildingContext context) throws MappingException {\n \t\t//@Entity and @MappedSuperclass on the same class leads to a NPE down the road\n \t\tif ( clazzToProcess.isAnnotationPresent( Entity.class )\n \t\t\t\t&&  clazzToProcess.isAnnotationPresent( MappedSuperclass.class ) ) {\n \t\t\tthrow new AnnotationException( \"An entity cannot be annotated with both @Entity and @MappedSuperclass: \"\n \t\t\t\t\t+ clazzToProcess.getName() );\n \t\t}\n \n \t\t//TODO: be more strict with secondarytable allowance (not for ids, not for secondary table join columns etc)\n \t\tInheritanceState inheritanceState = inheritanceStatePerClass.get( clazzToProcess );\n-\t\tAnnotatedClassType classType = mappings.getClassType( clazzToProcess );\n+\t\tAnnotatedClassType classType = context.getMetadataCollector().getClassType( clazzToProcess );\n \n \t\t//Queries declared in MappedSuperclass should be usable in Subclasses\n \t\tif ( AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals( classType ) ) {\n-\t\t\tbindQueries( clazzToProcess, mappings );\n-\t\t\tbindTypeDefs( clazzToProcess, mappings );\n-\t\t\tbindFilterDefs( clazzToProcess, mappings );\n+\t\t\tbindQueries( clazzToProcess, context );\n+\t\t\tbindTypeDefs( clazzToProcess, context );\n+\t\t\tbindFilterDefs( clazzToProcess, context );\n \t\t}\n \n \t\tif ( !isEntityClassType( clazzToProcess, classType ) ) {\n \t\t\treturn;\n \t\t}\n \n \t\tif ( LOG.isDebugEnabled() ) {\n \t\t\tLOG.debugf( \"Binding entity from annotated class: %s\", clazzToProcess.getName() );\n \t\t}\n \n \t\tPersistentClass superEntity = getSuperEntity(\n-\t\t\t\tclazzToProcess, inheritanceStatePerClass, mappings, inheritanceState\n+\t\t\t\tclazzToProcess,\n+\t\t\t\tinheritanceStatePerClass,\n+\t\t\t\tcontext,\n+\t\t\t\tinheritanceState\n \t\t);\n \n \t\tPersistentClass persistentClass = makePersistentClass( inheritanceState, superEntity );\n \t\tEntity entityAnn = clazzToProcess.getAnnotation( Entity.class );\n \t\torg.hibernate.annotations.Entity hibEntityAnn = clazzToProcess.getAnnotation(\n \t\t\t\torg.hibernate.annotations.Entity.class\n \t\t);\n \t\tEntityBinder entityBinder = new EntityBinder(\n-\t\t\t\tentityAnn, hibEntityAnn, clazzToProcess, persistentClass, mappings\n+\t\t\t\tentityAnn,\n+\t\t\t\thibEntityAnn,\n+\t\t\t\tclazzToProcess,\n+\t\t\t\tpersistentClass,\n+\t\t\t\tcontext\n \t\t);\n \t\tentityBinder.setInheritanceState( inheritanceState );\n \n-\t\tbindQueries( clazzToProcess, mappings );\n-\t\tbindFilterDefs( clazzToProcess, mappings );\n-\t\tbindTypeDefs( clazzToProcess, mappings );\n-\t\tbindFetchProfiles( clazzToProcess, mappings );\n-\t\tBinderHelper.bindAnyMetaDefs( clazzToProcess, mappings );\n+\t\tbindQueries( clazzToProcess, context );\n+\t\tbindFilterDefs( clazzToProcess, context );\n+\t\tbindTypeDefs( clazzToProcess, context );\n+\t\tbindFetchProfiles( clazzToProcess, context );\n+\t\tBinderHelper.bindAnyMetaDefs( clazzToProcess, context );\n \n \t\tString schema = \"\";\n \t\tString table = \"\"; //might be no @Table annotation on the annotated class\n \t\tString catalog = \"\";\n \t\tList<UniqueConstraintHolder> uniqueConstraints = new ArrayList<UniqueConstraintHolder>();\n \t\tjavax.persistence.Table tabAnn = null;\n \t\tif ( clazzToProcess.isAnnotationPresent( javax.persistence.Table.class ) ) {\n \t\t\ttabAnn = clazzToProcess.getAnnotation( javax.persistence.Table.class );\n \t\t\ttable = tabAnn.name();\n \t\t\tschema = tabAnn.schema();\n \t\t\tcatalog = tabAnn.catalog();\n \t\t\tuniqueConstraints = TableBinder.buildUniqueConstraintHolders( tabAnn.uniqueConstraints() );\n \t\t}\n \n \t\tEjb3JoinColumn[] inheritanceJoinedColumns = makeInheritanceJoinColumns(\n-\t\t\t\tclazzToProcess, mappings, inheritanceState, superEntity\n+\t\t\t\tclazzToProcess,\n+\t\t\t\tcontext,\n+\t\t\t\tinheritanceState,\n+\t\t\t\tsuperEntity\n \t\t);\n \n \t\tfinal Ejb3DiscriminatorColumn discriminatorColumn;\n \t\tif ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.getType() ) ) {\n \t\t\tdiscriminatorColumn = processSingleTableDiscriminatorProperties(\n \t\t\t\t\tclazzToProcess,\n-\t\t\t\t\tmappings,\n+\t\t\t\t\tcontext,\n \t\t\t\t\tinheritanceState,\n \t\t\t\t\tentityBinder\n \t\t\t);\n \t\t}\n \t\telse if ( InheritanceType.JOINED.equals( inheritanceState.getType() ) ) {\n \t\t\tdiscriminatorColumn = processJoinedDiscriminatorProperties(\n \t\t\t\t\tclazzToProcess,\n-\t\t\t\t\tmappings,\n+\t\t\t\t\tcontext,\n \t\t\t\t\tinheritanceState,\n \t\t\t\t\tentityBinder\n \t\t\t);\n \t\t}\n \t\telse {\n \t\t\tdiscriminatorColumn = null;\n \t\t}\n \n \t\tentityBinder.setProxy( clazzToProcess.getAnnotation( Proxy.class ) );\n \t\tentityBinder.setBatchSize( clazzToProcess.getAnnotation( BatchSize.class ) );\n \t\tentityBinder.setWhere( clazzToProcess.getAnnotation( Where.class ) );\n-\t    entityBinder.setCache( determineCacheSettings( clazzToProcess, mappings ) );\n+\t    entityBinder.setCache( determineCacheSettings( clazzToProcess, context ) );\n \t    entityBinder.setNaturalIdCache( clazzToProcess, clazzToProcess.getAnnotation( NaturalIdCache.class ) );\n \n-\t\tbindFilters( clazzToProcess, entityBinder, mappings );\n+\t\tbindFilters( clazzToProcess, entityBinder, context );\n \n \t\tentityBinder.bindEntity();\n \n \t\tif ( inheritanceState.hasTable() ) {\n \t\t\tCheck checkAnn = clazzToProcess.getAnnotation( Check.class );\n-\t\t\tString constraints = checkAnn == null ?\n-\t\t\t\t\tnull :\n-\t\t\t\t\tcheckAnn.constraints();\n+\t\t\tString constraints = checkAnn == null\n+\t\t\t\t\t? null\n+\t\t\t\t\t: checkAnn.constraints();\n+\n+\t\t\tEntityTableXref denormalizedTableXref = inheritanceState.hasDenormalizedTable()\n+\t\t\t\t\t? context.getMetadataCollector().getEntityTableXref( superEntity.getEntityName() )\n+\t\t\t\t\t: null;\n+\n \t\t\tentityBinder.bindTable(\n-\t\t\t\t\tschema, catalog, table, uniqueConstraints,\n-\t\t\t\t\tconstraints, inheritanceState.hasDenormalizedTable() ?\n-\t\t\t\t\t\t\tsuperEntity.getTable() :\n-\t\t\t\t\t\t\tnull\n+\t\t\t\t\tschema,\n+\t\t\t\t\tcatalog,\n+\t\t\t\t\ttable,\n+\t\t\t\t\tuniqueConstraints,\n+\t\t\t\t\tconstraints,\n+\t\t\t\t\tdenormalizedTableXref\n \t\t\t);\n \t\t}\n-\t\telse if ( clazzToProcess.isAnnotationPresent( Table.class ) ) {\n-\t\t\tLOG.invalidTableAnnotation( clazzToProcess.getName() );\n+\t\telse {\n+\t\t\tif ( clazzToProcess.isAnnotationPresent( Table.class ) ) {\n+\t\t\t\tLOG.invalidTableAnnotation( clazzToProcess.getName() );\n+\t\t\t}\n+\n+\t\t\tif ( inheritanceState.getType() == InheritanceType.SINGLE_TABLE ) {\n+\t\t\t\t// we at least need to properly set up the EntityTableXref\n+\t\t\t\tentityBinder.bindTableForDiscriminatedSubclass(\n+\t\t\t\t\t\tcontext.getMetadataCollector().getEntityTableXref( superEntity.getEntityName() )\n+\t\t\t\t);\n+\t\t\t}\n \t\t}\n \n \n \t\tPropertyHolder propertyHolder = PropertyHolderBuilder.buildPropertyHolder(\n \t\t\t\tclazzToProcess,\n \t\t\t\tpersistentClass,\n-\t\t\t\tentityBinder, mappings, inheritanceStatePerClass\n+\t\t\t\tentityBinder,\n+\t\t\t\tcontext,\n+\t\t\t\tinheritanceStatePerClass\n \t\t);\n \n \t\tjavax.persistence.SecondaryTable secTabAnn = clazzToProcess.getAnnotation(\n \t\t\t\tjavax.persistence.SecondaryTable.class\n \t\t);\n \t\tjavax.persistence.SecondaryTables secTabsAnn = clazzToProcess.getAnnotation(\n \t\t\t\tjavax.persistence.SecondaryTables.class\n \t\t);\n \t\tentityBinder.firstLevelSecondaryTablesBinding( secTabAnn, secTabsAnn );\n \n \t\tOnDelete onDeleteAnn = clazzToProcess.getAnnotation( OnDelete.class );\n \t\tboolean onDeleteAppropriate = false;\n \n \t\t// todo : sucks that this is separate from RootClass distinction\n \t\tfinal boolean isInheritanceRoot = !inheritanceState.hasParents();\n \t\tfinal boolean hasSubclasses = inheritanceState.hasSiblings();\n \n \t\tif ( InheritanceType.JOINED.equals( inheritanceState.getType() ) ) {\n \t\t\tif ( inheritanceState.hasParents() ) {\n \t\t\t\tonDeleteAppropriate = true;\n \t\t\t\tfinal JoinedSubclass jsc = ( JoinedSubclass ) persistentClass;\n-\t\t\t\tSimpleValue key = new DependantValue( mappings, jsc.getTable(), jsc.getIdentifier() );\n+\t\t\t\tSimpleValue key = new DependantValue( context.getMetadataCollector(), jsc.getTable(), jsc.getIdentifier() );\n \t\t\t\tjsc.setKey( key );\n \t\t\t\tForeignKey fk = clazzToProcess.getAnnotation( ForeignKey.class );\n \t\t\t\tif ( fk != null && !BinderHelper.isEmptyAnnotationValue( fk.name() ) ) {\n \t\t\t\t\tkey.setForeignKeyName( fk.name() );\n \t\t\t\t}\n \t\t\t\tif ( onDeleteAnn != null ) {\n \t\t\t\t\tkey.setCascadeDeleteEnabled( OnDeleteAction.CASCADE.equals( onDeleteAnn.action() ) );\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tkey.setCascadeDeleteEnabled( false );\n \t\t\t\t}\n \t\t\t\t//we are never in a second pass at that stage, so queue it\n-\t\t\t\tSecondPass sp = new JoinedSubclassFkSecondPass( jsc, inheritanceJoinedColumns, key, mappings );\n-\t\t\t\tmappings.addSecondPass( sp );\n-\t\t\t\tmappings.addSecondPass( new CreateKeySecondPass( jsc ) );\n+\t\t\t\tcontext.getMetadataCollector().addSecondPass( new JoinedSubclassFkSecondPass( jsc, inheritanceJoinedColumns, key, context ) );\n+\t\t\t\tcontext.getMetadataCollector().addSecondPass( new CreateKeySecondPass( jsc ) );\n \t\t\t}\n \n \t\t\tif ( isInheritanceRoot ) {\n \t\t\t\t// the class we are processing is the root of the hierarchy, see if we had a discriminator column\n \t\t\t\t// (it is perfectly valid for joined subclasses to not have discriminators).\n \t\t\t\tif ( discriminatorColumn != null ) {\n \t\t\t\t\t// we have a discriminator column\n \t\t\t\t\tif ( hasSubclasses || !discriminatorColumn.isImplicit() ) {\n \t\t\t\t\t\tbindDiscriminatorColumnToRootPersistentClass(\n \t\t\t\t\t\t\t\t(RootClass) persistentClass,\n \t\t\t\t\t\t\t\tdiscriminatorColumn,\n \t\t\t\t\t\t\t\tentityBinder.getSecondaryTables(),\n \t\t\t\t\t\t\t\tpropertyHolder,\n-\t\t\t\t\t\t\t\tmappings\n+\t\t\t\t\t\t\t\tcontext\n \t\t\t\t\t\t);\n \t\t\t\t\t\t//bind it again since the type might have changed\n \t\t\t\t\t\tentityBinder.bindDiscriminatorValue();\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\telse if ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.getType() ) ) {\n \t\t\tif ( isInheritanceRoot ) {\n \t\t\t\tif ( hasSubclasses || !discriminatorColumn.isImplicit() ) {\n \t\t\t\t\tbindDiscriminatorColumnToRootPersistentClass(\n \t\t\t\t\t\t\t(RootClass) persistentClass,\n \t\t\t\t\t\t\tdiscriminatorColumn,\n \t\t\t\t\t\t\tentityBinder.getSecondaryTables(),\n \t\t\t\t\t\t\tpropertyHolder,\n-\t\t\t\t\t\t\tmappings\n+\t\t\t\t\t\t\tcontext\n \t\t\t\t\t);\n \t\t\t\t\t//bind it again since the type might have changed\n \t\t\t\t\tentityBinder.bindDiscriminatorValue();\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n         if ( onDeleteAnn != null && !onDeleteAppropriate ) {\n \t\t\tLOG.invalidOnDeleteAnnotation(propertyHolder.getEntityName());\n \t\t}\n \n \t\t// try to find class level generators\n-\t\tHashMap<String, IdGenerator> classGenerators = buildLocalGenerators( clazzToProcess, mappings );\n+\t\tHashMap<String, IdentifierGeneratorDefinition> classGenerators = buildLocalGenerators( clazzToProcess, context );\n \n \t\t// check properties\n \t\tfinal InheritanceState.ElementsToProcess elementsToProcess = inheritanceState.getElementsToProcess();\n \t\tinheritanceState.postProcess( persistentClass, entityBinder );\n \n \t\tfinal boolean subclassAndSingleTableStrategy = inheritanceState.getType() == InheritanceType.SINGLE_TABLE\n \t\t\t\t&& inheritanceState.hasParents();\n \t\tSet<String> idPropertiesIfIdClass = new HashSet<String>();\n \t\tboolean isIdClass = mapAsIdClass(\n \t\t\t\tinheritanceStatePerClass,\n \t\t\t\tinheritanceState,\n \t\t\t\tpersistentClass,\n \t\t\t\tentityBinder,\n \t\t\t\tpropertyHolder,\n \t\t\t\telementsToProcess,\n \t\t\t\tidPropertiesIfIdClass,\n-\t\t\t\tmappings\n+\t\t\t\tcontext\n \t\t);\n \n \t\tif ( !isIdClass ) {\n \t\t\tentityBinder.setWrapIdsInEmbeddedComponents( elementsToProcess.getIdPropertyCount() > 1 );\n \t\t}\n \n \t\tprocessIdPropertiesIfNotAlready(\n \t\t\t\tinheritanceStatePerClass,\n-\t\t\t\tmappings,\n+\t\t\t\tcontext,\n \t\t\t\tpersistentClass,\n \t\t\t\tentityBinder,\n \t\t\t\tpropertyHolder,\n \t\t\t\tclassGenerators,\n \t\t\t\telementsToProcess,\n \t\t\t\tsubclassAndSingleTableStrategy,\n \t\t\t\tidPropertiesIfIdClass\n \t\t);\n \n \t\tif ( !inheritanceState.hasParents() ) {\n \t\t\tfinal RootClass rootClass = ( RootClass ) persistentClass;\n-\t\t\tmappings.addSecondPass( new CreateKeySecondPass( rootClass ) );\n+\t\t\tcontext.getMetadataCollector().addSecondPass( new CreateKeySecondPass( rootClass ) );\n \t\t}\n \t\telse {\n \t\t\tsuperEntity.addSubclass( ( Subclass ) persistentClass );\n \t\t}\n \n-\t\tmappings.addClass( persistentClass );\n+\t\tcontext.getMetadataCollector().addEntityBinding( persistentClass );\n \n \t\t//Process secondary tables and complementary definitions (ie o.h.a.Table)\n-\t\tmappings.addSecondPass( new SecondaryTableSecondPass( entityBinder, propertyHolder, clazzToProcess ) );\n+\t\tcontext.getMetadataCollector().addSecondPass(\n+\t\t\t\tnew SecondaryTableSecondPass(\n+\t\t\t\t\t\tentityBinder,\n+\t\t\t\t\t\tpropertyHolder,\n+\t\t\t\t\t\tclazzToProcess\n+\t\t\t\t)\n+\t\t);\n \n \t\t//add process complementary Table definition (index & all)\n \t\tentityBinder.processComplementaryTableDefinitions( clazzToProcess.getAnnotation( org.hibernate.annotations.Table.class ) );\n \t\tentityBinder.processComplementaryTableDefinitions( clazzToProcess.getAnnotation( org.hibernate.annotations.Tables.class ) );\n \t\tentityBinder.processComplementaryTableDefinitions( tabAnn );\n \t}\n\\ No newline at end of file\n",
					"extendedDetails": {}
				}
			]
		},
		"5329bba1ea724eabf5783c71e5127b8f84ad0fcc": {
			"type": "Ybodychange",
			"commitMessage": "HHH-6911 - Write DiscriminatorValue to DiscriminatorColumn when combined with InheritanceType#JOINED\n",
			"commitDate": "2013-12-12, 10:57 PM",
			"commitName": "5329bba1ea724eabf5783c71e5127b8f84ad0fcc",
			"commitAuthor": "Steve Ebersole",
			"commitDateOld": "2013-12-10, 5:33 PM",
			"commitNameOld": "637c8b4b08fab8c07406371a19c2674f67eb705d",
			"commitAuthorOld": "Brett Meyer",
			"daysBetweenCommits": 2.23,
			"commitsBetweenForRepo": 7,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,212 +1,252 @@\n \tpublic static void bindClass(\n \t\t\tXClass clazzToProcess,\n \t\t\tMap<XClass, InheritanceState> inheritanceStatePerClass,\n \t\t\tMappings mappings) throws MappingException {\n \t\t//@Entity and @MappedSuperclass on the same class leads to a NPE down the road\n \t\tif ( clazzToProcess.isAnnotationPresent( Entity.class )\n \t\t\t\t&&  clazzToProcess.isAnnotationPresent( MappedSuperclass.class ) ) {\n \t\t\tthrow new AnnotationException( \"An entity cannot be annotated with both @Entity and @MappedSuperclass: \"\n \t\t\t\t\t+ clazzToProcess.getName() );\n \t\t}\n \n \t\t//TODO: be more strict with secondarytable allowance (not for ids, not for secondary table join columns etc)\n \t\tInheritanceState inheritanceState = inheritanceStatePerClass.get( clazzToProcess );\n \t\tAnnotatedClassType classType = mappings.getClassType( clazzToProcess );\n \n \t\t//Queries declared in MappedSuperclass should be usable in Subclasses\n \t\tif ( AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals( classType ) ) {\n \t\t\tbindQueries( clazzToProcess, mappings );\n \t\t\tbindTypeDefs( clazzToProcess, mappings );\n \t\t\tbindFilterDefs( clazzToProcess, mappings );\n \t\t}\n \n \t\tif ( !isEntityClassType( clazzToProcess, classType ) ) {\n \t\t\treturn;\n \t\t}\n \n \t\tif ( LOG.isDebugEnabled() ) {\n \t\t\tLOG.debugf( \"Binding entity from annotated class: %s\", clazzToProcess.getName() );\n \t\t}\n \n \t\tPersistentClass superEntity = getSuperEntity(\n \t\t\t\tclazzToProcess, inheritanceStatePerClass, mappings, inheritanceState\n \t\t);\n \n \t\tPersistentClass persistentClass = makePersistentClass( inheritanceState, superEntity );\n \t\tEntity entityAnn = clazzToProcess.getAnnotation( Entity.class );\n \t\torg.hibernate.annotations.Entity hibEntityAnn = clazzToProcess.getAnnotation(\n \t\t\t\torg.hibernate.annotations.Entity.class\n \t\t);\n \t\tEntityBinder entityBinder = new EntityBinder(\n \t\t\t\tentityAnn, hibEntityAnn, clazzToProcess, persistentClass, mappings\n \t\t);\n \t\tentityBinder.setInheritanceState( inheritanceState );\n \n \t\tbindQueries( clazzToProcess, mappings );\n \t\tbindFilterDefs( clazzToProcess, mappings );\n \t\tbindTypeDefs( clazzToProcess, mappings );\n \t\tbindFetchProfiles( clazzToProcess, mappings );\n \t\tBinderHelper.bindAnyMetaDefs( clazzToProcess, mappings );\n \n \t\tString schema = \"\";\n \t\tString table = \"\"; //might be no @Table annotation on the annotated class\n \t\tString catalog = \"\";\n \t\tList<UniqueConstraintHolder> uniqueConstraints = new ArrayList<UniqueConstraintHolder>();\n \t\tjavax.persistence.Table tabAnn = null;\n \t\tif ( clazzToProcess.isAnnotationPresent( javax.persistence.Table.class ) ) {\n \t\t\ttabAnn = clazzToProcess.getAnnotation( javax.persistence.Table.class );\n \t\t\ttable = tabAnn.name();\n \t\t\tschema = tabAnn.schema();\n \t\t\tcatalog = tabAnn.catalog();\n \t\t\tuniqueConstraints = TableBinder.buildUniqueConstraintHolders( tabAnn.uniqueConstraints() );\n \t\t}\n \n \t\tEjb3JoinColumn[] inheritanceJoinedColumns = makeInheritanceJoinColumns(\n \t\t\t\tclazzToProcess, mappings, inheritanceState, superEntity\n \t\t);\n-\t\tEjb3DiscriminatorColumn discriminatorColumn = null;\n+\n+\t\tfinal Ejb3DiscriminatorColumn discriminatorColumn;\n \t\tif ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.getType() ) ) {\n-\t\t\tdiscriminatorColumn = processDiscriminatorProperties(\n-\t\t\t\t\tclazzToProcess, mappings, inheritanceState, entityBinder\n+\t\t\tdiscriminatorColumn = processSingleTableDiscriminatorProperties(\n+\t\t\t\t\tclazzToProcess,\n+\t\t\t\t\tmappings,\n+\t\t\t\t\tinheritanceState,\n+\t\t\t\t\tentityBinder\n \t\t\t);\n \t\t}\n+\t\telse if ( InheritanceType.JOINED.equals( inheritanceState.getType() ) ) {\n+\t\t\tdiscriminatorColumn = processJoinedDiscriminatorProperties(\n+\t\t\t\t\tclazzToProcess,\n+\t\t\t\t\tmappings,\n+\t\t\t\t\tinheritanceState,\n+\t\t\t\t\tentityBinder\n+\t\t\t);\n+\t\t}\n+\t\telse {\n+\t\t\tdiscriminatorColumn = null;\n+\t\t}\n \n \t\tentityBinder.setProxy( clazzToProcess.getAnnotation( Proxy.class ) );\n \t\tentityBinder.setBatchSize( clazzToProcess.getAnnotation( BatchSize.class ) );\n \t\tentityBinder.setWhere( clazzToProcess.getAnnotation( Where.class ) );\n \t    entityBinder.setCache( determineCacheSettings( clazzToProcess, mappings ) );\n \t    entityBinder.setNaturalIdCache( clazzToProcess, clazzToProcess.getAnnotation( NaturalIdCache.class ) );\n \n \t\tbindFilters( clazzToProcess, entityBinder, mappings );\n \n \t\tentityBinder.bindEntity();\n \n \t\tif ( inheritanceState.hasTable() ) {\n \t\t\tCheck checkAnn = clazzToProcess.getAnnotation( Check.class );\n \t\t\tString constraints = checkAnn == null ?\n \t\t\t\t\tnull :\n \t\t\t\t\tcheckAnn.constraints();\n \t\t\tentityBinder.bindTable(\n \t\t\t\t\tschema, catalog, table, uniqueConstraints,\n \t\t\t\t\tconstraints, inheritanceState.hasDenormalizedTable() ?\n \t\t\t\t\t\t\tsuperEntity.getTable() :\n \t\t\t\t\t\t\tnull\n \t\t\t);\n \t\t}\n \t\telse if ( clazzToProcess.isAnnotationPresent( Table.class ) ) {\n \t\t\tLOG.invalidTableAnnotation( clazzToProcess.getName() );\n \t\t}\n \n \n \t\tPropertyHolder propertyHolder = PropertyHolderBuilder.buildPropertyHolder(\n \t\t\t\tclazzToProcess,\n \t\t\t\tpersistentClass,\n \t\t\t\tentityBinder, mappings, inheritanceStatePerClass\n \t\t);\n \n \t\tjavax.persistence.SecondaryTable secTabAnn = clazzToProcess.getAnnotation(\n \t\t\t\tjavax.persistence.SecondaryTable.class\n \t\t);\n \t\tjavax.persistence.SecondaryTables secTabsAnn = clazzToProcess.getAnnotation(\n \t\t\t\tjavax.persistence.SecondaryTables.class\n \t\t);\n \t\tentityBinder.firstLevelSecondaryTablesBinding( secTabAnn, secTabsAnn );\n \n \t\tOnDelete onDeleteAnn = clazzToProcess.getAnnotation( OnDelete.class );\n \t\tboolean onDeleteAppropriate = false;\n-\t\tif ( InheritanceType.JOINED.equals( inheritanceState.getType() ) && inheritanceState.hasParents() ) {\n-\t\t\tonDeleteAppropriate = true;\n-\t\t\tfinal JoinedSubclass jsc = ( JoinedSubclass ) persistentClass;\n-\t\t\tSimpleValue key = new DependantValue( mappings, jsc.getTable(), jsc.getIdentifier() );\n-\t\t\tjsc.setKey( key );\n-\t\t\tForeignKey fk = clazzToProcess.getAnnotation( ForeignKey.class );\n-\t\t\tif ( fk != null && !BinderHelper.isEmptyAnnotationValue( fk.name() ) ) {\n-\t\t\t\tkey.setForeignKeyName( fk.name() );\n-\t\t\t}\n-\t\t\tif ( onDeleteAnn != null ) {\n-\t\t\t\tkey.setCascadeDeleteEnabled( OnDeleteAction.CASCADE.equals( onDeleteAnn.action() ) );\n-\t\t\t}\n-\t\t\telse {\n-\t\t\t\tkey.setCascadeDeleteEnabled( false );\n-\t\t\t}\n-\t\t\t//we are never in a second pass at that stage, so queue it\n-\t\t\tSecondPass sp = new JoinedSubclassFkSecondPass( jsc, inheritanceJoinedColumns, key, mappings );\n-\t\t\tmappings.addSecondPass( sp );\n-\t\t\tmappings.addSecondPass( new CreateKeySecondPass( jsc ) );\n \n+\t\t// todo : sucks that this is separate from RootClass distinction\n+\t\tfinal boolean isInheritanceRoot = !inheritanceState.hasParents();\n+\t\tfinal boolean hasSubclasses = inheritanceState.hasSiblings();\n+\n+\t\tif ( InheritanceType.JOINED.equals( inheritanceState.getType() ) ) {\n+\t\t\tif ( inheritanceState.hasParents() ) {\n+\t\t\t\tonDeleteAppropriate = true;\n+\t\t\t\tfinal JoinedSubclass jsc = ( JoinedSubclass ) persistentClass;\n+\t\t\t\tSimpleValue key = new DependantValue( mappings, jsc.getTable(), jsc.getIdentifier() );\n+\t\t\t\tjsc.setKey( key );\n+\t\t\t\tForeignKey fk = clazzToProcess.getAnnotation( ForeignKey.class );\n+\t\t\t\tif ( fk != null && !BinderHelper.isEmptyAnnotationValue( fk.name() ) ) {\n+\t\t\t\t\tkey.setForeignKeyName( fk.name() );\n+\t\t\t\t}\n+\t\t\t\tif ( onDeleteAnn != null ) {\n+\t\t\t\t\tkey.setCascadeDeleteEnabled( OnDeleteAction.CASCADE.equals( onDeleteAnn.action() ) );\n+\t\t\t\t}\n+\t\t\t\telse {\n+\t\t\t\t\tkey.setCascadeDeleteEnabled( false );\n+\t\t\t\t}\n+\t\t\t\t//we are never in a second pass at that stage, so queue it\n+\t\t\t\tSecondPass sp = new JoinedSubclassFkSecondPass( jsc, inheritanceJoinedColumns, key, mappings );\n+\t\t\t\tmappings.addSecondPass( sp );\n+\t\t\t\tmappings.addSecondPass( new CreateKeySecondPass( jsc ) );\n+\t\t\t}\n+\n+\t\t\tif ( isInheritanceRoot ) {\n+\t\t\t\t// the class we are processing is the root of the hierarchy, see if we had a discriminator column\n+\t\t\t\t// (it is perfectly valid for joined subclasses to not have discriminators).\n+\t\t\t\tif ( discriminatorColumn != null ) {\n+\t\t\t\t\t// we have a discriminator column\n+\t\t\t\t\tif ( hasSubclasses || !discriminatorColumn.isImplicit() ) {\n+\t\t\t\t\t\tbindDiscriminatorColumnToRootPersistentClass(\n+\t\t\t\t\t\t\t\t(RootClass) persistentClass,\n+\t\t\t\t\t\t\t\tdiscriminatorColumn,\n+\t\t\t\t\t\t\t\tentityBinder.getSecondaryTables(),\n+\t\t\t\t\t\t\t\tpropertyHolder,\n+\t\t\t\t\t\t\t\tmappings\n+\t\t\t\t\t\t);\n+\t\t\t\t\t\t//bind it again since the type might have changed\n+\t\t\t\t\t\tentityBinder.bindDiscriminatorValue();\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n \t\t}\n \t\telse if ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.getType() ) ) {\n-\t\t\tif ( ! inheritanceState.hasParents() ) {\n-\t\t\t\tif ( inheritanceState.hasSiblings() || !discriminatorColumn.isImplicit() ) {\n-\t\t\t\t\t//need a discriminator column\n-\t\t\t\t\tbindDiscriminatorToPersistentClass(\n-\t\t\t\t\t\t\t( RootClass ) persistentClass,\n+\t\t\tif ( isInheritanceRoot ) {\n+\t\t\t\tif ( hasSubclasses || !discriminatorColumn.isImplicit() ) {\n+\t\t\t\t\tbindDiscriminatorColumnToRootPersistentClass(\n+\t\t\t\t\t\t\t(RootClass) persistentClass,\n \t\t\t\t\t\t\tdiscriminatorColumn,\n \t\t\t\t\t\t\tentityBinder.getSecondaryTables(),\n \t\t\t\t\t\t\tpropertyHolder,\n \t\t\t\t\t\t\tmappings\n \t\t\t\t\t);\n-\t\t\t\t\tentityBinder.bindDiscriminatorValue();//bind it again since the type might have changed\n+\t\t\t\t\t//bind it again since the type might have changed\n+\t\t\t\t\tentityBinder.bindDiscriminatorValue();\n \t\t\t\t}\n \t\t\t}\n \t\t}\n-\t\telse if ( InheritanceType.TABLE_PER_CLASS.equals( inheritanceState.getType() ) ) {\n-\t\t\t//nothing to do\n+\n+        if ( onDeleteAnn != null && !onDeleteAppropriate ) {\n+\t\t\tLOG.invalidOnDeleteAnnotation(propertyHolder.getEntityName());\n \t\t}\n-        if (onDeleteAnn != null && !onDeleteAppropriate) LOG.invalidOnDeleteAnnotation(propertyHolder.getEntityName());\n \n \t\t// try to find class level generators\n \t\tHashMap<String, IdGenerator> classGenerators = buildLocalGenerators( clazzToProcess, mappings );\n \n \t\t// check properties\n \t\tfinal InheritanceState.ElementsToProcess elementsToProcess = inheritanceState.getElementsToProcess();\n \t\tinheritanceState.postProcess( persistentClass, entityBinder );\n \n \t\tfinal boolean subclassAndSingleTableStrategy = inheritanceState.getType() == InheritanceType.SINGLE_TABLE\n \t\t\t\t&& inheritanceState.hasParents();\n \t\tSet<String> idPropertiesIfIdClass = new HashSet<String>();\n \t\tboolean isIdClass = mapAsIdClass(\n \t\t\t\tinheritanceStatePerClass,\n \t\t\t\tinheritanceState,\n \t\t\t\tpersistentClass,\n \t\t\t\tentityBinder,\n \t\t\t\tpropertyHolder,\n \t\t\t\telementsToProcess,\n \t\t\t\tidPropertiesIfIdClass,\n \t\t\t\tmappings\n \t\t);\n \n \t\tif ( !isIdClass ) {\n \t\t\tentityBinder.setWrapIdsInEmbeddedComponents( elementsToProcess.getIdPropertyCount() > 1 );\n \t\t}\n \n \t\tprocessIdPropertiesIfNotAlready(\n \t\t\t\tinheritanceStatePerClass,\n \t\t\t\tmappings,\n \t\t\t\tpersistentClass,\n \t\t\t\tentityBinder,\n \t\t\t\tpropertyHolder,\n \t\t\t\tclassGenerators,\n \t\t\t\telementsToProcess,\n \t\t\t\tsubclassAndSingleTableStrategy,\n \t\t\t\tidPropertiesIfIdClass\n \t\t);\n \n \t\tif ( !inheritanceState.hasParents() ) {\n \t\t\tfinal RootClass rootClass = ( RootClass ) persistentClass;\n \t\t\tmappings.addSecondPass( new CreateKeySecondPass( rootClass ) );\n \t\t}\n \t\telse {\n \t\t\tsuperEntity.addSubclass( ( Subclass ) persistentClass );\n \t\t}\n \n \t\tmappings.addClass( persistentClass );\n \n \t\t//Process secondary tables and complementary definitions (ie o.h.a.Table)\n \t\tmappings.addSecondPass( new SecondaryTableSecondPass( entityBinder, propertyHolder, clazzToProcess ) );\n \n \t\t//add process complementary Table definition (index & all)\n \t\tentityBinder.processComplementaryTableDefinitions( clazzToProcess.getAnnotation( org.hibernate.annotations.Table.class ) );\n \t\tentityBinder.processComplementaryTableDefinitions( clazzToProcess.getAnnotation( org.hibernate.annotations.Tables.class ) );\n \t\tentityBinder.processComplementaryTableDefinitions( tabAnn );\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"1d9b7a06a52b56b84844513d97c535eb00d0ed8a": {
			"type": "Ybodychange",
			"commitMessage": "HHH-7969 initial @Table#indexes support\n",
			"commitDate": "2013-02-05, 8:09 AM",
			"commitName": "1d9b7a06a52b56b84844513d97c535eb00d0ed8a",
			"commitAuthor": "Strong Liu",
			"commitDateOld": "2012-12-25, 3:25 AM",
			"commitNameOld": "6c6df695350f917fe707b4f830e29c8c52c3f5d0",
			"commitAuthorOld": "Strong Liu",
			"daysBetweenCommits": 42.2,
			"commitsBetweenForRepo": 65,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,211 +1,212 @@\n \tpublic static void bindClass(\n \t\t\tXClass clazzToProcess,\n \t\t\tMap<XClass, InheritanceState> inheritanceStatePerClass,\n \t\t\tMappings mappings) throws MappingException {\n \t\t//@Entity and @MappedSuperclass on the same class leads to a NPE down the road\n \t\tif ( clazzToProcess.isAnnotationPresent( Entity.class )\n \t\t\t\t&&  clazzToProcess.isAnnotationPresent( MappedSuperclass.class ) ) {\n \t\t\tthrow new AnnotationException( \"An entity cannot be annotated with both @Entity and @MappedSuperclass: \"\n \t\t\t\t\t+ clazzToProcess.getName() );\n \t\t}\n \n \t\t//TODO: be more strict with secondarytable allowance (not for ids, not for secondary table join columns etc)\n \t\tInheritanceState inheritanceState = inheritanceStatePerClass.get( clazzToProcess );\n \t\tAnnotatedClassType classType = mappings.getClassType( clazzToProcess );\n \n \t\t//Queries declared in MappedSuperclass should be usable in Subclasses\n \t\tif ( AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals( classType ) ) {\n \t\t\tbindQueries( clazzToProcess, mappings );\n \t\t\tbindTypeDefs( clazzToProcess, mappings );\n \t\t\tbindFilterDefs( clazzToProcess, mappings );\n \t\t}\n \n \t\tif ( !isEntityClassType( clazzToProcess, classType ) ) {\n \t\t\treturn;\n \t\t}\n \n \t\tif ( LOG.isDebugEnabled() ) {\n \t\t\tLOG.debugf( \"Binding entity from annotated class: %s\", clazzToProcess.getName() );\n \t\t}\n \n \t\tPersistentClass superEntity = getSuperEntity(\n \t\t\t\tclazzToProcess, inheritanceStatePerClass, mappings, inheritanceState\n \t\t);\n \n \t\tPersistentClass persistentClass = makePersistentClass( inheritanceState, superEntity );\n \t\tEntity entityAnn = clazzToProcess.getAnnotation( Entity.class );\n \t\torg.hibernate.annotations.Entity hibEntityAnn = clazzToProcess.getAnnotation(\n \t\t\t\torg.hibernate.annotations.Entity.class\n \t\t);\n \t\tEntityBinder entityBinder = new EntityBinder(\n \t\t\t\tentityAnn, hibEntityAnn, clazzToProcess, persistentClass, mappings\n \t\t);\n \t\tentityBinder.setInheritanceState( inheritanceState );\n \n \t\tbindQueries( clazzToProcess, mappings );\n \t\tbindFilterDefs( clazzToProcess, mappings );\n \t\tbindTypeDefs( clazzToProcess, mappings );\n \t\tbindFetchProfiles( clazzToProcess, mappings );\n \t\tBinderHelper.bindAnyMetaDefs( clazzToProcess, mappings );\n \n \t\tString schema = \"\";\n \t\tString table = \"\"; //might be no @Table annotation on the annotated class\n \t\tString catalog = \"\";\n \t\tList<UniqueConstraintHolder> uniqueConstraints = new ArrayList<UniqueConstraintHolder>();\n+\t\tjavax.persistence.Table tabAnn = null;\n \t\tif ( clazzToProcess.isAnnotationPresent( javax.persistence.Table.class ) ) {\n-\t\t\tjavax.persistence.Table tabAnn = clazzToProcess.getAnnotation( javax.persistence.Table.class );\n+\t\t\ttabAnn = clazzToProcess.getAnnotation( javax.persistence.Table.class );\n \t\t\ttable = tabAnn.name();\n \t\t\tschema = tabAnn.schema();\n \t\t\tcatalog = tabAnn.catalog();\n \t\t\tuniqueConstraints = TableBinder.buildUniqueConstraintHolders( tabAnn.uniqueConstraints() );\n \t\t}\n \n \t\tEjb3JoinColumn[] inheritanceJoinedColumns = makeInheritanceJoinColumns(\n \t\t\t\tclazzToProcess, mappings, inheritanceState, superEntity\n \t\t);\n \t\tEjb3DiscriminatorColumn discriminatorColumn = null;\n \t\tif ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.getType() ) ) {\n \t\t\tdiscriminatorColumn = processDiscriminatorProperties(\n \t\t\t\t\tclazzToProcess, mappings, inheritanceState, entityBinder\n \t\t\t);\n \t\t}\n \n \t\tentityBinder.setProxy( clazzToProcess.getAnnotation( Proxy.class ) );\n \t\tentityBinder.setBatchSize( clazzToProcess.getAnnotation( BatchSize.class ) );\n \t\tentityBinder.setWhere( clazzToProcess.getAnnotation( Where.class ) );\n \t    entityBinder.setCache( determineCacheSettings( clazzToProcess, mappings ) );\n \t    entityBinder.setNaturalIdCache( clazzToProcess, clazzToProcess.getAnnotation( NaturalIdCache.class ) );\n \n \t\tbindFilters( clazzToProcess, entityBinder, mappings );\n \n \t\tentityBinder.bindEntity();\n \n \t\tif ( inheritanceState.hasTable() ) {\n \t\t\tCheck checkAnn = clazzToProcess.getAnnotation( Check.class );\n \t\t\tString constraints = checkAnn == null ?\n \t\t\t\t\tnull :\n \t\t\t\t\tcheckAnn.constraints();\n \t\t\tentityBinder.bindTable(\n \t\t\t\t\tschema, catalog, table, uniqueConstraints,\n \t\t\t\t\tconstraints, inheritanceState.hasDenormalizedTable() ?\n \t\t\t\t\t\t\tsuperEntity.getTable() :\n \t\t\t\t\t\t\tnull\n \t\t\t);\n \t\t}\n \t\telse if ( clazzToProcess.isAnnotationPresent( Table.class ) ) {\n \t\t\tLOG.invalidTableAnnotation( clazzToProcess.getName() );\n \t\t}\n \n \n \t\tPropertyHolder propertyHolder = PropertyHolderBuilder.buildPropertyHolder(\n \t\t\t\tclazzToProcess,\n \t\t\t\tpersistentClass,\n \t\t\t\tentityBinder, mappings, inheritanceStatePerClass\n \t\t);\n \n \t\tjavax.persistence.SecondaryTable secTabAnn = clazzToProcess.getAnnotation(\n \t\t\t\tjavax.persistence.SecondaryTable.class\n \t\t);\n \t\tjavax.persistence.SecondaryTables secTabsAnn = clazzToProcess.getAnnotation(\n \t\t\t\tjavax.persistence.SecondaryTables.class\n \t\t);\n \t\tentityBinder.firstLevelSecondaryTablesBinding( secTabAnn, secTabsAnn );\n \n \t\tOnDelete onDeleteAnn = clazzToProcess.getAnnotation( OnDelete.class );\n \t\tboolean onDeleteAppropriate = false;\n \t\tif ( InheritanceType.JOINED.equals( inheritanceState.getType() ) && inheritanceState.hasParents() ) {\n \t\t\tonDeleteAppropriate = true;\n \t\t\tfinal JoinedSubclass jsc = ( JoinedSubclass ) persistentClass;\n \t\t\tSimpleValue key = new DependantValue( mappings, jsc.getTable(), jsc.getIdentifier() );\n \t\t\tjsc.setKey( key );\n \t\t\tForeignKey fk = clazzToProcess.getAnnotation( ForeignKey.class );\n \t\t\tif ( fk != null && !BinderHelper.isEmptyAnnotationValue( fk.name() ) ) {\n \t\t\t\tkey.setForeignKeyName( fk.name() );\n \t\t\t}\n \t\t\tif ( onDeleteAnn != null ) {\n \t\t\t\tkey.setCascadeDeleteEnabled( OnDeleteAction.CASCADE.equals( onDeleteAnn.action() ) );\n \t\t\t}\n \t\t\telse {\n \t\t\t\tkey.setCascadeDeleteEnabled( false );\n \t\t\t}\n \t\t\t//we are never in a second pass at that stage, so queue it\n \t\t\tSecondPass sp = new JoinedSubclassFkSecondPass( jsc, inheritanceJoinedColumns, key, mappings );\n \t\t\tmappings.addSecondPass( sp );\n \t\t\tmappings.addSecondPass( new CreateKeySecondPass( jsc ) );\n \n \t\t}\n \t\telse if ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.getType() ) ) {\n \t\t\tif ( ! inheritanceState.hasParents() ) {\n \t\t\t\tif ( inheritanceState.hasSiblings() || !discriminatorColumn.isImplicit() ) {\n \t\t\t\t\t//need a discriminator column\n \t\t\t\t\tbindDiscriminatorToPersistentClass(\n \t\t\t\t\t\t\t( RootClass ) persistentClass,\n \t\t\t\t\t\t\tdiscriminatorColumn,\n \t\t\t\t\t\t\tentityBinder.getSecondaryTables(),\n \t\t\t\t\t\t\tpropertyHolder,\n \t\t\t\t\t\t\tmappings\n \t\t\t\t\t);\n \t\t\t\t\tentityBinder.bindDiscriminatorValue();//bind it again since the type might have changed\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\telse if ( InheritanceType.TABLE_PER_CLASS.equals( inheritanceState.getType() ) ) {\n \t\t\t//nothing to do\n \t\t}\n         if (onDeleteAnn != null && !onDeleteAppropriate) LOG.invalidOnDeleteAnnotation(propertyHolder.getEntityName());\n \n \t\t// try to find class level generators\n \t\tHashMap<String, IdGenerator> classGenerators = buildLocalGenerators( clazzToProcess, mappings );\n \n \t\t// check properties\n \t\tfinal InheritanceState.ElementsToProcess elementsToProcess = inheritanceState.getElementsToProcess();\n \t\tinheritanceState.postProcess( persistentClass, entityBinder );\n \n \t\tfinal boolean subclassAndSingleTableStrategy = inheritanceState.getType() == InheritanceType.SINGLE_TABLE\n \t\t\t\t&& inheritanceState.hasParents();\n \t\tSet<String> idPropertiesIfIdClass = new HashSet<String>();\n \t\tboolean isIdClass = mapAsIdClass(\n \t\t\t\tinheritanceStatePerClass,\n \t\t\t\tinheritanceState,\n \t\t\t\tpersistentClass,\n \t\t\t\tentityBinder,\n \t\t\t\tpropertyHolder,\n \t\t\t\telementsToProcess,\n \t\t\t\tidPropertiesIfIdClass,\n \t\t\t\tmappings\n \t\t);\n \n \t\tif ( !isIdClass ) {\n \t\t\tentityBinder.setWrapIdsInEmbeddedComponents( elementsToProcess.getIdPropertyCount() > 1 );\n \t\t}\n \n \t\tprocessIdPropertiesIfNotAlready(\n \t\t\t\tinheritanceStatePerClass,\n \t\t\t\tmappings,\n \t\t\t\tpersistentClass,\n \t\t\t\tentityBinder,\n \t\t\t\tpropertyHolder,\n \t\t\t\tclassGenerators,\n \t\t\t\telementsToProcess,\n \t\t\t\tsubclassAndSingleTableStrategy,\n \t\t\t\tidPropertiesIfIdClass\n \t\t);\n \n \t\tif ( !inheritanceState.hasParents() ) {\n \t\t\tfinal RootClass rootClass = ( RootClass ) persistentClass;\n \t\t\tmappings.addSecondPass( new CreateKeySecondPass( rootClass ) );\n \t\t}\n \t\telse {\n \t\t\tsuperEntity.addSubclass( ( Subclass ) persistentClass );\n \t\t}\n \n \t\tmappings.addClass( persistentClass );\n \n \t\t//Process secondary tables and complementary definitions (ie o.h.a.Table)\n \t\tmappings.addSecondPass( new SecondaryTableSecondPass( entityBinder, propertyHolder, clazzToProcess ) );\n \n \t\t//add process complementary Table definition (index & all)\n \t\tentityBinder.processComplementaryTableDefinitions( clazzToProcess.getAnnotation( org.hibernate.annotations.Table.class ) );\n \t\tentityBinder.processComplementaryTableDefinitions( clazzToProcess.getAnnotation( org.hibernate.annotations.Tables.class ) );\n-\n+\t\tentityBinder.processComplementaryTableDefinitions( tabAnn );\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"09547a9051dd0ed851d8d6c5bd90841a93db2604": {
			"type": "Ybodychange",
			"commitMessage": "HHH-2394 Remove conditions that blocked filters on sub-classes (for annotations)\n",
			"commitDate": "2012-07-12, 7:58 AM",
			"commitName": "09547a9051dd0ed851d8d6c5bd90841a93db2604",
			"commitAuthor": "Rob Worsnop",
			"commitDateOld": "2012-06-01, 9:59 AM",
			"commitNameOld": "e26b8be6a5a935ae00e537c01c59a6fcb24fc67d",
			"commitAuthorOld": "Steve Ebersole",
			"daysBetweenCommits": 40.92,
			"commitsBetweenForRepo": 35,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,214 +1,211 @@\n \tpublic static void bindClass(\n \t\t\tXClass clazzToProcess,\n \t\t\tMap<XClass, InheritanceState> inheritanceStatePerClass,\n \t\t\tMappings mappings) throws MappingException {\n \t\t//@Entity and @MappedSuperclass on the same class leads to a NPE down the road\n \t\tif ( clazzToProcess.isAnnotationPresent( Entity.class )\n \t\t\t\t&&  clazzToProcess.isAnnotationPresent( MappedSuperclass.class ) ) {\n \t\t\tthrow new AnnotationException( \"An entity cannot be annotated with both @Entity and @MappedSuperclass: \"\n \t\t\t\t\t+ clazzToProcess.getName() );\n \t\t}\n \n \t\t//TODO: be more strict with secondarytable allowance (not for ids, not for secondary table join columns etc)\n \t\tInheritanceState inheritanceState = inheritanceStatePerClass.get( clazzToProcess );\n \t\tAnnotatedClassType classType = mappings.getClassType( clazzToProcess );\n \n \t\t//Queries declared in MappedSuperclass should be usable in Subclasses\n \t\tif ( AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals( classType ) ) {\n \t\t\tbindQueries( clazzToProcess, mappings );\n \t\t\tbindTypeDefs( clazzToProcess, mappings );\n \t\t\tbindFilterDefs( clazzToProcess, mappings );\n \t\t}\n \n \t\tif ( !isEntityClassType( clazzToProcess, classType ) ) {\n \t\t\treturn;\n \t\t}\n \n \t\tif ( LOG.isDebugEnabled() ) {\n \t\t\tLOG.debugf( \"Binding entity from annotated class: %s\", clazzToProcess.getName() );\n \t\t}\n \n \t\tPersistentClass superEntity = getSuperEntity(\n \t\t\t\tclazzToProcess, inheritanceStatePerClass, mappings, inheritanceState\n \t\t);\n \n \t\tPersistentClass persistentClass = makePersistentClass( inheritanceState, superEntity );\n \t\tEntity entityAnn = clazzToProcess.getAnnotation( Entity.class );\n \t\torg.hibernate.annotations.Entity hibEntityAnn = clazzToProcess.getAnnotation(\n \t\t\t\torg.hibernate.annotations.Entity.class\n \t\t);\n \t\tEntityBinder entityBinder = new EntityBinder(\n \t\t\t\tentityAnn, hibEntityAnn, clazzToProcess, persistentClass, mappings\n \t\t);\n \t\tentityBinder.setInheritanceState( inheritanceState );\n \n \t\tbindQueries( clazzToProcess, mappings );\n \t\tbindFilterDefs( clazzToProcess, mappings );\n \t\tbindTypeDefs( clazzToProcess, mappings );\n \t\tbindFetchProfiles( clazzToProcess, mappings );\n \t\tBinderHelper.bindAnyMetaDefs( clazzToProcess, mappings );\n \n \t\tString schema = \"\";\n \t\tString table = \"\"; //might be no @Table annotation on the annotated class\n \t\tString catalog = \"\";\n \t\tList<UniqueConstraintHolder> uniqueConstraints = new ArrayList<UniqueConstraintHolder>();\n \t\tif ( clazzToProcess.isAnnotationPresent( javax.persistence.Table.class ) ) {\n \t\t\tjavax.persistence.Table tabAnn = clazzToProcess.getAnnotation( javax.persistence.Table.class );\n \t\t\ttable = tabAnn.name();\n \t\t\tschema = tabAnn.schema();\n \t\t\tcatalog = tabAnn.catalog();\n \t\t\tuniqueConstraints = TableBinder.buildUniqueConstraintHolders( tabAnn.uniqueConstraints() );\n \t\t}\n \n \t\tEjb3JoinColumn[] inheritanceJoinedColumns = makeInheritanceJoinColumns(\n \t\t\t\tclazzToProcess, mappings, inheritanceState, superEntity\n \t\t);\n \t\tEjb3DiscriminatorColumn discriminatorColumn = null;\n \t\tif ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.getType() ) ) {\n \t\t\tdiscriminatorColumn = processDiscriminatorProperties(\n \t\t\t\t\tclazzToProcess, mappings, inheritanceState, entityBinder\n \t\t\t);\n \t\t}\n \n \t\tentityBinder.setProxy( clazzToProcess.getAnnotation( Proxy.class ) );\n \t\tentityBinder.setBatchSize( clazzToProcess.getAnnotation( BatchSize.class ) );\n \t\tentityBinder.setWhere( clazzToProcess.getAnnotation( Where.class ) );\n \t    entityBinder.setCache( determineCacheSettings( clazzToProcess, mappings ) );\n \t    entityBinder.setNaturalIdCache( clazzToProcess, clazzToProcess.getAnnotation( NaturalIdCache.class ) );\n \n-\t\t//Filters are not allowed on subclasses\n-\t\tif ( !inheritanceState.hasParents() ) {\n-\t\t\tbindFilters( clazzToProcess, entityBinder, mappings );\n-\t\t}\n+\t\tbindFilters( clazzToProcess, entityBinder, mappings );\n \n \t\tentityBinder.bindEntity();\n \n \t\tif ( inheritanceState.hasTable() ) {\n \t\t\tCheck checkAnn = clazzToProcess.getAnnotation( Check.class );\n \t\t\tString constraints = checkAnn == null ?\n \t\t\t\t\tnull :\n \t\t\t\t\tcheckAnn.constraints();\n \t\t\tentityBinder.bindTable(\n \t\t\t\t\tschema, catalog, table, uniqueConstraints,\n \t\t\t\t\tconstraints, inheritanceState.hasDenormalizedTable() ?\n \t\t\t\t\t\t\tsuperEntity.getTable() :\n \t\t\t\t\t\t\tnull\n \t\t\t);\n \t\t}\n \t\telse if ( clazzToProcess.isAnnotationPresent( Table.class ) ) {\n \t\t\tLOG.invalidTableAnnotation( clazzToProcess.getName() );\n \t\t}\n \n \n \t\tPropertyHolder propertyHolder = PropertyHolderBuilder.buildPropertyHolder(\n \t\t\t\tclazzToProcess,\n \t\t\t\tpersistentClass,\n \t\t\t\tentityBinder, mappings, inheritanceStatePerClass\n \t\t);\n \n \t\tjavax.persistence.SecondaryTable secTabAnn = clazzToProcess.getAnnotation(\n \t\t\t\tjavax.persistence.SecondaryTable.class\n \t\t);\n \t\tjavax.persistence.SecondaryTables secTabsAnn = clazzToProcess.getAnnotation(\n \t\t\t\tjavax.persistence.SecondaryTables.class\n \t\t);\n \t\tentityBinder.firstLevelSecondaryTablesBinding( secTabAnn, secTabsAnn );\n \n \t\tOnDelete onDeleteAnn = clazzToProcess.getAnnotation( OnDelete.class );\n \t\tboolean onDeleteAppropriate = false;\n \t\tif ( InheritanceType.JOINED.equals( inheritanceState.getType() ) && inheritanceState.hasParents() ) {\n \t\t\tonDeleteAppropriate = true;\n \t\t\tfinal JoinedSubclass jsc = ( JoinedSubclass ) persistentClass;\n \t\t\tSimpleValue key = new DependantValue( mappings, jsc.getTable(), jsc.getIdentifier() );\n \t\t\tjsc.setKey( key );\n \t\t\tForeignKey fk = clazzToProcess.getAnnotation( ForeignKey.class );\n \t\t\tif ( fk != null && !BinderHelper.isEmptyAnnotationValue( fk.name() ) ) {\n \t\t\t\tkey.setForeignKeyName( fk.name() );\n \t\t\t}\n \t\t\tif ( onDeleteAnn != null ) {\n \t\t\t\tkey.setCascadeDeleteEnabled( OnDeleteAction.CASCADE.equals( onDeleteAnn.action() ) );\n \t\t\t}\n \t\t\telse {\n \t\t\t\tkey.setCascadeDeleteEnabled( false );\n \t\t\t}\n \t\t\t//we are never in a second pass at that stage, so queue it\n \t\t\tSecondPass sp = new JoinedSubclassFkSecondPass( jsc, inheritanceJoinedColumns, key, mappings );\n \t\t\tmappings.addSecondPass( sp );\n \t\t\tmappings.addSecondPass( new CreateKeySecondPass( jsc ) );\n \n \t\t}\n \t\telse if ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.getType() ) ) {\n \t\t\tif ( ! inheritanceState.hasParents() ) {\n \t\t\t\tif ( inheritanceState.hasSiblings() || !discriminatorColumn.isImplicit() ) {\n \t\t\t\t\t//need a discriminator column\n \t\t\t\t\tbindDiscriminatorToPersistentClass(\n \t\t\t\t\t\t\t( RootClass ) persistentClass,\n \t\t\t\t\t\t\tdiscriminatorColumn,\n \t\t\t\t\t\t\tentityBinder.getSecondaryTables(),\n \t\t\t\t\t\t\tpropertyHolder,\n \t\t\t\t\t\t\tmappings\n \t\t\t\t\t);\n \t\t\t\t\tentityBinder.bindDiscriminatorValue();//bind it again since the type might have changed\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\telse if ( InheritanceType.TABLE_PER_CLASS.equals( inheritanceState.getType() ) ) {\n \t\t\t//nothing to do\n \t\t}\n         if (onDeleteAnn != null && !onDeleteAppropriate) LOG.invalidOnDeleteAnnotation(propertyHolder.getEntityName());\n \n \t\t// try to find class level generators\n \t\tHashMap<String, IdGenerator> classGenerators = buildLocalGenerators( clazzToProcess, mappings );\n \n \t\t// check properties\n \t\tfinal InheritanceState.ElementsToProcess elementsToProcess = inheritanceState.getElementsToProcess();\n \t\tinheritanceState.postProcess( persistentClass, entityBinder );\n \n \t\tfinal boolean subclassAndSingleTableStrategy = inheritanceState.getType() == InheritanceType.SINGLE_TABLE\n \t\t\t\t&& inheritanceState.hasParents();\n \t\tSet<String> idPropertiesIfIdClass = new HashSet<String>();\n \t\tboolean isIdClass = mapAsIdClass(\n \t\t\t\tinheritanceStatePerClass,\n \t\t\t\tinheritanceState,\n \t\t\t\tpersistentClass,\n \t\t\t\tentityBinder,\n \t\t\t\tpropertyHolder,\n \t\t\t\telementsToProcess,\n \t\t\t\tidPropertiesIfIdClass,\n \t\t\t\tmappings\n \t\t);\n \n \t\tif ( !isIdClass ) {\n \t\t\tentityBinder.setWrapIdsInEmbeddedComponents( elementsToProcess.getIdPropertyCount() > 1 );\n \t\t}\n \n \t\tprocessIdPropertiesIfNotAlready(\n \t\t\t\tinheritanceStatePerClass,\n \t\t\t\tmappings,\n \t\t\t\tpersistentClass,\n \t\t\t\tentityBinder,\n \t\t\t\tpropertyHolder,\n \t\t\t\tclassGenerators,\n \t\t\t\telementsToProcess,\n \t\t\t\tsubclassAndSingleTableStrategy,\n \t\t\t\tidPropertiesIfIdClass\n \t\t);\n \n \t\tif ( !inheritanceState.hasParents() ) {\n \t\t\tfinal RootClass rootClass = ( RootClass ) persistentClass;\n \t\t\tmappings.addSecondPass( new CreateKeySecondPass( rootClass ) );\n \t\t}\n \t\telse {\n \t\t\tsuperEntity.addSubclass( ( Subclass ) persistentClass );\n \t\t}\n \n \t\tmappings.addClass( persistentClass );\n \n \t\t//Process secondary tables and complementary definitions (ie o.h.a.Table)\n \t\tmappings.addSecondPass( new SecondaryTableSecondPass( entityBinder, propertyHolder, clazzToProcess ) );\n \n \t\t//add process complementary Table definition (index & all)\n \t\tentityBinder.processComplementaryTableDefinitions( clazzToProcess.getAnnotation( org.hibernate.annotations.Table.class ) );\n \t\tentityBinder.processComplementaryTableDefinitions( clazzToProcess.getAnnotation( org.hibernate.annotations.Tables.class ) );\n \n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"1569e6194b45038a210984d73d25079dd1482b3f": {
			"type": "Ybodychange",
			"commitMessage": "HHH-6974 Complete second level caching of natural id resolution\n",
			"commitDate": "2012-02-07, 6:34 AM",
			"commitName": "1569e6194b45038a210984d73d25079dd1482b3f",
			"commitAuthor": "Eric Dalquist",
			"commitDateOld": "2012-02-07, 6:34 AM",
			"commitNameOld": "c47352058541e14e0b80d38f94c65d939d5394f5",
			"commitAuthorOld": "Eric Dalquist",
			"daysBetweenCommits": 0,
			"commitsBetweenForRepo": 2,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,214 +1,214 @@\n \tpublic static void bindClass(\n \t\t\tXClass clazzToProcess,\n \t\t\tMap<XClass, InheritanceState> inheritanceStatePerClass,\n \t\t\tMappings mappings) throws MappingException {\n \t\t//@Entity and @MappedSuperclass on the same class leads to a NPE down the road\n \t\tif ( clazzToProcess.isAnnotationPresent( Entity.class )\n \t\t\t\t&&  clazzToProcess.isAnnotationPresent( MappedSuperclass.class ) ) {\n \t\t\tthrow new AnnotationException( \"An entity cannot be annotated with both @Entity and @MappedSuperclass: \"\n \t\t\t\t\t+ clazzToProcess.getName() );\n \t\t}\n \n \t\t//TODO: be more strict with secondarytable allowance (not for ids, not for secondary table join columns etc)\n \t\tInheritanceState inheritanceState = inheritanceStatePerClass.get( clazzToProcess );\n \t\tAnnotatedClassType classType = mappings.getClassType( clazzToProcess );\n \n \t\t//Queries declared in MappedSuperclass should be usable in Subclasses\n \t\tif ( AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals( classType ) ) {\n \t\t\tbindQueries( clazzToProcess, mappings );\n \t\t\tbindTypeDefs( clazzToProcess, mappings );\n \t\t\tbindFilterDefs( clazzToProcess, mappings );\n \t\t}\n \n \t\tif ( !isEntityClassType( clazzToProcess, classType ) ) {\n \t\t\treturn;\n \t\t}\n \n \t\tif ( LOG.isDebugEnabled() ) {\n \t\t\tLOG.debugf( \"Binding entity from annotated class: %s\", clazzToProcess.getName() );\n \t\t}\n \n \t\tPersistentClass superEntity = getSuperEntity(\n \t\t\t\tclazzToProcess, inheritanceStatePerClass, mappings, inheritanceState\n \t\t);\n \n \t\tPersistentClass persistentClass = makePersistentClass( inheritanceState, superEntity );\n \t\tEntity entityAnn = clazzToProcess.getAnnotation( Entity.class );\n \t\torg.hibernate.annotations.Entity hibEntityAnn = clazzToProcess.getAnnotation(\n \t\t\t\torg.hibernate.annotations.Entity.class\n \t\t);\n \t\tEntityBinder entityBinder = new EntityBinder(\n \t\t\t\tentityAnn, hibEntityAnn, clazzToProcess, persistentClass, mappings\n \t\t);\n \t\tentityBinder.setInheritanceState( inheritanceState );\n \n \t\tbindQueries( clazzToProcess, mappings );\n \t\tbindFilterDefs( clazzToProcess, mappings );\n \t\tbindTypeDefs( clazzToProcess, mappings );\n \t\tbindFetchProfiles( clazzToProcess, mappings );\n \t\tBinderHelper.bindAnyMetaDefs( clazzToProcess, mappings );\n \n \t\tString schema = \"\";\n \t\tString table = \"\"; //might be no @Table annotation on the annotated class\n \t\tString catalog = \"\";\n \t\tList<UniqueConstraintHolder> uniqueConstraints = new ArrayList<UniqueConstraintHolder>();\n \t\tif ( clazzToProcess.isAnnotationPresent( javax.persistence.Table.class ) ) {\n \t\t\tjavax.persistence.Table tabAnn = clazzToProcess.getAnnotation( javax.persistence.Table.class );\n \t\t\ttable = tabAnn.name();\n \t\t\tschema = tabAnn.schema();\n \t\t\tcatalog = tabAnn.catalog();\n \t\t\tuniqueConstraints = TableBinder.buildUniqueConstraintHolders( tabAnn.uniqueConstraints() );\n \t\t}\n \n \t\tEjb3JoinColumn[] inheritanceJoinedColumns = makeInheritanceJoinColumns(\n \t\t\t\tclazzToProcess, mappings, inheritanceState, superEntity\n \t\t);\n \t\tEjb3DiscriminatorColumn discriminatorColumn = null;\n \t\tif ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.getType() ) ) {\n \t\t\tdiscriminatorColumn = processDiscriminatorProperties(\n \t\t\t\t\tclazzToProcess, mappings, inheritanceState, entityBinder\n \t\t\t);\n \t\t}\n \n \t\tentityBinder.setProxy( clazzToProcess.getAnnotation( Proxy.class ) );\n \t\tentityBinder.setBatchSize( clazzToProcess.getAnnotation( BatchSize.class ) );\n \t\tentityBinder.setWhere( clazzToProcess.getAnnotation( Where.class ) );\n \t    entityBinder.setCache( determineCacheSettings( clazzToProcess, mappings ) );\n-\t    entityBinder.setNaturalIdCache( clazzToProcess.getAnnotation( NaturalIdCache.class ) );\n+\t    entityBinder.setNaturalIdCache( clazzToProcess, clazzToProcess.getAnnotation( NaturalIdCache.class ) );\n \n \t\t//Filters are not allowed on subclasses\n \t\tif ( !inheritanceState.hasParents() ) {\n \t\t\tbindFilters( clazzToProcess, entityBinder, mappings );\n \t\t}\n \n \t\tentityBinder.bindEntity();\n \n \t\tif ( inheritanceState.hasTable() ) {\n \t\t\tCheck checkAnn = clazzToProcess.getAnnotation( Check.class );\n \t\t\tString constraints = checkAnn == null ?\n \t\t\t\t\tnull :\n \t\t\t\t\tcheckAnn.constraints();\n \t\t\tentityBinder.bindTable(\n \t\t\t\t\tschema, catalog, table, uniqueConstraints,\n \t\t\t\t\tconstraints, inheritanceState.hasDenormalizedTable() ?\n \t\t\t\t\t\t\tsuperEntity.getTable() :\n \t\t\t\t\t\t\tnull\n \t\t\t);\n \t\t}\n \t\telse if ( clazzToProcess.isAnnotationPresent( Table.class ) ) {\n \t\t\tLOG.invalidTableAnnotation( clazzToProcess.getName() );\n \t\t}\n \n \n \t\tPropertyHolder propertyHolder = PropertyHolderBuilder.buildPropertyHolder(\n \t\t\t\tclazzToProcess,\n \t\t\t\tpersistentClass,\n \t\t\t\tentityBinder, mappings, inheritanceStatePerClass\n \t\t);\n \n \t\tjavax.persistence.SecondaryTable secTabAnn = clazzToProcess.getAnnotation(\n \t\t\t\tjavax.persistence.SecondaryTable.class\n \t\t);\n \t\tjavax.persistence.SecondaryTables secTabsAnn = clazzToProcess.getAnnotation(\n \t\t\t\tjavax.persistence.SecondaryTables.class\n \t\t);\n \t\tentityBinder.firstLevelSecondaryTablesBinding( secTabAnn, secTabsAnn );\n \n \t\tOnDelete onDeleteAnn = clazzToProcess.getAnnotation( OnDelete.class );\n \t\tboolean onDeleteAppropriate = false;\n \t\tif ( InheritanceType.JOINED.equals( inheritanceState.getType() ) && inheritanceState.hasParents() ) {\n \t\t\tonDeleteAppropriate = true;\n \t\t\tfinal JoinedSubclass jsc = ( JoinedSubclass ) persistentClass;\n \t\t\tSimpleValue key = new DependantValue( mappings, jsc.getTable(), jsc.getIdentifier() );\n \t\t\tjsc.setKey( key );\n \t\t\tForeignKey fk = clazzToProcess.getAnnotation( ForeignKey.class );\n \t\t\tif ( fk != null && !BinderHelper.isEmptyAnnotationValue( fk.name() ) ) {\n \t\t\t\tkey.setForeignKeyName( fk.name() );\n \t\t\t}\n \t\t\tif ( onDeleteAnn != null ) {\n \t\t\t\tkey.setCascadeDeleteEnabled( OnDeleteAction.CASCADE.equals( onDeleteAnn.action() ) );\n \t\t\t}\n \t\t\telse {\n \t\t\t\tkey.setCascadeDeleteEnabled( false );\n \t\t\t}\n \t\t\t//we are never in a second pass at that stage, so queue it\n \t\t\tSecondPass sp = new JoinedSubclassFkSecondPass( jsc, inheritanceJoinedColumns, key, mappings );\n \t\t\tmappings.addSecondPass( sp );\n \t\t\tmappings.addSecondPass( new CreateKeySecondPass( jsc ) );\n \n \t\t}\n \t\telse if ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.getType() ) ) {\n \t\t\tif ( ! inheritanceState.hasParents() ) {\n \t\t\t\tif ( inheritanceState.hasSiblings() || !discriminatorColumn.isImplicit() ) {\n \t\t\t\t\t//need a discriminator column\n \t\t\t\t\tbindDiscriminatorToPersistentClass(\n \t\t\t\t\t\t\t( RootClass ) persistentClass,\n \t\t\t\t\t\t\tdiscriminatorColumn,\n \t\t\t\t\t\t\tentityBinder.getSecondaryTables(),\n \t\t\t\t\t\t\tpropertyHolder,\n \t\t\t\t\t\t\tmappings\n \t\t\t\t\t);\n \t\t\t\t\tentityBinder.bindDiscriminatorValue();//bind it again since the type might have changed\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\telse if ( InheritanceType.TABLE_PER_CLASS.equals( inheritanceState.getType() ) ) {\n \t\t\t//nothing to do\n \t\t}\n         if (onDeleteAnn != null && !onDeleteAppropriate) LOG.invalidOnDeleteAnnotation(propertyHolder.getEntityName());\n \n \t\t// try to find class level generators\n \t\tHashMap<String, IdGenerator> classGenerators = buildLocalGenerators( clazzToProcess, mappings );\n \n \t\t// check properties\n \t\tfinal InheritanceState.ElementsToProcess elementsToProcess = inheritanceState.getElementsToProcess();\n \t\tinheritanceState.postProcess( persistentClass, entityBinder );\n \n \t\tfinal boolean subclassAndSingleTableStrategy = inheritanceState.getType() == InheritanceType.SINGLE_TABLE\n \t\t\t\t&& inheritanceState.hasParents();\n \t\tSet<String> idPropertiesIfIdClass = new HashSet<String>();\n \t\tboolean isIdClass = mapAsIdClass(\n \t\t\t\tinheritanceStatePerClass,\n \t\t\t\tinheritanceState,\n \t\t\t\tpersistentClass,\n \t\t\t\tentityBinder,\n \t\t\t\tpropertyHolder,\n \t\t\t\telementsToProcess,\n \t\t\t\tidPropertiesIfIdClass,\n \t\t\t\tmappings\n \t\t);\n \n \t\tif ( !isIdClass ) {\n \t\t\tentityBinder.setWrapIdsInEmbeddedComponents( elementsToProcess.getIdPropertyCount() > 1 );\n \t\t}\n \n \t\tprocessIdPropertiesIfNotAlready(\n \t\t\t\tinheritanceStatePerClass,\n \t\t\t\tmappings,\n \t\t\t\tpersistentClass,\n \t\t\t\tentityBinder,\n \t\t\t\tpropertyHolder,\n \t\t\t\tclassGenerators,\n \t\t\t\telementsToProcess,\n \t\t\t\tsubclassAndSingleTableStrategy,\n \t\t\t\tidPropertiesIfIdClass\n \t\t);\n \n \t\tif ( !inheritanceState.hasParents() ) {\n \t\t\tfinal RootClass rootClass = ( RootClass ) persistentClass;\n \t\t\tmappings.addSecondPass( new CreateKeySecondPass( rootClass ) );\n \t\t}\n \t\telse {\n \t\t\tsuperEntity.addSubclass( ( Subclass ) persistentClass );\n \t\t}\n \n \t\tmappings.addClass( persistentClass );\n \n \t\t//Process secondary tables and complementary definitions (ie o.h.a.Table)\n \t\tmappings.addSecondPass( new SecondaryTableSecondPass( entityBinder, propertyHolder, clazzToProcess ) );\n \n \t\t//add process complementary Table definition (index & all)\n \t\tentityBinder.processComplementaryTableDefinitions( clazzToProcess.getAnnotation( org.hibernate.annotations.Table.class ) );\n \t\tentityBinder.processComplementaryTableDefinitions( clazzToProcess.getAnnotation( org.hibernate.annotations.Tables.class ) );\n \n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"c47352058541e14e0b80d38f94c65d939d5394f5": {
			"type": "Ybodychange",
			"commitMessage": "HHH-6974 Class level naturalId cache and stats\n\nAdd class level @NaturalIdCache annotation to denote if second level natualId caching should be done\nFlush out stats model for naturalId cache related stats\nAdd ehcache support classes for naturalId region\n",
			"commitDate": "2012-02-07, 6:34 AM",
			"commitName": "c47352058541e14e0b80d38f94c65d939d5394f5",
			"commitAuthor": "Eric Dalquist",
			"commitDateOld": "2011-11-23, 2:51 AM",
			"commitNameOld": "6c7379c38f8b6b43c13791b29cd09b1f4a26bd8e",
			"commitAuthorOld": "Sanne Grinovero",
			"daysBetweenCommits": 76.15,
			"commitsBetweenForRepo": 206,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,213 +1,214 @@\n \tpublic static void bindClass(\n \t\t\tXClass clazzToProcess,\n \t\t\tMap<XClass, InheritanceState> inheritanceStatePerClass,\n \t\t\tMappings mappings) throws MappingException {\n \t\t//@Entity and @MappedSuperclass on the same class leads to a NPE down the road\n \t\tif ( clazzToProcess.isAnnotationPresent( Entity.class )\n \t\t\t\t&&  clazzToProcess.isAnnotationPresent( MappedSuperclass.class ) ) {\n \t\t\tthrow new AnnotationException( \"An entity cannot be annotated with both @Entity and @MappedSuperclass: \"\n \t\t\t\t\t+ clazzToProcess.getName() );\n \t\t}\n \n \t\t//TODO: be more strict with secondarytable allowance (not for ids, not for secondary table join columns etc)\n \t\tInheritanceState inheritanceState = inheritanceStatePerClass.get( clazzToProcess );\n \t\tAnnotatedClassType classType = mappings.getClassType( clazzToProcess );\n \n \t\t//Queries declared in MappedSuperclass should be usable in Subclasses\n \t\tif ( AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals( classType ) ) {\n \t\t\tbindQueries( clazzToProcess, mappings );\n \t\t\tbindTypeDefs( clazzToProcess, mappings );\n \t\t\tbindFilterDefs( clazzToProcess, mappings );\n \t\t}\n \n \t\tif ( !isEntityClassType( clazzToProcess, classType ) ) {\n \t\t\treturn;\n \t\t}\n \n \t\tif ( LOG.isDebugEnabled() ) {\n \t\t\tLOG.debugf( \"Binding entity from annotated class: %s\", clazzToProcess.getName() );\n \t\t}\n \n \t\tPersistentClass superEntity = getSuperEntity(\n \t\t\t\tclazzToProcess, inheritanceStatePerClass, mappings, inheritanceState\n \t\t);\n \n \t\tPersistentClass persistentClass = makePersistentClass( inheritanceState, superEntity );\n \t\tEntity entityAnn = clazzToProcess.getAnnotation( Entity.class );\n \t\torg.hibernate.annotations.Entity hibEntityAnn = clazzToProcess.getAnnotation(\n \t\t\t\torg.hibernate.annotations.Entity.class\n \t\t);\n \t\tEntityBinder entityBinder = new EntityBinder(\n \t\t\t\tentityAnn, hibEntityAnn, clazzToProcess, persistentClass, mappings\n \t\t);\n \t\tentityBinder.setInheritanceState( inheritanceState );\n \n \t\tbindQueries( clazzToProcess, mappings );\n \t\tbindFilterDefs( clazzToProcess, mappings );\n \t\tbindTypeDefs( clazzToProcess, mappings );\n \t\tbindFetchProfiles( clazzToProcess, mappings );\n \t\tBinderHelper.bindAnyMetaDefs( clazzToProcess, mappings );\n \n \t\tString schema = \"\";\n \t\tString table = \"\"; //might be no @Table annotation on the annotated class\n \t\tString catalog = \"\";\n \t\tList<UniqueConstraintHolder> uniqueConstraints = new ArrayList<UniqueConstraintHolder>();\n \t\tif ( clazzToProcess.isAnnotationPresent( javax.persistence.Table.class ) ) {\n \t\t\tjavax.persistence.Table tabAnn = clazzToProcess.getAnnotation( javax.persistence.Table.class );\n \t\t\ttable = tabAnn.name();\n \t\t\tschema = tabAnn.schema();\n \t\t\tcatalog = tabAnn.catalog();\n \t\t\tuniqueConstraints = TableBinder.buildUniqueConstraintHolders( tabAnn.uniqueConstraints() );\n \t\t}\n \n \t\tEjb3JoinColumn[] inheritanceJoinedColumns = makeInheritanceJoinColumns(\n \t\t\t\tclazzToProcess, mappings, inheritanceState, superEntity\n \t\t);\n \t\tEjb3DiscriminatorColumn discriminatorColumn = null;\n \t\tif ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.getType() ) ) {\n \t\t\tdiscriminatorColumn = processDiscriminatorProperties(\n \t\t\t\t\tclazzToProcess, mappings, inheritanceState, entityBinder\n \t\t\t);\n \t\t}\n \n \t\tentityBinder.setProxy( clazzToProcess.getAnnotation( Proxy.class ) );\n \t\tentityBinder.setBatchSize( clazzToProcess.getAnnotation( BatchSize.class ) );\n \t\tentityBinder.setWhere( clazzToProcess.getAnnotation( Where.class ) );\n \t    entityBinder.setCache( determineCacheSettings( clazzToProcess, mappings ) );\n+\t    entityBinder.setNaturalIdCache( clazzToProcess.getAnnotation( NaturalIdCache.class ) );\n \n \t\t//Filters are not allowed on subclasses\n \t\tif ( !inheritanceState.hasParents() ) {\n \t\t\tbindFilters( clazzToProcess, entityBinder, mappings );\n \t\t}\n \n \t\tentityBinder.bindEntity();\n \n \t\tif ( inheritanceState.hasTable() ) {\n \t\t\tCheck checkAnn = clazzToProcess.getAnnotation( Check.class );\n \t\t\tString constraints = checkAnn == null ?\n \t\t\t\t\tnull :\n \t\t\t\t\tcheckAnn.constraints();\n \t\t\tentityBinder.bindTable(\n \t\t\t\t\tschema, catalog, table, uniqueConstraints,\n \t\t\t\t\tconstraints, inheritanceState.hasDenormalizedTable() ?\n \t\t\t\t\t\t\tsuperEntity.getTable() :\n \t\t\t\t\t\t\tnull\n \t\t\t);\n \t\t}\n \t\telse if ( clazzToProcess.isAnnotationPresent( Table.class ) ) {\n \t\t\tLOG.invalidTableAnnotation( clazzToProcess.getName() );\n \t\t}\n \n \n \t\tPropertyHolder propertyHolder = PropertyHolderBuilder.buildPropertyHolder(\n \t\t\t\tclazzToProcess,\n \t\t\t\tpersistentClass,\n \t\t\t\tentityBinder, mappings, inheritanceStatePerClass\n \t\t);\n \n \t\tjavax.persistence.SecondaryTable secTabAnn = clazzToProcess.getAnnotation(\n \t\t\t\tjavax.persistence.SecondaryTable.class\n \t\t);\n \t\tjavax.persistence.SecondaryTables secTabsAnn = clazzToProcess.getAnnotation(\n \t\t\t\tjavax.persistence.SecondaryTables.class\n \t\t);\n \t\tentityBinder.firstLevelSecondaryTablesBinding( secTabAnn, secTabsAnn );\n \n \t\tOnDelete onDeleteAnn = clazzToProcess.getAnnotation( OnDelete.class );\n \t\tboolean onDeleteAppropriate = false;\n \t\tif ( InheritanceType.JOINED.equals( inheritanceState.getType() ) && inheritanceState.hasParents() ) {\n \t\t\tonDeleteAppropriate = true;\n \t\t\tfinal JoinedSubclass jsc = ( JoinedSubclass ) persistentClass;\n \t\t\tSimpleValue key = new DependantValue( mappings, jsc.getTable(), jsc.getIdentifier() );\n \t\t\tjsc.setKey( key );\n \t\t\tForeignKey fk = clazzToProcess.getAnnotation( ForeignKey.class );\n \t\t\tif ( fk != null && !BinderHelper.isEmptyAnnotationValue( fk.name() ) ) {\n \t\t\t\tkey.setForeignKeyName( fk.name() );\n \t\t\t}\n \t\t\tif ( onDeleteAnn != null ) {\n \t\t\t\tkey.setCascadeDeleteEnabled( OnDeleteAction.CASCADE.equals( onDeleteAnn.action() ) );\n \t\t\t}\n \t\t\telse {\n \t\t\t\tkey.setCascadeDeleteEnabled( false );\n \t\t\t}\n \t\t\t//we are never in a second pass at that stage, so queue it\n \t\t\tSecondPass sp = new JoinedSubclassFkSecondPass( jsc, inheritanceJoinedColumns, key, mappings );\n \t\t\tmappings.addSecondPass( sp );\n \t\t\tmappings.addSecondPass( new CreateKeySecondPass( jsc ) );\n \n \t\t}\n \t\telse if ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.getType() ) ) {\n \t\t\tif ( ! inheritanceState.hasParents() ) {\n \t\t\t\tif ( inheritanceState.hasSiblings() || !discriminatorColumn.isImplicit() ) {\n \t\t\t\t\t//need a discriminator column\n \t\t\t\t\tbindDiscriminatorToPersistentClass(\n \t\t\t\t\t\t\t( RootClass ) persistentClass,\n \t\t\t\t\t\t\tdiscriminatorColumn,\n \t\t\t\t\t\t\tentityBinder.getSecondaryTables(),\n \t\t\t\t\t\t\tpropertyHolder,\n \t\t\t\t\t\t\tmappings\n \t\t\t\t\t);\n \t\t\t\t\tentityBinder.bindDiscriminatorValue();//bind it again since the type might have changed\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\telse if ( InheritanceType.TABLE_PER_CLASS.equals( inheritanceState.getType() ) ) {\n \t\t\t//nothing to do\n \t\t}\n         if (onDeleteAnn != null && !onDeleteAppropriate) LOG.invalidOnDeleteAnnotation(propertyHolder.getEntityName());\n \n \t\t// try to find class level generators\n \t\tHashMap<String, IdGenerator> classGenerators = buildLocalGenerators( clazzToProcess, mappings );\n \n \t\t// check properties\n \t\tfinal InheritanceState.ElementsToProcess elementsToProcess = inheritanceState.getElementsToProcess();\n \t\tinheritanceState.postProcess( persistentClass, entityBinder );\n \n \t\tfinal boolean subclassAndSingleTableStrategy = inheritanceState.getType() == InheritanceType.SINGLE_TABLE\n \t\t\t\t&& inheritanceState.hasParents();\n \t\tSet<String> idPropertiesIfIdClass = new HashSet<String>();\n \t\tboolean isIdClass = mapAsIdClass(\n \t\t\t\tinheritanceStatePerClass,\n \t\t\t\tinheritanceState,\n \t\t\t\tpersistentClass,\n \t\t\t\tentityBinder,\n \t\t\t\tpropertyHolder,\n \t\t\t\telementsToProcess,\n \t\t\t\tidPropertiesIfIdClass,\n \t\t\t\tmappings\n \t\t);\n \n \t\tif ( !isIdClass ) {\n \t\t\tentityBinder.setWrapIdsInEmbeddedComponents( elementsToProcess.getIdPropertyCount() > 1 );\n \t\t}\n \n \t\tprocessIdPropertiesIfNotAlready(\n \t\t\t\tinheritanceStatePerClass,\n \t\t\t\tmappings,\n \t\t\t\tpersistentClass,\n \t\t\t\tentityBinder,\n \t\t\t\tpropertyHolder,\n \t\t\t\tclassGenerators,\n \t\t\t\telementsToProcess,\n \t\t\t\tsubclassAndSingleTableStrategy,\n \t\t\t\tidPropertiesIfIdClass\n \t\t);\n \n \t\tif ( !inheritanceState.hasParents() ) {\n \t\t\tfinal RootClass rootClass = ( RootClass ) persistentClass;\n \t\t\tmappings.addSecondPass( new CreateKeySecondPass( rootClass ) );\n \t\t}\n \t\telse {\n \t\t\tsuperEntity.addSubclass( ( Subclass ) persistentClass );\n \t\t}\n \n \t\tmappings.addClass( persistentClass );\n \n \t\t//Process secondary tables and complementary definitions (ie o.h.a.Table)\n \t\tmappings.addSecondPass( new SecondaryTableSecondPass( entityBinder, propertyHolder, clazzToProcess ) );\n \n \t\t//add process complementary Table definition (index & all)\n \t\tentityBinder.processComplementaryTableDefinitions( clazzToProcess.getAnnotation( org.hibernate.annotations.Table.class ) );\n \t\tentityBinder.processComplementaryTableDefinitions( clazzToProcess.getAnnotation( org.hibernate.annotations.Tables.class ) );\n \n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"129c0f13482b99e2705f0e234b6bc0572a95c271": {
			"type": "Ybodychange",
			"commitMessage": "HHH-6732 more logging trace statements are missing guards against unneeded string creation\n",
			"commitDate": "2011-10-26, 3:24 PM",
			"commitName": "129c0f13482b99e2705f0e234b6bc0572a95c271",
			"commitAuthor": "Sanne Grinovero",
			"commitDateOld": "2011-10-24, 1:26 AM",
			"commitNameOld": "bdba5898c90ef7667e7c5df35e72d2e993e32556",
			"commitAuthorOld": "Strong Liu",
			"daysBetweenCommits": 2.58,
			"commitsBetweenForRepo": 26,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,208 +1,213 @@\n \tpublic static void bindClass(\n \t\t\tXClass clazzToProcess,\n \t\t\tMap<XClass, InheritanceState> inheritanceStatePerClass,\n \t\t\tMappings mappings) throws MappingException {\n \t\t//@Entity and @MappedSuperclass on the same class leads to a NPE down the road\n \t\tif ( clazzToProcess.isAnnotationPresent( Entity.class )\n \t\t\t\t&&  clazzToProcess.isAnnotationPresent( MappedSuperclass.class ) ) {\n \t\t\tthrow new AnnotationException( \"An entity cannot be annotated with both @Entity and @MappedSuperclass: \"\n \t\t\t\t\t+ clazzToProcess.getName() );\n \t\t}\n \n \t\t//TODO: be more strict with secondarytable allowance (not for ids, not for secondary table join columns etc)\n \t\tInheritanceState inheritanceState = inheritanceStatePerClass.get( clazzToProcess );\n \t\tAnnotatedClassType classType = mappings.getClassType( clazzToProcess );\n \n \t\t//Queries declared in MappedSuperclass should be usable in Subclasses\n \t\tif ( AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals( classType ) ) {\n \t\t\tbindQueries( clazzToProcess, mappings );\n \t\t\tbindTypeDefs( clazzToProcess, mappings );\n \t\t\tbindFilterDefs( clazzToProcess, mappings );\n \t\t}\n \n \t\tif ( !isEntityClassType( clazzToProcess, classType ) ) {\n \t\t\treturn;\n \t\t}\n \n-        LOG.debugf( \"Binding entity from annotated class: %s\", clazzToProcess.getName() );\n+\t\tif ( LOG.isDebugEnabled() ) {\n+\t\t\tLOG.debugf( \"Binding entity from annotated class: %s\", clazzToProcess.getName() );\n+\t\t}\n \n \t\tPersistentClass superEntity = getSuperEntity(\n \t\t\t\tclazzToProcess, inheritanceStatePerClass, mappings, inheritanceState\n \t\t);\n \n \t\tPersistentClass persistentClass = makePersistentClass( inheritanceState, superEntity );\n \t\tEntity entityAnn = clazzToProcess.getAnnotation( Entity.class );\n \t\torg.hibernate.annotations.Entity hibEntityAnn = clazzToProcess.getAnnotation(\n \t\t\t\torg.hibernate.annotations.Entity.class\n \t\t);\n \t\tEntityBinder entityBinder = new EntityBinder(\n \t\t\t\tentityAnn, hibEntityAnn, clazzToProcess, persistentClass, mappings\n \t\t);\n \t\tentityBinder.setInheritanceState( inheritanceState );\n \n \t\tbindQueries( clazzToProcess, mappings );\n \t\tbindFilterDefs( clazzToProcess, mappings );\n \t\tbindTypeDefs( clazzToProcess, mappings );\n \t\tbindFetchProfiles( clazzToProcess, mappings );\n \t\tBinderHelper.bindAnyMetaDefs( clazzToProcess, mappings );\n \n \t\tString schema = \"\";\n \t\tString table = \"\"; //might be no @Table annotation on the annotated class\n \t\tString catalog = \"\";\n \t\tList<UniqueConstraintHolder> uniqueConstraints = new ArrayList<UniqueConstraintHolder>();\n \t\tif ( clazzToProcess.isAnnotationPresent( javax.persistence.Table.class ) ) {\n \t\t\tjavax.persistence.Table tabAnn = clazzToProcess.getAnnotation( javax.persistence.Table.class );\n \t\t\ttable = tabAnn.name();\n \t\t\tschema = tabAnn.schema();\n \t\t\tcatalog = tabAnn.catalog();\n \t\t\tuniqueConstraints = TableBinder.buildUniqueConstraintHolders( tabAnn.uniqueConstraints() );\n \t\t}\n \n \t\tEjb3JoinColumn[] inheritanceJoinedColumns = makeInheritanceJoinColumns(\n \t\t\t\tclazzToProcess, mappings, inheritanceState, superEntity\n \t\t);\n \t\tEjb3DiscriminatorColumn discriminatorColumn = null;\n \t\tif ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.getType() ) ) {\n \t\t\tdiscriminatorColumn = processDiscriminatorProperties(\n \t\t\t\t\tclazzToProcess, mappings, inheritanceState, entityBinder\n \t\t\t);\n \t\t}\n \n \t\tentityBinder.setProxy( clazzToProcess.getAnnotation( Proxy.class ) );\n \t\tentityBinder.setBatchSize( clazzToProcess.getAnnotation( BatchSize.class ) );\n \t\tentityBinder.setWhere( clazzToProcess.getAnnotation( Where.class ) );\n \t    entityBinder.setCache( determineCacheSettings( clazzToProcess, mappings ) );\n \n \t\t//Filters are not allowed on subclasses\n \t\tif ( !inheritanceState.hasParents() ) {\n \t\t\tbindFilters( clazzToProcess, entityBinder, mappings );\n \t\t}\n \n \t\tentityBinder.bindEntity();\n \n \t\tif ( inheritanceState.hasTable() ) {\n \t\t\tCheck checkAnn = clazzToProcess.getAnnotation( Check.class );\n \t\t\tString constraints = checkAnn == null ?\n \t\t\t\t\tnull :\n \t\t\t\t\tcheckAnn.constraints();\n \t\t\tentityBinder.bindTable(\n \t\t\t\t\tschema, catalog, table, uniqueConstraints,\n \t\t\t\t\tconstraints, inheritanceState.hasDenormalizedTable() ?\n \t\t\t\t\t\t\tsuperEntity.getTable() :\n \t\t\t\t\t\t\tnull\n \t\t\t);\n-        } else if (clazzToProcess.isAnnotationPresent(Table.class)) LOG.invalidTableAnnotation(clazzToProcess.getName());\n+\t\t}\n+\t\telse if ( clazzToProcess.isAnnotationPresent( Table.class ) ) {\n+\t\t\tLOG.invalidTableAnnotation( clazzToProcess.getName() );\n+\t\t}\n \n \n \t\tPropertyHolder propertyHolder = PropertyHolderBuilder.buildPropertyHolder(\n \t\t\t\tclazzToProcess,\n \t\t\t\tpersistentClass,\n \t\t\t\tentityBinder, mappings, inheritanceStatePerClass\n \t\t);\n \n \t\tjavax.persistence.SecondaryTable secTabAnn = clazzToProcess.getAnnotation(\n \t\t\t\tjavax.persistence.SecondaryTable.class\n \t\t);\n \t\tjavax.persistence.SecondaryTables secTabsAnn = clazzToProcess.getAnnotation(\n \t\t\t\tjavax.persistence.SecondaryTables.class\n \t\t);\n \t\tentityBinder.firstLevelSecondaryTablesBinding( secTabAnn, secTabsAnn );\n \n \t\tOnDelete onDeleteAnn = clazzToProcess.getAnnotation( OnDelete.class );\n \t\tboolean onDeleteAppropriate = false;\n \t\tif ( InheritanceType.JOINED.equals( inheritanceState.getType() ) && inheritanceState.hasParents() ) {\n \t\t\tonDeleteAppropriate = true;\n \t\t\tfinal JoinedSubclass jsc = ( JoinedSubclass ) persistentClass;\n \t\t\tSimpleValue key = new DependantValue( mappings, jsc.getTable(), jsc.getIdentifier() );\n \t\t\tjsc.setKey( key );\n \t\t\tForeignKey fk = clazzToProcess.getAnnotation( ForeignKey.class );\n \t\t\tif ( fk != null && !BinderHelper.isEmptyAnnotationValue( fk.name() ) ) {\n \t\t\t\tkey.setForeignKeyName( fk.name() );\n \t\t\t}\n \t\t\tif ( onDeleteAnn != null ) {\n \t\t\t\tkey.setCascadeDeleteEnabled( OnDeleteAction.CASCADE.equals( onDeleteAnn.action() ) );\n \t\t\t}\n \t\t\telse {\n \t\t\t\tkey.setCascadeDeleteEnabled( false );\n \t\t\t}\n \t\t\t//we are never in a second pass at that stage, so queue it\n \t\t\tSecondPass sp = new JoinedSubclassFkSecondPass( jsc, inheritanceJoinedColumns, key, mappings );\n \t\t\tmappings.addSecondPass( sp );\n \t\t\tmappings.addSecondPass( new CreateKeySecondPass( jsc ) );\n \n \t\t}\n \t\telse if ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.getType() ) ) {\n \t\t\tif ( ! inheritanceState.hasParents() ) {\n \t\t\t\tif ( inheritanceState.hasSiblings() || !discriminatorColumn.isImplicit() ) {\n \t\t\t\t\t//need a discriminator column\n \t\t\t\t\tbindDiscriminatorToPersistentClass(\n \t\t\t\t\t\t\t( RootClass ) persistentClass,\n \t\t\t\t\t\t\tdiscriminatorColumn,\n \t\t\t\t\t\t\tentityBinder.getSecondaryTables(),\n \t\t\t\t\t\t\tpropertyHolder,\n \t\t\t\t\t\t\tmappings\n \t\t\t\t\t);\n \t\t\t\t\tentityBinder.bindDiscriminatorValue();//bind it again since the type might have changed\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\telse if ( InheritanceType.TABLE_PER_CLASS.equals( inheritanceState.getType() ) ) {\n \t\t\t//nothing to do\n \t\t}\n         if (onDeleteAnn != null && !onDeleteAppropriate) LOG.invalidOnDeleteAnnotation(propertyHolder.getEntityName());\n \n \t\t// try to find class level generators\n \t\tHashMap<String, IdGenerator> classGenerators = buildLocalGenerators( clazzToProcess, mappings );\n \n \t\t// check properties\n \t\tfinal InheritanceState.ElementsToProcess elementsToProcess = inheritanceState.getElementsToProcess();\n \t\tinheritanceState.postProcess( persistentClass, entityBinder );\n \n \t\tfinal boolean subclassAndSingleTableStrategy = inheritanceState.getType() == InheritanceType.SINGLE_TABLE\n \t\t\t\t&& inheritanceState.hasParents();\n \t\tSet<String> idPropertiesIfIdClass = new HashSet<String>();\n \t\tboolean isIdClass = mapAsIdClass(\n \t\t\t\tinheritanceStatePerClass,\n \t\t\t\tinheritanceState,\n \t\t\t\tpersistentClass,\n \t\t\t\tentityBinder,\n \t\t\t\tpropertyHolder,\n \t\t\t\telementsToProcess,\n \t\t\t\tidPropertiesIfIdClass,\n \t\t\t\tmappings\n \t\t);\n \n \t\tif ( !isIdClass ) {\n \t\t\tentityBinder.setWrapIdsInEmbeddedComponents( elementsToProcess.getIdPropertyCount() > 1 );\n \t\t}\n \n \t\tprocessIdPropertiesIfNotAlready(\n \t\t\t\tinheritanceStatePerClass,\n \t\t\t\tmappings,\n \t\t\t\tpersistentClass,\n \t\t\t\tentityBinder,\n \t\t\t\tpropertyHolder,\n \t\t\t\tclassGenerators,\n \t\t\t\telementsToProcess,\n \t\t\t\tsubclassAndSingleTableStrategy,\n \t\t\t\tidPropertiesIfIdClass\n \t\t);\n \n \t\tif ( !inheritanceState.hasParents() ) {\n \t\t\tfinal RootClass rootClass = ( RootClass ) persistentClass;\n \t\t\tmappings.addSecondPass( new CreateKeySecondPass( rootClass ) );\n \t\t}\n \t\telse {\n \t\t\tsuperEntity.addSubclass( ( Subclass ) persistentClass );\n \t\t}\n \n \t\tmappings.addClass( persistentClass );\n \n \t\t//Process secondary tables and complementary definitions (ie o.h.a.Table)\n \t\tmappings.addSecondPass( new SecondaryTableSecondPass( entityBinder, propertyHolder, clazzToProcess ) );\n \n \t\t//add process complementary Table definition (index & all)\n \t\tentityBinder.processComplementaryTableDefinitions( clazzToProcess.getAnnotation( org.hibernate.annotations.Table.class ) );\n \t\tentityBinder.processComplementaryTableDefinitions( clazzToProcess.getAnnotation( org.hibernate.annotations.Tables.class ) );\n \n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"a351c520205d18f18bc1c47091b4a62629f19de1": {
			"type": "Ybodychange",
			"commitMessage": "HHH-6724 Move persister binding for class hierarchies to PersisterClassResolver out of {Hbm|Annotation}Binder",
			"commitDate": "2011-10-11, 5:13 PM",
			"commitName": "a351c520205d18f18bc1c47091b4a62629f19de1",
			"commitAuthor": "Emmanuel Bernard",
			"commitDateOld": "2011-06-28, 1:29 AM",
			"commitNameOld": "ffb14b28b72c67dc2d658bfeb89545ca16eb3399",
			"commitAuthorOld": "Strong Liu",
			"daysBetweenCommits": 105.66,
			"commitsBetweenForRepo": 324,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,220 +1,208 @@\n \tpublic static void bindClass(\n \t\t\tXClass clazzToProcess,\n \t\t\tMap<XClass, InheritanceState> inheritanceStatePerClass,\n \t\t\tMappings mappings) throws MappingException {\n \t\t//@Entity and @MappedSuperclass on the same class leads to a NPE down the road\n \t\tif ( clazzToProcess.isAnnotationPresent( Entity.class )\n \t\t\t\t&&  clazzToProcess.isAnnotationPresent( MappedSuperclass.class ) ) {\n \t\t\tthrow new AnnotationException( \"An entity cannot be annotated with both @Entity and @MappedSuperclass: \"\n \t\t\t\t\t+ clazzToProcess.getName() );\n \t\t}\n \n \t\t//TODO: be more strict with secondarytable allowance (not for ids, not for secondary table join columns etc)\n \t\tInheritanceState inheritanceState = inheritanceStatePerClass.get( clazzToProcess );\n \t\tAnnotatedClassType classType = mappings.getClassType( clazzToProcess );\n \n \t\t//Queries declared in MappedSuperclass should be usable in Subclasses\n \t\tif ( AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals( classType ) ) {\n \t\t\tbindQueries( clazzToProcess, mappings );\n \t\t\tbindTypeDefs( clazzToProcess, mappings );\n \t\t\tbindFilterDefs( clazzToProcess, mappings );\n \t\t}\n \n \t\tif ( !isEntityClassType( clazzToProcess, classType ) ) {\n \t\t\treturn;\n \t\t}\n \n         LOG.debugf( \"Binding entity from annotated class: %s\", clazzToProcess.getName() );\n \n \t\tPersistentClass superEntity = getSuperEntity(\n \t\t\t\tclazzToProcess, inheritanceStatePerClass, mappings, inheritanceState\n \t\t);\n \n \t\tPersistentClass persistentClass = makePersistentClass( inheritanceState, superEntity );\n \t\tEntity entityAnn = clazzToProcess.getAnnotation( Entity.class );\n \t\torg.hibernate.annotations.Entity hibEntityAnn = clazzToProcess.getAnnotation(\n \t\t\t\torg.hibernate.annotations.Entity.class\n \t\t);\n \t\tEntityBinder entityBinder = new EntityBinder(\n \t\t\t\tentityAnn, hibEntityAnn, clazzToProcess, persistentClass, mappings\n \t\t);\n \t\tentityBinder.setInheritanceState( inheritanceState );\n \n \t\tbindQueries( clazzToProcess, mappings );\n \t\tbindFilterDefs( clazzToProcess, mappings );\n \t\tbindTypeDefs( clazzToProcess, mappings );\n \t\tbindFetchProfiles( clazzToProcess, mappings );\n \t\tBinderHelper.bindAnyMetaDefs( clazzToProcess, mappings );\n \n \t\tString schema = \"\";\n \t\tString table = \"\"; //might be no @Table annotation on the annotated class\n \t\tString catalog = \"\";\n \t\tList<UniqueConstraintHolder> uniqueConstraints = new ArrayList<UniqueConstraintHolder>();\n \t\tif ( clazzToProcess.isAnnotationPresent( javax.persistence.Table.class ) ) {\n \t\t\tjavax.persistence.Table tabAnn = clazzToProcess.getAnnotation( javax.persistence.Table.class );\n \t\t\ttable = tabAnn.name();\n \t\t\tschema = tabAnn.schema();\n \t\t\tcatalog = tabAnn.catalog();\n \t\t\tuniqueConstraints = TableBinder.buildUniqueConstraintHolders( tabAnn.uniqueConstraints() );\n \t\t}\n \n \t\tEjb3JoinColumn[] inheritanceJoinedColumns = makeInheritanceJoinColumns(\n \t\t\t\tclazzToProcess, mappings, inheritanceState, superEntity\n \t\t);\n \t\tEjb3DiscriminatorColumn discriminatorColumn = null;\n \t\tif ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.getType() ) ) {\n \t\t\tdiscriminatorColumn = processDiscriminatorProperties(\n \t\t\t\t\tclazzToProcess, mappings, inheritanceState, entityBinder\n \t\t\t);\n \t\t}\n \n \t\tentityBinder.setProxy( clazzToProcess.getAnnotation( Proxy.class ) );\n \t\tentityBinder.setBatchSize( clazzToProcess.getAnnotation( BatchSize.class ) );\n \t\tentityBinder.setWhere( clazzToProcess.getAnnotation( Where.class ) );\n \t    entityBinder.setCache( determineCacheSettings( clazzToProcess, mappings ) );\n \n \t\t//Filters are not allowed on subclasses\n \t\tif ( !inheritanceState.hasParents() ) {\n \t\t\tbindFilters( clazzToProcess, entityBinder, mappings );\n \t\t}\n \n \t\tentityBinder.bindEntity();\n \n \t\tif ( inheritanceState.hasTable() ) {\n \t\t\tCheck checkAnn = clazzToProcess.getAnnotation( Check.class );\n \t\t\tString constraints = checkAnn == null ?\n \t\t\t\t\tnull :\n \t\t\t\t\tcheckAnn.constraints();\n \t\t\tentityBinder.bindTable(\n \t\t\t\t\tschema, catalog, table, uniqueConstraints,\n \t\t\t\t\tconstraints, inheritanceState.hasDenormalizedTable() ?\n \t\t\t\t\t\t\tsuperEntity.getTable() :\n \t\t\t\t\t\t\tnull\n \t\t\t);\n         } else if (clazzToProcess.isAnnotationPresent(Table.class)) LOG.invalidTableAnnotation(clazzToProcess.getName());\n \n \n \t\tPropertyHolder propertyHolder = PropertyHolderBuilder.buildPropertyHolder(\n \t\t\t\tclazzToProcess,\n \t\t\t\tpersistentClass,\n \t\t\t\tentityBinder, mappings, inheritanceStatePerClass\n \t\t);\n \n \t\tjavax.persistence.SecondaryTable secTabAnn = clazzToProcess.getAnnotation(\n \t\t\t\tjavax.persistence.SecondaryTable.class\n \t\t);\n \t\tjavax.persistence.SecondaryTables secTabsAnn = clazzToProcess.getAnnotation(\n \t\t\t\tjavax.persistence.SecondaryTables.class\n \t\t);\n \t\tentityBinder.firstLevelSecondaryTablesBinding( secTabAnn, secTabsAnn );\n \n \t\tOnDelete onDeleteAnn = clazzToProcess.getAnnotation( OnDelete.class );\n \t\tboolean onDeleteAppropriate = false;\n \t\tif ( InheritanceType.JOINED.equals( inheritanceState.getType() ) && inheritanceState.hasParents() ) {\n \t\t\tonDeleteAppropriate = true;\n \t\t\tfinal JoinedSubclass jsc = ( JoinedSubclass ) persistentClass;\n-\t\t\tif ( persistentClass.getEntityPersisterClass() == null ) {\n-\t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( JoinedSubclassEntityPersister.class );\n-\t\t\t}\n \t\t\tSimpleValue key = new DependantValue( mappings, jsc.getTable(), jsc.getIdentifier() );\n \t\t\tjsc.setKey( key );\n \t\t\tForeignKey fk = clazzToProcess.getAnnotation( ForeignKey.class );\n \t\t\tif ( fk != null && !BinderHelper.isEmptyAnnotationValue( fk.name() ) ) {\n \t\t\t\tkey.setForeignKeyName( fk.name() );\n \t\t\t}\n \t\t\tif ( onDeleteAnn != null ) {\n \t\t\t\tkey.setCascadeDeleteEnabled( OnDeleteAction.CASCADE.equals( onDeleteAnn.action() ) );\n \t\t\t}\n \t\t\telse {\n \t\t\t\tkey.setCascadeDeleteEnabled( false );\n \t\t\t}\n \t\t\t//we are never in a second pass at that stage, so queue it\n \t\t\tSecondPass sp = new JoinedSubclassFkSecondPass( jsc, inheritanceJoinedColumns, key, mappings );\n \t\t\tmappings.addSecondPass( sp );\n \t\t\tmappings.addSecondPass( new CreateKeySecondPass( jsc ) );\n \n \t\t}\n \t\telse if ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.getType() ) ) {\n-\t\t\tif ( inheritanceState.hasParents() ) {\n-\t\t\t\tif ( persistentClass.getEntityPersisterClass() == null ) {\n-\t\t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( SingleTableEntityPersister.class );\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\telse {\n+\t\t\tif ( ! inheritanceState.hasParents() ) {\n \t\t\t\tif ( inheritanceState.hasSiblings() || !discriminatorColumn.isImplicit() ) {\n \t\t\t\t\t//need a discriminator column\n \t\t\t\t\tbindDiscriminatorToPersistentClass(\n \t\t\t\t\t\t\t( RootClass ) persistentClass,\n \t\t\t\t\t\t\tdiscriminatorColumn,\n \t\t\t\t\t\t\tentityBinder.getSecondaryTables(),\n \t\t\t\t\t\t\tpropertyHolder,\n \t\t\t\t\t\t\tmappings\n \t\t\t\t\t);\n \t\t\t\t\tentityBinder.bindDiscriminatorValue();//bind it again since the type might have changed\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\telse if ( InheritanceType.TABLE_PER_CLASS.equals( inheritanceState.getType() ) ) {\n-\t\t\tif ( inheritanceState.hasParents() ) {\n-\t\t\t\tif ( persistentClass.getEntityPersisterClass() == null ) {\n-\t\t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( UnionSubclassEntityPersister.class );\n-\t\t\t\t}\n-\t\t\t}\n+\t\t\t//nothing to do\n \t\t}\n         if (onDeleteAnn != null && !onDeleteAppropriate) LOG.invalidOnDeleteAnnotation(propertyHolder.getEntityName());\n \n \t\t// try to find class level generators\n \t\tHashMap<String, IdGenerator> classGenerators = buildLocalGenerators( clazzToProcess, mappings );\n \n \t\t// check properties\n \t\tfinal InheritanceState.ElementsToProcess elementsToProcess = inheritanceState.getElementsToProcess();\n \t\tinheritanceState.postProcess( persistentClass, entityBinder );\n \n \t\tfinal boolean subclassAndSingleTableStrategy = inheritanceState.getType() == InheritanceType.SINGLE_TABLE\n \t\t\t\t&& inheritanceState.hasParents();\n \t\tSet<String> idPropertiesIfIdClass = new HashSet<String>();\n \t\tboolean isIdClass = mapAsIdClass(\n \t\t\t\tinheritanceStatePerClass,\n \t\t\t\tinheritanceState,\n \t\t\t\tpersistentClass,\n \t\t\t\tentityBinder,\n \t\t\t\tpropertyHolder,\n \t\t\t\telementsToProcess,\n \t\t\t\tidPropertiesIfIdClass,\n \t\t\t\tmappings\n \t\t);\n \n \t\tif ( !isIdClass ) {\n \t\t\tentityBinder.setWrapIdsInEmbeddedComponents( elementsToProcess.getIdPropertyCount() > 1 );\n \t\t}\n \n \t\tprocessIdPropertiesIfNotAlready(\n \t\t\t\tinheritanceStatePerClass,\n \t\t\t\tmappings,\n \t\t\t\tpersistentClass,\n \t\t\t\tentityBinder,\n \t\t\t\tpropertyHolder,\n \t\t\t\tclassGenerators,\n \t\t\t\telementsToProcess,\n \t\t\t\tsubclassAndSingleTableStrategy,\n \t\t\t\tidPropertiesIfIdClass\n \t\t);\n \n \t\tif ( !inheritanceState.hasParents() ) {\n \t\t\tfinal RootClass rootClass = ( RootClass ) persistentClass;\n \t\t\tmappings.addSecondPass( new CreateKeySecondPass( rootClass ) );\n \t\t}\n \t\telse {\n \t\t\tsuperEntity.addSubclass( ( Subclass ) persistentClass );\n \t\t}\n \n \t\tmappings.addClass( persistentClass );\n \n \t\t//Process secondary tables and complementary definitions (ie o.h.a.Table)\n \t\tmappings.addSecondPass( new SecondaryTableSecondPass( entityBinder, propertyHolder, clazzToProcess ) );\n \n \t\t//add process complementary Table definition (index & all)\n \t\tentityBinder.processComplementaryTableDefinitions( clazzToProcess.getAnnotation( org.hibernate.annotations.Table.class ) );\n \t\tentityBinder.processComplementaryTableDefinitions( clazzToProcess.getAnnotation( org.hibernate.annotations.Tables.class ) );\n \n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"ad17f89c4c29f0327c843cf5265e156d65743ab1": {
			"type": "Ybodychange",
			"commitMessage": "HHH-6097 - Review log levels, especially related to i18n messages\n",
			"commitDate": "2011-04-12, 7:07 AM",
			"commitName": "ad17f89c4c29f0327c843cf5265e156d65743ab1",
			"commitAuthor": "Steve Ebersole",
			"commitDateOld": "2011-04-11, 7:59 PM",
			"commitNameOld": "62da5aa5bc2600252399060a0c48d32505b879ac",
			"commitAuthorOld": "Steve Ebersole",
			"daysBetweenCommits": 0.46,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,220 +1,220 @@\n \tpublic static void bindClass(\n \t\t\tXClass clazzToProcess,\n \t\t\tMap<XClass, InheritanceState> inheritanceStatePerClass,\n \t\t\tMappings mappings) throws MappingException {\n \t\t//@Entity and @MappedSuperclass on the same class leads to a NPE down the road\n \t\tif ( clazzToProcess.isAnnotationPresent( Entity.class )\n \t\t\t\t&&  clazzToProcess.isAnnotationPresent( MappedSuperclass.class ) ) {\n \t\t\tthrow new AnnotationException( \"An entity cannot be annotated with both @Entity and @MappedSuperclass: \"\n \t\t\t\t\t+ clazzToProcess.getName() );\n \t\t}\n \n \t\t//TODO: be more strict with secondarytable allowance (not for ids, not for secondary table join columns etc)\n \t\tInheritanceState inheritanceState = inheritanceStatePerClass.get( clazzToProcess );\n \t\tAnnotatedClassType classType = mappings.getClassType( clazzToProcess );\n \n \t\t//Queries declared in MappedSuperclass should be usable in Subclasses\n \t\tif ( AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals( classType ) ) {\n \t\t\tbindQueries( clazzToProcess, mappings );\n \t\t\tbindTypeDefs( clazzToProcess, mappings );\n \t\t\tbindFilterDefs( clazzToProcess, mappings );\n \t\t}\n \n \t\tif ( !isEntityClassType( clazzToProcess, classType ) ) {\n \t\t\treturn;\n \t\t}\n \n-        LOG.bindingEntityFromClass( clazzToProcess.getName() );\n+        LOG.debugf( \"Binding entity from annotated class: %s\", clazzToProcess.getName() );\n \n \t\tPersistentClass superEntity = getSuperEntity(\n \t\t\t\tclazzToProcess, inheritanceStatePerClass, mappings, inheritanceState\n \t\t);\n \n \t\tPersistentClass persistentClass = makePersistentClass( inheritanceState, superEntity );\n \t\tEntity entityAnn = clazzToProcess.getAnnotation( Entity.class );\n \t\torg.hibernate.annotations.Entity hibEntityAnn = clazzToProcess.getAnnotation(\n \t\t\t\torg.hibernate.annotations.Entity.class\n \t\t);\n \t\tEntityBinder entityBinder = new EntityBinder(\n \t\t\t\tentityAnn, hibEntityAnn, clazzToProcess, persistentClass, mappings\n \t\t);\n \t\tentityBinder.setInheritanceState( inheritanceState );\n \n \t\tbindQueries( clazzToProcess, mappings );\n \t\tbindFilterDefs( clazzToProcess, mappings );\n \t\tbindTypeDefs( clazzToProcess, mappings );\n \t\tbindFetchProfiles( clazzToProcess, mappings );\n \t\tBinderHelper.bindAnyMetaDefs( clazzToProcess, mappings );\n \n \t\tString schema = \"\";\n \t\tString table = \"\"; //might be no @Table annotation on the annotated class\n \t\tString catalog = \"\";\n \t\tList<UniqueConstraintHolder> uniqueConstraints = new ArrayList<UniqueConstraintHolder>();\n \t\tif ( clazzToProcess.isAnnotationPresent( javax.persistence.Table.class ) ) {\n \t\t\tjavax.persistence.Table tabAnn = clazzToProcess.getAnnotation( javax.persistence.Table.class );\n \t\t\ttable = tabAnn.name();\n \t\t\tschema = tabAnn.schema();\n \t\t\tcatalog = tabAnn.catalog();\n \t\t\tuniqueConstraints = TableBinder.buildUniqueConstraintHolders( tabAnn.uniqueConstraints() );\n \t\t}\n \n \t\tEjb3JoinColumn[] inheritanceJoinedColumns = makeInheritanceJoinColumns(\n \t\t\t\tclazzToProcess, mappings, inheritanceState, superEntity\n \t\t);\n \t\tEjb3DiscriminatorColumn discriminatorColumn = null;\n \t\tif ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.getType() ) ) {\n \t\t\tdiscriminatorColumn = processDiscriminatorProperties(\n \t\t\t\t\tclazzToProcess, mappings, inheritanceState, entityBinder\n \t\t\t);\n \t\t}\n \n \t\tentityBinder.setProxy( clazzToProcess.getAnnotation( Proxy.class ) );\n \t\tentityBinder.setBatchSize( clazzToProcess.getAnnotation( BatchSize.class ) );\n \t\tentityBinder.setWhere( clazzToProcess.getAnnotation( Where.class ) );\n \t    entityBinder.setCache( determineCacheSettings( clazzToProcess, mappings ) );\n \n \t\t//Filters are not allowed on subclasses\n \t\tif ( !inheritanceState.hasParents() ) {\n \t\t\tbindFilters( clazzToProcess, entityBinder, mappings );\n \t\t}\n \n \t\tentityBinder.bindEntity();\n \n \t\tif ( inheritanceState.hasTable() ) {\n \t\t\tCheck checkAnn = clazzToProcess.getAnnotation( Check.class );\n \t\t\tString constraints = checkAnn == null ?\n \t\t\t\t\tnull :\n \t\t\t\t\tcheckAnn.constraints();\n \t\t\tentityBinder.bindTable(\n \t\t\t\t\tschema, catalog, table, uniqueConstraints,\n \t\t\t\t\tconstraints, inheritanceState.hasDenormalizedTable() ?\n \t\t\t\t\t\t\tsuperEntity.getTable() :\n \t\t\t\t\t\t\tnull\n \t\t\t);\n         } else if (clazzToProcess.isAnnotationPresent(Table.class)) LOG.invalidTableAnnotation(clazzToProcess.getName());\n \n \n \t\tPropertyHolder propertyHolder = PropertyHolderBuilder.buildPropertyHolder(\n \t\t\t\tclazzToProcess,\n \t\t\t\tpersistentClass,\n \t\t\t\tentityBinder, mappings, inheritanceStatePerClass\n \t\t);\n \n \t\tjavax.persistence.SecondaryTable secTabAnn = clazzToProcess.getAnnotation(\n \t\t\t\tjavax.persistence.SecondaryTable.class\n \t\t);\n \t\tjavax.persistence.SecondaryTables secTabsAnn = clazzToProcess.getAnnotation(\n \t\t\t\tjavax.persistence.SecondaryTables.class\n \t\t);\n \t\tentityBinder.firstLevelSecondaryTablesBinding( secTabAnn, secTabsAnn );\n \n \t\tOnDelete onDeleteAnn = clazzToProcess.getAnnotation( OnDelete.class );\n \t\tboolean onDeleteAppropriate = false;\n \t\tif ( InheritanceType.JOINED.equals( inheritanceState.getType() ) && inheritanceState.hasParents() ) {\n \t\t\tonDeleteAppropriate = true;\n \t\t\tfinal JoinedSubclass jsc = ( JoinedSubclass ) persistentClass;\n \t\t\tif ( persistentClass.getEntityPersisterClass() == null ) {\n \t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( JoinedSubclassEntityPersister.class );\n \t\t\t}\n \t\t\tSimpleValue key = new DependantValue( mappings, jsc.getTable(), jsc.getIdentifier() );\n \t\t\tjsc.setKey( key );\n \t\t\tForeignKey fk = clazzToProcess.getAnnotation( ForeignKey.class );\n \t\t\tif ( fk != null && !BinderHelper.isEmptyAnnotationValue( fk.name() ) ) {\n \t\t\t\tkey.setForeignKeyName( fk.name() );\n \t\t\t}\n \t\t\tif ( onDeleteAnn != null ) {\n \t\t\t\tkey.setCascadeDeleteEnabled( OnDeleteAction.CASCADE.equals( onDeleteAnn.action() ) );\n \t\t\t}\n \t\t\telse {\n \t\t\t\tkey.setCascadeDeleteEnabled( false );\n \t\t\t}\n \t\t\t//we are never in a second pass at that stage, so queue it\n \t\t\tSecondPass sp = new JoinedSubclassFkSecondPass( jsc, inheritanceJoinedColumns, key, mappings );\n \t\t\tmappings.addSecondPass( sp );\n \t\t\tmappings.addSecondPass( new CreateKeySecondPass( jsc ) );\n \n \t\t}\n \t\telse if ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.getType() ) ) {\n \t\t\tif ( inheritanceState.hasParents() ) {\n \t\t\t\tif ( persistentClass.getEntityPersisterClass() == null ) {\n \t\t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( SingleTableEntityPersister.class );\n \t\t\t\t}\n \t\t\t}\n \t\t\telse {\n \t\t\t\tif ( inheritanceState.hasSiblings() || !discriminatorColumn.isImplicit() ) {\n \t\t\t\t\t//need a discriminator column\n \t\t\t\t\tbindDiscriminatorToPersistentClass(\n \t\t\t\t\t\t\t( RootClass ) persistentClass,\n \t\t\t\t\t\t\tdiscriminatorColumn,\n \t\t\t\t\t\t\tentityBinder.getSecondaryTables(),\n \t\t\t\t\t\t\tpropertyHolder,\n \t\t\t\t\t\t\tmappings\n \t\t\t\t\t);\n \t\t\t\t\tentityBinder.bindDiscriminatorValue();//bind it again since the type might have changed\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\telse if ( InheritanceType.TABLE_PER_CLASS.equals( inheritanceState.getType() ) ) {\n \t\t\tif ( inheritanceState.hasParents() ) {\n \t\t\t\tif ( persistentClass.getEntityPersisterClass() == null ) {\n \t\t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( UnionSubclassEntityPersister.class );\n \t\t\t\t}\n \t\t\t}\n \t\t}\n         if (onDeleteAnn != null && !onDeleteAppropriate) LOG.invalidOnDeleteAnnotation(propertyHolder.getEntityName());\n \n \t\t// try to find class level generators\n \t\tHashMap<String, IdGenerator> classGenerators = buildLocalGenerators( clazzToProcess, mappings );\n \n \t\t// check properties\n \t\tfinal InheritanceState.ElementsToProcess elementsToProcess = inheritanceState.getElementsToProcess();\n \t\tinheritanceState.postProcess( persistentClass, entityBinder );\n \n \t\tfinal boolean subclassAndSingleTableStrategy = inheritanceState.getType() == InheritanceType.SINGLE_TABLE\n \t\t\t\t&& inheritanceState.hasParents();\n \t\tSet<String> idPropertiesIfIdClass = new HashSet<String>();\n \t\tboolean isIdClass = mapAsIdClass(\n \t\t\t\tinheritanceStatePerClass,\n \t\t\t\tinheritanceState,\n \t\t\t\tpersistentClass,\n \t\t\t\tentityBinder,\n \t\t\t\tpropertyHolder,\n \t\t\t\telementsToProcess,\n \t\t\t\tidPropertiesIfIdClass,\n \t\t\t\tmappings\n \t\t);\n \n \t\tif ( !isIdClass ) {\n \t\t\tentityBinder.setWrapIdsInEmbeddedComponents( elementsToProcess.getIdPropertyCount() > 1 );\n \t\t}\n \n \t\tprocessIdPropertiesIfNotAlready(\n \t\t\t\tinheritanceStatePerClass,\n \t\t\t\tmappings,\n \t\t\t\tpersistentClass,\n \t\t\t\tentityBinder,\n \t\t\t\tpropertyHolder,\n \t\t\t\tclassGenerators,\n \t\t\t\telementsToProcess,\n \t\t\t\tsubclassAndSingleTableStrategy,\n \t\t\t\tidPropertiesIfIdClass\n \t\t);\n \n \t\tif ( !inheritanceState.hasParents() ) {\n \t\t\tfinal RootClass rootClass = ( RootClass ) persistentClass;\n \t\t\tmappings.addSecondPass( new CreateKeySecondPass( rootClass ) );\n \t\t}\n \t\telse {\n \t\t\tsuperEntity.addSubclass( ( Subclass ) persistentClass );\n \t\t}\n \n \t\tmappings.addClass( persistentClass );\n \n \t\t//Process secondary tables and complementary definitions (ie o.h.a.Table)\n \t\tmappings.addSecondPass( new SecondaryTableSecondPass( entityBinder, propertyHolder, clazzToProcess ) );\n \n \t\t//add process complementary Table definition (index & all)\n \t\tentityBinder.processComplementaryTableDefinitions( clazzToProcess.getAnnotation( org.hibernate.annotations.Table.class ) );\n \t\tentityBinder.processComplementaryTableDefinitions( clazzToProcess.getAnnotation( org.hibernate.annotations.Tables.class ) );\n \n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"a9b1425f3f07021dae556e710b2bdfdc3812661b": {
			"type": "Ybodychange",
			"commitMessage": "Replaced references to slf4j with references to new jboss.logging.Logger implementations and i18n'd where it was clear how to do so.\n",
			"commitDate": "2011-01-18, 1:35 PM",
			"commitName": "a9b1425f3f07021dae556e710b2bdfdc3812661b",
			"commitAuthor": "JPAV",
			"commitDateOld": "2010-10-11, 12:41 PM",
			"commitNameOld": "34c2839dccef33a8f3abb4eaf3192c1e1d9e1814",
			"commitAuthorOld": "Steve Ebersole",
			"daysBetweenCommits": 99.08,
			"commitsBetweenForRepo": 193,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,231 +1,220 @@\n \tpublic static void bindClass(\n \t\t\tXClass clazzToProcess,\n \t\t\tMap<XClass, InheritanceState> inheritanceStatePerClass,\n \t\t\tMappings mappings) throws MappingException {\n \t\t//@Entity and @MappedSuperclass on the same class leads to a NPE down the road\n-\t\tif ( clazzToProcess.isAnnotationPresent( Entity.class ) \n+\t\tif ( clazzToProcess.isAnnotationPresent( Entity.class )\n \t\t\t\t&&  clazzToProcess.isAnnotationPresent( MappedSuperclass.class ) ) {\n \t\t\tthrow new AnnotationException( \"An entity cannot be annotated with both @Entity and @MappedSuperclass: \"\n \t\t\t\t\t+ clazzToProcess.getName() );\n \t\t}\n \n \t\t//TODO: be more strict with secondarytable allowance (not for ids, not for secondary table join columns etc)\n \t\tInheritanceState inheritanceState = inheritanceStatePerClass.get( clazzToProcess );\n \t\tAnnotatedClassType classType = mappings.getClassType( clazzToProcess );\n \n \t\t//Queries declared in MappedSuperclass should be usable in Subclasses\n \t\tif ( AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals( classType ) ) {\n \t\t\tbindQueries( clazzToProcess, mappings );\n \t\t\tbindTypeDefs( clazzToProcess, mappings );\n \t\t\tbindFilterDefs( clazzToProcess, mappings );\n \t\t}\n \n \t\tif ( !isEntityClassType( clazzToProcess, classType ) ) {\n \t\t\treturn;\n \t\t}\n \n-\t\tlog.info( \"Binding entity from annotated class: {}\", clazzToProcess.getName() );\n+        LOG.bindingEntityFromClass(clazzToProcess.getName());\n \n \t\tPersistentClass superEntity = getSuperEntity(\n \t\t\t\tclazzToProcess, inheritanceStatePerClass, mappings, inheritanceState\n \t\t);\n \n \t\tPersistentClass persistentClass = makePersistentClass( inheritanceState, superEntity );\n \t\tEntity entityAnn = clazzToProcess.getAnnotation( Entity.class );\n \t\torg.hibernate.annotations.Entity hibEntityAnn = clazzToProcess.getAnnotation(\n \t\t\t\torg.hibernate.annotations.Entity.class\n \t\t);\n \t\tEntityBinder entityBinder = new EntityBinder(\n \t\t\t\tentityAnn, hibEntityAnn, clazzToProcess, persistentClass, mappings\n \t\t);\n \t\tentityBinder.setInheritanceState( inheritanceState );\n \n \t\tbindQueries( clazzToProcess, mappings );\n \t\tbindFilterDefs( clazzToProcess, mappings );\n \t\tbindTypeDefs( clazzToProcess, mappings );\n \t\tbindFetchProfiles( clazzToProcess, mappings );\n \t\tBinderHelper.bindAnyMetaDefs( clazzToProcess, mappings );\n \n \t\tString schema = \"\";\n \t\tString table = \"\"; //might be no @Table annotation on the annotated class\n \t\tString catalog = \"\";\n \t\tList<UniqueConstraintHolder> uniqueConstraints = new ArrayList<UniqueConstraintHolder>();\n \t\tif ( clazzToProcess.isAnnotationPresent( javax.persistence.Table.class ) ) {\n \t\t\tjavax.persistence.Table tabAnn = clazzToProcess.getAnnotation( javax.persistence.Table.class );\n \t\t\ttable = tabAnn.name();\n \t\t\tschema = tabAnn.schema();\n \t\t\tcatalog = tabAnn.catalog();\n \t\t\tuniqueConstraints = TableBinder.buildUniqueConstraintHolders( tabAnn.uniqueConstraints() );\n \t\t}\n \n \t\tEjb3JoinColumn[] inheritanceJoinedColumns = makeInheritanceJoinColumns(\n \t\t\t\tclazzToProcess, mappings, inheritanceState, superEntity\n \t\t);\n \t\tEjb3DiscriminatorColumn discriminatorColumn = null;\n \t\tif ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.getType() ) ) {\n \t\t\tdiscriminatorColumn = processDiscriminatorProperties(\n \t\t\t\t\tclazzToProcess, mappings, inheritanceState, entityBinder\n \t\t\t);\n \t\t}\n \n \t\tentityBinder.setProxy( clazzToProcess.getAnnotation( Proxy.class ) );\n \t\tentityBinder.setBatchSize( clazzToProcess.getAnnotation( BatchSize.class ) );\n \t\tentityBinder.setWhere( clazzToProcess.getAnnotation( Where.class ) );\n \t    entityBinder.setCache( determineCacheSettings( clazzToProcess, mappings ) );\n \n \t\t//Filters are not allowed on subclasses\n \t\tif ( !inheritanceState.hasParents() ) {\n \t\t\tbindFilters( clazzToProcess, entityBinder, mappings );\n \t\t}\n \n \t\tentityBinder.bindEntity();\n \n \t\tif ( inheritanceState.hasTable() ) {\n \t\t\tCheck checkAnn = clazzToProcess.getAnnotation( Check.class );\n \t\t\tString constraints = checkAnn == null ?\n \t\t\t\t\tnull :\n \t\t\t\t\tcheckAnn.constraints();\n \t\t\tentityBinder.bindTable(\n \t\t\t\t\tschema, catalog, table, uniqueConstraints,\n \t\t\t\t\tconstraints, inheritanceState.hasDenormalizedTable() ?\n \t\t\t\t\t\t\tsuperEntity.getTable() :\n \t\t\t\t\t\t\tnull\n \t\t\t);\n-\t\t}\n-\t\telse {\n-\t\t\tif ( clazzToProcess.isAnnotationPresent( Table.class ) ) {\n-\t\t\t\tlog.warn(\n-\t\t\t\t\t\t\"Illegal use of @Table in a subclass of a SINGLE_TABLE hierarchy: \" + clazzToProcess\n-\t\t\t\t\t\t\t\t.getName()\n-\t\t\t\t);\n-\t\t\t}\n-\t\t}\n+        } else if (clazzToProcess.isAnnotationPresent(Table.class)) LOG.invalidTableAnnotation(clazzToProcess.getName());\n+\n \n \t\tPropertyHolder propertyHolder = PropertyHolderBuilder.buildPropertyHolder(\n \t\t\t\tclazzToProcess,\n \t\t\t\tpersistentClass,\n \t\t\t\tentityBinder, mappings, inheritanceStatePerClass\n \t\t);\n \n \t\tjavax.persistence.SecondaryTable secTabAnn = clazzToProcess.getAnnotation(\n \t\t\t\tjavax.persistence.SecondaryTable.class\n \t\t);\n \t\tjavax.persistence.SecondaryTables secTabsAnn = clazzToProcess.getAnnotation(\n \t\t\t\tjavax.persistence.SecondaryTables.class\n \t\t);\n \t\tentityBinder.firstLevelSecondaryTablesBinding( secTabAnn, secTabsAnn );\n \n \t\tOnDelete onDeleteAnn = clazzToProcess.getAnnotation( OnDelete.class );\n \t\tboolean onDeleteAppropriate = false;\n \t\tif ( InheritanceType.JOINED.equals( inheritanceState.getType() ) && inheritanceState.hasParents() ) {\n \t\t\tonDeleteAppropriate = true;\n \t\t\tfinal JoinedSubclass jsc = ( JoinedSubclass ) persistentClass;\n \t\t\tif ( persistentClass.getEntityPersisterClass() == null ) {\n \t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( JoinedSubclassEntityPersister.class );\n \t\t\t}\n \t\t\tSimpleValue key = new DependantValue( mappings, jsc.getTable(), jsc.getIdentifier() );\n \t\t\tjsc.setKey( key );\n \t\t\tForeignKey fk = clazzToProcess.getAnnotation( ForeignKey.class );\n \t\t\tif ( fk != null && !BinderHelper.isEmptyAnnotationValue( fk.name() ) ) {\n \t\t\t\tkey.setForeignKeyName( fk.name() );\n \t\t\t}\n \t\t\tif ( onDeleteAnn != null ) {\n \t\t\t\tkey.setCascadeDeleteEnabled( OnDeleteAction.CASCADE.equals( onDeleteAnn.action() ) );\n \t\t\t}\n \t\t\telse {\n \t\t\t\tkey.setCascadeDeleteEnabled( false );\n \t\t\t}\n \t\t\t//we are never in a second pass at that stage, so queue it\n \t\t\tSecondPass sp = new JoinedSubclassFkSecondPass( jsc, inheritanceJoinedColumns, key, mappings );\n \t\t\tmappings.addSecondPass( sp );\n \t\t\tmappings.addSecondPass( new CreateKeySecondPass( jsc ) );\n \n \t\t}\n \t\telse if ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.getType() ) ) {\n \t\t\tif ( inheritanceState.hasParents() ) {\n \t\t\t\tif ( persistentClass.getEntityPersisterClass() == null ) {\n \t\t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( SingleTableEntityPersister.class );\n \t\t\t\t}\n \t\t\t}\n \t\t\telse {\n \t\t\t\tif ( inheritanceState.hasSiblings() || !discriminatorColumn.isImplicit() ) {\n \t\t\t\t\t//need a discriminator column\n \t\t\t\t\tbindDiscriminatorToPersistentClass(\n \t\t\t\t\t\t\t( RootClass ) persistentClass,\n \t\t\t\t\t\t\tdiscriminatorColumn,\n \t\t\t\t\t\t\tentityBinder.getSecondaryTables(),\n \t\t\t\t\t\t\tpropertyHolder,\n \t\t\t\t\t\t\tmappings\n \t\t\t\t\t);\n \t\t\t\t\tentityBinder.bindDiscriminatorValue();//bind it again since the type might have changed\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\telse if ( InheritanceType.TABLE_PER_CLASS.equals( inheritanceState.getType() ) ) {\n \t\t\tif ( inheritanceState.hasParents() ) {\n \t\t\t\tif ( persistentClass.getEntityPersisterClass() == null ) {\n \t\t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( UnionSubclassEntityPersister.class );\n \t\t\t\t}\n \t\t\t}\n \t\t}\n-\t\tif ( onDeleteAnn != null && !onDeleteAppropriate ) {\n-\t\t\tlog.warn(\n-\t\t\t\t\t\"Inapropriate use of @OnDelete on entity, annotation ignored: {}\", propertyHolder.getEntityName()\n-\t\t\t);\n-\t\t}\n+        if (onDeleteAnn != null && !onDeleteAppropriate) LOG.invalidOnDeleteAnnotation(propertyHolder.getEntityName());\n \n \t\t// try to find class level generators\n \t\tHashMap<String, IdGenerator> classGenerators = buildLocalGenerators( clazzToProcess, mappings );\n \n \t\t// check properties\n \t\tfinal InheritanceState.ElementsToProcess elementsToProcess = inheritanceState.getElementsToProcess();\n \t\tinheritanceState.postProcess( persistentClass, entityBinder );\n \n \t\tfinal boolean subclassAndSingleTableStrategy = inheritanceState.getType() == InheritanceType.SINGLE_TABLE\n \t\t\t\t&& inheritanceState.hasParents();\n \t\tSet<String> idPropertiesIfIdClass = new HashSet<String>();\n \t\tboolean isIdClass = mapAsIdClass(\n \t\t\t\tinheritanceStatePerClass,\n \t\t\t\tinheritanceState,\n \t\t\t\tpersistentClass,\n \t\t\t\tentityBinder,\n \t\t\t\tpropertyHolder,\n \t\t\t\telementsToProcess,\n \t\t\t\tidPropertiesIfIdClass,\n \t\t\t\tmappings\n \t\t);\n \n \t\tif ( !isIdClass ) {\n \t\t\tentityBinder.setWrapIdsInEmbeddedComponents( elementsToProcess.getIdPropertyCount() > 1 );\n \t\t}\n \n \t\tprocessIdPropertiesIfNotAlready(\n \t\t\t\tinheritanceStatePerClass,\n \t\t\t\tmappings,\n \t\t\t\tpersistentClass,\n \t\t\t\tentityBinder,\n \t\t\t\tpropertyHolder,\n \t\t\t\tclassGenerators,\n \t\t\t\telementsToProcess,\n \t\t\t\tsubclassAndSingleTableStrategy,\n \t\t\t\tidPropertiesIfIdClass\n \t\t);\n \n \t\tif ( !inheritanceState.hasParents() ) {\n \t\t\tfinal RootClass rootClass = ( RootClass ) persistentClass;\n \t\t\tmappings.addSecondPass( new CreateKeySecondPass( rootClass ) );\n \t\t}\n \t\telse {\n \t\t\tsuperEntity.addSubclass( ( Subclass ) persistentClass );\n \t\t}\n \n \t\tmappings.addClass( persistentClass );\n \n \t\t//Process secondary tables and complementary definitions (ie o.h.a.Table)\n \t\tmappings.addSecondPass( new SecondaryTableSecondPass( entityBinder, propertyHolder, clazzToProcess ) );\n \n \t\t//add process complementary Table definition (index & all)\n \t\tentityBinder.processComplementaryTableDefinitions( clazzToProcess.getAnnotation( org.hibernate.annotations.Table.class ) );\n \t\tentityBinder.processComplementaryTableDefinitions( clazzToProcess.getAnnotation( org.hibernate.annotations.Tables.class ) );\n \n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"34c2839dccef33a8f3abb4eaf3192c1e1d9e1814": {
			"type": "Yfilerename",
			"commitMessage": "HHH-5616 - Switch to Gradle for builds\n",
			"commitDate": "2010-10-11, 12:41 PM",
			"commitName": "34c2839dccef33a8f3abb4eaf3192c1e1d9e1814",
			"commitAuthor": "Steve Ebersole",
			"commitDateOld": "2010-10-11, 11:51 AM",
			"commitNameOld": "0bfe7869e41076fd0846ca7592740710876f2427",
			"commitAuthorOld": "Gail Badner",
			"daysBetweenCommits": 0.04,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "",
			"extendedDetails": {
				"oldPath": "core/src/main/java/org/hibernate/cfg/AnnotationBinder.java",
				"newPath": "hibernate-core/src/main/java/org/hibernate/cfg/AnnotationBinder.java"
			}
		},
		"bf7607e24495af5133165ae6ed6b85feecf59148": {
			"type": "Ybodychange",
			"commitMessage": "HHH-5190 - Introduced new annotation @DiscriminatorOptions and deprecated @ForceDiscriminator\n\ngit-svn-id: https://svn.jboss.org/repos/hibernate/core/trunk@20749 1b8cb986-b30d-0410-93ca-fae66ebed9b2\n",
			"commitDate": "2010-09-29, 3:45 AM",
			"commitName": "bf7607e24495af5133165ae6ed6b85feecf59148",
			"commitAuthor": "Hardy Ferentschik",
			"commitDateOld": "2010-09-28, 9:28 AM",
			"commitNameOld": "e14f58de29eb5f8a3de7480dbd8bc10fcc9e6185",
			"commitAuthorOld": "Hardy Ferentschik",
			"daysBetweenCommits": 0.76,
			"commitsBetweenForRepo": 9,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,261 +1,231 @@\n \tpublic static void bindClass(\n \t\t\tXClass clazzToProcess,\n \t\t\tMap<XClass, InheritanceState> inheritanceStatePerClass,\n \t\t\tMappings mappings) throws MappingException {\n \t\t//@Entity and @MappedSuperclass on the same class leads to a NPE down the road\n \t\tif ( clazzToProcess.isAnnotationPresent( Entity.class ) \n \t\t\t\t&&  clazzToProcess.isAnnotationPresent( MappedSuperclass.class ) ) {\n \t\t\tthrow new AnnotationException( \"An entity cannot be annotated with both @Entity and @MappedSuperclass: \"\n \t\t\t\t\t+ clazzToProcess.getName() );\n \t\t}\n \n \t\t//TODO: be more strict with secondarytable allowance (not for ids, not for secondary table join columns etc)\n \t\tInheritanceState inheritanceState = inheritanceStatePerClass.get( clazzToProcess );\n \t\tAnnotatedClassType classType = mappings.getClassType( clazzToProcess );\n \n \t\t//Queries declared in MappedSuperclass should be usable in Subclasses\n \t\tif ( AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals( classType ) ) {\n \t\t\tbindQueries( clazzToProcess, mappings );\n \t\t\tbindTypeDefs( clazzToProcess, mappings );\n \t\t\tbindFilterDefs( clazzToProcess, mappings );\n \t\t}\n \n \t\tif ( !isEntityClassType( clazzToProcess, classType ) ) {\n \t\t\treturn;\n \t\t}\n \n \t\tlog.info( \"Binding entity from annotated class: {}\", clazzToProcess.getName() );\n \n \t\tPersistentClass superEntity = getSuperEntity(\n \t\t\t\tclazzToProcess, inheritanceStatePerClass, mappings, inheritanceState\n \t\t);\n \n+\t\tPersistentClass persistentClass = makePersistentClass( inheritanceState, superEntity );\n+\t\tEntity entityAnn = clazzToProcess.getAnnotation( Entity.class );\n+\t\torg.hibernate.annotations.Entity hibEntityAnn = clazzToProcess.getAnnotation(\n+\t\t\t\torg.hibernate.annotations.Entity.class\n+\t\t);\n+\t\tEntityBinder entityBinder = new EntityBinder(\n+\t\t\t\tentityAnn, hibEntityAnn, clazzToProcess, persistentClass, mappings\n+\t\t);\n+\t\tentityBinder.setInheritanceState( inheritanceState );\n+\n \t\tbindQueries( clazzToProcess, mappings );\n \t\tbindFilterDefs( clazzToProcess, mappings );\n \t\tbindTypeDefs( clazzToProcess, mappings );\n \t\tbindFetchProfiles( clazzToProcess, mappings );\n \t\tBinderHelper.bindAnyMetaDefs( clazzToProcess, mappings );\n \n \t\tString schema = \"\";\n \t\tString table = \"\"; //might be no @Table annotation on the annotated class\n \t\tString catalog = \"\";\n \t\tList<UniqueConstraintHolder> uniqueConstraints = new ArrayList<UniqueConstraintHolder>();\n \t\tif ( clazzToProcess.isAnnotationPresent( javax.persistence.Table.class ) ) {\n \t\t\tjavax.persistence.Table tabAnn = clazzToProcess.getAnnotation( javax.persistence.Table.class );\n \t\t\ttable = tabAnn.name();\n \t\t\tschema = tabAnn.schema();\n \t\t\tcatalog = tabAnn.catalog();\n \t\t\tuniqueConstraints = TableBinder.buildUniqueConstraintHolders( tabAnn.uniqueConstraints() );\n \t\t}\n \n \t\tEjb3JoinColumn[] inheritanceJoinedColumns = makeInheritanceJoinColumns(\n \t\t\t\tclazzToProcess, mappings, inheritanceState, superEntity\n \t\t);\n \t\tEjb3DiscriminatorColumn discriminatorColumn = null;\n-\t\tString discrimValue = null;\n \t\tif ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.getType() ) ) {\n-\t\t\tjavax.persistence.DiscriminatorColumn discAnn = clazzToProcess.getAnnotation(\n-\t\t\t\t\tjavax.persistence.DiscriminatorColumn.class\n+\t\t\tdiscriminatorColumn = processDiscriminatorProperties(\n+\t\t\t\t\tclazzToProcess, mappings, inheritanceState, entityBinder\n \t\t\t);\n-\t\t\tDiscriminatorType discriminatorType = discAnn != null ?\n-\t\t\t\t\tdiscAnn.discriminatorType() :\n-\t\t\t\t\tDiscriminatorType.STRING;\n-\n-\t\t\torg.hibernate.annotations.DiscriminatorFormula discFormulaAnn = clazzToProcess.getAnnotation(\n-\t\t\t\t\torg.hibernate.annotations.DiscriminatorFormula.class\n-\t\t\t);\n-\t\t\tif ( !inheritanceState.hasParents() ) {\n-\t\t\t\tdiscriminatorColumn = Ejb3DiscriminatorColumn.buildDiscriminatorColumn(\n-\t\t\t\t\t\tdiscriminatorType, discAnn, discFormulaAnn, mappings\n-\t\t\t\t);\n-\t\t\t}\n-\t\t\tif ( discAnn != null && inheritanceState.hasParents() ) {\n-\t\t\t\tlog.warn(\n-\t\t\t\t\t\t\"Discriminator column has to be defined in the root entity, it will be ignored in subclass: {}\",\n-\t\t\t\t\t\tclazzToProcess.getName()\n-\t\t\t\t);\n-\t\t\t}\n-\n-\t\t\tdiscrimValue = clazzToProcess.isAnnotationPresent( DiscriminatorValue.class ) ?\n-\t\t\t\t\tclazzToProcess.getAnnotation( DiscriminatorValue.class ).value() :\n-\t\t\t\t\tnull;\n \t\t}\n \n-\t\tPersistentClass persistentClass = makePersistentClass( inheritanceState, superEntity );\n-\n-\t\tProxy proxyAnn = clazzToProcess.getAnnotation( Proxy.class );\n-\t\tBatchSize sizeAnn = clazzToProcess.getAnnotation( BatchSize.class );\n-\t\tWhere whereAnn = clazzToProcess.getAnnotation( Where.class );\n-\t\tEntity entityAnn = clazzToProcess.getAnnotation( Entity.class );\n-\t\torg.hibernate.annotations.Entity hibEntityAnn = clazzToProcess.getAnnotation(\n-\t\t\t\torg.hibernate.annotations.Entity.class\n-\t\t);\n-\n-\t\tCache cacheAnn = determineCacheSettings( clazzToProcess, mappings );\n-\n-\t\tEntityBinder entityBinder = new EntityBinder(\n-\t\t\t\tentityAnn, hibEntityAnn, clazzToProcess, persistentClass, mappings\n-\t\t);\n-\t\tentityBinder.setDiscriminatorValue( discrimValue );\n-\t\tentityBinder.setBatchSize( sizeAnn );\n-\t\tentityBinder.setProxy( proxyAnn );\n-\t\tentityBinder.setWhere( whereAnn );\n-\t\tentityBinder.setCache( cacheAnn );\n-\t\tentityBinder.setInheritanceState( inheritanceState );\n+\t\tentityBinder.setProxy( clazzToProcess.getAnnotation( Proxy.class ) );\n+\t\tentityBinder.setBatchSize( clazzToProcess.getAnnotation( BatchSize.class ) );\n+\t\tentityBinder.setWhere( clazzToProcess.getAnnotation( Where.class ) );\n+\t    entityBinder.setCache( determineCacheSettings( clazzToProcess, mappings ) );\n \n \t\t//Filters are not allowed on subclasses\n \t\tif ( !inheritanceState.hasParents() ) {\n \t\t\tbindFilters( clazzToProcess, entityBinder, mappings );\n \t\t}\n \n \t\tentityBinder.bindEntity();\n \n \t\tif ( inheritanceState.hasTable() ) {\n \t\t\tCheck checkAnn = clazzToProcess.getAnnotation( Check.class );\n \t\t\tString constraints = checkAnn == null ?\n \t\t\t\t\tnull :\n \t\t\t\t\tcheckAnn.constraints();\n \t\t\tentityBinder.bindTable(\n \t\t\t\t\tschema, catalog, table, uniqueConstraints,\n \t\t\t\t\tconstraints, inheritanceState.hasDenormalizedTable() ?\n \t\t\t\t\t\t\tsuperEntity.getTable() :\n \t\t\t\t\t\t\tnull\n \t\t\t);\n \t\t}\n \t\telse {\n \t\t\tif ( clazzToProcess.isAnnotationPresent( Table.class ) ) {\n \t\t\t\tlog.warn(\n \t\t\t\t\t\t\"Illegal use of @Table in a subclass of a SINGLE_TABLE hierarchy: \" + clazzToProcess\n \t\t\t\t\t\t\t\t.getName()\n \t\t\t\t);\n \t\t\t}\n \t\t}\n \n \t\tPropertyHolder propertyHolder = PropertyHolderBuilder.buildPropertyHolder(\n \t\t\t\tclazzToProcess,\n \t\t\t\tpersistentClass,\n \t\t\t\tentityBinder, mappings, inheritanceStatePerClass\n \t\t);\n \n \t\tjavax.persistence.SecondaryTable secTabAnn = clazzToProcess.getAnnotation(\n \t\t\t\tjavax.persistence.SecondaryTable.class\n \t\t);\n \t\tjavax.persistence.SecondaryTables secTabsAnn = clazzToProcess.getAnnotation(\n \t\t\t\tjavax.persistence.SecondaryTables.class\n \t\t);\n \t\tentityBinder.firstLevelSecondaryTablesBinding( secTabAnn, secTabsAnn );\n \n \t\tOnDelete onDeleteAnn = clazzToProcess.getAnnotation( OnDelete.class );\n \t\tboolean onDeleteAppropriate = false;\n \t\tif ( InheritanceType.JOINED.equals( inheritanceState.getType() ) && inheritanceState.hasParents() ) {\n \t\t\tonDeleteAppropriate = true;\n \t\t\tfinal JoinedSubclass jsc = ( JoinedSubclass ) persistentClass;\n \t\t\tif ( persistentClass.getEntityPersisterClass() == null ) {\n \t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( JoinedSubclassEntityPersister.class );\n \t\t\t}\n \t\t\tSimpleValue key = new DependantValue( mappings, jsc.getTable(), jsc.getIdentifier() );\n \t\t\tjsc.setKey( key );\n \t\t\tForeignKey fk = clazzToProcess.getAnnotation( ForeignKey.class );\n \t\t\tif ( fk != null && !BinderHelper.isEmptyAnnotationValue( fk.name() ) ) {\n \t\t\t\tkey.setForeignKeyName( fk.name() );\n \t\t\t}\n \t\t\tif ( onDeleteAnn != null ) {\n \t\t\t\tkey.setCascadeDeleteEnabled( OnDeleteAction.CASCADE.equals( onDeleteAnn.action() ) );\n \t\t\t}\n \t\t\telse {\n \t\t\t\tkey.setCascadeDeleteEnabled( false );\n \t\t\t}\n \t\t\t//we are never in a second pass at that stage, so queue it\n \t\t\tSecondPass sp = new JoinedSubclassFkSecondPass( jsc, inheritanceJoinedColumns, key, mappings );\n \t\t\tmappings.addSecondPass( sp );\n \t\t\tmappings.addSecondPass( new CreateKeySecondPass( jsc ) );\n \n \t\t}\n \t\telse if ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.getType() ) ) {\n \t\t\tif ( inheritanceState.hasParents() ) {\n \t\t\t\tif ( persistentClass.getEntityPersisterClass() == null ) {\n \t\t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( SingleTableEntityPersister.class );\n \t\t\t\t}\n \t\t\t}\n \t\t\telse {\n \t\t\t\tif ( inheritanceState.hasSiblings() || !discriminatorColumn.isImplicit() ) {\n \t\t\t\t\t//need a discriminator column\n \t\t\t\t\tbindDiscriminatorToPersistentClass(\n \t\t\t\t\t\t\t( RootClass ) persistentClass,\n \t\t\t\t\t\t\tdiscriminatorColumn,\n \t\t\t\t\t\t\tentityBinder.getSecondaryTables(),\n \t\t\t\t\t\t\tpropertyHolder,\n \t\t\t\t\t\t\tmappings\n \t\t\t\t\t);\n \t\t\t\t\tentityBinder.bindDiscriminatorValue();//bind it again since the type might have changed\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\telse if ( InheritanceType.TABLE_PER_CLASS.equals( inheritanceState.getType() ) ) {\n \t\t\tif ( inheritanceState.hasParents() ) {\n \t\t\t\tif ( persistentClass.getEntityPersisterClass() == null ) {\n \t\t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( UnionSubclassEntityPersister.class );\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\tif ( onDeleteAnn != null && !onDeleteAppropriate ) {\n \t\t\tlog.warn(\n \t\t\t\t\t\"Inapropriate use of @OnDelete on entity, annotation ignored: {}\", propertyHolder.getEntityName()\n \t\t\t);\n \t\t}\n \n \t\t// try to find class level generators\n \t\tHashMap<String, IdGenerator> classGenerators = buildLocalGenerators( clazzToProcess, mappings );\n \n \t\t// check properties\n \t\tfinal InheritanceState.ElementsToProcess elementsToProcess = inheritanceState.getElementsToProcess();\n \t\tinheritanceState.postProcess( persistentClass, entityBinder );\n \n \t\tfinal boolean subclassAndSingleTableStrategy = inheritanceState.getType() == InheritanceType.SINGLE_TABLE\n \t\t\t\t&& inheritanceState.hasParents();\n \t\tSet<String> idPropertiesIfIdClass = new HashSet<String>();\n \t\tboolean isIdClass = mapAsIdClass(\n \t\t\t\tinheritanceStatePerClass,\n \t\t\t\tinheritanceState,\n \t\t\t\tpersistentClass,\n \t\t\t\tentityBinder,\n \t\t\t\tpropertyHolder,\n \t\t\t\telementsToProcess,\n \t\t\t\tidPropertiesIfIdClass,\n \t\t\t\tmappings\n \t\t);\n \n \t\tif ( !isIdClass ) {\n \t\t\tentityBinder.setWrapIdsInEmbeddedComponents( elementsToProcess.getIdPropertyCount() > 1 );\n \t\t}\n \n \t\tprocessIdPropertiesIfNotAlready(\n \t\t\t\tinheritanceStatePerClass,\n \t\t\t\tmappings,\n \t\t\t\tpersistentClass,\n \t\t\t\tentityBinder,\n \t\t\t\tpropertyHolder,\n \t\t\t\tclassGenerators,\n \t\t\t\telementsToProcess,\n \t\t\t\tsubclassAndSingleTableStrategy,\n \t\t\t\tidPropertiesIfIdClass\n \t\t);\n \n \t\tif ( !inheritanceState.hasParents() ) {\n \t\t\tfinal RootClass rootClass = ( RootClass ) persistentClass;\n \t\t\tmappings.addSecondPass( new CreateKeySecondPass( rootClass ) );\n \t\t}\n \t\telse {\n \t\t\tsuperEntity.addSubclass( ( Subclass ) persistentClass );\n \t\t}\n \n \t\tmappings.addClass( persistentClass );\n \n \t\t//Process secondary tables and complementary definitions (ie o.h.a.Table)\n \t\tmappings.addSecondPass( new SecondaryTableSecondPass( entityBinder, propertyHolder, clazzToProcess ) );\n \n \t\t//add process complementary Table definition (index & all)\n \t\tentityBinder.processComplementaryTableDefinitions( clazzToProcess.getAnnotation( org.hibernate.annotations.Table.class ) );\n \t\tentityBinder.processComplementaryTableDefinitions( clazzToProcess.getAnnotation( org.hibernate.annotations.Tables.class ) );\n \n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"e14f58de29eb5f8a3de7480dbd8bc10fcc9e6185": {
			"type": "Ybodychange",
			"commitMessage": "HHH-5205 - Added @Source and emum SourceType, fixed implementation and added a test\n\ngit-svn-id: https://svn.jboss.org/repos/hibernate/core/trunk@20740 1b8cb986-b30d-0410-93ca-fae66ebed9b2\n",
			"commitDate": "2010-09-28, 9:28 AM",
			"commitName": "e14f58de29eb5f8a3de7480dbd8bc10fcc9e6185",
			"commitAuthor": "Hardy Ferentschik",
			"commitDateOld": "2010-08-26, 2:00 PM",
			"commitNameOld": "232a77e5ddfa3eaf59034a7e55fd52debeb0242a",
			"commitAuthorOld": "Steve Ebersole",
			"daysBetweenCommits": 32.81,
			"commitsBetweenForRepo": 87,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,261 +1,261 @@\n \tpublic static void bindClass(\n \t\t\tXClass clazzToProcess,\n \t\t\tMap<XClass, InheritanceState> inheritanceStatePerClass,\n \t\t\tMappings mappings) throws MappingException {\n \t\t//@Entity and @MappedSuperclass on the same class leads to a NPE down the road\n \t\tif ( clazzToProcess.isAnnotationPresent( Entity.class ) \n \t\t\t\t&&  clazzToProcess.isAnnotationPresent( MappedSuperclass.class ) ) {\n \t\t\tthrow new AnnotationException( \"An entity cannot be annotated with both @Entity and @MappedSuperclass: \"\n \t\t\t\t\t+ clazzToProcess.getName() );\n \t\t}\n \n \t\t//TODO: be more strict with secondarytable allowance (not for ids, not for secondary table join columns etc)\n \t\tInheritanceState inheritanceState = inheritanceStatePerClass.get( clazzToProcess );\n \t\tAnnotatedClassType classType = mappings.getClassType( clazzToProcess );\n \n \t\t//Queries declared in MappedSuperclass should be usable in Subclasses\n \t\tif ( AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals( classType ) ) {\n \t\t\tbindQueries( clazzToProcess, mappings );\n \t\t\tbindTypeDefs( clazzToProcess, mappings );\n \t\t\tbindFilterDefs( clazzToProcess, mappings );\n \t\t}\n \n \t\tif ( !isEntityClassType( clazzToProcess, classType ) ) {\n \t\t\treturn;\n \t\t}\n \n \t\tlog.info( \"Binding entity from annotated class: {}\", clazzToProcess.getName() );\n \n \t\tPersistentClass superEntity = getSuperEntity(\n \t\t\t\tclazzToProcess, inheritanceStatePerClass, mappings, inheritanceState\n \t\t);\n \n \t\tbindQueries( clazzToProcess, mappings );\n \t\tbindFilterDefs( clazzToProcess, mappings );\n \t\tbindTypeDefs( clazzToProcess, mappings );\n \t\tbindFetchProfiles( clazzToProcess, mappings );\n \t\tBinderHelper.bindAnyMetaDefs( clazzToProcess, mappings );\n \n \t\tString schema = \"\";\n \t\tString table = \"\"; //might be no @Table annotation on the annotated class\n \t\tString catalog = \"\";\n \t\tList<UniqueConstraintHolder> uniqueConstraints = new ArrayList<UniqueConstraintHolder>();\n \t\tif ( clazzToProcess.isAnnotationPresent( javax.persistence.Table.class ) ) {\n \t\t\tjavax.persistence.Table tabAnn = clazzToProcess.getAnnotation( javax.persistence.Table.class );\n \t\t\ttable = tabAnn.name();\n \t\t\tschema = tabAnn.schema();\n \t\t\tcatalog = tabAnn.catalog();\n \t\t\tuniqueConstraints = TableBinder.buildUniqueConstraintHolders( tabAnn.uniqueConstraints() );\n \t\t}\n \n \t\tEjb3JoinColumn[] inheritanceJoinedColumns = makeInheritanceJoinColumns(\n \t\t\t\tclazzToProcess, mappings, inheritanceState, superEntity\n \t\t);\n \t\tEjb3DiscriminatorColumn discriminatorColumn = null;\n \t\tString discrimValue = null;\n \t\tif ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.getType() ) ) {\n \t\t\tjavax.persistence.DiscriminatorColumn discAnn = clazzToProcess.getAnnotation(\n \t\t\t\t\tjavax.persistence.DiscriminatorColumn.class\n \t\t\t);\n \t\t\tDiscriminatorType discriminatorType = discAnn != null ?\n \t\t\t\t\tdiscAnn.discriminatorType() :\n \t\t\t\t\tDiscriminatorType.STRING;\n \n \t\t\torg.hibernate.annotations.DiscriminatorFormula discFormulaAnn = clazzToProcess.getAnnotation(\n \t\t\t\t\torg.hibernate.annotations.DiscriminatorFormula.class\n \t\t\t);\n \t\t\tif ( !inheritanceState.hasParents() ) {\n \t\t\t\tdiscriminatorColumn = Ejb3DiscriminatorColumn.buildDiscriminatorColumn(\n \t\t\t\t\t\tdiscriminatorType, discAnn, discFormulaAnn, mappings\n \t\t\t\t);\n \t\t\t}\n \t\t\tif ( discAnn != null && inheritanceState.hasParents() ) {\n \t\t\t\tlog.warn(\n \t\t\t\t\t\t\"Discriminator column has to be defined in the root entity, it will be ignored in subclass: {}\",\n \t\t\t\t\t\tclazzToProcess.getName()\n \t\t\t\t);\n \t\t\t}\n \n \t\t\tdiscrimValue = clazzToProcess.isAnnotationPresent( DiscriminatorValue.class ) ?\n \t\t\t\t\tclazzToProcess.getAnnotation( DiscriminatorValue.class ).value() :\n \t\t\t\t\tnull;\n \t\t}\n \n \t\tPersistentClass persistentClass = makePersistentClass( inheritanceState, superEntity );\n \n \t\tProxy proxyAnn = clazzToProcess.getAnnotation( Proxy.class );\n \t\tBatchSize sizeAnn = clazzToProcess.getAnnotation( BatchSize.class );\n \t\tWhere whereAnn = clazzToProcess.getAnnotation( Where.class );\n \t\tEntity entityAnn = clazzToProcess.getAnnotation( Entity.class );\n \t\torg.hibernate.annotations.Entity hibEntityAnn = clazzToProcess.getAnnotation(\n \t\t\t\torg.hibernate.annotations.Entity.class\n \t\t);\n \n \t\tCache cacheAnn = determineCacheSettings( clazzToProcess, mappings );\n \n \t\tEntityBinder entityBinder = new EntityBinder(\n \t\t\t\tentityAnn, hibEntityAnn, clazzToProcess, persistentClass, mappings\n \t\t);\n \t\tentityBinder.setDiscriminatorValue( discrimValue );\n \t\tentityBinder.setBatchSize( sizeAnn );\n \t\tentityBinder.setProxy( proxyAnn );\n \t\tentityBinder.setWhere( whereAnn );\n \t\tentityBinder.setCache( cacheAnn );\n \t\tentityBinder.setInheritanceState( inheritanceState );\n \n \t\t//Filters are not allowed on subclasses\n \t\tif ( !inheritanceState.hasParents() ) {\n \t\t\tbindFilters( clazzToProcess, entityBinder, mappings );\n \t\t}\n \n \t\tentityBinder.bindEntity();\n \n \t\tif ( inheritanceState.hasTable() ) {\n \t\t\tCheck checkAnn = clazzToProcess.getAnnotation( Check.class );\n \t\t\tString constraints = checkAnn == null ?\n \t\t\t\t\tnull :\n \t\t\t\t\tcheckAnn.constraints();\n \t\t\tentityBinder.bindTable(\n \t\t\t\t\tschema, catalog, table, uniqueConstraints,\n \t\t\t\t\tconstraints, inheritanceState.hasDenormalizedTable() ?\n \t\t\t\t\t\t\tsuperEntity.getTable() :\n \t\t\t\t\t\t\tnull\n \t\t\t);\n \t\t}\n \t\telse {\n \t\t\tif ( clazzToProcess.isAnnotationPresent( Table.class ) ) {\n \t\t\t\tlog.warn(\n \t\t\t\t\t\t\"Illegal use of @Table in a subclass of a SINGLE_TABLE hierarchy: \" + clazzToProcess\n \t\t\t\t\t\t\t\t.getName()\n \t\t\t\t);\n \t\t\t}\n \t\t}\n \n \t\tPropertyHolder propertyHolder = PropertyHolderBuilder.buildPropertyHolder(\n \t\t\t\tclazzToProcess,\n \t\t\t\tpersistentClass,\n \t\t\t\tentityBinder, mappings, inheritanceStatePerClass\n \t\t);\n \n \t\tjavax.persistence.SecondaryTable secTabAnn = clazzToProcess.getAnnotation(\n \t\t\t\tjavax.persistence.SecondaryTable.class\n \t\t);\n \t\tjavax.persistence.SecondaryTables secTabsAnn = clazzToProcess.getAnnotation(\n \t\t\t\tjavax.persistence.SecondaryTables.class\n \t\t);\n \t\tentityBinder.firstLevelSecondaryTablesBinding( secTabAnn, secTabsAnn );\n \n \t\tOnDelete onDeleteAnn = clazzToProcess.getAnnotation( OnDelete.class );\n \t\tboolean onDeleteAppropriate = false;\n \t\tif ( InheritanceType.JOINED.equals( inheritanceState.getType() ) && inheritanceState.hasParents() ) {\n \t\t\tonDeleteAppropriate = true;\n \t\t\tfinal JoinedSubclass jsc = ( JoinedSubclass ) persistentClass;\n \t\t\tif ( persistentClass.getEntityPersisterClass() == null ) {\n \t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( JoinedSubclassEntityPersister.class );\n \t\t\t}\n \t\t\tSimpleValue key = new DependantValue( mappings, jsc.getTable(), jsc.getIdentifier() );\n \t\t\tjsc.setKey( key );\n \t\t\tForeignKey fk = clazzToProcess.getAnnotation( ForeignKey.class );\n-\t\t\tif ( fk != null && !BinderHelper.isDefault( fk.name() ) ) {\n+\t\t\tif ( fk != null && !BinderHelper.isEmptyAnnotationValue( fk.name() ) ) {\n \t\t\t\tkey.setForeignKeyName( fk.name() );\n \t\t\t}\n \t\t\tif ( onDeleteAnn != null ) {\n \t\t\t\tkey.setCascadeDeleteEnabled( OnDeleteAction.CASCADE.equals( onDeleteAnn.action() ) );\n \t\t\t}\n \t\t\telse {\n \t\t\t\tkey.setCascadeDeleteEnabled( false );\n \t\t\t}\n \t\t\t//we are never in a second pass at that stage, so queue it\n \t\t\tSecondPass sp = new JoinedSubclassFkSecondPass( jsc, inheritanceJoinedColumns, key, mappings );\n \t\t\tmappings.addSecondPass( sp );\n \t\t\tmappings.addSecondPass( new CreateKeySecondPass( jsc ) );\n \n \t\t}\n \t\telse if ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.getType() ) ) {\n \t\t\tif ( inheritanceState.hasParents() ) {\n \t\t\t\tif ( persistentClass.getEntityPersisterClass() == null ) {\n \t\t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( SingleTableEntityPersister.class );\n \t\t\t\t}\n \t\t\t}\n \t\t\telse {\n \t\t\t\tif ( inheritanceState.hasSiblings() || !discriminatorColumn.isImplicit() ) {\n \t\t\t\t\t//need a discriminator column\n \t\t\t\t\tbindDiscriminatorToPersistentClass(\n \t\t\t\t\t\t\t( RootClass ) persistentClass,\n \t\t\t\t\t\t\tdiscriminatorColumn,\n \t\t\t\t\t\t\tentityBinder.getSecondaryTables(),\n \t\t\t\t\t\t\tpropertyHolder,\n \t\t\t\t\t\t\tmappings\n \t\t\t\t\t);\n \t\t\t\t\tentityBinder.bindDiscriminatorValue();//bind it again since the type might have changed\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\telse if ( InheritanceType.TABLE_PER_CLASS.equals( inheritanceState.getType() ) ) {\n \t\t\tif ( inheritanceState.hasParents() ) {\n \t\t\t\tif ( persistentClass.getEntityPersisterClass() == null ) {\n \t\t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( UnionSubclassEntityPersister.class );\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\tif ( onDeleteAnn != null && !onDeleteAppropriate ) {\n \t\t\tlog.warn(\n \t\t\t\t\t\"Inapropriate use of @OnDelete on entity, annotation ignored: {}\", propertyHolder.getEntityName()\n \t\t\t);\n \t\t}\n \n \t\t// try to find class level generators\n \t\tHashMap<String, IdGenerator> classGenerators = buildLocalGenerators( clazzToProcess, mappings );\n \n \t\t// check properties\n \t\tfinal InheritanceState.ElementsToProcess elementsToProcess = inheritanceState.getElementsToProcess();\n \t\tinheritanceState.postProcess( persistentClass, entityBinder );\n \n \t\tfinal boolean subclassAndSingleTableStrategy = inheritanceState.getType() == InheritanceType.SINGLE_TABLE\n \t\t\t\t&& inheritanceState.hasParents();\n \t\tSet<String> idPropertiesIfIdClass = new HashSet<String>();\n \t\tboolean isIdClass = mapAsIdClass(\n \t\t\t\tinheritanceStatePerClass,\n \t\t\t\tinheritanceState,\n \t\t\t\tpersistentClass,\n \t\t\t\tentityBinder,\n \t\t\t\tpropertyHolder,\n \t\t\t\telementsToProcess,\n \t\t\t\tidPropertiesIfIdClass,\n \t\t\t\tmappings\n \t\t);\n \n \t\tif ( !isIdClass ) {\n \t\t\tentityBinder.setWrapIdsInEmbeddedComponents( elementsToProcess.getIdPropertyCount() > 1 );\n \t\t}\n \n \t\tprocessIdPropertiesIfNotAlready(\n \t\t\t\tinheritanceStatePerClass,\n \t\t\t\tmappings,\n \t\t\t\tpersistentClass,\n \t\t\t\tentityBinder,\n \t\t\t\tpropertyHolder,\n \t\t\t\tclassGenerators,\n \t\t\t\telementsToProcess,\n \t\t\t\tsubclassAndSingleTableStrategy,\n \t\t\t\tidPropertiesIfIdClass\n \t\t);\n \n \t\tif ( !inheritanceState.hasParents() ) {\n \t\t\tfinal RootClass rootClass = ( RootClass ) persistentClass;\n \t\t\tmappings.addSecondPass( new CreateKeySecondPass( rootClass ) );\n \t\t}\n \t\telse {\n \t\t\tsuperEntity.addSubclass( ( Subclass ) persistentClass );\n \t\t}\n \n \t\tmappings.addClass( persistentClass );\n \n \t\t//Process secondary tables and complementary definitions (ie o.h.a.Table)\n \t\tmappings.addSecondPass( new SecondaryTableSecondPass( entityBinder, propertyHolder, clazzToProcess ) );\n \n \t\t//add process complementary Table definition (index & all)\n \t\tentityBinder.processComplementaryTableDefinitions( clazzToProcess.getAnnotation( org.hibernate.annotations.Table.class ) );\n \t\tentityBinder.processComplementaryTableDefinitions( clazzToProcess.getAnnotation( org.hibernate.annotations.Tables.class ) );\n \n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"f0f82e4f1ba7416ef010d5d71914a2bbde7fc22f": {
			"type": "Yparameterchange",
			"commitMessage": "HHH-5474 - Clean up usages of now deprecated ExtendedMappings\n\n\ngit-svn-id: https://svn.jboss.org/repos/hibernate/core/trunk@20136 1b8cb986-b30d-0410-93ca-fae66ebed9b2\n",
			"commitDate": "2010-08-12, 12:13 PM",
			"commitName": "f0f82e4f1ba7416ef010d5d71914a2bbde7fc22f",
			"commitAuthor": "Steve Ebersole",
			"commitDateOld": "2010-07-08, 4:56 PM",
			"commitNameOld": "df184979ed2f19887bbea46603148dd59d3bfd1f",
			"commitAuthorOld": "Steve Ebersole",
			"daysBetweenCommits": 34.8,
			"commitsBetweenForRepo": 79,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,260 +1,261 @@\n \tpublic static void bindClass(\n-\t\t\tXClass clazzToProcess, Map<XClass, InheritanceState> inheritanceStatePerClass, ExtendedMappings mappings\n-\t) throws MappingException {\n+\t\t\tXClass clazzToProcess,\n+\t\t\tMap<XClass, InheritanceState> inheritanceStatePerClass,\n+\t\t\tMappings mappings) throws MappingException {\n \t\t//@Entity and @MappedSuperclass on the same class leads to a NPE down the road\n \t\tif ( clazzToProcess.isAnnotationPresent( Entity.class ) \n \t\t\t\t&&  clazzToProcess.isAnnotationPresent( MappedSuperclass.class ) ) {\n \t\t\tthrow new AnnotationException( \"An entity cannot be annotated with both @Entity and @MappedSuperclass: \"\n \t\t\t\t\t+ clazzToProcess.getName() );\n \t\t}\n \n \t\t//TODO: be more strict with secondarytable allowance (not for ids, not for secondary table join columns etc)\n \t\tInheritanceState inheritanceState = inheritanceStatePerClass.get( clazzToProcess );\n \t\tAnnotatedClassType classType = mappings.getClassType( clazzToProcess );\n \n \t\t//Queries declared in MappedSuperclass should be usable in Subclasses\n \t\tif ( AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals( classType ) ) {\n \t\t\tbindQueries( clazzToProcess, mappings );\n \t\t\tbindTypeDefs( clazzToProcess, mappings );\n \t\t\tbindFilterDefs( clazzToProcess, mappings );\n \t\t}\n \n \t\tif ( !isEntityClassType( clazzToProcess, classType ) ) {\n \t\t\treturn;\n \t\t}\n \n \t\tlog.info( \"Binding entity from annotated class: {}\", clazzToProcess.getName() );\n \n \t\tPersistentClass superEntity = getSuperEntity(\n \t\t\t\tclazzToProcess, inheritanceStatePerClass, mappings, inheritanceState\n \t\t);\n \n \t\tbindQueries( clazzToProcess, mappings );\n \t\tbindFilterDefs( clazzToProcess, mappings );\n \t\tbindTypeDefs( clazzToProcess, mappings );\n \t\tbindFetchProfiles( clazzToProcess, mappings );\n \t\tBinderHelper.bindAnyMetaDefs( clazzToProcess, mappings );\n \n \t\tString schema = \"\";\n \t\tString table = \"\"; //might be no @Table annotation on the annotated class\n \t\tString catalog = \"\";\n \t\tList<UniqueConstraintHolder> uniqueConstraints = new ArrayList<UniqueConstraintHolder>();\n \t\tif ( clazzToProcess.isAnnotationPresent( javax.persistence.Table.class ) ) {\n \t\t\tjavax.persistence.Table tabAnn = clazzToProcess.getAnnotation( javax.persistence.Table.class );\n \t\t\ttable = tabAnn.name();\n \t\t\tschema = tabAnn.schema();\n \t\t\tcatalog = tabAnn.catalog();\n \t\t\tuniqueConstraints = TableBinder.buildUniqueConstraintHolders( tabAnn.uniqueConstraints() );\n \t\t}\n \n \t\tEjb3JoinColumn[] inheritanceJoinedColumns = makeInheritanceJoinColumns(\n \t\t\t\tclazzToProcess, mappings, inheritanceState, superEntity\n \t\t);\n \t\tEjb3DiscriminatorColumn discriminatorColumn = null;\n \t\tString discrimValue = null;\n \t\tif ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.getType() ) ) {\n \t\t\tjavax.persistence.DiscriminatorColumn discAnn = clazzToProcess.getAnnotation(\n \t\t\t\t\tjavax.persistence.DiscriminatorColumn.class\n \t\t\t);\n \t\t\tDiscriminatorType discriminatorType = discAnn != null ?\n \t\t\t\t\tdiscAnn.discriminatorType() :\n \t\t\t\t\tDiscriminatorType.STRING;\n \n \t\t\torg.hibernate.annotations.DiscriminatorFormula discFormulaAnn = clazzToProcess.getAnnotation(\n \t\t\t\t\torg.hibernate.annotations.DiscriminatorFormula.class\n \t\t\t);\n \t\t\tif ( !inheritanceState.hasParents() ) {\n \t\t\t\tdiscriminatorColumn = Ejb3DiscriminatorColumn.buildDiscriminatorColumn(\n \t\t\t\t\t\tdiscriminatorType, discAnn, discFormulaAnn, mappings\n \t\t\t\t);\n \t\t\t}\n \t\t\tif ( discAnn != null && inheritanceState.hasParents() ) {\n \t\t\t\tlog.warn(\n \t\t\t\t\t\t\"Discriminator column has to be defined in the root entity, it will be ignored in subclass: {}\",\n \t\t\t\t\t\tclazzToProcess.getName()\n \t\t\t\t);\n \t\t\t}\n \n \t\t\tdiscrimValue = clazzToProcess.isAnnotationPresent( DiscriminatorValue.class ) ?\n \t\t\t\t\tclazzToProcess.getAnnotation( DiscriminatorValue.class ).value() :\n \t\t\t\t\tnull;\n \t\t}\n \n \t\tPersistentClass persistentClass = makePersistentClass( inheritanceState, superEntity );\n \n \t\tProxy proxyAnn = clazzToProcess.getAnnotation( Proxy.class );\n \t\tBatchSize sizeAnn = clazzToProcess.getAnnotation( BatchSize.class );\n \t\tWhere whereAnn = clazzToProcess.getAnnotation( Where.class );\n \t\tEntity entityAnn = clazzToProcess.getAnnotation( Entity.class );\n \t\torg.hibernate.annotations.Entity hibEntityAnn = clazzToProcess.getAnnotation(\n \t\t\t\torg.hibernate.annotations.Entity.class\n \t\t);\n \n \t\tCache cacheAnn = determineCacheSettings( clazzToProcess, mappings );\n \n \t\tEntityBinder entityBinder = new EntityBinder(\n \t\t\t\tentityAnn, hibEntityAnn, clazzToProcess, persistentClass, mappings\n \t\t);\n \t\tentityBinder.setDiscriminatorValue( discrimValue );\n \t\tentityBinder.setBatchSize( sizeAnn );\n \t\tentityBinder.setProxy( proxyAnn );\n \t\tentityBinder.setWhere( whereAnn );\n \t\tentityBinder.setCache( cacheAnn );\n \t\tentityBinder.setInheritanceState( inheritanceState );\n \n \t\t//Filters are not allowed on subclasses\n \t\tif ( !inheritanceState.hasParents() ) {\n \t\t\tbindFilters( clazzToProcess, entityBinder, mappings );\n \t\t}\n \n \t\tentityBinder.bindEntity();\n \n \t\tif ( inheritanceState.hasTable() ) {\n \t\t\tCheck checkAnn = clazzToProcess.getAnnotation( Check.class );\n \t\t\tString constraints = checkAnn == null ?\n \t\t\t\t\tnull :\n \t\t\t\t\tcheckAnn.constraints();\n \t\t\tentityBinder.bindTable(\n \t\t\t\t\tschema, catalog, table, uniqueConstraints,\n \t\t\t\t\tconstraints, inheritanceState.hasDenormalizedTable() ?\n \t\t\t\t\t\t\tsuperEntity.getTable() :\n \t\t\t\t\t\t\tnull\n \t\t\t);\n \t\t}\n \t\telse {\n \t\t\tif ( clazzToProcess.isAnnotationPresent( Table.class ) ) {\n \t\t\t\tlog.warn(\n \t\t\t\t\t\t\"Illegal use of @Table in a subclass of a SINGLE_TABLE hierarchy: \" + clazzToProcess\n \t\t\t\t\t\t\t\t.getName()\n \t\t\t\t);\n \t\t\t}\n \t\t}\n \n \t\tPropertyHolder propertyHolder = PropertyHolderBuilder.buildPropertyHolder(\n \t\t\t\tclazzToProcess,\n \t\t\t\tpersistentClass,\n \t\t\t\tentityBinder, mappings, inheritanceStatePerClass\n \t\t);\n \n \t\tjavax.persistence.SecondaryTable secTabAnn = clazzToProcess.getAnnotation(\n \t\t\t\tjavax.persistence.SecondaryTable.class\n \t\t);\n \t\tjavax.persistence.SecondaryTables secTabsAnn = clazzToProcess.getAnnotation(\n \t\t\t\tjavax.persistence.SecondaryTables.class\n \t\t);\n \t\tentityBinder.firstLevelSecondaryTablesBinding( secTabAnn, secTabsAnn );\n \n \t\tOnDelete onDeleteAnn = clazzToProcess.getAnnotation( OnDelete.class );\n \t\tboolean onDeleteAppropriate = false;\n \t\tif ( InheritanceType.JOINED.equals( inheritanceState.getType() ) && inheritanceState.hasParents() ) {\n \t\t\tonDeleteAppropriate = true;\n \t\t\tfinal JoinedSubclass jsc = ( JoinedSubclass ) persistentClass;\n \t\t\tif ( persistentClass.getEntityPersisterClass() == null ) {\n \t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( JoinedSubclassEntityPersister.class );\n \t\t\t}\n \t\t\tSimpleValue key = new DependantValue( mappings, jsc.getTable(), jsc.getIdentifier() );\n \t\t\tjsc.setKey( key );\n \t\t\tForeignKey fk = clazzToProcess.getAnnotation( ForeignKey.class );\n \t\t\tif ( fk != null && !BinderHelper.isDefault( fk.name() ) ) {\n \t\t\t\tkey.setForeignKeyName( fk.name() );\n \t\t\t}\n \t\t\tif ( onDeleteAnn != null ) {\n \t\t\t\tkey.setCascadeDeleteEnabled( OnDeleteAction.CASCADE.equals( onDeleteAnn.action() ) );\n \t\t\t}\n \t\t\telse {\n \t\t\t\tkey.setCascadeDeleteEnabled( false );\n \t\t\t}\n \t\t\t//we are never in a second pass at that stage, so queue it\n \t\t\tSecondPass sp = new JoinedSubclassFkSecondPass( jsc, inheritanceJoinedColumns, key, mappings );\n \t\t\tmappings.addSecondPass( sp );\n \t\t\tmappings.addSecondPass( new CreateKeySecondPass( jsc ) );\n \n \t\t}\n \t\telse if ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.getType() ) ) {\n \t\t\tif ( inheritanceState.hasParents() ) {\n \t\t\t\tif ( persistentClass.getEntityPersisterClass() == null ) {\n \t\t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( SingleTableEntityPersister.class );\n \t\t\t\t}\n \t\t\t}\n \t\t\telse {\n \t\t\t\tif ( inheritanceState.hasSiblings() || !discriminatorColumn.isImplicit() ) {\n \t\t\t\t\t//need a discriminator column\n \t\t\t\t\tbindDiscriminatorToPersistentClass(\n \t\t\t\t\t\t\t( RootClass ) persistentClass,\n \t\t\t\t\t\t\tdiscriminatorColumn,\n \t\t\t\t\t\t\tentityBinder.getSecondaryTables(),\n \t\t\t\t\t\t\tpropertyHolder,\n \t\t\t\t\t\t\tmappings\n \t\t\t\t\t);\n \t\t\t\t\tentityBinder.bindDiscriminatorValue();//bind it again since the type might have changed\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\telse if ( InheritanceType.TABLE_PER_CLASS.equals( inheritanceState.getType() ) ) {\n \t\t\tif ( inheritanceState.hasParents() ) {\n \t\t\t\tif ( persistentClass.getEntityPersisterClass() == null ) {\n \t\t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( UnionSubclassEntityPersister.class );\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\tif ( onDeleteAnn != null && !onDeleteAppropriate ) {\n \t\t\tlog.warn(\n \t\t\t\t\t\"Inapropriate use of @OnDelete on entity, annotation ignored: {}\", propertyHolder.getEntityName()\n \t\t\t);\n \t\t}\n \n \t\t// try to find class level generators\n \t\tHashMap<String, IdGenerator> classGenerators = buildLocalGenerators( clazzToProcess, mappings );\n \n \t\t// check properties\n \t\tfinal InheritanceState.ElementsToProcess elementsToProcess = inheritanceState.getElementsToProcess();\n \t\tinheritanceState.postProcess( persistentClass, entityBinder );\n \n \t\tfinal boolean subclassAndSingleTableStrategy = inheritanceState.getType() == InheritanceType.SINGLE_TABLE\n \t\t\t\t&& inheritanceState.hasParents();\n \t\tSet<String> idPropertiesIfIdClass = new HashSet<String>();\n \t\tboolean isIdClass = mapAsIdClass(\n \t\t\t\tinheritanceStatePerClass,\n \t\t\t\tinheritanceState,\n \t\t\t\tpersistentClass,\n \t\t\t\tentityBinder,\n \t\t\t\tpropertyHolder,\n \t\t\t\telementsToProcess,\n \t\t\t\tidPropertiesIfIdClass,\n \t\t\t\tmappings\n \t\t);\n \n \t\tif ( !isIdClass ) {\n \t\t\tentityBinder.setWrapIdsInEmbeddedComponents( elementsToProcess.getIdPropertyCount() > 1 );\n \t\t}\n \n \t\tprocessIdPropertiesIfNotAlready(\n \t\t\t\tinheritanceStatePerClass,\n \t\t\t\tmappings,\n \t\t\t\tpersistentClass,\n \t\t\t\tentityBinder,\n \t\t\t\tpropertyHolder,\n \t\t\t\tclassGenerators,\n \t\t\t\telementsToProcess,\n \t\t\t\tsubclassAndSingleTableStrategy,\n \t\t\t\tidPropertiesIfIdClass\n \t\t);\n \n \t\tif ( !inheritanceState.hasParents() ) {\n \t\t\tfinal RootClass rootClass = ( RootClass ) persistentClass;\n \t\t\tmappings.addSecondPass( new CreateKeySecondPass( rootClass ) );\n \t\t}\n \t\telse {\n \t\t\tsuperEntity.addSubclass( ( Subclass ) persistentClass );\n \t\t}\n \n \t\tmappings.addClass( persistentClass );\n \n \t\t//Process secondary tables and complementary definitions (ie o.h.a.Table)\n \t\tmappings.addSecondPass( new SecondaryTableSecondPass( entityBinder, propertyHolder, clazzToProcess ) );\n \n \t\t//add process complementary Table definition (index & all)\n \t\tentityBinder.processComplementaryTableDefinitions( clazzToProcess.getAnnotation( org.hibernate.annotations.Table.class ) );\n \t\tentityBinder.processComplementaryTableDefinitions( clazzToProcess.getAnnotation( org.hibernate.annotations.Tables.class ) );\n \n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {
				"oldValue": "[clazzToProcess-XClass, inheritanceStatePerClass-Map<XClass,InheritanceState>, mappings-ExtendedMappings]",
				"newValue": "[clazzToProcess-XClass, inheritanceStatePerClass-Map<XClass,InheritanceState>, mappings-Mappings]"
			}
		},
		"1ca2bc19a5f667e10f9a2c2b10320b9c40921563": {
			"type": "Yfilerename",
			"commitMessage": "HHH-5367 - Move annotations module sources into core module\n\n\ngit-svn-id: https://svn.jboss.org/repos/hibernate/core/trunk@19921 1b8cb986-b30d-0410-93ca-fae66ebed9b2\n",
			"commitDate": "2010-07-08, 4:41 PM",
			"commitName": "1ca2bc19a5f667e10f9a2c2b10320b9c40921563",
			"commitAuthor": "Steve Ebersole",
			"commitDateOld": "2010-07-08, 10:32 AM",
			"commitNameOld": "cc3b41a09c983913594b16d6c909be0bfd41bd7a",
			"commitAuthorOld": "Steve Ebersole",
			"daysBetweenCommits": 0.26,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "",
			"extendedDetails": {
				"oldPath": "annotations/src/main/java/org/hibernate/cfg/AnnotationBinder.java",
				"newPath": "core/src/main/java/org/hibernate/cfg/AnnotationBinder.java"
			}
		},
		"421789ddcd906e806bf901fea9d9e713daebd51a": {
			"type": "Ybodychange",
			"commitMessage": "HHH-5138 - Redesign types + introduce TypeRegistry & TypeResolver\n\ngit-svn-id: https://svn.jboss.org/repos/hibernate/core/trunk@19335 1b8cb986-b30d-0410-93ca-fae66ebed9b2\n",
			"commitDate": "2010-05-01, 11:20 AM",
			"commitName": "421789ddcd906e806bf901fea9d9e713daebd51a",
			"commitAuthor": "Steve Ebersole",
			"commitDateOld": "2010-04-27, 1:38 AM",
			"commitNameOld": "b912a95d5422d6ce91c8b89aecb6b3923626e9c7",
			"commitAuthorOld": "Sharath Reddy",
			"daysBetweenCommits": 4.4,
			"commitsBetweenForRepo": 9,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,259 +1,260 @@\n \tpublic static void bindClass(\n \t\t\tXClass clazzToProcess, Map<XClass, InheritanceState> inheritanceStatePerClass, ExtendedMappings mappings\n \t) throws MappingException {\n \t\t//@Entity and @MappedSuperclass on the same class leads to a NPE down the road\n \t\tif ( clazzToProcess.isAnnotationPresent( Entity.class ) \n \t\t\t\t&&  clazzToProcess.isAnnotationPresent( MappedSuperclass.class ) ) {\n \t\t\tthrow new AnnotationException( \"An entity cannot be annotated with both @Entity and @MappedSuperclass: \"\n \t\t\t\t\t+ clazzToProcess.getName() );\n \t\t}\n \n \t\t//TODO: be more strict with secondarytable allowance (not for ids, not for secondary table join columns etc)\n \t\tInheritanceState inheritanceState = inheritanceStatePerClass.get( clazzToProcess );\n \t\tAnnotatedClassType classType = mappings.getClassType( clazzToProcess );\n \n \t\t//Queries declared in MappedSuperclass should be usable in Subclasses\n \t\tif ( AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals( classType ) ) {\n \t\t\tbindQueries( clazzToProcess, mappings );\n \t\t\tbindTypeDefs( clazzToProcess, mappings );\n \t\t\tbindFilterDefs( clazzToProcess, mappings );\n \t\t}\n \n \t\tif ( !isEntityClassType( clazzToProcess, classType ) ) {\n \t\t\treturn;\n \t\t}\n \n \t\tlog.info( \"Binding entity from annotated class: {}\", clazzToProcess.getName() );\n \n \t\tPersistentClass superEntity = getSuperEntity(\n \t\t\t\tclazzToProcess, inheritanceStatePerClass, mappings, inheritanceState\n \t\t);\n \n \t\tbindQueries( clazzToProcess, mappings );\n \t\tbindFilterDefs( clazzToProcess, mappings );\n \t\tbindTypeDefs( clazzToProcess, mappings );\n \t\tbindFetchProfiles( clazzToProcess, mappings );\n \t\tBinderHelper.bindAnyMetaDefs( clazzToProcess, mappings );\n \n \t\tString schema = \"\";\n \t\tString table = \"\"; //might be no @Table annotation on the annotated class\n \t\tString catalog = \"\";\n \t\tList<UniqueConstraintHolder> uniqueConstraints = new ArrayList<UniqueConstraintHolder>();\n \t\tif ( clazzToProcess.isAnnotationPresent( javax.persistence.Table.class ) ) {\n \t\t\tjavax.persistence.Table tabAnn = clazzToProcess.getAnnotation( javax.persistence.Table.class );\n \t\t\ttable = tabAnn.name();\n \t\t\tschema = tabAnn.schema();\n \t\t\tcatalog = tabAnn.catalog();\n \t\t\tuniqueConstraints = TableBinder.buildUniqueConstraintHolders( tabAnn.uniqueConstraints() );\n \t\t}\n \n \t\tEjb3JoinColumn[] inheritanceJoinedColumns = makeInheritanceJoinColumns(\n \t\t\t\tclazzToProcess, mappings, inheritanceState, superEntity\n \t\t);\n \t\tEjb3DiscriminatorColumn discriminatorColumn = null;\n \t\tString discrimValue = null;\n \t\tif ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.getType() ) ) {\n \t\t\tjavax.persistence.DiscriminatorColumn discAnn = clazzToProcess.getAnnotation(\n \t\t\t\t\tjavax.persistence.DiscriminatorColumn.class\n \t\t\t);\n \t\t\tDiscriminatorType discriminatorType = discAnn != null ?\n \t\t\t\t\tdiscAnn.discriminatorType() :\n \t\t\t\t\tDiscriminatorType.STRING;\n \n \t\t\torg.hibernate.annotations.DiscriminatorFormula discFormulaAnn = clazzToProcess.getAnnotation(\n \t\t\t\t\torg.hibernate.annotations.DiscriminatorFormula.class\n \t\t\t);\n \t\t\tif ( !inheritanceState.hasParents() ) {\n \t\t\t\tdiscriminatorColumn = Ejb3DiscriminatorColumn.buildDiscriminatorColumn(\n \t\t\t\t\t\tdiscriminatorType, discAnn, discFormulaAnn, mappings\n \t\t\t\t);\n \t\t\t}\n \t\t\tif ( discAnn != null && inheritanceState.hasParents() ) {\n \t\t\t\tlog.warn(\n \t\t\t\t\t\t\"Discriminator column has to be defined in the root entity, it will be ignored in subclass: {}\",\n \t\t\t\t\t\tclazzToProcess.getName()\n \t\t\t\t);\n \t\t\t}\n \n \t\t\tdiscrimValue = clazzToProcess.isAnnotationPresent( DiscriminatorValue.class ) ?\n \t\t\t\t\tclazzToProcess.getAnnotation( DiscriminatorValue.class ).value() :\n \t\t\t\t\tnull;\n \t\t}\n \n \t\tPersistentClass persistentClass = makePersistentClass( inheritanceState, superEntity );\n \n \t\tProxy proxyAnn = clazzToProcess.getAnnotation( Proxy.class );\n \t\tBatchSize sizeAnn = clazzToProcess.getAnnotation( BatchSize.class );\n \t\tWhere whereAnn = clazzToProcess.getAnnotation( Where.class );\n \t\tEntity entityAnn = clazzToProcess.getAnnotation( Entity.class );\n \t\torg.hibernate.annotations.Entity hibEntityAnn = clazzToProcess.getAnnotation(\n \t\t\t\torg.hibernate.annotations.Entity.class\n \t\t);\n \n \t\tCache cacheAnn = determineCacheSettings( clazzToProcess, mappings );\n \n \t\tEntityBinder entityBinder = new EntityBinder(\n \t\t\t\tentityAnn, hibEntityAnn, clazzToProcess, persistentClass, mappings\n \t\t);\n \t\tentityBinder.setDiscriminatorValue( discrimValue );\n \t\tentityBinder.setBatchSize( sizeAnn );\n \t\tentityBinder.setProxy( proxyAnn );\n \t\tentityBinder.setWhere( whereAnn );\n \t\tentityBinder.setCache( cacheAnn );\n \t\tentityBinder.setInheritanceState( inheritanceState );\n \n \t\t//Filters are not allowed on subclasses\n \t\tif ( !inheritanceState.hasParents() ) {\n \t\t\tbindFilters( clazzToProcess, entityBinder, mappings );\n \t\t}\n \n \t\tentityBinder.bindEntity();\n \n \t\tif ( inheritanceState.hasTable() ) {\n \t\t\tCheck checkAnn = clazzToProcess.getAnnotation( Check.class );\n \t\t\tString constraints = checkAnn == null ?\n \t\t\t\t\tnull :\n \t\t\t\t\tcheckAnn.constraints();\n \t\t\tentityBinder.bindTable(\n \t\t\t\t\tschema, catalog, table, uniqueConstraints,\n \t\t\t\t\tconstraints, inheritanceState.hasDenormalizedTable() ?\n \t\t\t\t\t\t\tsuperEntity.getTable() :\n \t\t\t\t\t\t\tnull\n \t\t\t);\n \t\t}\n \t\telse {\n \t\t\tif ( clazzToProcess.isAnnotationPresent( Table.class ) ) {\n \t\t\t\tlog.warn(\n \t\t\t\t\t\t\"Illegal use of @Table in a subclass of a SINGLE_TABLE hierarchy: \" + clazzToProcess\n \t\t\t\t\t\t\t\t.getName()\n \t\t\t\t);\n \t\t\t}\n \t\t}\n \n \t\tPropertyHolder propertyHolder = PropertyHolderBuilder.buildPropertyHolder(\n \t\t\t\tclazzToProcess,\n \t\t\t\tpersistentClass,\n \t\t\t\tentityBinder, mappings, inheritanceStatePerClass\n \t\t);\n \n \t\tjavax.persistence.SecondaryTable secTabAnn = clazzToProcess.getAnnotation(\n \t\t\t\tjavax.persistence.SecondaryTable.class\n \t\t);\n \t\tjavax.persistence.SecondaryTables secTabsAnn = clazzToProcess.getAnnotation(\n \t\t\t\tjavax.persistence.SecondaryTables.class\n \t\t);\n \t\tentityBinder.firstLevelSecondaryTablesBinding( secTabAnn, secTabsAnn );\n \n \t\tOnDelete onDeleteAnn = clazzToProcess.getAnnotation( OnDelete.class );\n \t\tboolean onDeleteAppropriate = false;\n \t\tif ( InheritanceType.JOINED.equals( inheritanceState.getType() ) && inheritanceState.hasParents() ) {\n \t\t\tonDeleteAppropriate = true;\n \t\t\tfinal JoinedSubclass jsc = ( JoinedSubclass ) persistentClass;\n \t\t\tif ( persistentClass.getEntityPersisterClass() == null ) {\n \t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( JoinedSubclassEntityPersister.class );\n \t\t\t}\n-\t\t\tSimpleValue key = new DependantValue( jsc.getTable(), jsc.getIdentifier() );\n+\t\t\tSimpleValue key = new DependantValue( mappings, jsc.getTable(), jsc.getIdentifier() );\n \t\t\tjsc.setKey( key );\n \t\t\tForeignKey fk = clazzToProcess.getAnnotation( ForeignKey.class );\n \t\t\tif ( fk != null && !BinderHelper.isDefault( fk.name() ) ) {\n \t\t\t\tkey.setForeignKeyName( fk.name() );\n \t\t\t}\n \t\t\tif ( onDeleteAnn != null ) {\n \t\t\t\tkey.setCascadeDeleteEnabled( OnDeleteAction.CASCADE.equals( onDeleteAnn.action() ) );\n \t\t\t}\n \t\t\telse {\n \t\t\t\tkey.setCascadeDeleteEnabled( false );\n \t\t\t}\n \t\t\t//we are never in a second pass at that stage, so queue it\n \t\t\tSecondPass sp = new JoinedSubclassFkSecondPass( jsc, inheritanceJoinedColumns, key, mappings );\n \t\t\tmappings.addSecondPass( sp );\n \t\t\tmappings.addSecondPass( new CreateKeySecondPass( jsc ) );\n \n \t\t}\n \t\telse if ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.getType() ) ) {\n \t\t\tif ( inheritanceState.hasParents() ) {\n \t\t\t\tif ( persistentClass.getEntityPersisterClass() == null ) {\n \t\t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( SingleTableEntityPersister.class );\n \t\t\t\t}\n \t\t\t}\n \t\t\telse {\n \t\t\t\tif ( inheritanceState.hasSiblings() || !discriminatorColumn.isImplicit() ) {\n \t\t\t\t\t//need a discriminator column\n \t\t\t\t\tbindDiscriminatorToPersistentClass(\n \t\t\t\t\t\t\t( RootClass ) persistentClass,\n \t\t\t\t\t\t\tdiscriminatorColumn,\n \t\t\t\t\t\t\tentityBinder.getSecondaryTables(),\n-\t\t\t\t\t\t\tpropertyHolder\n+\t\t\t\t\t\t\tpropertyHolder,\n+\t\t\t\t\t\t\tmappings\n \t\t\t\t\t);\n \t\t\t\t\tentityBinder.bindDiscriminatorValue();//bind it again since the type might have changed\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\telse if ( InheritanceType.TABLE_PER_CLASS.equals( inheritanceState.getType() ) ) {\n \t\t\tif ( inheritanceState.hasParents() ) {\n \t\t\t\tif ( persistentClass.getEntityPersisterClass() == null ) {\n \t\t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( UnionSubclassEntityPersister.class );\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\tif ( onDeleteAnn != null && !onDeleteAppropriate ) {\n \t\t\tlog.warn(\n \t\t\t\t\t\"Inapropriate use of @OnDelete on entity, annotation ignored: {}\", propertyHolder.getEntityName()\n \t\t\t);\n \t\t}\n \n \t\t// try to find class level generators\n \t\tHashMap<String, IdGenerator> classGenerators = buildLocalGenerators( clazzToProcess, mappings );\n \n \t\t// check properties\n \t\tfinal InheritanceState.ElementsToProcess elementsToProcess = inheritanceState.getElementsToProcess();\n \t\tinheritanceState.postProcess( persistentClass, entityBinder );\n \n \t\tfinal boolean subclassAndSingleTableStrategy = inheritanceState.getType() == InheritanceType.SINGLE_TABLE\n \t\t\t\t&& inheritanceState.hasParents();\n \t\tSet<String> idPropertiesIfIdClass = new HashSet<String>();\n \t\tboolean isIdClass = mapAsIdClass(\n \t\t\t\tinheritanceStatePerClass,\n \t\t\t\tinheritanceState,\n \t\t\t\tpersistentClass,\n \t\t\t\tentityBinder,\n \t\t\t\tpropertyHolder,\n \t\t\t\telementsToProcess,\n \t\t\t\tidPropertiesIfIdClass,\n \t\t\t\tmappings\n \t\t);\n \n \t\tif ( !isIdClass ) {\n \t\t\tentityBinder.setWrapIdsInEmbeddedComponents( elementsToProcess.getIdPropertyCount() > 1 );\n \t\t}\n \n \t\tprocessIdPropertiesIfNotAlready(\n \t\t\t\tinheritanceStatePerClass,\n \t\t\t\tmappings,\n \t\t\t\tpersistentClass,\n \t\t\t\tentityBinder,\n \t\t\t\tpropertyHolder,\n \t\t\t\tclassGenerators,\n \t\t\t\telementsToProcess,\n \t\t\t\tsubclassAndSingleTableStrategy,\n \t\t\t\tidPropertiesIfIdClass\n \t\t);\n \n \t\tif ( !inheritanceState.hasParents() ) {\n \t\t\tfinal RootClass rootClass = ( RootClass ) persistentClass;\n \t\t\tmappings.addSecondPass( new CreateKeySecondPass( rootClass ) );\n \t\t}\n \t\telse {\n \t\t\tsuperEntity.addSubclass( ( Subclass ) persistentClass );\n \t\t}\n \n \t\tmappings.addClass( persistentClass );\n \n \t\t//Process secondary tables and complementary definitions (ie o.h.a.Table)\n \t\tmappings.addSecondPass( new SecondaryTableSecondPass( entityBinder, propertyHolder, clazzToProcess ) );\n \n \t\t//add process complementary Table definition (index & all)\n \t\tentityBinder.processComplementaryTableDefinitions( clazzToProcess.getAnnotation( org.hibernate.annotations.Table.class ) );\n \t\tentityBinder.processComplementaryTableDefinitions( clazzToProcess.getAnnotation( org.hibernate.annotations.Tables.class ) );\n \n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"422ecc653a7d78ee0464478750a076710b697849": {
			"type": "Ybodychange",
			"commitMessage": "HHH-5125 Raise proper exception when @Entity and @MappedSuperclass are present on the same class\n\ngit-svn-id: https://svn.jboss.org/repos/hibernate/core/trunk@19241 1b8cb986-b30d-0410-93ca-fae66ebed9b2\n",
			"commitDate": "2010-04-16, 3:11 AM",
			"commitName": "422ecc653a7d78ee0464478750a076710b697849",
			"commitAuthor": "Emmanuel Bernard",
			"commitDateOld": "2010-03-04, 1:55 PM",
			"commitNameOld": "153ad753e19b1f71665e6cfcbd903fb1ced889db",
			"commitAuthorOld": "Hardy Ferentschik",
			"daysBetweenCommits": 42.51,
			"commitsBetweenForRepo": 128,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,252 +1,259 @@\n \tpublic static void bindClass(\n \t\t\tXClass clazzToProcess, Map<XClass, InheritanceState> inheritanceStatePerClass, ExtendedMappings mappings\n \t) throws MappingException {\n+\t\t//@Entity and @MappedSuperclass on the same class leads to a NPE down the road\n+\t\tif ( clazzToProcess.isAnnotationPresent( Entity.class ) \n+\t\t\t\t&&  clazzToProcess.isAnnotationPresent( MappedSuperclass.class ) ) {\n+\t\t\tthrow new AnnotationException( \"An entity cannot be annotated with both @Entity and @MappedSuperclass: \"\n+\t\t\t\t\t+ clazzToProcess.getName() );\n+\t\t}\n+\n \t\t//TODO: be more strict with secondarytable allowance (not for ids, not for secondary table join columns etc)\n \t\tInheritanceState inheritanceState = inheritanceStatePerClass.get( clazzToProcess );\n \t\tAnnotatedClassType classType = mappings.getClassType( clazzToProcess );\n \n \t\t//Queries declared in MappedSuperclass should be usable in Subclasses\n \t\tif ( AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals( classType ) ) {\n \t\t\tbindQueries( clazzToProcess, mappings );\n \t\t\tbindTypeDefs( clazzToProcess, mappings );\n \t\t\tbindFilterDefs( clazzToProcess, mappings );\n \t\t}\n \n \t\tif ( !isEntityClassType( clazzToProcess, classType ) ) {\n \t\t\treturn;\n \t\t}\n \n \t\tlog.info( \"Binding entity from annotated class: {}\", clazzToProcess.getName() );\n \n \t\tPersistentClass superEntity = getSuperEntity(\n \t\t\t\tclazzToProcess, inheritanceStatePerClass, mappings, inheritanceState\n \t\t);\n \n \t\tbindQueries( clazzToProcess, mappings );\n \t\tbindFilterDefs( clazzToProcess, mappings );\n \t\tbindTypeDefs( clazzToProcess, mappings );\n \t\tbindFetchProfiles( clazzToProcess, mappings );\n \t\tBinderHelper.bindAnyMetaDefs( clazzToProcess, mappings );\n \n \t\tString schema = \"\";\n \t\tString table = \"\"; //might be no @Table annotation on the annotated class\n \t\tString catalog = \"\";\n \t\tList<UniqueConstraintHolder> uniqueConstraints = new ArrayList<UniqueConstraintHolder>();\n \t\tif ( clazzToProcess.isAnnotationPresent( javax.persistence.Table.class ) ) {\n \t\t\tjavax.persistence.Table tabAnn = clazzToProcess.getAnnotation( javax.persistence.Table.class );\n \t\t\ttable = tabAnn.name();\n \t\t\tschema = tabAnn.schema();\n \t\t\tcatalog = tabAnn.catalog();\n \t\t\tuniqueConstraints = TableBinder.buildUniqueConstraintHolders( tabAnn.uniqueConstraints() );\n \t\t}\n \n \t\tEjb3JoinColumn[] inheritanceJoinedColumns = makeInheritanceJoinColumns(\n \t\t\t\tclazzToProcess, mappings, inheritanceState, superEntity\n \t\t);\n \t\tEjb3DiscriminatorColumn discriminatorColumn = null;\n \t\tString discrimValue = null;\n \t\tif ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.getType() ) ) {\n \t\t\tjavax.persistence.DiscriminatorColumn discAnn = clazzToProcess.getAnnotation(\n \t\t\t\t\tjavax.persistence.DiscriminatorColumn.class\n \t\t\t);\n \t\t\tDiscriminatorType discriminatorType = discAnn != null ?\n \t\t\t\t\tdiscAnn.discriminatorType() :\n \t\t\t\t\tDiscriminatorType.STRING;\n \n \t\t\torg.hibernate.annotations.DiscriminatorFormula discFormulaAnn = clazzToProcess.getAnnotation(\n \t\t\t\t\torg.hibernate.annotations.DiscriminatorFormula.class\n \t\t\t);\n \t\t\tif ( !inheritanceState.hasParents() ) {\n \t\t\t\tdiscriminatorColumn = Ejb3DiscriminatorColumn.buildDiscriminatorColumn(\n \t\t\t\t\t\tdiscriminatorType, discAnn, discFormulaAnn, mappings\n \t\t\t\t);\n \t\t\t}\n \t\t\tif ( discAnn != null && inheritanceState.hasParents() ) {\n \t\t\t\tlog.warn(\n \t\t\t\t\t\t\"Discriminator column has to be defined in the root entity, it will be ignored in subclass: {}\",\n \t\t\t\t\t\tclazzToProcess.getName()\n \t\t\t\t);\n \t\t\t}\n \n \t\t\tdiscrimValue = clazzToProcess.isAnnotationPresent( DiscriminatorValue.class ) ?\n \t\t\t\t\tclazzToProcess.getAnnotation( DiscriminatorValue.class ).value() :\n \t\t\t\t\tnull;\n \t\t}\n \n \t\tPersistentClass persistentClass = makePersistentClass( inheritanceState, superEntity );\n \n \t\tProxy proxyAnn = clazzToProcess.getAnnotation( Proxy.class );\n \t\tBatchSize sizeAnn = clazzToProcess.getAnnotation( BatchSize.class );\n \t\tWhere whereAnn = clazzToProcess.getAnnotation( Where.class );\n \t\tEntity entityAnn = clazzToProcess.getAnnotation( Entity.class );\n \t\torg.hibernate.annotations.Entity hibEntityAnn = clazzToProcess.getAnnotation(\n \t\t\t\torg.hibernate.annotations.Entity.class\n \t\t);\n \n \t\tCache cacheAnn = determineCacheSettings( clazzToProcess, mappings );\n \n \t\tEntityBinder entityBinder = new EntityBinder(\n \t\t\t\tentityAnn, hibEntityAnn, clazzToProcess, persistentClass, mappings\n \t\t);\n \t\tentityBinder.setDiscriminatorValue( discrimValue );\n \t\tentityBinder.setBatchSize( sizeAnn );\n \t\tentityBinder.setProxy( proxyAnn );\n \t\tentityBinder.setWhere( whereAnn );\n \t\tentityBinder.setCache( cacheAnn );\n \t\tentityBinder.setInheritanceState( inheritanceState );\n \n \t\t//Filters are not allowed on subclasses\n \t\tif ( !inheritanceState.hasParents() ) {\n \t\t\tbindFilters( clazzToProcess, entityBinder, mappings );\n \t\t}\n \n \t\tentityBinder.bindEntity();\n \n \t\tif ( inheritanceState.hasTable() ) {\n \t\t\tCheck checkAnn = clazzToProcess.getAnnotation( Check.class );\n \t\t\tString constraints = checkAnn == null ?\n \t\t\t\t\tnull :\n \t\t\t\t\tcheckAnn.constraints();\n \t\t\tentityBinder.bindTable(\n \t\t\t\t\tschema, catalog, table, uniqueConstraints,\n \t\t\t\t\tconstraints, inheritanceState.hasDenormalizedTable() ?\n \t\t\t\t\t\t\tsuperEntity.getTable() :\n \t\t\t\t\t\t\tnull\n \t\t\t);\n \t\t}\n \t\telse {\n \t\t\tif ( clazzToProcess.isAnnotationPresent( Table.class ) ) {\n \t\t\t\tlog.warn(\n \t\t\t\t\t\t\"Illegal use of @Table in a subclass of a SINGLE_TABLE hierarchy: \" + clazzToProcess\n \t\t\t\t\t\t\t\t.getName()\n \t\t\t\t);\n \t\t\t}\n \t\t}\n \n \t\tPropertyHolder propertyHolder = PropertyHolderBuilder.buildPropertyHolder(\n \t\t\t\tclazzToProcess,\n \t\t\t\tpersistentClass,\n \t\t\t\tentityBinder, mappings, inheritanceStatePerClass\n \t\t);\n \n \t\tjavax.persistence.SecondaryTable secTabAnn = clazzToProcess.getAnnotation(\n \t\t\t\tjavax.persistence.SecondaryTable.class\n \t\t);\n \t\tjavax.persistence.SecondaryTables secTabsAnn = clazzToProcess.getAnnotation(\n \t\t\t\tjavax.persistence.SecondaryTables.class\n \t\t);\n \t\tentityBinder.firstLevelSecondaryTablesBinding( secTabAnn, secTabsAnn );\n \n \t\tOnDelete onDeleteAnn = clazzToProcess.getAnnotation( OnDelete.class );\n \t\tboolean onDeleteAppropriate = false;\n \t\tif ( InheritanceType.JOINED.equals( inheritanceState.getType() ) && inheritanceState.hasParents() ) {\n \t\t\tonDeleteAppropriate = true;\n \t\t\tfinal JoinedSubclass jsc = ( JoinedSubclass ) persistentClass;\n \t\t\tif ( persistentClass.getEntityPersisterClass() == null ) {\n \t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( JoinedSubclassEntityPersister.class );\n \t\t\t}\n \t\t\tSimpleValue key = new DependantValue( jsc.getTable(), jsc.getIdentifier() );\n \t\t\tjsc.setKey( key );\n \t\t\tForeignKey fk = clazzToProcess.getAnnotation( ForeignKey.class );\n \t\t\tif ( fk != null && !BinderHelper.isDefault( fk.name() ) ) {\n \t\t\t\tkey.setForeignKeyName( fk.name() );\n \t\t\t}\n \t\t\tif ( onDeleteAnn != null ) {\n \t\t\t\tkey.setCascadeDeleteEnabled( OnDeleteAction.CASCADE.equals( onDeleteAnn.action() ) );\n \t\t\t}\n \t\t\telse {\n \t\t\t\tkey.setCascadeDeleteEnabled( false );\n \t\t\t}\n \t\t\t//we are never in a second pass at that stage, so queue it\n \t\t\tSecondPass sp = new JoinedSubclassFkSecondPass( jsc, inheritanceJoinedColumns, key, mappings );\n \t\t\tmappings.addSecondPass( sp );\n \t\t\tmappings.addSecondPass( new CreateKeySecondPass( jsc ) );\n \n \t\t}\n \t\telse if ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.getType() ) ) {\n \t\t\tif ( inheritanceState.hasParents() ) {\n \t\t\t\tif ( persistentClass.getEntityPersisterClass() == null ) {\n \t\t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( SingleTableEntityPersister.class );\n \t\t\t\t}\n \t\t\t}\n \t\t\telse {\n \t\t\t\tif ( inheritanceState.hasSiblings() || !discriminatorColumn.isImplicit() ) {\n \t\t\t\t\t//need a discriminator column\n \t\t\t\t\tbindDiscriminatorToPersistentClass(\n \t\t\t\t\t\t\t( RootClass ) persistentClass,\n \t\t\t\t\t\t\tdiscriminatorColumn,\n \t\t\t\t\t\t\tentityBinder.getSecondaryTables(),\n \t\t\t\t\t\t\tpropertyHolder\n \t\t\t\t\t);\n \t\t\t\t\tentityBinder.bindDiscriminatorValue();//bind it again since the type might have changed\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\telse if ( InheritanceType.TABLE_PER_CLASS.equals( inheritanceState.getType() ) ) {\n \t\t\tif ( inheritanceState.hasParents() ) {\n \t\t\t\tif ( persistentClass.getEntityPersisterClass() == null ) {\n \t\t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( UnionSubclassEntityPersister.class );\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\tif ( onDeleteAnn != null && !onDeleteAppropriate ) {\n \t\t\tlog.warn(\n \t\t\t\t\t\"Inapropriate use of @OnDelete on entity, annotation ignored: {}\", propertyHolder.getEntityName()\n \t\t\t);\n \t\t}\n \n \t\t// try to find class level generators\n \t\tHashMap<String, IdGenerator> classGenerators = buildLocalGenerators( clazzToProcess, mappings );\n \n \t\t// check properties\n \t\tfinal InheritanceState.ElementsToProcess elementsToProcess = inheritanceState.getElementsToProcess();\n \t\tinheritanceState.postProcess( persistentClass, entityBinder );\n \n \t\tfinal boolean subclassAndSingleTableStrategy = inheritanceState.getType() == InheritanceType.SINGLE_TABLE\n \t\t\t\t&& inheritanceState.hasParents();\n \t\tSet<String> idPropertiesIfIdClass = new HashSet<String>();\n \t\tboolean isIdClass = mapAsIdClass(\n \t\t\t\tinheritanceStatePerClass,\n \t\t\t\tinheritanceState,\n \t\t\t\tpersistentClass,\n \t\t\t\tentityBinder,\n \t\t\t\tpropertyHolder,\n \t\t\t\telementsToProcess,\n \t\t\t\tidPropertiesIfIdClass,\n \t\t\t\tmappings\n \t\t);\n \n \t\tif ( !isIdClass ) {\n \t\t\tentityBinder.setWrapIdsInEmbeddedComponents( elementsToProcess.getIdPropertyCount() > 1 );\n \t\t}\n \n \t\tprocessIdPropertiesIfNotAlready(\n \t\t\t\tinheritanceStatePerClass,\n \t\t\t\tmappings,\n \t\t\t\tpersistentClass,\n \t\t\t\tentityBinder,\n \t\t\t\tpropertyHolder,\n \t\t\t\tclassGenerators,\n \t\t\t\telementsToProcess,\n \t\t\t\tsubclassAndSingleTableStrategy,\n \t\t\t\tidPropertiesIfIdClass\n \t\t);\n \n \t\tif ( !inheritanceState.hasParents() ) {\n \t\t\tfinal RootClass rootClass = ( RootClass ) persistentClass;\n \t\t\tmappings.addSecondPass( new CreateKeySecondPass( rootClass ) );\n \t\t}\n \t\telse {\n \t\t\tsuperEntity.addSubclass( ( Subclass ) persistentClass );\n \t\t}\n \n \t\tmappings.addClass( persistentClass );\n \n \t\t//Process secondary tables and complementary definitions (ie o.h.a.Table)\n \t\tmappings.addSecondPass( new SecondaryTableSecondPass( entityBinder, propertyHolder, clazzToProcess ) );\n \n \t\t//add process complementary Table definition (index & all)\n \t\tentityBinder.processComplementaryTableDefinitions( clazzToProcess.getAnnotation( org.hibernate.annotations.Table.class ) );\n \t\tentityBinder.processComplementaryTableDefinitions( clazzToProcess.getAnnotation( org.hibernate.annotations.Tables.class ) );\n \n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"153ad753e19b1f71665e6cfcbd903fb1ced889db": {
			"type": "Ybodychange",
			"commitMessage": "HHH-4812\nAdded @FetchProfile and @FetchProfiles annotations and wired them up. Added also some error handling in the AnnotationBinder.\nRefactor the handling of precedence in the AnnotationConfiguration, because I thought I would be reusing it for the fetch profile as well, but in the end decided to jsut implement in a way that xml configured fetch profiles always win over annotation confgured ones.\n\n\ngit-svn-id: https://svn.jboss.org/repos/hibernate/core/trunk@18924 1b8cb986-b30d-0410-93ca-fae66ebed9b2\n",
			"commitDate": "2010-03-04, 1:55 PM",
			"commitName": "153ad753e19b1f71665e6cfcbd903fb1ced889db",
			"commitAuthor": "Hardy Ferentschik",
			"commitDateOld": "2010-02-18, 1:59 AM",
			"commitNameOld": "b5529c05a56106ddf3d582355a4b07ac3d6510d0",
			"commitAuthorOld": "Emmanuel Bernard",
			"daysBetweenCommits": 14.5,
			"commitsBetweenForRepo": 50,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,245 +1,252 @@\n \tpublic static void bindClass(\n \t\t\tXClass clazzToProcess, Map<XClass, InheritanceState> inheritanceStatePerClass, ExtendedMappings mappings\n \t) throws MappingException {\n \t\t//TODO: be more strict with secondarytable allowance (not for ids, not for secondary table join columns etc)\n \t\tInheritanceState inheritanceState = inheritanceStatePerClass.get( clazzToProcess );\n \t\tAnnotatedClassType classType = mappings.getClassType( clazzToProcess );\n \n \t\t//Queries declared in MappedSuperclass should be usable in Subclasses\n \t\tif ( AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals( classType ) ) {\n \t\t\tbindQueries( clazzToProcess, mappings );\n-\t\t\tbindTypeDefs(clazzToProcess, mappings);\n-\t\t\tbindFilterDefs(clazzToProcess, mappings);\n+\t\t\tbindTypeDefs( clazzToProcess, mappings );\n+\t\t\tbindFilterDefs( clazzToProcess, mappings );\n \t\t}\n \n-\t\tif( !isEntityClassType( clazzToProcess, classType ) ) {\n+\t\tif ( !isEntityClassType( clazzToProcess, classType ) ) {\n \t\t\treturn;\n \t\t}\n \n \t\tlog.info( \"Binding entity from annotated class: {}\", clazzToProcess.getName() );\n \n-\t\tPersistentClass superEntity = getSuperEntity(clazzToProcess, inheritanceStatePerClass, mappings, inheritanceState);\n+\t\tPersistentClass superEntity = getSuperEntity(\n+\t\t\t\tclazzToProcess, inheritanceStatePerClass, mappings, inheritanceState\n+\t\t);\n \n \t\tbindQueries( clazzToProcess, mappings );\n \t\tbindFilterDefs( clazzToProcess, mappings );\n \t\tbindTypeDefs( clazzToProcess, mappings );\n+\t\tbindFetchProfiles( clazzToProcess, mappings );\n \t\tBinderHelper.bindAnyMetaDefs( clazzToProcess, mappings );\n \n \t\tString schema = \"\";\n \t\tString table = \"\"; //might be no @Table annotation on the annotated class\n \t\tString catalog = \"\";\n \t\tList<UniqueConstraintHolder> uniqueConstraints = new ArrayList<UniqueConstraintHolder>();\n \t\tif ( clazzToProcess.isAnnotationPresent( javax.persistence.Table.class ) ) {\n \t\t\tjavax.persistence.Table tabAnn = clazzToProcess.getAnnotation( javax.persistence.Table.class );\n \t\t\ttable = tabAnn.name();\n \t\t\tschema = tabAnn.schema();\n \t\t\tcatalog = tabAnn.catalog();\n \t\t\tuniqueConstraints = TableBinder.buildUniqueConstraintHolders( tabAnn.uniqueConstraints() );\n \t\t}\n \n-\t\tEjb3JoinColumn[] inheritanceJoinedColumns = makeInheritanceJoinColumns( clazzToProcess, mappings, inheritanceState, superEntity );\n+\t\tEjb3JoinColumn[] inheritanceJoinedColumns = makeInheritanceJoinColumns(\n+\t\t\t\tclazzToProcess, mappings, inheritanceState, superEntity\n+\t\t);\n \t\tEjb3DiscriminatorColumn discriminatorColumn = null;\n \t\tString discrimValue = null;\n \t\tif ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.getType() ) ) {\n \t\t\tjavax.persistence.DiscriminatorColumn discAnn = clazzToProcess.getAnnotation(\n \t\t\t\t\tjavax.persistence.DiscriminatorColumn.class\n \t\t\t);\n \t\t\tDiscriminatorType discriminatorType = discAnn != null ?\n \t\t\t\t\tdiscAnn.discriminatorType() :\n \t\t\t\t\tDiscriminatorType.STRING;\n \n \t\t\torg.hibernate.annotations.DiscriminatorFormula discFormulaAnn = clazzToProcess.getAnnotation(\n \t\t\t\t\torg.hibernate.annotations.DiscriminatorFormula.class\n \t\t\t);\n \t\t\tif ( !inheritanceState.hasParents() ) {\n \t\t\t\tdiscriminatorColumn = Ejb3DiscriminatorColumn.buildDiscriminatorColumn(\n \t\t\t\t\t\tdiscriminatorType, discAnn, discFormulaAnn, mappings\n \t\t\t\t);\n \t\t\t}\n \t\t\tif ( discAnn != null && inheritanceState.hasParents() ) {\n \t\t\t\tlog.warn(\n \t\t\t\t\t\t\"Discriminator column has to be defined in the root entity, it will be ignored in subclass: {}\",\n \t\t\t\t\t\tclazzToProcess.getName()\n \t\t\t\t);\n \t\t\t}\n \n \t\t\tdiscrimValue = clazzToProcess.isAnnotationPresent( DiscriminatorValue.class ) ?\n \t\t\t\t\tclazzToProcess.getAnnotation( DiscriminatorValue.class ).value() :\n \t\t\t\t\tnull;\n \t\t}\n \n \t\tPersistentClass persistentClass = makePersistentClass( inheritanceState, superEntity );\n \n \t\tProxy proxyAnn = clazzToProcess.getAnnotation( Proxy.class );\n \t\tBatchSize sizeAnn = clazzToProcess.getAnnotation( BatchSize.class );\n \t\tWhere whereAnn = clazzToProcess.getAnnotation( Where.class );\n \t\tEntity entityAnn = clazzToProcess.getAnnotation( Entity.class );\n \t\torg.hibernate.annotations.Entity hibEntityAnn = clazzToProcess.getAnnotation(\n \t\t\t\torg.hibernate.annotations.Entity.class\n \t\t);\n \n \t\tCache cacheAnn = determineCacheSettings( clazzToProcess, mappings );\n \n \t\tEntityBinder entityBinder = new EntityBinder(\n \t\t\t\tentityAnn, hibEntityAnn, clazzToProcess, persistentClass, mappings\n \t\t);\n \t\tentityBinder.setDiscriminatorValue( discrimValue );\n \t\tentityBinder.setBatchSize( sizeAnn );\n \t\tentityBinder.setProxy( proxyAnn );\n \t\tentityBinder.setWhere( whereAnn );\n \t\tentityBinder.setCache( cacheAnn );\n \t\tentityBinder.setInheritanceState( inheritanceState );\n \n \t\t//Filters are not allowed on subclasses\n \t\tif ( !inheritanceState.hasParents() ) {\n-\t\t\tbindFilters(clazzToProcess, entityBinder, mappings);\n+\t\t\tbindFilters( clazzToProcess, entityBinder, mappings );\n \t\t}\n \n \t\tentityBinder.bindEntity();\n \n \t\tif ( inheritanceState.hasTable() ) {\n \t\t\tCheck checkAnn = clazzToProcess.getAnnotation( Check.class );\n \t\t\tString constraints = checkAnn == null ?\n \t\t\t\t\tnull :\n \t\t\t\t\tcheckAnn.constraints();\n \t\t\tentityBinder.bindTable(\n \t\t\t\t\tschema, catalog, table, uniqueConstraints,\n \t\t\t\t\tconstraints, inheritanceState.hasDenormalizedTable() ?\n-\t\t\t\t\tsuperEntity.getTable() :\n-\t\t\t\t\tnull\n+\t\t\t\t\t\t\tsuperEntity.getTable() :\n+\t\t\t\t\t\t\tnull\n \t\t\t);\n \t\t}\n \t\telse {\n \t\t\tif ( clazzToProcess.isAnnotationPresent( Table.class ) ) {\n-\t\t\t\tlog.warn( \"Illegal use of @Table in a subclass of a SINGLE_TABLE hierarchy: \" + clazzToProcess\n-\t\t\t\t\t\t.getName() );\n+\t\t\t\tlog.warn(\n+\t\t\t\t\t\t\"Illegal use of @Table in a subclass of a SINGLE_TABLE hierarchy: \" + clazzToProcess\n+\t\t\t\t\t\t\t\t.getName()\n+\t\t\t\t);\n \t\t\t}\n \t\t}\n \n \t\tPropertyHolder propertyHolder = PropertyHolderBuilder.buildPropertyHolder(\n \t\t\t\tclazzToProcess,\n \t\t\t\tpersistentClass,\n \t\t\t\tentityBinder, mappings, inheritanceStatePerClass\n \t\t);\n \n \t\tjavax.persistence.SecondaryTable secTabAnn = clazzToProcess.getAnnotation(\n \t\t\t\tjavax.persistence.SecondaryTable.class\n \t\t);\n \t\tjavax.persistence.SecondaryTables secTabsAnn = clazzToProcess.getAnnotation(\n \t\t\t\tjavax.persistence.SecondaryTables.class\n \t\t);\n \t\tentityBinder.firstLevelSecondaryTablesBinding( secTabAnn, secTabsAnn );\n \n \t\tOnDelete onDeleteAnn = clazzToProcess.getAnnotation( OnDelete.class );\n \t\tboolean onDeleteAppropriate = false;\n \t\tif ( InheritanceType.JOINED.equals( inheritanceState.getType() ) && inheritanceState.hasParents() ) {\n \t\t\tonDeleteAppropriate = true;\n-\t\t\tfinal JoinedSubclass jsc = (JoinedSubclass) persistentClass;\n+\t\t\tfinal JoinedSubclass jsc = ( JoinedSubclass ) persistentClass;\n \t\t\tif ( persistentClass.getEntityPersisterClass() == null ) {\n \t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( JoinedSubclassEntityPersister.class );\n \t\t\t}\n \t\t\tSimpleValue key = new DependantValue( jsc.getTable(), jsc.getIdentifier() );\n \t\t\tjsc.setKey( key );\n \t\t\tForeignKey fk = clazzToProcess.getAnnotation( ForeignKey.class );\n \t\t\tif ( fk != null && !BinderHelper.isDefault( fk.name() ) ) {\n \t\t\t\tkey.setForeignKeyName( fk.name() );\n \t\t\t}\n \t\t\tif ( onDeleteAnn != null ) {\n \t\t\t\tkey.setCascadeDeleteEnabled( OnDeleteAction.CASCADE.equals( onDeleteAnn.action() ) );\n \t\t\t}\n \t\t\telse {\n \t\t\t\tkey.setCascadeDeleteEnabled( false );\n \t\t\t}\n \t\t\t//we are never in a second pass at that stage, so queue it\n \t\t\tSecondPass sp = new JoinedSubclassFkSecondPass( jsc, inheritanceJoinedColumns, key, mappings );\n \t\t\tmappings.addSecondPass( sp );\n \t\t\tmappings.addSecondPass( new CreateKeySecondPass( jsc ) );\n \n \t\t}\n \t\telse if ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.getType() ) ) {\n \t\t\tif ( inheritanceState.hasParents() ) {\n \t\t\t\tif ( persistentClass.getEntityPersisterClass() == null ) {\n \t\t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( SingleTableEntityPersister.class );\n \t\t\t\t}\n \t\t\t}\n \t\t\telse {\n \t\t\t\tif ( inheritanceState.hasSiblings() || !discriminatorColumn.isImplicit() ) {\n \t\t\t\t\t//need a discriminator column\n \t\t\t\t\tbindDiscriminatorToPersistentClass(\n-\t\t\t\t\t\t\t(RootClass) persistentClass,\n+\t\t\t\t\t\t\t( RootClass ) persistentClass,\n \t\t\t\t\t\t\tdiscriminatorColumn,\n \t\t\t\t\t\t\tentityBinder.getSecondaryTables(),\n \t\t\t\t\t\t\tpropertyHolder\n \t\t\t\t\t);\n \t\t\t\t\tentityBinder.bindDiscriminatorValue();//bind it again since the type might have changed\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\telse if ( InheritanceType.TABLE_PER_CLASS.equals( inheritanceState.getType() ) ) {\n \t\t\tif ( inheritanceState.hasParents() ) {\n \t\t\t\tif ( persistentClass.getEntityPersisterClass() == null ) {\n \t\t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( UnionSubclassEntityPersister.class );\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\tif ( onDeleteAnn != null && !onDeleteAppropriate ) {\n \t\t\tlog.warn(\n \t\t\t\t\t\"Inapropriate use of @OnDelete on entity, annotation ignored: {}\", propertyHolder.getEntityName()\n \t\t\t);\n \t\t}\n \n \t\t// try to find class level generators\n \t\tHashMap<String, IdGenerator> classGenerators = buildLocalGenerators( clazzToProcess, mappings );\n \n \t\t// check properties\n \t\tfinal InheritanceState.ElementsToProcess elementsToProcess = inheritanceState.getElementsToProcess();\n \t\tinheritanceState.postProcess( persistentClass, entityBinder );\n \n \t\tfinal boolean subclassAndSingleTableStrategy = inheritanceState.getType() == InheritanceType.SINGLE_TABLE\n \t\t\t\t&& inheritanceState.hasParents();\n \t\tSet<String> idPropertiesIfIdClass = new HashSet<String>();\n \t\tboolean isIdClass = mapAsIdClass(\n \t\t\t\tinheritanceStatePerClass,\n \t\t\t\tinheritanceState,\n \t\t\t\tpersistentClass,\n \t\t\t\tentityBinder,\n \t\t\t\tpropertyHolder,\n \t\t\t\telementsToProcess,\n \t\t\t\tidPropertiesIfIdClass,\n \t\t\t\tmappings\n \t\t);\n \n-\t\tif (!isIdClass) {\n+\t\tif ( !isIdClass ) {\n \t\t\tentityBinder.setWrapIdsInEmbeddedComponents( elementsToProcess.getIdPropertyCount() > 1 );\n \t\t}\n \n \t\tprocessIdPropertiesIfNotAlready(\n \t\t\t\tinheritanceStatePerClass,\n \t\t\t\tmappings,\n \t\t\t\tpersistentClass,\n \t\t\t\tentityBinder,\n \t\t\t\tpropertyHolder,\n \t\t\t\tclassGenerators,\n \t\t\t\telementsToProcess,\n \t\t\t\tsubclassAndSingleTableStrategy,\n \t\t\t\tidPropertiesIfIdClass\n \t\t);\n \n \t\tif ( !inheritanceState.hasParents() ) {\n-\t\t\tfinal RootClass rootClass = (RootClass) persistentClass;\n+\t\t\tfinal RootClass rootClass = ( RootClass ) persistentClass;\n \t\t\tmappings.addSecondPass( new CreateKeySecondPass( rootClass ) );\n \t\t}\n \t\telse {\n-\t\t\tsuperEntity.addSubclass( (Subclass) persistentClass );\n+\t\t\tsuperEntity.addSubclass( ( Subclass ) persistentClass );\n \t\t}\n \n \t\tmappings.addClass( persistentClass );\n \n \t\t//Process secondary tables and complementary definitions (ie o.h.a.Table)\n \t\tmappings.addSecondPass( new SecondaryTableSecondPass( entityBinder, propertyHolder, clazzToProcess ) );\n \n \t\t//add process complementary Table definition (index & all)\n \t\tentityBinder.processComplementaryTableDefinitions( clazzToProcess.getAnnotation( org.hibernate.annotations.Table.class ) );\n \t\tentityBinder.processComplementaryTableDefinitions( clazzToProcess.getAnnotation( org.hibernate.annotations.Tables.class ) );\n \n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"8478d5b44b6c8d72b386d7a1a2841bfe7b37fb08": {
			"type": "Ybodychange",
			"commitMessage": "HHH-4848 finish support for derived identity Yeah! More specifically @IdClass on dependent where the @IdClass points to the associated entity id type\n\ngit-svn-id: https://svn.jboss.org/repos/hibernate/core/trunk@18708 1b8cb986-b30d-0410-93ca-fae66ebed9b2\n",
			"commitDate": "2010-02-05, 3:33 PM",
			"commitName": "8478d5b44b6c8d72b386d7a1a2841bfe7b37fb08",
			"commitAuthor": "Emmanuel Bernard",
			"commitDateOld": "2010-02-05, 10:28 AM",
			"commitNameOld": "5c16c01064f4e2970860c5da47d0f0425aefac02",
			"commitAuthorOld": "Steve Ebersole",
			"daysBetweenCommits": 0.21,
			"commitsBetweenForRepo": 4,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,335 +1,245 @@\n \tpublic static void bindClass(\n \t\t\tXClass clazzToProcess, Map<XClass, InheritanceState> inheritanceStatePerClass, ExtendedMappings mappings\n \t) throws MappingException {\n \t\t//TODO: be more strict with secondarytable allowance (not for ids, not for secondary table join columns etc)\n \t\tInheritanceState inheritanceState = inheritanceStatePerClass.get( clazzToProcess );\n \t\tAnnotatedClassType classType = mappings.getClassType( clazzToProcess );\n \n \t\t//Queries declared in MappedSuperclass should be usable in Subclasses\n \t\tif ( AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals( classType ) ) {\n \t\t\tbindQueries( clazzToProcess, mappings );\n \t\t\tbindTypeDefs(clazzToProcess, mappings);\n \t\t\tbindFilterDefs(clazzToProcess, mappings);\n \t\t}\n \n \t\tif( !isEntityClassType( clazzToProcess, classType ) ) {\n \t\t\treturn;\n \t\t}\n \n \t\tlog.info( \"Binding entity from annotated class: {}\", clazzToProcess.getName() );\n \n \t\tPersistentClass superEntity = getSuperEntity(clazzToProcess, inheritanceStatePerClass, mappings, inheritanceState);\n \n \t\tbindQueries( clazzToProcess, mappings );\n \t\tbindFilterDefs( clazzToProcess, mappings );\n \t\tbindTypeDefs( clazzToProcess, mappings );\n \t\tBinderHelper.bindAnyMetaDefs( clazzToProcess, mappings );\n \n \t\tString schema = \"\";\n \t\tString table = \"\"; //might be no @Table annotation on the annotated class\n \t\tString catalog = \"\";\n \t\tList<UniqueConstraintHolder> uniqueConstraints = new ArrayList<UniqueConstraintHolder>();\n \t\tif ( clazzToProcess.isAnnotationPresent( javax.persistence.Table.class ) ) {\n \t\t\tjavax.persistence.Table tabAnn = clazzToProcess.getAnnotation( javax.persistence.Table.class );\n \t\t\ttable = tabAnn.name();\n \t\t\tschema = tabAnn.schema();\n \t\t\tcatalog = tabAnn.catalog();\n \t\t\tuniqueConstraints = TableBinder.buildUniqueConstraintHolders( tabAnn.uniqueConstraints() );\n \t\t}\n \n \t\tEjb3JoinColumn[] inheritanceJoinedColumns = makeInheritanceJoinColumns( clazzToProcess, mappings, inheritanceState, superEntity );\n \t\tEjb3DiscriminatorColumn discriminatorColumn = null;\n \t\tString discrimValue = null;\n \t\tif ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.getType() ) ) {\n \t\t\tjavax.persistence.DiscriminatorColumn discAnn = clazzToProcess.getAnnotation(\n \t\t\t\t\tjavax.persistence.DiscriminatorColumn.class\n \t\t\t);\n \t\t\tDiscriminatorType discriminatorType = discAnn != null ?\n \t\t\t\t\tdiscAnn.discriminatorType() :\n \t\t\t\t\tDiscriminatorType.STRING;\n \n \t\t\torg.hibernate.annotations.DiscriminatorFormula discFormulaAnn = clazzToProcess.getAnnotation(\n \t\t\t\t\torg.hibernate.annotations.DiscriminatorFormula.class\n \t\t\t);\n \t\t\tif ( !inheritanceState.hasParents() ) {\n \t\t\t\tdiscriminatorColumn = Ejb3DiscriminatorColumn.buildDiscriminatorColumn(\n \t\t\t\t\t\tdiscriminatorType, discAnn, discFormulaAnn, mappings\n \t\t\t\t);\n \t\t\t}\n \t\t\tif ( discAnn != null && inheritanceState.hasParents() ) {\n \t\t\t\tlog.warn(\n \t\t\t\t\t\t\"Discriminator column has to be defined in the root entity, it will be ignored in subclass: {}\",\n \t\t\t\t\t\tclazzToProcess.getName()\n \t\t\t\t);\n \t\t\t}\n \n \t\t\tdiscrimValue = clazzToProcess.isAnnotationPresent( DiscriminatorValue.class ) ?\n \t\t\t\t\tclazzToProcess.getAnnotation( DiscriminatorValue.class ).value() :\n \t\t\t\t\tnull;\n \t\t}\n \n \t\tPersistentClass persistentClass = makePersistentClass( inheritanceState, superEntity );\n \n \t\tProxy proxyAnn = clazzToProcess.getAnnotation( Proxy.class );\n \t\tBatchSize sizeAnn = clazzToProcess.getAnnotation( BatchSize.class );\n \t\tWhere whereAnn = clazzToProcess.getAnnotation( Where.class );\n \t\tEntity entityAnn = clazzToProcess.getAnnotation( Entity.class );\n \t\torg.hibernate.annotations.Entity hibEntityAnn = clazzToProcess.getAnnotation(\n \t\t\t\torg.hibernate.annotations.Entity.class\n \t\t);\n \n \t\tCache cacheAnn = determineCacheSettings( clazzToProcess, mappings );\n \n \t\tEntityBinder entityBinder = new EntityBinder(\n \t\t\t\tentityAnn, hibEntityAnn, clazzToProcess, persistentClass, mappings\n \t\t);\n \t\tentityBinder.setDiscriminatorValue( discrimValue );\n \t\tentityBinder.setBatchSize( sizeAnn );\n \t\tentityBinder.setProxy( proxyAnn );\n \t\tentityBinder.setWhere( whereAnn );\n \t\tentityBinder.setCache( cacheAnn );\n \t\tentityBinder.setInheritanceState( inheritanceState );\n \n \t\t//Filters are not allowed on subclasses\n \t\tif ( !inheritanceState.hasParents() ) {\n \t\t\tbindFilters(clazzToProcess, entityBinder, mappings);\n \t\t}\n \n \t\tentityBinder.bindEntity();\n \n \t\tif ( inheritanceState.hasTable() ) {\n \t\t\tCheck checkAnn = clazzToProcess.getAnnotation( Check.class );\n \t\t\tString constraints = checkAnn == null ?\n \t\t\t\t\tnull :\n \t\t\t\t\tcheckAnn.constraints();\n \t\t\tentityBinder.bindTable(\n \t\t\t\t\tschema, catalog, table, uniqueConstraints,\n \t\t\t\t\tconstraints, inheritanceState.hasDenormalizedTable() ?\n \t\t\t\t\tsuperEntity.getTable() :\n \t\t\t\t\tnull\n \t\t\t);\n \t\t}\n \t\telse {\n \t\t\tif ( clazzToProcess.isAnnotationPresent( Table.class ) ) {\n \t\t\t\tlog.warn( \"Illegal use of @Table in a subclass of a SINGLE_TABLE hierarchy: \" + clazzToProcess\n \t\t\t\t\t\t.getName() );\n \t\t\t}\n \t\t}\n \n \t\tPropertyHolder propertyHolder = PropertyHolderBuilder.buildPropertyHolder(\n \t\t\t\tclazzToProcess,\n \t\t\t\tpersistentClass,\n \t\t\t\tentityBinder, mappings, inheritanceStatePerClass\n \t\t);\n \n \t\tjavax.persistence.SecondaryTable secTabAnn = clazzToProcess.getAnnotation(\n \t\t\t\tjavax.persistence.SecondaryTable.class\n \t\t);\n \t\tjavax.persistence.SecondaryTables secTabsAnn = clazzToProcess.getAnnotation(\n \t\t\t\tjavax.persistence.SecondaryTables.class\n \t\t);\n \t\tentityBinder.firstLevelSecondaryTablesBinding( secTabAnn, secTabsAnn );\n \n \t\tOnDelete onDeleteAnn = clazzToProcess.getAnnotation( OnDelete.class );\n \t\tboolean onDeleteAppropriate = false;\n \t\tif ( InheritanceType.JOINED.equals( inheritanceState.getType() ) && inheritanceState.hasParents() ) {\n \t\t\tonDeleteAppropriate = true;\n \t\t\tfinal JoinedSubclass jsc = (JoinedSubclass) persistentClass;\n \t\t\tif ( persistentClass.getEntityPersisterClass() == null ) {\n \t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( JoinedSubclassEntityPersister.class );\n \t\t\t}\n \t\t\tSimpleValue key = new DependantValue( jsc.getTable(), jsc.getIdentifier() );\n \t\t\tjsc.setKey( key );\n \t\t\tForeignKey fk = clazzToProcess.getAnnotation( ForeignKey.class );\n \t\t\tif ( fk != null && !BinderHelper.isDefault( fk.name() ) ) {\n \t\t\t\tkey.setForeignKeyName( fk.name() );\n \t\t\t}\n \t\t\tif ( onDeleteAnn != null ) {\n \t\t\t\tkey.setCascadeDeleteEnabled( OnDeleteAction.CASCADE.equals( onDeleteAnn.action() ) );\n \t\t\t}\n \t\t\telse {\n \t\t\t\tkey.setCascadeDeleteEnabled( false );\n \t\t\t}\n \t\t\t//we are never in a second pass at that stage, so queue it\n \t\t\tSecondPass sp = new JoinedSubclassFkSecondPass( jsc, inheritanceJoinedColumns, key, mappings );\n \t\t\tmappings.addSecondPass( sp );\n \t\t\tmappings.addSecondPass( new CreateKeySecondPass( jsc ) );\n \n \t\t}\n \t\telse if ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.getType() ) ) {\n \t\t\tif ( inheritanceState.hasParents() ) {\n \t\t\t\tif ( persistentClass.getEntityPersisterClass() == null ) {\n \t\t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( SingleTableEntityPersister.class );\n \t\t\t\t}\n \t\t\t}\n \t\t\telse {\n \t\t\t\tif ( inheritanceState.hasSiblings() || !discriminatorColumn.isImplicit() ) {\n \t\t\t\t\t//need a discriminator column\n \t\t\t\t\tbindDiscriminatorToPersistentClass(\n \t\t\t\t\t\t\t(RootClass) persistentClass,\n \t\t\t\t\t\t\tdiscriminatorColumn,\n \t\t\t\t\t\t\tentityBinder.getSecondaryTables(),\n \t\t\t\t\t\t\tpropertyHolder\n \t\t\t\t\t);\n \t\t\t\t\tentityBinder.bindDiscriminatorValue();//bind it again since the type might have changed\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\telse if ( InheritanceType.TABLE_PER_CLASS.equals( inheritanceState.getType() ) ) {\n \t\t\tif ( inheritanceState.hasParents() ) {\n \t\t\t\tif ( persistentClass.getEntityPersisterClass() == null ) {\n \t\t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( UnionSubclassEntityPersister.class );\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\tif ( onDeleteAnn != null && !onDeleteAppropriate ) {\n \t\t\tlog.warn(\n \t\t\t\t\t\"Inapropriate use of @OnDelete on entity, annotation ignored: {}\", propertyHolder.getEntityName()\n \t\t\t);\n \t\t}\n \n \t\t// try to find class level generators\n \t\tHashMap<String, IdGenerator> classGenerators = buildLocalGenerators( clazzToProcess, mappings );\n \n \t\t// check properties\n \t\tfinal InheritanceState.ElementsToProcess elementsToProcess = inheritanceState.getElementsToProcess();\n \t\tinheritanceState.postProcess( persistentClass, entityBinder );\n \n \t\tfinal boolean subclassAndSingleTableStrategy = inheritanceState.getType() == InheritanceType.SINGLE_TABLE\n \t\t\t\t&& inheritanceState.hasParents();\n-\t\t//process idclass if any\n-\t\tSet<String> idProperties = new HashSet<String>();\n-\t\tXClass classWithIdClass = inheritanceState.getClassWithIdClass(false);\n-\t\tif ( classWithIdClass != null ) {\n-\t\t\tIdClass idClass = classWithIdClass.getAnnotation( IdClass.class );\n-\t\t\tXClass compositeClass = mappings.getReflectionManager().toXClass( idClass.value() );\n-\t\t\tboolean isComponent = true;\n-\t\t\tAccessType propertyAccessor = entityBinder.getPropertyAccessor( compositeClass );\n-\t\t\tString generatorType = \"assigned\";\n-\t\t\tString generator = BinderHelper.ANNOTATION_STRING_DEFAULT;\n-\t\t\tPropertyData inferredData = new PropertyPreloadedData(\n-\t\t\t\t\tentityBinder.getPropertyAccessType(), \"id\", compositeClass\n-\t\t\t);\n-\t\t\tPropertyData baseInferredData = new PropertyPreloadedData(\n-                  entityBinder.getPropertyAccessType(), \"id\", classWithIdClass\n-            );\n-\t\t\tHashMap<String, IdGenerator> localGenerators = new HashMap<String, IdGenerator>();\n-\t\t\tboolean ignoreIdAnnotations = entityBinder.isIgnoreIdAnnotations();\n-\t\t\tentityBinder.setIgnoreIdAnnotations( true );\n-\t\t\tpropertyHolder.setInIdClass( true );\n-\t\t\tbindId(\n-\t\t\t\t\tgeneratorType,\n-\t\t\t\t\tgenerator,\n-\t\t\t\t\tinferredData,\n-\t\t\t\t\tbaseInferredData,\n-\t\t\t\t\tnull,\n-\t\t\t\t\tpropertyHolder,\n-\t\t\t\t\tlocalGenerators,\n-\t\t\t\t\tisComponent,\n-\t\t\t\t\tpropertyAccessor, entityBinder,\n-\t\t\t\t\ttrue,\n-\t\t\t\t\tfalse,\n-\t\t\t\t\tmappings,\n-\t\t\t\t\tinheritanceStatePerClass\n-\t\t\t);\n-\t\t\tpropertyHolder.setInIdClass( null );\n-\t\t\tinferredData = new PropertyPreloadedData(\n-\t\t\t\t\tpropertyAccessor, \"_identifierMapper\", compositeClass\n-\t\t\t);\n-\t\t\tComponent mapper = fillComponent(\n-\t\t\t\t\tpropertyHolder,\n-\t\t\t\t\tinferredData,\n-\t\t\t\t\tbaseInferredData,\n-\t\t\t\t\tpropertyAccessor,\n-\t\t\t\t\tfalse,\n-\t\t\t\t\tentityBinder,\n-\t\t\t\t\ttrue,\n-\t\t\t\t\ttrue,\n-\t\t\t\t\tfalse,\n-\t\t\t\t\tmappings,\n-\t\t\t\t\tinheritanceStatePerClass\n-\t\t\t);\n-\t\t\tentityBinder.setIgnoreIdAnnotations( ignoreIdAnnotations );\n-\t\t\tpersistentClass.setIdentifierMapper( mapper );\n+\t\tSet<String> idPropertiesIfIdClass = new HashSet<String>();\n+\t\tboolean isIdClass = mapAsIdClass(\n+\t\t\t\tinheritanceStatePerClass,\n+\t\t\t\tinheritanceState,\n+\t\t\t\tpersistentClass,\n+\t\t\t\tentityBinder,\n+\t\t\t\tpropertyHolder,\n+\t\t\t\telementsToProcess,\n+\t\t\t\tidPropertiesIfIdClass,\n+\t\t\t\tmappings\n+\t\t);\n \n-\t\t\t//If id definition is on a mapped superclass, update the mapping\n-\t\t\tfinal org.hibernate.mapping.MappedSuperclass superclass = BinderHelper.getMappedSuperclassOrNull(\n-\t\t\t\t\tinferredData.getDeclaringClass(),\n-\t\t\t\t\tinheritanceStatePerClass,\n-\t\t\t\t\tmappings\n-\t\t\t);\n-\t\t\tif (superclass != null) {\n-\t\t\t\tsuperclass.setDeclaredIdentifierMapper(mapper);\n-\t\t\t}\n-\t\t\telse {\n-\t\t\t\t//we are for sure on the entity\n-\t\t\t\tpersistentClass.setDeclaredIdentifierMapper( mapper );\n-\t\t\t}\n-\n-\t\t\tProperty property = new Property();\n-\t\t\tproperty.setName( \"_identifierMapper\" );\n-\t\t\tproperty.setNodeName( \"id\" );\n-\t\t\tproperty.setUpdateable( false );\n-\t\t\tproperty.setInsertable( false );\n-\t\t\tproperty.setValue( mapper );\n-\t\t\tproperty.setPropertyAccessorName( \"embedded\" );\n-\t\t\tpersistentClass.addProperty( property );\n-\t\t\tentityBinder.setIgnoreIdAnnotations( true );\n-\n-\t\t\tIterator properties = mapper.getPropertyIterator();\n-\t\t\twhile ( properties.hasNext() ) {\n-\t\t\t\tidProperties.add( ( (Property) properties.next() ).getName() );\n-\t\t\t}\n-\t\t}\n-\t\telse {\n+\t\tif (!isIdClass) {\n \t\t\tentityBinder.setWrapIdsInEmbeddedComponents( elementsToProcess.getIdPropertyCount() > 1 );\n \t\t}\n-\t\tSet<String> missingIdProperties = new HashSet<String>( idProperties );\n-\t\tfor (PropertyData propertyAnnotatedElement : elementsToProcess.getElements() ) {\n-\t\t\tString propertyName = propertyAnnotatedElement.getPropertyName();\n-\t\t\tif ( !idProperties.contains( propertyName ) ) {\n-\t\t\t\tprocessElementAnnotations(\n-\t\t\t\t\t\tpropertyHolder,\n-\t\t\t\t\t\tsubclassAndSingleTableStrategy ?\n-\t\t\t\t\t\t\t\tNullability.FORCED_NULL :\n-\t\t\t\t\t\t\t\tNullability.NO_CONSTRAINT,\n-\t\t\t\t\t\tpropertyAnnotatedElement.getProperty(),\n-\t\t\t\t\t\tpropertyAnnotatedElement, classGenerators, entityBinder,\n-\t\t\t\t\t\tfalse, false, false, mappings, inheritanceStatePerClass\n-\t\t\t\t);\n-\t\t\t}\n-\t\t\telse {\n-\t\t\t\tmissingIdProperties.remove( propertyName );\n-\t\t\t}\n-\t\t}\n \n-\t\tif ( missingIdProperties.size() != 0 ) {\n-\t\t\tStringBuilder missings = new StringBuilder();\n-\t\t\tfor (String property : missingIdProperties) {\n-\t\t\t\tmissings.append( property ).append( \", \" );\n-\t\t\t}\n-\t\t\tthrow new AnnotationException(\n-\t\t\t\t\t\"Unable to find properties (\"\n-\t\t\t\t\t\t\t+ missings.substring( 0, missings.length() - 2 )\n-\t\t\t\t\t\t\t+ \") in entity annotated with @IdClass:\" + persistentClass.getEntityName()\n-\t\t\t);\n-\t\t}\n+\t\tprocessIdPropertiesIfNotAlready(\n+\t\t\t\tinheritanceStatePerClass,\n+\t\t\t\tmappings,\n+\t\t\t\tpersistentClass,\n+\t\t\t\tentityBinder,\n+\t\t\t\tpropertyHolder,\n+\t\t\t\tclassGenerators,\n+\t\t\t\telementsToProcess,\n+\t\t\t\tsubclassAndSingleTableStrategy,\n+\t\t\t\tidPropertiesIfIdClass\n+\t\t);\n \n \t\tif ( !inheritanceState.hasParents() ) {\n \t\t\tfinal RootClass rootClass = (RootClass) persistentClass;\n \t\t\tmappings.addSecondPass( new CreateKeySecondPass( rootClass ) );\n \t\t}\n \t\telse {\n \t\t\tsuperEntity.addSubclass( (Subclass) persistentClass );\n \t\t}\n \n \t\tmappings.addClass( persistentClass );\n \n \t\t//Process secondary tables and complementary definitions (ie o.h.a.Table)\n \t\tmappings.addSecondPass( new SecondaryTableSecondPass( entityBinder, propertyHolder, clazzToProcess ) );\n \n \t\t//add process complementary Table definition (index & all)\n \t\tentityBinder.processComplementaryTableDefinitions( clazzToProcess.getAnnotation( org.hibernate.annotations.Table.class ) );\n \t\tentityBinder.processComplementaryTableDefinitions( clazzToProcess.getAnnotation( org.hibernate.annotations.Tables.class ) );\n \n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"252299cfee96892b71b3bd3e200181089e350e27": {
			"type": "Ybodychange",
			"commitMessage": "HHH-4848 partial implementation of @IdClass support in derivedidentity (example 1 case a of the spec)\n\ngit-svn-id: https://svn.jboss.org/repos/hibernate/core/trunk@18692 1b8cb986-b30d-0410-93ca-fae66ebed9b2\n",
			"commitDate": "2010-02-04, 9:54 AM",
			"commitName": "252299cfee96892b71b3bd3e200181089e350e27",
			"commitAuthor": "Emmanuel Bernard",
			"commitDateOld": "2010-01-27, 10:58 AM",
			"commitNameOld": "016a02ff506b715e8217b8577594ac62b3f318ce",
			"commitAuthorOld": "Emmanuel Bernard",
			"daysBetweenCommits": 7.96,
			"commitsBetweenForRepo": 22,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,331 +1,335 @@\n \tpublic static void bindClass(\n \t\t\tXClass clazzToProcess, Map<XClass, InheritanceState> inheritanceStatePerClass, ExtendedMappings mappings\n \t) throws MappingException {\n \t\t//TODO: be more strict with secondarytable allowance (not for ids, not for secondary table join columns etc)\n \t\tInheritanceState inheritanceState = inheritanceStatePerClass.get( clazzToProcess );\n \t\tAnnotatedClassType classType = mappings.getClassType( clazzToProcess );\n \n \t\t//Queries declared in MappedSuperclass should be usable in Subclasses\n \t\tif ( AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals( classType ) ) {\n \t\t\tbindQueries( clazzToProcess, mappings );\n \t\t\tbindTypeDefs(clazzToProcess, mappings);\n \t\t\tbindFilterDefs(clazzToProcess, mappings);\n \t\t}\n \n \t\tif( !isEntityClassType( clazzToProcess, classType ) ) {\n \t\t\treturn;\n \t\t}\n \n \t\tlog.info( \"Binding entity from annotated class: {}\", clazzToProcess.getName() );\n \n \t\tPersistentClass superEntity = getSuperEntity(clazzToProcess, inheritanceStatePerClass, mappings, inheritanceState);\n \n \t\tbindQueries( clazzToProcess, mappings );\n \t\tbindFilterDefs( clazzToProcess, mappings );\n \t\tbindTypeDefs( clazzToProcess, mappings );\n \t\tBinderHelper.bindAnyMetaDefs( clazzToProcess, mappings );\n \n \t\tString schema = \"\";\n \t\tString table = \"\"; //might be no @Table annotation on the annotated class\n \t\tString catalog = \"\";\n \t\tList<UniqueConstraintHolder> uniqueConstraints = new ArrayList<UniqueConstraintHolder>();\n \t\tif ( clazzToProcess.isAnnotationPresent( javax.persistence.Table.class ) ) {\n \t\t\tjavax.persistence.Table tabAnn = clazzToProcess.getAnnotation( javax.persistence.Table.class );\n \t\t\ttable = tabAnn.name();\n \t\t\tschema = tabAnn.schema();\n \t\t\tcatalog = tabAnn.catalog();\n \t\t\tuniqueConstraints = TableBinder.buildUniqueConstraintHolders( tabAnn.uniqueConstraints() );\n \t\t}\n \n \t\tEjb3JoinColumn[] inheritanceJoinedColumns = makeInheritanceJoinColumns( clazzToProcess, mappings, inheritanceState, superEntity );\n \t\tEjb3DiscriminatorColumn discriminatorColumn = null;\n \t\tString discrimValue = null;\n \t\tif ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.getType() ) ) {\n \t\t\tjavax.persistence.DiscriminatorColumn discAnn = clazzToProcess.getAnnotation(\n \t\t\t\t\tjavax.persistence.DiscriminatorColumn.class\n \t\t\t);\n \t\t\tDiscriminatorType discriminatorType = discAnn != null ?\n \t\t\t\t\tdiscAnn.discriminatorType() :\n \t\t\t\t\tDiscriminatorType.STRING;\n \n \t\t\torg.hibernate.annotations.DiscriminatorFormula discFormulaAnn = clazzToProcess.getAnnotation(\n \t\t\t\t\torg.hibernate.annotations.DiscriminatorFormula.class\n \t\t\t);\n \t\t\tif ( !inheritanceState.hasParents() ) {\n \t\t\t\tdiscriminatorColumn = Ejb3DiscriminatorColumn.buildDiscriminatorColumn(\n \t\t\t\t\t\tdiscriminatorType, discAnn, discFormulaAnn, mappings\n \t\t\t\t);\n \t\t\t}\n \t\t\tif ( discAnn != null && inheritanceState.hasParents() ) {\n \t\t\t\tlog.warn(\n \t\t\t\t\t\t\"Discriminator column has to be defined in the root entity, it will be ignored in subclass: {}\",\n \t\t\t\t\t\tclazzToProcess.getName()\n \t\t\t\t);\n \t\t\t}\n \n \t\t\tdiscrimValue = clazzToProcess.isAnnotationPresent( DiscriminatorValue.class ) ?\n \t\t\t\t\tclazzToProcess.getAnnotation( DiscriminatorValue.class ).value() :\n \t\t\t\t\tnull;\n \t\t}\n \n \t\tPersistentClass persistentClass = makePersistentClass( inheritanceState, superEntity );\n \n \t\tProxy proxyAnn = clazzToProcess.getAnnotation( Proxy.class );\n \t\tBatchSize sizeAnn = clazzToProcess.getAnnotation( BatchSize.class );\n \t\tWhere whereAnn = clazzToProcess.getAnnotation( Where.class );\n \t\tEntity entityAnn = clazzToProcess.getAnnotation( Entity.class );\n \t\torg.hibernate.annotations.Entity hibEntityAnn = clazzToProcess.getAnnotation(\n \t\t\t\torg.hibernate.annotations.Entity.class\n \t\t);\n \n \t\tCache cacheAnn = determineCacheSettings( clazzToProcess, mappings );\n \n \t\tEntityBinder entityBinder = new EntityBinder(\n \t\t\t\tentityAnn, hibEntityAnn, clazzToProcess, persistentClass, mappings\n \t\t);\n \t\tentityBinder.setDiscriminatorValue( discrimValue );\n \t\tentityBinder.setBatchSize( sizeAnn );\n \t\tentityBinder.setProxy( proxyAnn );\n \t\tentityBinder.setWhere( whereAnn );\n \t\tentityBinder.setCache( cacheAnn );\n \t\tentityBinder.setInheritanceState( inheritanceState );\n \n \t\t//Filters are not allowed on subclasses\n \t\tif ( !inheritanceState.hasParents() ) {\n \t\t\tbindFilters(clazzToProcess, entityBinder, mappings);\n \t\t}\n \n \t\tentityBinder.bindEntity();\n \n \t\tif ( inheritanceState.hasTable() ) {\n \t\t\tCheck checkAnn = clazzToProcess.getAnnotation( Check.class );\n \t\t\tString constraints = checkAnn == null ?\n \t\t\t\t\tnull :\n \t\t\t\t\tcheckAnn.constraints();\n \t\t\tentityBinder.bindTable(\n \t\t\t\t\tschema, catalog, table, uniqueConstraints,\n \t\t\t\t\tconstraints, inheritanceState.hasDenormalizedTable() ?\n \t\t\t\t\tsuperEntity.getTable() :\n \t\t\t\t\tnull\n \t\t\t);\n \t\t}\n \t\telse {\n \t\t\tif ( clazzToProcess.isAnnotationPresent( Table.class ) ) {\n \t\t\t\tlog.warn( \"Illegal use of @Table in a subclass of a SINGLE_TABLE hierarchy: \" + clazzToProcess\n \t\t\t\t\t\t.getName() );\n \t\t\t}\n \t\t}\n \n \t\tPropertyHolder propertyHolder = PropertyHolderBuilder.buildPropertyHolder(\n \t\t\t\tclazzToProcess,\n \t\t\t\tpersistentClass,\n \t\t\t\tentityBinder, mappings, inheritanceStatePerClass\n \t\t);\n \n \t\tjavax.persistence.SecondaryTable secTabAnn = clazzToProcess.getAnnotation(\n \t\t\t\tjavax.persistence.SecondaryTable.class\n \t\t);\n \t\tjavax.persistence.SecondaryTables secTabsAnn = clazzToProcess.getAnnotation(\n \t\t\t\tjavax.persistence.SecondaryTables.class\n \t\t);\n \t\tentityBinder.firstLevelSecondaryTablesBinding( secTabAnn, secTabsAnn );\n \n \t\tOnDelete onDeleteAnn = clazzToProcess.getAnnotation( OnDelete.class );\n \t\tboolean onDeleteAppropriate = false;\n \t\tif ( InheritanceType.JOINED.equals( inheritanceState.getType() ) && inheritanceState.hasParents() ) {\n \t\t\tonDeleteAppropriate = true;\n \t\t\tfinal JoinedSubclass jsc = (JoinedSubclass) persistentClass;\n \t\t\tif ( persistentClass.getEntityPersisterClass() == null ) {\n \t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( JoinedSubclassEntityPersister.class );\n \t\t\t}\n \t\t\tSimpleValue key = new DependantValue( jsc.getTable(), jsc.getIdentifier() );\n \t\t\tjsc.setKey( key );\n \t\t\tForeignKey fk = clazzToProcess.getAnnotation( ForeignKey.class );\n \t\t\tif ( fk != null && !BinderHelper.isDefault( fk.name() ) ) {\n \t\t\t\tkey.setForeignKeyName( fk.name() );\n \t\t\t}\n \t\t\tif ( onDeleteAnn != null ) {\n \t\t\t\tkey.setCascadeDeleteEnabled( OnDeleteAction.CASCADE.equals( onDeleteAnn.action() ) );\n \t\t\t}\n \t\t\telse {\n \t\t\t\tkey.setCascadeDeleteEnabled( false );\n \t\t\t}\n \t\t\t//we are never in a second pass at that stage, so queue it\n \t\t\tSecondPass sp = new JoinedSubclassFkSecondPass( jsc, inheritanceJoinedColumns, key, mappings );\n \t\t\tmappings.addSecondPass( sp );\n \t\t\tmappings.addSecondPass( new CreateKeySecondPass( jsc ) );\n \n \t\t}\n \t\telse if ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.getType() ) ) {\n \t\t\tif ( inheritanceState.hasParents() ) {\n \t\t\t\tif ( persistentClass.getEntityPersisterClass() == null ) {\n \t\t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( SingleTableEntityPersister.class );\n \t\t\t\t}\n \t\t\t}\n \t\t\telse {\n \t\t\t\tif ( inheritanceState.hasSiblings() || !discriminatorColumn.isImplicit() ) {\n \t\t\t\t\t//need a discriminator column\n \t\t\t\t\tbindDiscriminatorToPersistentClass(\n \t\t\t\t\t\t\t(RootClass) persistentClass,\n \t\t\t\t\t\t\tdiscriminatorColumn,\n \t\t\t\t\t\t\tentityBinder.getSecondaryTables(),\n \t\t\t\t\t\t\tpropertyHolder\n \t\t\t\t\t);\n \t\t\t\t\tentityBinder.bindDiscriminatorValue();//bind it again since the type might have changed\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\telse if ( InheritanceType.TABLE_PER_CLASS.equals( inheritanceState.getType() ) ) {\n \t\t\tif ( inheritanceState.hasParents() ) {\n \t\t\t\tif ( persistentClass.getEntityPersisterClass() == null ) {\n \t\t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( UnionSubclassEntityPersister.class );\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\tif ( onDeleteAnn != null && !onDeleteAppropriate ) {\n \t\t\tlog.warn(\n \t\t\t\t\t\"Inapropriate use of @OnDelete on entity, annotation ignored: {}\", propertyHolder.getEntityName()\n \t\t\t);\n \t\t}\n \n \t\t// try to find class level generators\n \t\tHashMap<String, IdGenerator> classGenerators = buildLocalGenerators( clazzToProcess, mappings );\n \n \t\t// check properties\n \t\tfinal InheritanceState.ElementsToProcess elementsToProcess = inheritanceState.getElementsToProcess();\n \t\tinheritanceState.postProcess( persistentClass, entityBinder );\n \n \t\tfinal boolean subclassAndSingleTableStrategy = inheritanceState.getType() == InheritanceType.SINGLE_TABLE\n \t\t\t\t&& inheritanceState.hasParents();\n \t\t//process idclass if any\n \t\tSet<String> idProperties = new HashSet<String>();\n \t\tXClass classWithIdClass = inheritanceState.getClassWithIdClass(false);\n \t\tif ( classWithIdClass != null ) {\n \t\t\tIdClass idClass = classWithIdClass.getAnnotation( IdClass.class );\n \t\t\tXClass compositeClass = mappings.getReflectionManager().toXClass( idClass.value() );\n \t\t\tboolean isComponent = true;\n \t\t\tAccessType propertyAccessor = entityBinder.getPropertyAccessor( compositeClass );\n \t\t\tString generatorType = \"assigned\";\n \t\t\tString generator = BinderHelper.ANNOTATION_STRING_DEFAULT;\n \t\t\tPropertyData inferredData = new PropertyPreloadedData(\n \t\t\t\t\tentityBinder.getPropertyAccessType(), \"id\", compositeClass\n \t\t\t);\n \t\t\tPropertyData baseInferredData = new PropertyPreloadedData(\n                   entityBinder.getPropertyAccessType(), \"id\", classWithIdClass\n             );\n \t\t\tHashMap<String, IdGenerator> localGenerators = new HashMap<String, IdGenerator>();\n \t\t\tboolean ignoreIdAnnotations = entityBinder.isIgnoreIdAnnotations();\n \t\t\tentityBinder.setIgnoreIdAnnotations( true );\n+\t\t\tpropertyHolder.setInIdClass( true );\n \t\t\tbindId(\n \t\t\t\t\tgeneratorType,\n \t\t\t\t\tgenerator,\n \t\t\t\t\tinferredData,\n \t\t\t\t\tbaseInferredData,\n \t\t\t\t\tnull,\n \t\t\t\t\tpropertyHolder,\n \t\t\t\t\tlocalGenerators,\n \t\t\t\t\tisComponent,\n \t\t\t\t\tpropertyAccessor, entityBinder,\n \t\t\t\t\ttrue,\n \t\t\t\t\tfalse,\n \t\t\t\t\tmappings,\n \t\t\t\t\tinheritanceStatePerClass\n \t\t\t);\n+\t\t\tpropertyHolder.setInIdClass( null );\n \t\t\tinferredData = new PropertyPreloadedData(\n \t\t\t\t\tpropertyAccessor, \"_identifierMapper\", compositeClass\n \t\t\t);\n \t\t\tComponent mapper = fillComponent(\n \t\t\t\t\tpropertyHolder,\n \t\t\t\t\tinferredData,\n \t\t\t\t\tbaseInferredData,\n \t\t\t\t\tpropertyAccessor,\n \t\t\t\t\tfalse,\n \t\t\t\t\tentityBinder,\n \t\t\t\t\ttrue,\n \t\t\t\t\ttrue,\n-\t\t\t\t\tfalse, mappings, inheritanceStatePerClass\n+\t\t\t\t\tfalse,\n+\t\t\t\t\tmappings,\n+\t\t\t\t\tinheritanceStatePerClass\n \t\t\t);\n \t\t\tentityBinder.setIgnoreIdAnnotations( ignoreIdAnnotations );\n \t\t\tpersistentClass.setIdentifierMapper( mapper );\n \n \t\t\t//If id definition is on a mapped superclass, update the mapping\n \t\t\tfinal org.hibernate.mapping.MappedSuperclass superclass = BinderHelper.getMappedSuperclassOrNull(\n \t\t\t\t\tinferredData.getDeclaringClass(),\n \t\t\t\t\tinheritanceStatePerClass,\n \t\t\t\t\tmappings\n \t\t\t);\n \t\t\tif (superclass != null) {\n \t\t\t\tsuperclass.setDeclaredIdentifierMapper(mapper);\n \t\t\t}\n \t\t\telse {\n \t\t\t\t//we are for sure on the entity\n \t\t\t\tpersistentClass.setDeclaredIdentifierMapper( mapper );\n \t\t\t}\n \n \t\t\tProperty property = new Property();\n \t\t\tproperty.setName( \"_identifierMapper\" );\n \t\t\tproperty.setNodeName( \"id\" );\n \t\t\tproperty.setUpdateable( false );\n \t\t\tproperty.setInsertable( false );\n \t\t\tproperty.setValue( mapper );\n \t\t\tproperty.setPropertyAccessorName( \"embedded\" );\n \t\t\tpersistentClass.addProperty( property );\n \t\t\tentityBinder.setIgnoreIdAnnotations( true );\n \n \t\t\tIterator properties = mapper.getPropertyIterator();\n \t\t\twhile ( properties.hasNext() ) {\n \t\t\t\tidProperties.add( ( (Property) properties.next() ).getName() );\n \t\t\t}\n \t\t}\n \t\telse {\n \t\t\tentityBinder.setWrapIdsInEmbeddedComponents( elementsToProcess.getIdPropertyCount() > 1 );\n \t\t}\n \t\tSet<String> missingIdProperties = new HashSet<String>( idProperties );\n \t\tfor (PropertyData propertyAnnotatedElement : elementsToProcess.getElements() ) {\n \t\t\tString propertyName = propertyAnnotatedElement.getPropertyName();\n \t\t\tif ( !idProperties.contains( propertyName ) ) {\n \t\t\t\tprocessElementAnnotations(\n \t\t\t\t\t\tpropertyHolder,\n \t\t\t\t\t\tsubclassAndSingleTableStrategy ?\n \t\t\t\t\t\t\t\tNullability.FORCED_NULL :\n \t\t\t\t\t\t\t\tNullability.NO_CONSTRAINT,\n \t\t\t\t\t\tpropertyAnnotatedElement.getProperty(),\n \t\t\t\t\t\tpropertyAnnotatedElement, classGenerators, entityBinder,\n \t\t\t\t\t\tfalse, false, false, mappings, inheritanceStatePerClass\n \t\t\t\t);\n \t\t\t}\n \t\t\telse {\n \t\t\t\tmissingIdProperties.remove( propertyName );\n \t\t\t}\n \t\t}\n \n \t\tif ( missingIdProperties.size() != 0 ) {\n \t\t\tStringBuilder missings = new StringBuilder();\n \t\t\tfor (String property : missingIdProperties) {\n \t\t\t\tmissings.append( property ).append( \", \" );\n \t\t\t}\n \t\t\tthrow new AnnotationException(\n \t\t\t\t\t\"Unable to find properties (\"\n \t\t\t\t\t\t\t+ missings.substring( 0, missings.length() - 2 )\n \t\t\t\t\t\t\t+ \") in entity annotated with @IdClass:\" + persistentClass.getEntityName()\n \t\t\t);\n \t\t}\n \n \t\tif ( !inheritanceState.hasParents() ) {\n \t\t\tfinal RootClass rootClass = (RootClass) persistentClass;\n \t\t\tmappings.addSecondPass( new CreateKeySecondPass( rootClass ) );\n \t\t}\n \t\telse {\n \t\t\tsuperEntity.addSubclass( (Subclass) persistentClass );\n \t\t}\n \n \t\tmappings.addClass( persistentClass );\n \n \t\t//Process secondary tables and complementary definitions (ie o.h.a.Table)\n \t\tmappings.addSecondPass( new SecondaryTableSecondPass( entityBinder, propertyHolder, clazzToProcess ) );\n \n \t\t//add process complementary Table definition (index & all)\n \t\tentityBinder.processComplementaryTableDefinitions( clazzToProcess.getAnnotation( org.hibernate.annotations.Table.class ) );\n \t\tentityBinder.processComplementaryTableDefinitions( clazzToProcess.getAnnotation( org.hibernate.annotations.Tables.class ) );\n \n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"5ee9ba361c96c29b06542720cb8b01e1034d8544": {
			"type": "Ybodychange",
			"commitMessage": "HHH-4529 Add support for parent's id being an IdClass or an EmbeddedId (last case not tested yet). (example e2.b)\n\ngit-svn-id: https://svn.jboss.org/repos/hibernate/core/trunk@18625 1b8cb986-b30d-0410-93ca-fae66ebed9b2\n",
			"commitDate": "2010-01-26, 4:57 AM",
			"commitName": "5ee9ba361c96c29b06542720cb8b01e1034d8544",
			"commitAuthor": "Emmanuel Bernard",
			"commitDateOld": "2010-01-25, 9:19 AM",
			"commitNameOld": "d00f7efb308fab613b4918f9b8831f07602c6bd0",
			"commitAuthorOld": "Emmanuel Bernard",
			"daysBetweenCommits": 0.82,
			"commitsBetweenForRepo": 3,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,345 +1,331 @@\n \tpublic static void bindClass(\n \t\t\tXClass clazzToProcess, Map<XClass, InheritanceState> inheritanceStatePerClass, ExtendedMappings mappings\n \t) throws MappingException {\n \t\t//TODO: be more strict with secondarytable allowance (not for ids, not for secondary table join columns etc)\n \t\tInheritanceState inheritanceState = inheritanceStatePerClass.get( clazzToProcess );\n \t\tAnnotatedClassType classType = mappings.getClassType( clazzToProcess );\n \n \t\t//Queries declared in MappedSuperclass should be usable in Subclasses\n \t\tif ( AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals( classType ) ) {\n \t\t\tbindQueries( clazzToProcess, mappings );\n \t\t\tbindTypeDefs(clazzToProcess, mappings);\n \t\t\tbindFilterDefs(clazzToProcess, mappings);\n \t\t}\n \n \t\tif( !isEntityClassType( clazzToProcess, classType ) ) {\n \t\t\treturn;\n \t\t}\n \n \t\tlog.info( \"Binding entity from annotated class: {}\", clazzToProcess.getName() );\n \n \t\tPersistentClass superEntity = getSuperEntity(clazzToProcess, inheritanceStatePerClass, mappings, inheritanceState);\n \n \t\tbindQueries( clazzToProcess, mappings );\n \t\tbindFilterDefs( clazzToProcess, mappings );\n \t\tbindTypeDefs( clazzToProcess, mappings );\n \t\tBinderHelper.bindAnyMetaDefs( clazzToProcess, mappings );\n \n \t\tString schema = \"\";\n \t\tString table = \"\"; //might be no @Table annotation on the annotated class\n \t\tString catalog = \"\";\n \t\tList<UniqueConstraintHolder> uniqueConstraints = new ArrayList<UniqueConstraintHolder>();\n \t\tif ( clazzToProcess.isAnnotationPresent( javax.persistence.Table.class ) ) {\n \t\t\tjavax.persistence.Table tabAnn = clazzToProcess.getAnnotation( javax.persistence.Table.class );\n \t\t\ttable = tabAnn.name();\n \t\t\tschema = tabAnn.schema();\n \t\t\tcatalog = tabAnn.catalog();\n \t\t\tuniqueConstraints = TableBinder.buildUniqueConstraintHolders( tabAnn.uniqueConstraints() );\n \t\t}\n \n \t\tEjb3JoinColumn[] inheritanceJoinedColumns = makeInheritanceJoinColumns( clazzToProcess, mappings, inheritanceState, superEntity );\n \t\tEjb3DiscriminatorColumn discriminatorColumn = null;\n \t\tString discrimValue = null;\n \t\tif ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.getType() ) ) {\n \t\t\tjavax.persistence.DiscriminatorColumn discAnn = clazzToProcess.getAnnotation(\n \t\t\t\t\tjavax.persistence.DiscriminatorColumn.class\n \t\t\t);\n \t\t\tDiscriminatorType discriminatorType = discAnn != null ?\n \t\t\t\t\tdiscAnn.discriminatorType() :\n \t\t\t\t\tDiscriminatorType.STRING;\n \n \t\t\torg.hibernate.annotations.DiscriminatorFormula discFormulaAnn = clazzToProcess.getAnnotation(\n \t\t\t\t\torg.hibernate.annotations.DiscriminatorFormula.class\n \t\t\t);\n \t\t\tif ( !inheritanceState.hasParents() ) {\n \t\t\t\tdiscriminatorColumn = Ejb3DiscriminatorColumn.buildDiscriminatorColumn(\n \t\t\t\t\t\tdiscriminatorType, discAnn, discFormulaAnn, mappings\n \t\t\t\t);\n \t\t\t}\n \t\t\tif ( discAnn != null && inheritanceState.hasParents() ) {\n \t\t\t\tlog.warn(\n \t\t\t\t\t\t\"Discriminator column has to be defined in the root entity, it will be ignored in subclass: {}\",\n \t\t\t\t\t\tclazzToProcess.getName()\n \t\t\t\t);\n \t\t\t}\n \n \t\t\tdiscrimValue = clazzToProcess.isAnnotationPresent( DiscriminatorValue.class ) ?\n \t\t\t\t\tclazzToProcess.getAnnotation( DiscriminatorValue.class ).value() :\n \t\t\t\t\tnull;\n \t\t}\n \n \t\tPersistentClass persistentClass = makePersistentClass( inheritanceState, superEntity );\n \n \t\tProxy proxyAnn = clazzToProcess.getAnnotation( Proxy.class );\n \t\tBatchSize sizeAnn = clazzToProcess.getAnnotation( BatchSize.class );\n \t\tWhere whereAnn = clazzToProcess.getAnnotation( Where.class );\n \t\tEntity entityAnn = clazzToProcess.getAnnotation( Entity.class );\n \t\torg.hibernate.annotations.Entity hibEntityAnn = clazzToProcess.getAnnotation(\n \t\t\t\torg.hibernate.annotations.Entity.class\n \t\t);\n \n \t\tCache cacheAnn = determineCacheSettings( clazzToProcess, mappings );\n \n \t\tEntityBinder entityBinder = new EntityBinder(\n \t\t\t\tentityAnn, hibEntityAnn, clazzToProcess, persistentClass, mappings\n \t\t);\n \t\tentityBinder.setDiscriminatorValue( discrimValue );\n \t\tentityBinder.setBatchSize( sizeAnn );\n \t\tentityBinder.setProxy( proxyAnn );\n \t\tentityBinder.setWhere( whereAnn );\n \t\tentityBinder.setCache( cacheAnn );\n \t\tentityBinder.setInheritanceState( inheritanceState );\n \n \t\t//Filters are not allowed on subclasses\n \t\tif ( !inheritanceState.hasParents() ) {\n \t\t\tbindFilters(clazzToProcess, entityBinder, mappings);\n \t\t}\n \n \t\tentityBinder.bindEntity();\n \n \t\tif ( inheritanceState.hasTable() ) {\n \t\t\tCheck checkAnn = clazzToProcess.getAnnotation( Check.class );\n \t\t\tString constraints = checkAnn == null ?\n \t\t\t\t\tnull :\n \t\t\t\t\tcheckAnn.constraints();\n \t\t\tentityBinder.bindTable(\n \t\t\t\t\tschema, catalog, table, uniqueConstraints,\n \t\t\t\t\tconstraints, inheritanceState.hasDenormalizedTable() ?\n \t\t\t\t\tsuperEntity.getTable() :\n \t\t\t\t\tnull\n \t\t\t);\n \t\t}\n \t\telse {\n \t\t\tif ( clazzToProcess.isAnnotationPresent( Table.class ) ) {\n \t\t\t\tlog.warn( \"Illegal use of @Table in a subclass of a SINGLE_TABLE hierarchy: \" + clazzToProcess\n \t\t\t\t\t\t.getName() );\n \t\t\t}\n \t\t}\n \n \t\tPropertyHolder propertyHolder = PropertyHolderBuilder.buildPropertyHolder(\n \t\t\t\tclazzToProcess,\n \t\t\t\tpersistentClass,\n \t\t\t\tentityBinder, mappings, inheritanceStatePerClass\n \t\t);\n \n \t\tjavax.persistence.SecondaryTable secTabAnn = clazzToProcess.getAnnotation(\n \t\t\t\tjavax.persistence.SecondaryTable.class\n \t\t);\n \t\tjavax.persistence.SecondaryTables secTabsAnn = clazzToProcess.getAnnotation(\n \t\t\t\tjavax.persistence.SecondaryTables.class\n \t\t);\n \t\tentityBinder.firstLevelSecondaryTablesBinding( secTabAnn, secTabsAnn );\n \n \t\tOnDelete onDeleteAnn = clazzToProcess.getAnnotation( OnDelete.class );\n \t\tboolean onDeleteAppropriate = false;\n \t\tif ( InheritanceType.JOINED.equals( inheritanceState.getType() ) && inheritanceState.hasParents() ) {\n \t\t\tonDeleteAppropriate = true;\n \t\t\tfinal JoinedSubclass jsc = (JoinedSubclass) persistentClass;\n \t\t\tif ( persistentClass.getEntityPersisterClass() == null ) {\n \t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( JoinedSubclassEntityPersister.class );\n \t\t\t}\n \t\t\tSimpleValue key = new DependantValue( jsc.getTable(), jsc.getIdentifier() );\n \t\t\tjsc.setKey( key );\n \t\t\tForeignKey fk = clazzToProcess.getAnnotation( ForeignKey.class );\n \t\t\tif ( fk != null && !BinderHelper.isDefault( fk.name() ) ) {\n \t\t\t\tkey.setForeignKeyName( fk.name() );\n \t\t\t}\n \t\t\tif ( onDeleteAnn != null ) {\n \t\t\t\tkey.setCascadeDeleteEnabled( OnDeleteAction.CASCADE.equals( onDeleteAnn.action() ) );\n \t\t\t}\n \t\t\telse {\n \t\t\t\tkey.setCascadeDeleteEnabled( false );\n \t\t\t}\n \t\t\t//we are never in a second pass at that stage, so queue it\n \t\t\tSecondPass sp = new JoinedSubclassFkSecondPass( jsc, inheritanceJoinedColumns, key, mappings );\n \t\t\tmappings.addSecondPass( sp );\n \t\t\tmappings.addSecondPass( new CreateKeySecondPass( jsc ) );\n \n \t\t}\n \t\telse if ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.getType() ) ) {\n \t\t\tif ( inheritanceState.hasParents() ) {\n \t\t\t\tif ( persistentClass.getEntityPersisterClass() == null ) {\n \t\t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( SingleTableEntityPersister.class );\n \t\t\t\t}\n \t\t\t}\n \t\t\telse {\n \t\t\t\tif ( inheritanceState.hasSiblings() || !discriminatorColumn.isImplicit() ) {\n \t\t\t\t\t//need a discriminator column\n \t\t\t\t\tbindDiscriminatorToPersistentClass(\n \t\t\t\t\t\t\t(RootClass) persistentClass,\n \t\t\t\t\t\t\tdiscriminatorColumn,\n \t\t\t\t\t\t\tentityBinder.getSecondaryTables(),\n \t\t\t\t\t\t\tpropertyHolder\n \t\t\t\t\t);\n \t\t\t\t\tentityBinder.bindDiscriminatorValue();//bind it again since the type might have changed\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\telse if ( InheritanceType.TABLE_PER_CLASS.equals( inheritanceState.getType() ) ) {\n \t\t\tif ( inheritanceState.hasParents() ) {\n \t\t\t\tif ( persistentClass.getEntityPersisterClass() == null ) {\n \t\t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( UnionSubclassEntityPersister.class );\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\tif ( onDeleteAnn != null && !onDeleteAppropriate ) {\n \t\t\tlog.warn(\n \t\t\t\t\t\"Inapropriate use of @OnDelete on entity, annotation ignored: {}\", propertyHolder.getEntityName()\n \t\t\t);\n \t\t}\n \n \t\t// try to find class level generators\n \t\tHashMap<String, IdGenerator> classGenerators = buildLocalGenerators( clazzToProcess, mappings );\n \n \t\t// check properties\n-\t\tfinal ElementsToProcess elementsToProcess = getElementsToProcess(\n-\t\t\t\tpersistentClass, clazzToProcess, inheritanceStatePerClass, entityBinder, mappings\n-\t\t);\n-\t\t\n+\t\tfinal InheritanceState.ElementsToProcess elementsToProcess = inheritanceState.getElementsToProcess();\n+\t\tinheritanceState.postProcess( persistentClass, entityBinder );\n+\n \t\tfinal boolean subclassAndSingleTableStrategy = inheritanceState.getType() == InheritanceType.SINGLE_TABLE\n \t\t\t\t&& inheritanceState.hasParents();\n \t\t//process idclass if any\n \t\tSet<String> idProperties = new HashSet<String>();\n-\t\tIdClass idClass = null;\n-\t\tXClass current = null;\n-\t\tif ( !inheritanceState.hasParents() ) {\n-\t\t\t//look for idClass\n-\t\t\tInheritanceState state = inheritanceState;\n-\t\t\tdo {\n-\t\t\t\tcurrent = state.getClazz();\n-\t\t\t\tif ( current.isAnnotationPresent( IdClass.class ) ) {\n-\t\t\t\t\tidClass = current.getAnnotation( IdClass.class );\n-\t\t\t\t\tbreak;\n-\t\t\t\t}\n-\t\t\t\tstate = InheritanceState.getSuperclassInheritanceState( current, inheritanceStatePerClass );\n-\t\t\t}\n-\t\t\twhile ( state != null );\n-\t\t}\n-\t\tif ( idClass != null ) {\n+\t\tXClass classWithIdClass = inheritanceState.getClassWithIdClass(false);\n+\t\tif ( classWithIdClass != null ) {\n+\t\t\tIdClass idClass = classWithIdClass.getAnnotation( IdClass.class );\n \t\t\tXClass compositeClass = mappings.getReflectionManager().toXClass( idClass.value() );\n \t\t\tboolean isComponent = true;\n \t\t\tAccessType propertyAccessor = entityBinder.getPropertyAccessor( compositeClass );\n \t\t\tString generatorType = \"assigned\";\n \t\t\tString generator = BinderHelper.ANNOTATION_STRING_DEFAULT;\n \t\t\tPropertyData inferredData = new PropertyPreloadedData(\n \t\t\t\t\tentityBinder.getPropertyAccessType(), \"id\", compositeClass\n \t\t\t);\n \t\t\tPropertyData baseInferredData = new PropertyPreloadedData(\n-                  entityBinder.getPropertyAccessType(), \"id\", current\n+                  entityBinder.getPropertyAccessType(), \"id\", classWithIdClass\n             );\n \t\t\tHashMap<String, IdGenerator> localGenerators = new HashMap<String, IdGenerator>();\n \t\t\tboolean ignoreIdAnnotations = entityBinder.isIgnoreIdAnnotations();\n \t\t\tentityBinder.setIgnoreIdAnnotations( true );\n \t\t\tbindId(\n \t\t\t\t\tgeneratorType,\n \t\t\t\t\tgenerator,\n \t\t\t\t\tinferredData,\n \t\t\t\t\tbaseInferredData,\n \t\t\t\t\tnull,\n \t\t\t\t\tpropertyHolder,\n \t\t\t\t\tlocalGenerators,\n \t\t\t\t\tisComponent,\n \t\t\t\t\tpropertyAccessor, entityBinder,\n \t\t\t\t\ttrue,\n \t\t\t\t\tfalse,\n \t\t\t\t\tmappings,\n \t\t\t\t\tinheritanceStatePerClass\n \t\t\t);\n \t\t\tinferredData = new PropertyPreloadedData(\n \t\t\t\t\tpropertyAccessor, \"_identifierMapper\", compositeClass\n \t\t\t);\n \t\t\tComponent mapper = fillComponent(\n \t\t\t\t\tpropertyHolder,\n \t\t\t\t\tinferredData,\n \t\t\t\t\tbaseInferredData,\n \t\t\t\t\tpropertyAccessor,\n \t\t\t\t\tfalse,\n \t\t\t\t\tentityBinder,\n \t\t\t\t\ttrue,\n \t\t\t\t\ttrue,\n \t\t\t\t\tfalse, mappings, inheritanceStatePerClass\n \t\t\t);\n \t\t\tentityBinder.setIgnoreIdAnnotations( ignoreIdAnnotations );\n \t\t\tpersistentClass.setIdentifierMapper( mapper );\n \n \t\t\t//If id definition is on a mapped superclass, update the mapping\n \t\t\tfinal org.hibernate.mapping.MappedSuperclass superclass = BinderHelper.getMappedSuperclassOrNull(\n \t\t\t\t\tinferredData.getDeclaringClass(),\n \t\t\t\t\tinheritanceStatePerClass,\n \t\t\t\t\tmappings\n \t\t\t);\n \t\t\tif (superclass != null) {\n \t\t\t\tsuperclass.setDeclaredIdentifierMapper(mapper);\n \t\t\t}\n \t\t\telse {\n \t\t\t\t//we are for sure on the entity\n \t\t\t\tpersistentClass.setDeclaredIdentifierMapper( mapper );\n \t\t\t}\n \n \t\t\tProperty property = new Property();\n \t\t\tproperty.setName( \"_identifierMapper\" );\n \t\t\tproperty.setNodeName( \"id\" );\n \t\t\tproperty.setUpdateable( false );\n \t\t\tproperty.setInsertable( false );\n \t\t\tproperty.setValue( mapper );\n \t\t\tproperty.setPropertyAccessorName( \"embedded\" );\n \t\t\tpersistentClass.addProperty( property );\n \t\t\tentityBinder.setIgnoreIdAnnotations( true );\n \n \t\t\tIterator properties = mapper.getPropertyIterator();\n \t\t\twhile ( properties.hasNext() ) {\n \t\t\t\tidProperties.add( ( (Property) properties.next() ).getName() );\n \t\t\t}\n \t\t}\n \t\telse {\n \t\t\tentityBinder.setWrapIdsInEmbeddedComponents( elementsToProcess.getIdPropertyCount() > 1 );\n \t\t}\n \t\tSet<String> missingIdProperties = new HashSet<String>( idProperties );\n \t\tfor (PropertyData propertyAnnotatedElement : elementsToProcess.getElements() ) {\n \t\t\tString propertyName = propertyAnnotatedElement.getPropertyName();\n \t\t\tif ( !idProperties.contains( propertyName ) ) {\n \t\t\t\tprocessElementAnnotations(\n \t\t\t\t\t\tpropertyHolder,\n \t\t\t\t\t\tsubclassAndSingleTableStrategy ?\n \t\t\t\t\t\t\t\tNullability.FORCED_NULL :\n \t\t\t\t\t\t\t\tNullability.NO_CONSTRAINT,\n \t\t\t\t\t\tpropertyAnnotatedElement.getProperty(),\n \t\t\t\t\t\tpropertyAnnotatedElement, classGenerators, entityBinder,\n \t\t\t\t\t\tfalse, false, false, mappings, inheritanceStatePerClass\n \t\t\t\t);\n \t\t\t}\n \t\t\telse {\n \t\t\t\tmissingIdProperties.remove( propertyName );\n \t\t\t}\n \t\t}\n \n \t\tif ( missingIdProperties.size() != 0 ) {\n \t\t\tStringBuilder missings = new StringBuilder();\n \t\t\tfor (String property : missingIdProperties) {\n \t\t\t\tmissings.append( property ).append( \", \" );\n \t\t\t}\n \t\t\tthrow new AnnotationException(\n \t\t\t\t\t\"Unable to find properties (\"\n \t\t\t\t\t\t\t+ missings.substring( 0, missings.length() - 2 )\n \t\t\t\t\t\t\t+ \") in entity annotated with @IdClass:\" + persistentClass.getEntityName()\n \t\t\t);\n \t\t}\n \n \t\tif ( !inheritanceState.hasParents() ) {\n \t\t\tfinal RootClass rootClass = (RootClass) persistentClass;\n \t\t\tmappings.addSecondPass( new CreateKeySecondPass( rootClass ) );\n \t\t}\n \t\telse {\n \t\t\tsuperEntity.addSubclass( (Subclass) persistentClass );\n \t\t}\n \n \t\tmappings.addClass( persistentClass );\n \n \t\t//Process secondary tables and complementary definitions (ie o.h.a.Table)\n \t\tmappings.addSecondPass( new SecondaryTableSecondPass( entityBinder, propertyHolder, clazzToProcess ) );\n \n \t\t//add process complementary Table definition (index & all)\n \t\tentityBinder.processComplementaryTableDefinitions( clazzToProcess.getAnnotation( org.hibernate.annotations.Table.class ) );\n \t\tentityBinder.processComplementaryTableDefinitions( clazzToProcess.getAnnotation( org.hibernate.annotations.Tables.class ) );\n \n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"d00f7efb308fab613b4918f9b8831f07602c6bd0": {
			"type": "Ybodychange",
			"commitMessage": "HHH-4529 support for derived entity id as a XToOne pointing to the master entity\nHHH-4840 support for Core style embedded id (after all these years :) )\n\ngit-svn-id: https://svn.jboss.org/repos/hibernate/core/trunk@18619 1b8cb986-b30d-0410-93ca-fae66ebed9b2\n",
			"commitDate": "2010-01-25, 9:19 AM",
			"commitName": "d00f7efb308fab613b4918f9b8831f07602c6bd0",
			"commitAuthor": "Emmanuel Bernard",
			"commitDateOld": "2010-01-24, 9:07 AM",
			"commitNameOld": "5d8d70036a139f954e7b572a649ab52d4b930692",
			"commitAuthorOld": "Steve Ebersole",
			"daysBetweenCommits": 1.01,
			"commitsBetweenForRepo": 4,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,338 +1,345 @@\n \tpublic static void bindClass(\n \t\t\tXClass clazzToProcess, Map<XClass, InheritanceState> inheritanceStatePerClass, ExtendedMappings mappings\n \t) throws MappingException {\n \t\t//TODO: be more strict with secondarytable allowance (not for ids, not for secondary table join columns etc)\n \t\tInheritanceState inheritanceState = inheritanceStatePerClass.get( clazzToProcess );\n \t\tAnnotatedClassType classType = mappings.getClassType( clazzToProcess );\n \n \t\t//Queries declared in MappedSuperclass should be usable in Subclasses\n \t\tif ( AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals( classType ) ) {\n \t\t\tbindQueries( clazzToProcess, mappings );\n \t\t\tbindTypeDefs(clazzToProcess, mappings);\n \t\t\tbindFilterDefs(clazzToProcess, mappings);\n \t\t}\n \n \t\tif( !isEntityClassType( clazzToProcess, classType ) ) {\n \t\t\treturn;\n \t\t}\n \n \t\tlog.info( \"Binding entity from annotated class: {}\", clazzToProcess.getName() );\n \n \t\tPersistentClass superEntity = getSuperEntity(clazzToProcess, inheritanceStatePerClass, mappings, inheritanceState);\n \n \t\tbindQueries( clazzToProcess, mappings );\n \t\tbindFilterDefs( clazzToProcess, mappings );\n \t\tbindTypeDefs( clazzToProcess, mappings );\n \t\tBinderHelper.bindAnyMetaDefs( clazzToProcess, mappings );\n \n \t\tString schema = \"\";\n \t\tString table = \"\"; //might be no @Table annotation on the annotated class\n \t\tString catalog = \"\";\n \t\tList<UniqueConstraintHolder> uniqueConstraints = new ArrayList<UniqueConstraintHolder>();\n \t\tif ( clazzToProcess.isAnnotationPresent( javax.persistence.Table.class ) ) {\n \t\t\tjavax.persistence.Table tabAnn = clazzToProcess.getAnnotation( javax.persistence.Table.class );\n \t\t\ttable = tabAnn.name();\n \t\t\tschema = tabAnn.schema();\n \t\t\tcatalog = tabAnn.catalog();\n \t\t\tuniqueConstraints = TableBinder.buildUniqueConstraintHolders( tabAnn.uniqueConstraints() );\n \t\t}\n \n \t\tEjb3JoinColumn[] inheritanceJoinedColumns = makeInheritanceJoinColumns( clazzToProcess, mappings, inheritanceState, superEntity );\n \t\tEjb3DiscriminatorColumn discriminatorColumn = null;\n \t\tString discrimValue = null;\n \t\tif ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.getType() ) ) {\n \t\t\tjavax.persistence.DiscriminatorColumn discAnn = clazzToProcess.getAnnotation(\n \t\t\t\t\tjavax.persistence.DiscriminatorColumn.class\n \t\t\t);\n \t\t\tDiscriminatorType discriminatorType = discAnn != null ?\n \t\t\t\t\tdiscAnn.discriminatorType() :\n \t\t\t\t\tDiscriminatorType.STRING;\n \n \t\t\torg.hibernate.annotations.DiscriminatorFormula discFormulaAnn = clazzToProcess.getAnnotation(\n \t\t\t\t\torg.hibernate.annotations.DiscriminatorFormula.class\n \t\t\t);\n \t\t\tif ( !inheritanceState.hasParents() ) {\n \t\t\t\tdiscriminatorColumn = Ejb3DiscriminatorColumn.buildDiscriminatorColumn(\n \t\t\t\t\t\tdiscriminatorType, discAnn, discFormulaAnn, mappings\n \t\t\t\t);\n \t\t\t}\n \t\t\tif ( discAnn != null && inheritanceState.hasParents() ) {\n \t\t\t\tlog.warn(\n \t\t\t\t\t\t\"Discriminator column has to be defined in the root entity, it will be ignored in subclass: {}\",\n \t\t\t\t\t\tclazzToProcess.getName()\n \t\t\t\t);\n \t\t\t}\n \n \t\t\tdiscrimValue = clazzToProcess.isAnnotationPresent( DiscriminatorValue.class ) ?\n \t\t\t\t\tclazzToProcess.getAnnotation( DiscriminatorValue.class ).value() :\n \t\t\t\t\tnull;\n \t\t}\n \n \t\tPersistentClass persistentClass = makePersistentClass( inheritanceState, superEntity );\n \n \t\tProxy proxyAnn = clazzToProcess.getAnnotation( Proxy.class );\n \t\tBatchSize sizeAnn = clazzToProcess.getAnnotation( BatchSize.class );\n \t\tWhere whereAnn = clazzToProcess.getAnnotation( Where.class );\n \t\tEntity entityAnn = clazzToProcess.getAnnotation( Entity.class );\n \t\torg.hibernate.annotations.Entity hibEntityAnn = clazzToProcess.getAnnotation(\n \t\t\t\torg.hibernate.annotations.Entity.class\n \t\t);\n \n \t\tCache cacheAnn = determineCacheSettings( clazzToProcess, mappings );\n \n \t\tEntityBinder entityBinder = new EntityBinder(\n \t\t\t\tentityAnn, hibEntityAnn, clazzToProcess, persistentClass, mappings\n \t\t);\n \t\tentityBinder.setDiscriminatorValue( discrimValue );\n \t\tentityBinder.setBatchSize( sizeAnn );\n \t\tentityBinder.setProxy( proxyAnn );\n \t\tentityBinder.setWhere( whereAnn );\n \t\tentityBinder.setCache( cacheAnn );\n \t\tentityBinder.setInheritanceState( inheritanceState );\n \n \t\t//Filters are not allowed on subclasses\n \t\tif ( !inheritanceState.hasParents() ) {\n \t\t\tbindFilters(clazzToProcess, entityBinder, mappings);\n \t\t}\n \n \t\tentityBinder.bindEntity();\n \n \t\tif ( inheritanceState.hasTable() ) {\n \t\t\tCheck checkAnn = clazzToProcess.getAnnotation( Check.class );\n \t\t\tString constraints = checkAnn == null ?\n \t\t\t\t\tnull :\n \t\t\t\t\tcheckAnn.constraints();\n \t\t\tentityBinder.bindTable(\n \t\t\t\t\tschema, catalog, table, uniqueConstraints,\n \t\t\t\t\tconstraints, inheritanceState.hasDenormalizedTable() ?\n \t\t\t\t\tsuperEntity.getTable() :\n \t\t\t\t\tnull\n \t\t\t);\n \t\t}\n \t\telse {\n \t\t\tif ( clazzToProcess.isAnnotationPresent( Table.class ) ) {\n \t\t\t\tlog.warn( \"Illegal use of @Table in a subclass of a SINGLE_TABLE hierarchy: \" + clazzToProcess\n \t\t\t\t\t\t.getName() );\n \t\t\t}\n \t\t}\n \n \t\tPropertyHolder propertyHolder = PropertyHolderBuilder.buildPropertyHolder(\n \t\t\t\tclazzToProcess,\n \t\t\t\tpersistentClass,\n \t\t\t\tentityBinder, mappings, inheritanceStatePerClass\n \t\t);\n \n \t\tjavax.persistence.SecondaryTable secTabAnn = clazzToProcess.getAnnotation(\n \t\t\t\tjavax.persistence.SecondaryTable.class\n \t\t);\n \t\tjavax.persistence.SecondaryTables secTabsAnn = clazzToProcess.getAnnotation(\n \t\t\t\tjavax.persistence.SecondaryTables.class\n \t\t);\n \t\tentityBinder.firstLevelSecondaryTablesBinding( secTabAnn, secTabsAnn );\n \n \t\tOnDelete onDeleteAnn = clazzToProcess.getAnnotation( OnDelete.class );\n \t\tboolean onDeleteAppropriate = false;\n \t\tif ( InheritanceType.JOINED.equals( inheritanceState.getType() ) && inheritanceState.hasParents() ) {\n \t\t\tonDeleteAppropriate = true;\n \t\t\tfinal JoinedSubclass jsc = (JoinedSubclass) persistentClass;\n \t\t\tif ( persistentClass.getEntityPersisterClass() == null ) {\n \t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( JoinedSubclassEntityPersister.class );\n \t\t\t}\n \t\t\tSimpleValue key = new DependantValue( jsc.getTable(), jsc.getIdentifier() );\n \t\t\tjsc.setKey( key );\n \t\t\tForeignKey fk = clazzToProcess.getAnnotation( ForeignKey.class );\n \t\t\tif ( fk != null && !BinderHelper.isDefault( fk.name() ) ) {\n \t\t\t\tkey.setForeignKeyName( fk.name() );\n \t\t\t}\n \t\t\tif ( onDeleteAnn != null ) {\n \t\t\t\tkey.setCascadeDeleteEnabled( OnDeleteAction.CASCADE.equals( onDeleteAnn.action() ) );\n \t\t\t}\n \t\t\telse {\n \t\t\t\tkey.setCascadeDeleteEnabled( false );\n \t\t\t}\n \t\t\t//we are never in a second pass at that stage, so queue it\n \t\t\tSecondPass sp = new JoinedSubclassFkSecondPass( jsc, inheritanceJoinedColumns, key, mappings );\n \t\t\tmappings.addSecondPass( sp );\n \t\t\tmappings.addSecondPass( new CreateKeySecondPass( jsc ) );\n \n \t\t}\n \t\telse if ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.getType() ) ) {\n \t\t\tif ( inheritanceState.hasParents() ) {\n \t\t\t\tif ( persistentClass.getEntityPersisterClass() == null ) {\n \t\t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( SingleTableEntityPersister.class );\n \t\t\t\t}\n \t\t\t}\n \t\t\telse {\n \t\t\t\tif ( inheritanceState.hasSiblings() || !discriminatorColumn.isImplicit() ) {\n \t\t\t\t\t//need a discriminator column\n \t\t\t\t\tbindDiscriminatorToPersistentClass(\n \t\t\t\t\t\t\t(RootClass) persistentClass,\n \t\t\t\t\t\t\tdiscriminatorColumn,\n \t\t\t\t\t\t\tentityBinder.getSecondaryTables(),\n \t\t\t\t\t\t\tpropertyHolder\n \t\t\t\t\t);\n \t\t\t\t\tentityBinder.bindDiscriminatorValue();//bind it again since the type might have changed\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\telse if ( InheritanceType.TABLE_PER_CLASS.equals( inheritanceState.getType() ) ) {\n \t\t\tif ( inheritanceState.hasParents() ) {\n \t\t\t\tif ( persistentClass.getEntityPersisterClass() == null ) {\n \t\t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( UnionSubclassEntityPersister.class );\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\tif ( onDeleteAnn != null && !onDeleteAppropriate ) {\n \t\t\tlog.warn(\n \t\t\t\t\t\"Inapropriate use of @OnDelete on entity, annotation ignored: {}\", propertyHolder.getEntityName()\n \t\t\t);\n \t\t}\n \n \t\t// try to find class level generators\n \t\tHashMap<String, IdGenerator> classGenerators = buildLocalGenerators( clazzToProcess, mappings );\n \n \t\t// check properties\n-\t\tList<PropertyData> elements =\n-\t\t\t\tgetElementsToProcess(\n-\t\t\t\t\t\tpersistentClass, clazzToProcess, inheritanceStatePerClass, entityBinder, mappings\n-\t\t\t\t);\n+\t\tfinal ElementsToProcess elementsToProcess = getElementsToProcess(\n+\t\t\t\tpersistentClass, clazzToProcess, inheritanceStatePerClass, entityBinder, mappings\n+\t\t);\n+\t\t\n \t\tfinal boolean subclassAndSingleTableStrategy = inheritanceState.getType() == InheritanceType.SINGLE_TABLE\n \t\t\t\t&& inheritanceState.hasParents();\n \t\t//process idclass if any\n \t\tSet<String> idProperties = new HashSet<String>();\n \t\tIdClass idClass = null;\n \t\tXClass current = null;\n \t\tif ( !inheritanceState.hasParents() ) {\n \t\t\t//look for idClass\n \t\t\tInheritanceState state = inheritanceState;\n \t\t\tdo {\n \t\t\t\tcurrent = state.getClazz();\n \t\t\t\tif ( current.isAnnotationPresent( IdClass.class ) ) {\n \t\t\t\t\tidClass = current.getAnnotation( IdClass.class );\n \t\t\t\t\tbreak;\n \t\t\t\t}\n \t\t\t\tstate = InheritanceState.getSuperclassInheritanceState( current, inheritanceStatePerClass );\n \t\t\t}\n \t\t\twhile ( state != null );\n \t\t}\n \t\tif ( idClass != null ) {\n \t\t\tXClass compositeClass = mappings.getReflectionManager().toXClass( idClass.value() );\n \t\t\tboolean isComponent = true;\n \t\t\tAccessType propertyAccessor = entityBinder.getPropertyAccessor( compositeClass );\n \t\t\tString generatorType = \"assigned\";\n \t\t\tString generator = BinderHelper.ANNOTATION_STRING_DEFAULT;\n \t\t\tPropertyData inferredData = new PropertyPreloadedData(\n \t\t\t\t\tentityBinder.getPropertyAccessType(), \"id\", compositeClass\n \t\t\t);\n \t\t\tPropertyData baseInferredData = new PropertyPreloadedData(\n                   entityBinder.getPropertyAccessType(), \"id\", current\n             );\n \t\t\tHashMap<String, IdGenerator> localGenerators = new HashMap<String, IdGenerator>();\n \t\t\tboolean ignoreIdAnnotations = entityBinder.isIgnoreIdAnnotations();\n \t\t\tentityBinder.setIgnoreIdAnnotations( true );\n \t\t\tbindId(\n \t\t\t\t\tgeneratorType,\n \t\t\t\t\tgenerator,\n \t\t\t\t\tinferredData,\n \t\t\t\t\tbaseInferredData,\n \t\t\t\t\tnull,\n \t\t\t\t\tpropertyHolder,\n \t\t\t\t\tlocalGenerators,\n \t\t\t\t\tisComponent,\n \t\t\t\t\tpropertyAccessor, entityBinder,\n \t\t\t\t\ttrue,\n-\t\t\t\t\tfalse, mappings, inheritanceStatePerClass\n+\t\t\t\t\tfalse,\n+\t\t\t\t\tmappings,\n+\t\t\t\t\tinheritanceStatePerClass\n \t\t\t);\n \t\t\tinferredData = new PropertyPreloadedData(\n \t\t\t\t\tpropertyAccessor, \"_identifierMapper\", compositeClass\n \t\t\t);\n \t\t\tComponent mapper = fillComponent(\n \t\t\t\t\tpropertyHolder,\n \t\t\t\t\tinferredData,\n \t\t\t\t\tbaseInferredData,\n-\t\t\t\t\tpropertyAccessor, false,\n+\t\t\t\t\tpropertyAccessor,\n+\t\t\t\t\tfalse,\n \t\t\t\t\tentityBinder,\n-\t\t\t\t\ttrue, true,\n+\t\t\t\t\ttrue,\n+\t\t\t\t\ttrue,\n \t\t\t\t\tfalse, mappings, inheritanceStatePerClass\n \t\t\t);\n \t\t\tentityBinder.setIgnoreIdAnnotations( ignoreIdAnnotations );\n \t\t\tpersistentClass.setIdentifierMapper( mapper );\n \n \t\t\t//If id definition is on a mapped superclass, update the mapping\n \t\t\tfinal org.hibernate.mapping.MappedSuperclass superclass = BinderHelper.getMappedSuperclassOrNull(\n \t\t\t\t\tinferredData.getDeclaringClass(),\n \t\t\t\t\tinheritanceStatePerClass,\n \t\t\t\t\tmappings\n \t\t\t);\n \t\t\tif (superclass != null) {\n \t\t\t\tsuperclass.setDeclaredIdentifierMapper(mapper);\n \t\t\t}\n \t\t\telse {\n \t\t\t\t//we are for sure on the entity\n \t\t\t\tpersistentClass.setDeclaredIdentifierMapper( mapper );\n \t\t\t}\n \n \t\t\tProperty property = new Property();\n \t\t\tproperty.setName( \"_identifierMapper\" );\n \t\t\tproperty.setNodeName( \"id\" );\n \t\t\tproperty.setUpdateable( false );\n \t\t\tproperty.setInsertable( false );\n \t\t\tproperty.setValue( mapper );\n \t\t\tproperty.setPropertyAccessorName( \"embedded\" );\n \t\t\tpersistentClass.addProperty( property );\n \t\t\tentityBinder.setIgnoreIdAnnotations( true );\n \n \t\t\tIterator properties = mapper.getPropertyIterator();\n \t\t\twhile ( properties.hasNext() ) {\n \t\t\t\tidProperties.add( ( (Property) properties.next() ).getName() );\n \t\t\t}\n \t\t}\n+\t\telse {\n+\t\t\tentityBinder.setWrapIdsInEmbeddedComponents( elementsToProcess.getIdPropertyCount() > 1 );\n+\t\t}\n \t\tSet<String> missingIdProperties = new HashSet<String>( idProperties );\n-\t\tfor (PropertyData propertyAnnotatedElement : elements) {\n+\t\tfor (PropertyData propertyAnnotatedElement : elementsToProcess.getElements() ) {\n \t\t\tString propertyName = propertyAnnotatedElement.getPropertyName();\n \t\t\tif ( !idProperties.contains( propertyName ) ) {\n \t\t\t\tprocessElementAnnotations(\n \t\t\t\t\t\tpropertyHolder,\n \t\t\t\t\t\tsubclassAndSingleTableStrategy ?\n \t\t\t\t\t\t\t\tNullability.FORCED_NULL :\n \t\t\t\t\t\t\t\tNullability.NO_CONSTRAINT,\n \t\t\t\t\t\tpropertyAnnotatedElement.getProperty(),\n \t\t\t\t\t\tpropertyAnnotatedElement, classGenerators, entityBinder,\n \t\t\t\t\t\tfalse, false, false, mappings, inheritanceStatePerClass\n \t\t\t\t);\n \t\t\t}\n \t\t\telse {\n \t\t\t\tmissingIdProperties.remove( propertyName );\n \t\t\t}\n \t\t}\n \n \t\tif ( missingIdProperties.size() != 0 ) {\n \t\t\tStringBuilder missings = new StringBuilder();\n \t\t\tfor (String property : missingIdProperties) {\n \t\t\t\tmissings.append( property ).append( \", \" );\n \t\t\t}\n \t\t\tthrow new AnnotationException(\n \t\t\t\t\t\"Unable to find properties (\"\n \t\t\t\t\t\t\t+ missings.substring( 0, missings.length() - 2 )\n \t\t\t\t\t\t\t+ \") in entity annotated with @IdClass:\" + persistentClass.getEntityName()\n \t\t\t);\n \t\t}\n \n \t\tif ( !inheritanceState.hasParents() ) {\n \t\t\tfinal RootClass rootClass = (RootClass) persistentClass;\n \t\t\tmappings.addSecondPass( new CreateKeySecondPass( rootClass ) );\n \t\t}\n \t\telse {\n \t\t\tsuperEntity.addSubclass( (Subclass) persistentClass );\n \t\t}\n \n \t\tmappings.addClass( persistentClass );\n \n \t\t//Process secondary tables and complementary definitions (ie o.h.a.Table)\n \t\tmappings.addSecondPass( new SecondaryTableSecondPass( entityBinder, propertyHolder, clazzToProcess ) );\n \n \t\t//add process complementary Table definition (index & all)\n \t\tentityBinder.processComplementaryTableDefinitions( clazzToProcess.getAnnotation( org.hibernate.annotations.Table.class ) );\n \t\tentityBinder.processComplementaryTableDefinitions( clazzToProcess.getAnnotation( org.hibernate.annotations.Tables.class ) );\n \n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"d24ed1a1d39c1458d020a27a504a46e76dfe2e26": {
			"type": "Ybodychange",
			"commitMessage": "HHH-4659 - Add support for standard declarative cache (@Cacheable)\n\n\ngit-svn-id: https://svn.jboss.org/repos/hibernate/core/trunk@18605 1b8cb986-b30d-0410-93ca-fae66ebed9b2\n",
			"commitDate": "2010-01-21, 11:22 PM",
			"commitName": "d24ed1a1d39c1458d020a27a504a46e76dfe2e26",
			"commitAuthor": "Steve Ebersole",
			"commitDateOld": "2010-01-21, 9:51 AM",
			"commitNameOld": "8577a68e69d30d9e671024bf3330616000a3ec54",
			"commitAuthorOld": "Emmanuel Bernard",
			"daysBetweenCommits": 0.56,
			"commitsBetweenForRepo": 5,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,338 +1,338 @@\n \tpublic static void bindClass(\n \t\t\tXClass clazzToProcess, Map<XClass, InheritanceState> inheritanceStatePerClass, ExtendedMappings mappings\n \t) throws MappingException {\n \t\t//TODO: be more strict with secondarytable allowance (not for ids, not for secondary table join columns etc)\n \t\tInheritanceState inheritanceState = inheritanceStatePerClass.get( clazzToProcess );\n \t\tAnnotatedClassType classType = mappings.getClassType( clazzToProcess );\n \n \t\t//Queries declared in MappedSuperclass should be usable in Subclasses\n \t\tif ( AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals( classType ) ) {\n \t\t\tbindQueries( clazzToProcess, mappings );\n \t\t\tbindTypeDefs(clazzToProcess, mappings);\n \t\t\tbindFilterDefs(clazzToProcess, mappings);\n \t\t}\n \n \t\tif( !isEntityClassType( clazzToProcess, classType ) ) {\n \t\t\treturn;\n \t\t}\n \n \t\tlog.info( \"Binding entity from annotated class: {}\", clazzToProcess.getName() );\n \n \t\tPersistentClass superEntity = getSuperEntity(clazzToProcess, inheritanceStatePerClass, mappings, inheritanceState);\n \n \t\tbindQueries( clazzToProcess, mappings );\n \t\tbindFilterDefs( clazzToProcess, mappings );\n \t\tbindTypeDefs( clazzToProcess, mappings );\n \t\tBinderHelper.bindAnyMetaDefs( clazzToProcess, mappings );\n \n \t\tString schema = \"\";\n \t\tString table = \"\"; //might be no @Table annotation on the annotated class\n \t\tString catalog = \"\";\n \t\tList<UniqueConstraintHolder> uniqueConstraints = new ArrayList<UniqueConstraintHolder>();\n \t\tif ( clazzToProcess.isAnnotationPresent( javax.persistence.Table.class ) ) {\n \t\t\tjavax.persistence.Table tabAnn = clazzToProcess.getAnnotation( javax.persistence.Table.class );\n \t\t\ttable = tabAnn.name();\n \t\t\tschema = tabAnn.schema();\n \t\t\tcatalog = tabAnn.catalog();\n \t\t\tuniqueConstraints = TableBinder.buildUniqueConstraintHolders( tabAnn.uniqueConstraints() );\n \t\t}\n \n \t\tEjb3JoinColumn[] inheritanceJoinedColumns = makeInheritanceJoinColumns( clazzToProcess, mappings, inheritanceState, superEntity );\n \t\tEjb3DiscriminatorColumn discriminatorColumn = null;\n \t\tString discrimValue = null;\n \t\tif ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.getType() ) ) {\n \t\t\tjavax.persistence.DiscriminatorColumn discAnn = clazzToProcess.getAnnotation(\n \t\t\t\t\tjavax.persistence.DiscriminatorColumn.class\n \t\t\t);\n \t\t\tDiscriminatorType discriminatorType = discAnn != null ?\n \t\t\t\t\tdiscAnn.discriminatorType() :\n \t\t\t\t\tDiscriminatorType.STRING;\n \n \t\t\torg.hibernate.annotations.DiscriminatorFormula discFormulaAnn = clazzToProcess.getAnnotation(\n \t\t\t\t\torg.hibernate.annotations.DiscriminatorFormula.class\n \t\t\t);\n \t\t\tif ( !inheritanceState.hasParents() ) {\n \t\t\t\tdiscriminatorColumn = Ejb3DiscriminatorColumn.buildDiscriminatorColumn(\n \t\t\t\t\t\tdiscriminatorType, discAnn, discFormulaAnn, mappings\n \t\t\t\t);\n \t\t\t}\n \t\t\tif ( discAnn != null && inheritanceState.hasParents() ) {\n \t\t\t\tlog.warn(\n \t\t\t\t\t\t\"Discriminator column has to be defined in the root entity, it will be ignored in subclass: {}\",\n \t\t\t\t\t\tclazzToProcess.getName()\n \t\t\t\t);\n \t\t\t}\n \n \t\t\tdiscrimValue = clazzToProcess.isAnnotationPresent( DiscriminatorValue.class ) ?\n \t\t\t\t\tclazzToProcess.getAnnotation( DiscriminatorValue.class ).value() :\n \t\t\t\t\tnull;\n \t\t}\n \n \t\tPersistentClass persistentClass = makePersistentClass( inheritanceState, superEntity );\n \n \t\tProxy proxyAnn = clazzToProcess.getAnnotation( Proxy.class );\n \t\tBatchSize sizeAnn = clazzToProcess.getAnnotation( BatchSize.class );\n \t\tWhere whereAnn = clazzToProcess.getAnnotation( Where.class );\n \t\tEntity entityAnn = clazzToProcess.getAnnotation( Entity.class );\n \t\torg.hibernate.annotations.Entity hibEntityAnn = clazzToProcess.getAnnotation(\n \t\t\t\torg.hibernate.annotations.Entity.class\n \t\t);\n-\t\torg.hibernate.annotations.Cache cacheAnn = clazzToProcess.getAnnotation(\n-\t\t\t\torg.hibernate.annotations.Cache.class\n-\t\t);\n+\n+\t\tCache cacheAnn = determineCacheSettings( clazzToProcess, mappings );\n+\n \t\tEntityBinder entityBinder = new EntityBinder(\n \t\t\t\tentityAnn, hibEntityAnn, clazzToProcess, persistentClass, mappings\n \t\t);\n \t\tentityBinder.setDiscriminatorValue( discrimValue );\n \t\tentityBinder.setBatchSize( sizeAnn );\n \t\tentityBinder.setProxy( proxyAnn );\n \t\tentityBinder.setWhere( whereAnn );\n \t\tentityBinder.setCache( cacheAnn );\n \t\tentityBinder.setInheritanceState( inheritanceState );\n \n \t\t//Filters are not allowed on subclasses\n \t\tif ( !inheritanceState.hasParents() ) {\n \t\t\tbindFilters(clazzToProcess, entityBinder, mappings);\n \t\t}\n \n \t\tentityBinder.bindEntity();\n \n \t\tif ( inheritanceState.hasTable() ) {\n \t\t\tCheck checkAnn = clazzToProcess.getAnnotation( Check.class );\n \t\t\tString constraints = checkAnn == null ?\n \t\t\t\t\tnull :\n \t\t\t\t\tcheckAnn.constraints();\n \t\t\tentityBinder.bindTable(\n \t\t\t\t\tschema, catalog, table, uniqueConstraints,\n \t\t\t\t\tconstraints, inheritanceState.hasDenormalizedTable() ?\n \t\t\t\t\tsuperEntity.getTable() :\n \t\t\t\t\tnull\n \t\t\t);\n \t\t}\n \t\telse {\n \t\t\tif ( clazzToProcess.isAnnotationPresent( Table.class ) ) {\n \t\t\t\tlog.warn( \"Illegal use of @Table in a subclass of a SINGLE_TABLE hierarchy: \" + clazzToProcess\n \t\t\t\t\t\t.getName() );\n \t\t\t}\n \t\t}\n \n \t\tPropertyHolder propertyHolder = PropertyHolderBuilder.buildPropertyHolder(\n \t\t\t\tclazzToProcess,\n \t\t\t\tpersistentClass,\n \t\t\t\tentityBinder, mappings, inheritanceStatePerClass\n \t\t);\n \n \t\tjavax.persistence.SecondaryTable secTabAnn = clazzToProcess.getAnnotation(\n \t\t\t\tjavax.persistence.SecondaryTable.class\n \t\t);\n \t\tjavax.persistence.SecondaryTables secTabsAnn = clazzToProcess.getAnnotation(\n \t\t\t\tjavax.persistence.SecondaryTables.class\n \t\t);\n \t\tentityBinder.firstLevelSecondaryTablesBinding( secTabAnn, secTabsAnn );\n \n \t\tOnDelete onDeleteAnn = clazzToProcess.getAnnotation( OnDelete.class );\n \t\tboolean onDeleteAppropriate = false;\n \t\tif ( InheritanceType.JOINED.equals( inheritanceState.getType() ) && inheritanceState.hasParents() ) {\n \t\t\tonDeleteAppropriate = true;\n \t\t\tfinal JoinedSubclass jsc = (JoinedSubclass) persistentClass;\n \t\t\tif ( persistentClass.getEntityPersisterClass() == null ) {\n \t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( JoinedSubclassEntityPersister.class );\n \t\t\t}\n \t\t\tSimpleValue key = new DependantValue( jsc.getTable(), jsc.getIdentifier() );\n \t\t\tjsc.setKey( key );\n \t\t\tForeignKey fk = clazzToProcess.getAnnotation( ForeignKey.class );\n \t\t\tif ( fk != null && !BinderHelper.isDefault( fk.name() ) ) {\n \t\t\t\tkey.setForeignKeyName( fk.name() );\n \t\t\t}\n \t\t\tif ( onDeleteAnn != null ) {\n \t\t\t\tkey.setCascadeDeleteEnabled( OnDeleteAction.CASCADE.equals( onDeleteAnn.action() ) );\n \t\t\t}\n \t\t\telse {\n \t\t\t\tkey.setCascadeDeleteEnabled( false );\n \t\t\t}\n \t\t\t//we are never in a second pass at that stage, so queue it\n \t\t\tSecondPass sp = new JoinedSubclassFkSecondPass( jsc, inheritanceJoinedColumns, key, mappings );\n \t\t\tmappings.addSecondPass( sp );\n \t\t\tmappings.addSecondPass( new CreateKeySecondPass( jsc ) );\n \n \t\t}\n \t\telse if ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.getType() ) ) {\n \t\t\tif ( inheritanceState.hasParents() ) {\n \t\t\t\tif ( persistentClass.getEntityPersisterClass() == null ) {\n \t\t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( SingleTableEntityPersister.class );\n \t\t\t\t}\n \t\t\t}\n \t\t\telse {\n \t\t\t\tif ( inheritanceState.hasSiblings() || !discriminatorColumn.isImplicit() ) {\n \t\t\t\t\t//need a discriminator column\n \t\t\t\t\tbindDiscriminatorToPersistentClass(\n \t\t\t\t\t\t\t(RootClass) persistentClass,\n \t\t\t\t\t\t\tdiscriminatorColumn,\n \t\t\t\t\t\t\tentityBinder.getSecondaryTables(),\n \t\t\t\t\t\t\tpropertyHolder\n \t\t\t\t\t);\n \t\t\t\t\tentityBinder.bindDiscriminatorValue();//bind it again since the type might have changed\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\telse if ( InheritanceType.TABLE_PER_CLASS.equals( inheritanceState.getType() ) ) {\n \t\t\tif ( inheritanceState.hasParents() ) {\n \t\t\t\tif ( persistentClass.getEntityPersisterClass() == null ) {\n \t\t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( UnionSubclassEntityPersister.class );\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\tif ( onDeleteAnn != null && !onDeleteAppropriate ) {\n \t\t\tlog.warn(\n \t\t\t\t\t\"Inapropriate use of @OnDelete on entity, annotation ignored: {}\", propertyHolder.getEntityName()\n \t\t\t);\n \t\t}\n \n \t\t// try to find class level generators\n \t\tHashMap<String, IdGenerator> classGenerators = buildLocalGenerators( clazzToProcess, mappings );\n \n \t\t// check properties\n \t\tList<PropertyData> elements =\n \t\t\t\tgetElementsToProcess(\n \t\t\t\t\t\tpersistentClass, clazzToProcess, inheritanceStatePerClass, entityBinder, mappings\n \t\t\t\t);\n \t\tfinal boolean subclassAndSingleTableStrategy = inheritanceState.getType() == InheritanceType.SINGLE_TABLE\n \t\t\t\t&& inheritanceState.hasParents();\n \t\t//process idclass if any\n \t\tSet<String> idProperties = new HashSet<String>();\n \t\tIdClass idClass = null;\n \t\tXClass current = null;\n \t\tif ( !inheritanceState.hasParents() ) {\n \t\t\t//look for idClass\n \t\t\tInheritanceState state = inheritanceState;\n \t\t\tdo {\n \t\t\t\tcurrent = state.getClazz();\n \t\t\t\tif ( current.isAnnotationPresent( IdClass.class ) ) {\n \t\t\t\t\tidClass = current.getAnnotation( IdClass.class );\n \t\t\t\t\tbreak;\n \t\t\t\t}\n \t\t\t\tstate = InheritanceState.getSuperclassInheritanceState( current, inheritanceStatePerClass );\n \t\t\t}\n \t\t\twhile ( state != null );\n \t\t}\n \t\tif ( idClass != null ) {\n \t\t\tXClass compositeClass = mappings.getReflectionManager().toXClass( idClass.value() );\n \t\t\tboolean isComponent = true;\n \t\t\tAccessType propertyAccessor = entityBinder.getPropertyAccessor( compositeClass );\n \t\t\tString generatorType = \"assigned\";\n \t\t\tString generator = BinderHelper.ANNOTATION_STRING_DEFAULT;\n \t\t\tPropertyData inferredData = new PropertyPreloadedData(\n \t\t\t\t\tentityBinder.getPropertyAccessType(), \"id\", compositeClass\n \t\t\t);\n \t\t\tPropertyData baseInferredData = new PropertyPreloadedData(\n                   entityBinder.getPropertyAccessType(), \"id\", current\n             );\n \t\t\tHashMap<String, IdGenerator> localGenerators = new HashMap<String, IdGenerator>();\n \t\t\tboolean ignoreIdAnnotations = entityBinder.isIgnoreIdAnnotations();\n \t\t\tentityBinder.setIgnoreIdAnnotations( true );\n \t\t\tbindId(\n \t\t\t\t\tgeneratorType,\n \t\t\t\t\tgenerator,\n \t\t\t\t\tinferredData,\n \t\t\t\t\tbaseInferredData,\n \t\t\t\t\tnull,\n \t\t\t\t\tpropertyHolder,\n \t\t\t\t\tlocalGenerators,\n \t\t\t\t\tisComponent,\n \t\t\t\t\tpropertyAccessor, entityBinder,\n \t\t\t\t\ttrue,\n \t\t\t\t\tfalse, mappings, inheritanceStatePerClass\n \t\t\t);\n \t\t\tinferredData = new PropertyPreloadedData(\n \t\t\t\t\tpropertyAccessor, \"_identifierMapper\", compositeClass\n \t\t\t);\n \t\t\tComponent mapper = fillComponent(\n \t\t\t\t\tpropertyHolder,\n \t\t\t\t\tinferredData,\n \t\t\t\t\tbaseInferredData,\n \t\t\t\t\tpropertyAccessor, false,\n \t\t\t\t\tentityBinder,\n \t\t\t\t\ttrue, true,\n \t\t\t\t\tfalse, mappings, inheritanceStatePerClass\n \t\t\t);\n \t\t\tentityBinder.setIgnoreIdAnnotations( ignoreIdAnnotations );\n \t\t\tpersistentClass.setIdentifierMapper( mapper );\n \n \t\t\t//If id definition is on a mapped superclass, update the mapping\n \t\t\tfinal org.hibernate.mapping.MappedSuperclass superclass = BinderHelper.getMappedSuperclassOrNull(\n \t\t\t\t\tinferredData.getDeclaringClass(),\n \t\t\t\t\tinheritanceStatePerClass,\n \t\t\t\t\tmappings\n \t\t\t);\n \t\t\tif (superclass != null) {\n \t\t\t\tsuperclass.setDeclaredIdentifierMapper(mapper);\n \t\t\t}\n \t\t\telse {\n \t\t\t\t//we are for sure on the entity\n \t\t\t\tpersistentClass.setDeclaredIdentifierMapper( mapper );\n \t\t\t}\n \n \t\t\tProperty property = new Property();\n \t\t\tproperty.setName( \"_identifierMapper\" );\n \t\t\tproperty.setNodeName( \"id\" );\n \t\t\tproperty.setUpdateable( false );\n \t\t\tproperty.setInsertable( false );\n \t\t\tproperty.setValue( mapper );\n \t\t\tproperty.setPropertyAccessorName( \"embedded\" );\n \t\t\tpersistentClass.addProperty( property );\n \t\t\tentityBinder.setIgnoreIdAnnotations( true );\n \n \t\t\tIterator properties = mapper.getPropertyIterator();\n \t\t\twhile ( properties.hasNext() ) {\n \t\t\t\tidProperties.add( ( (Property) properties.next() ).getName() );\n \t\t\t}\n \t\t}\n \t\tSet<String> missingIdProperties = new HashSet<String>( idProperties );\n \t\tfor (PropertyData propertyAnnotatedElement : elements) {\n \t\t\tString propertyName = propertyAnnotatedElement.getPropertyName();\n \t\t\tif ( !idProperties.contains( propertyName ) ) {\n \t\t\t\tprocessElementAnnotations(\n \t\t\t\t\t\tpropertyHolder,\n \t\t\t\t\t\tsubclassAndSingleTableStrategy ?\n \t\t\t\t\t\t\t\tNullability.FORCED_NULL :\n \t\t\t\t\t\t\t\tNullability.NO_CONSTRAINT,\n \t\t\t\t\t\tpropertyAnnotatedElement.getProperty(),\n \t\t\t\t\t\tpropertyAnnotatedElement, classGenerators, entityBinder,\n \t\t\t\t\t\tfalse, false, false, mappings, inheritanceStatePerClass\n \t\t\t\t);\n \t\t\t}\n \t\t\telse {\n \t\t\t\tmissingIdProperties.remove( propertyName );\n \t\t\t}\n \t\t}\n \n \t\tif ( missingIdProperties.size() != 0 ) {\n \t\t\tStringBuilder missings = new StringBuilder();\n \t\t\tfor (String property : missingIdProperties) {\n \t\t\t\tmissings.append( property ).append( \", \" );\n \t\t\t}\n \t\t\tthrow new AnnotationException(\n \t\t\t\t\t\"Unable to find properties (\"\n \t\t\t\t\t\t\t+ missings.substring( 0, missings.length() - 2 )\n \t\t\t\t\t\t\t+ \") in entity annotated with @IdClass:\" + persistentClass.getEntityName()\n \t\t\t);\n \t\t}\n \n \t\tif ( !inheritanceState.hasParents() ) {\n \t\t\tfinal RootClass rootClass = (RootClass) persistentClass;\n \t\t\tmappings.addSecondPass( new CreateKeySecondPass( rootClass ) );\n \t\t}\n \t\telse {\n \t\t\tsuperEntity.addSubclass( (Subclass) persistentClass );\n \t\t}\n \n \t\tmappings.addClass( persistentClass );\n \n \t\t//Process secondary tables and complementary definitions (ie o.h.a.Table)\n \t\tmappings.addSecondPass( new SecondaryTableSecondPass( entityBinder, propertyHolder, clazzToProcess ) );\n \n \t\t//add process complementary Table definition (index & all)\n \t\tentityBinder.processComplementaryTableDefinitions( clazzToProcess.getAnnotation( org.hibernate.annotations.Table.class ) );\n \t\tentityBinder.processComplementaryTableDefinitions( clazzToProcess.getAnnotation( org.hibernate.annotations.Tables.class ) );\n \n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"2dd470af1f453e54643d55b2c81ec5a7324952b1": {
			"type": "Ybodychange",
			"commitMessage": " HHH-4527 - added handling of proper default access propagation for class hierarchies and embedded classes (components)\n\ngit-svn-id: https://svn.jboss.org/repos/hibernate/core/trunk@18417 1b8cb986-b30d-0410-93ca-fae66ebed9b2\n",
			"commitDate": "2010-01-05, 1:51 PM",
			"commitName": "2dd470af1f453e54643d55b2c81ec5a7324952b1",
			"commitAuthor": "Hardy Ferentschik",
			"commitDateOld": "2010-01-04, 10:50 AM",
			"commitNameOld": "43dd13073d76e3ad1388f280aeff6f078f8db79f",
			"commitAuthorOld": "Emmanuel Bernard",
			"daysBetweenCommits": 1.13,
			"commitsBetweenForRepo": 12,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,343 +1,338 @@\n \tpublic static void bindClass(\n \t\t\tXClass clazzToProcess, Map<XClass, InheritanceState> inheritanceStatePerClass, ExtendedMappings mappings\n \t) throws MappingException {\n \t\t//TODO: be more strict with secondarytable allowance (not for ids, not for secondary table join columns etc)\n \t\tInheritanceState inheritanceState = inheritanceStatePerClass.get( clazzToProcess );\n \t\tAnnotatedClassType classType = mappings.getClassType( clazzToProcess );\n \n \t\t//Queries declared in MappedSuperclass should be usable in Subclasses\n \t\tif ( AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals( classType ) ) {\n \t\t\tbindQueries( clazzToProcess, mappings );\n \t\t\tbindTypeDefs(clazzToProcess, mappings);\n \t\t\tbindFilterDefs(clazzToProcess, mappings);\n \t\t}\n \n \t\tif( !isEntityClassType( clazzToProcess, classType ) ) {\n \t\t\treturn;\n \t\t}\n \n \t\tlog.info( \"Binding entity from annotated class: {}\", clazzToProcess.getName() );\n \n \t\tPersistentClass superEntity = getSuperEntity(clazzToProcess, inheritanceStatePerClass, mappings, inheritanceState);\n \n \t\tbindQueries( clazzToProcess, mappings );\n \t\tbindFilterDefs( clazzToProcess, mappings );\n \t\tbindTypeDefs( clazzToProcess, mappings );\n \t\tBinderHelper.bindAnyMetaDefs( clazzToProcess, mappings );\n \n \t\tString schema = \"\";\n \t\tString table = \"\"; //might be no @Table annotation on the annotated class\n \t\tString catalog = \"\";\n \t\tList<UniqueConstraintHolder> uniqueConstraints = new ArrayList<UniqueConstraintHolder>();\n \t\tif ( clazzToProcess.isAnnotationPresent( javax.persistence.Table.class ) ) {\n \t\t\tjavax.persistence.Table tabAnn = clazzToProcess.getAnnotation( javax.persistence.Table.class );\n \t\t\ttable = tabAnn.name();\n \t\t\tschema = tabAnn.schema();\n \t\t\tcatalog = tabAnn.catalog();\n \t\t\tuniqueConstraints = TableBinder.buildUniqueConstraintHolders( tabAnn.uniqueConstraints() );\n \t\t}\n \n \t\tEjb3JoinColumn[] inheritanceJoinedColumns = makeInheritanceJoinColumns( clazzToProcess, mappings, inheritanceState, superEntity );\n \t\tEjb3DiscriminatorColumn discriminatorColumn = null;\n \t\tString discrimValue = null;\n \t\tif ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.getType() ) ) {\n \t\t\tjavax.persistence.DiscriminatorColumn discAnn = clazzToProcess.getAnnotation(\n \t\t\t\t\tjavax.persistence.DiscriminatorColumn.class\n \t\t\t);\n \t\t\tDiscriminatorType discriminatorType = discAnn != null ?\n \t\t\t\t\tdiscAnn.discriminatorType() :\n \t\t\t\t\tDiscriminatorType.STRING;\n \n \t\t\torg.hibernate.annotations.DiscriminatorFormula discFormulaAnn = clazzToProcess.getAnnotation(\n \t\t\t\t\torg.hibernate.annotations.DiscriminatorFormula.class\n \t\t\t);\n \t\t\tif ( !inheritanceState.hasParents() ) {\n \t\t\t\tdiscriminatorColumn = Ejb3DiscriminatorColumn.buildDiscriminatorColumn(\n \t\t\t\t\t\tdiscriminatorType, discAnn, discFormulaAnn, mappings\n \t\t\t\t);\n \t\t\t}\n \t\t\tif ( discAnn != null && inheritanceState.hasParents() ) {\n \t\t\t\tlog.warn(\n \t\t\t\t\t\t\"Discriminator column has to be defined in the root entity, it will be ignored in subclass: {}\",\n \t\t\t\t\t\tclazzToProcess.getName()\n \t\t\t\t);\n \t\t\t}\n \n \t\t\tdiscrimValue = clazzToProcess.isAnnotationPresent( DiscriminatorValue.class ) ?\n \t\t\t\t\tclazzToProcess.getAnnotation( DiscriminatorValue.class ).value() :\n \t\t\t\t\tnull;\n \t\t}\n \n \t\tPersistentClass persistentClass = makePersistentClass( inheritanceState, superEntity );\n \n \t\tProxy proxyAnn = clazzToProcess.getAnnotation( Proxy.class );\n \t\tBatchSize sizeAnn = clazzToProcess.getAnnotation( BatchSize.class );\n \t\tWhere whereAnn = clazzToProcess.getAnnotation( Where.class );\n \t\tEntity entityAnn = clazzToProcess.getAnnotation( Entity.class );\n \t\torg.hibernate.annotations.Entity hibEntityAnn = clazzToProcess.getAnnotation(\n \t\t\t\torg.hibernate.annotations.Entity.class\n \t\t);\n \t\torg.hibernate.annotations.Cache cacheAnn = clazzToProcess.getAnnotation(\n \t\t\t\torg.hibernate.annotations.Cache.class\n \t\t);\n \t\tEntityBinder entityBinder = new EntityBinder(\n \t\t\t\tentityAnn, hibEntityAnn, clazzToProcess, persistentClass, mappings\n \t\t);\n \t\tentityBinder.setDiscriminatorValue( discrimValue );\n \t\tentityBinder.setBatchSize( sizeAnn );\n \t\tentityBinder.setProxy( proxyAnn );\n \t\tentityBinder.setWhere( whereAnn );\n \t\tentityBinder.setCache( cacheAnn );\n \t\tentityBinder.setInheritanceState( inheritanceState );\n \n \t\t//Filters are not allowed on subclasses\n \t\tif ( !inheritanceState.hasParents() ) {\n \t\t\tbindFilters(clazzToProcess, entityBinder, mappings);\n \t\t}\n \n \t\tentityBinder.bindEntity();\n \n \t\tif ( inheritanceState.hasTable() ) {\n \t\t\tCheck checkAnn = clazzToProcess.getAnnotation( Check.class );\n \t\t\tString constraints = checkAnn == null ?\n \t\t\t\t\tnull :\n \t\t\t\t\tcheckAnn.constraints();\n \t\t\tentityBinder.bindTable(\n \t\t\t\t\tschema, catalog, table, uniqueConstraints,\n \t\t\t\t\tconstraints, inheritanceState.hasDenormalizedTable() ?\n \t\t\t\t\tsuperEntity.getTable() :\n \t\t\t\t\tnull\n \t\t\t);\n \t\t}\n \t\telse {\n \t\t\tif ( clazzToProcess.isAnnotationPresent( Table.class ) ) {\n \t\t\t\tlog.warn( \"Illegal use of @Table in a subclass of a SINGLE_TABLE hierarchy: \" + clazzToProcess\n \t\t\t\t\t\t.getName() );\n \t\t\t}\n \t\t}\n \n \t\tPropertyHolder propertyHolder = PropertyHolderBuilder.buildPropertyHolder(\n \t\t\t\tclazzToProcess,\n \t\t\t\tpersistentClass,\n \t\t\t\tentityBinder, mappings, inheritanceStatePerClass\n \t\t);\n \n \t\tjavax.persistence.SecondaryTable secTabAnn = clazzToProcess.getAnnotation(\n \t\t\t\tjavax.persistence.SecondaryTable.class\n \t\t);\n \t\tjavax.persistence.SecondaryTables secTabsAnn = clazzToProcess.getAnnotation(\n \t\t\t\tjavax.persistence.SecondaryTables.class\n \t\t);\n \t\tentityBinder.firstLevelSecondaryTablesBinding( secTabAnn, secTabsAnn );\n \n \t\tOnDelete onDeleteAnn = clazzToProcess.getAnnotation( OnDelete.class );\n \t\tboolean onDeleteAppropriate = false;\n \t\tif ( InheritanceType.JOINED.equals( inheritanceState.getType() ) && inheritanceState.hasParents() ) {\n \t\t\tonDeleteAppropriate = true;\n \t\t\tfinal JoinedSubclass jsc = (JoinedSubclass) persistentClass;\n \t\t\tif ( persistentClass.getEntityPersisterClass() == null ) {\n \t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( JoinedSubclassEntityPersister.class );\n \t\t\t}\n \t\t\tSimpleValue key = new DependantValue( jsc.getTable(), jsc.getIdentifier() );\n \t\t\tjsc.setKey( key );\n \t\t\tForeignKey fk = clazzToProcess.getAnnotation( ForeignKey.class );\n \t\t\tif ( fk != null && !BinderHelper.isDefault( fk.name() ) ) {\n \t\t\t\tkey.setForeignKeyName( fk.name() );\n \t\t\t}\n \t\t\tif ( onDeleteAnn != null ) {\n \t\t\t\tkey.setCascadeDeleteEnabled( OnDeleteAction.CASCADE.equals( onDeleteAnn.action() ) );\n \t\t\t}\n \t\t\telse {\n \t\t\t\tkey.setCascadeDeleteEnabled( false );\n \t\t\t}\n \t\t\t//we are never in a second pass at that stage, so queue it\n \t\t\tSecondPass sp = new JoinedSubclassFkSecondPass( jsc, inheritanceJoinedColumns, key, mappings );\n \t\t\tmappings.addSecondPass( sp );\n \t\t\tmappings.addSecondPass( new CreateKeySecondPass( jsc ) );\n \n \t\t}\n \t\telse if ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.getType() ) ) {\n \t\t\tif ( inheritanceState.hasParents() ) {\n \t\t\t\tif ( persistentClass.getEntityPersisterClass() == null ) {\n \t\t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( SingleTableEntityPersister.class );\n \t\t\t\t}\n \t\t\t}\n \t\t\telse {\n \t\t\t\tif ( inheritanceState.hasSiblings() || !discriminatorColumn.isImplicit() ) {\n \t\t\t\t\t//need a discriminator column\n \t\t\t\t\tbindDiscriminatorToPersistentClass(\n \t\t\t\t\t\t\t(RootClass) persistentClass,\n \t\t\t\t\t\t\tdiscriminatorColumn,\n \t\t\t\t\t\t\tentityBinder.getSecondaryTables(),\n \t\t\t\t\t\t\tpropertyHolder\n \t\t\t\t\t);\n \t\t\t\t\tentityBinder.bindDiscriminatorValue();//bind it again since the type might have changed\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\telse if ( InheritanceType.TABLE_PER_CLASS.equals( inheritanceState.getType() ) ) {\n \t\t\tif ( inheritanceState.hasParents() ) {\n \t\t\t\tif ( persistentClass.getEntityPersisterClass() == null ) {\n \t\t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( UnionSubclassEntityPersister.class );\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\tif ( onDeleteAnn != null && !onDeleteAppropriate ) {\n \t\t\tlog.warn(\n \t\t\t\t\t\"Inapropriate use of @OnDelete on entity, annotation ignored: {}\", propertyHolder.getEntityName()\n \t\t\t);\n \t\t}\n \n-\t\t//try to find class level generators\n+\t\t// try to find class level generators\n \t\tHashMap<String, IdGenerator> classGenerators = buildLocalGenerators( clazzToProcess, mappings );\n \n \t\t// check properties\n \t\tList<PropertyData> elements =\n \t\t\t\tgetElementsToProcess(\n \t\t\t\t\t\tpersistentClass, clazzToProcess, inheritanceStatePerClass, entityBinder, mappings\n \t\t\t\t);\n-\t\tif ( elements == null ) {\n-\t\t\tthrow new AnnotationException( \"No identifier specified for entity: \" + propertyHolder.getEntityName() );\n-\t\t}\n \t\tfinal boolean subclassAndSingleTableStrategy = inheritanceState.getType() == InheritanceType.SINGLE_TABLE\n \t\t\t\t&& inheritanceState.hasParents();\n \t\t//process idclass if any\n \t\tSet<String> idProperties = new HashSet<String>();\n \t\tIdClass idClass = null;\n \t\tXClass current = null;\n \t\tif ( !inheritanceState.hasParents() ) {\n \t\t\t//look for idClass\n \t\t\tInheritanceState state = inheritanceState;\n \t\t\tdo {\n \t\t\t\tcurrent = state.getClazz();\n \t\t\t\tif ( current.isAnnotationPresent( IdClass.class ) ) {\n \t\t\t\t\tidClass = current.getAnnotation( IdClass.class );\n \t\t\t\t\tbreak;\n \t\t\t\t}\n-\t\t\t\tstate = InheritanceState.getSuperclassInheritanceState(\n-\t\t\t\t\t\tcurrent, inheritanceStatePerClass, mappings.getReflectionManager()\n-\t\t\t\t);\n+\t\t\t\tstate = InheritanceState.getSuperclassInheritanceState( current, inheritanceStatePerClass );\n \t\t\t}\n \t\t\twhile ( state != null );\n \t\t}\n \t\tif ( idClass != null ) {\n \t\t\tXClass compositeClass = mappings.getReflectionManager().toXClass( idClass.value() );\n \t\t\tboolean isComponent = true;\n \t\t\tAccessType propertyAccessor = entityBinder.getPropertyAccessor( compositeClass );\n \t\t\tString generatorType = \"assigned\";\n \t\t\tString generator = BinderHelper.ANNOTATION_STRING_DEFAULT;\n \t\t\tPropertyData inferredData = new PropertyPreloadedData(\n-\t\t\t\t\tentityBinder.getPropertyAccessor(), \"id\", compositeClass\n+\t\t\t\t\tentityBinder.getPropertyAccessType(), \"id\", compositeClass\n \t\t\t);\n \t\t\tPropertyData baseInferredData = new PropertyPreloadedData(\n-                  entityBinder.getPropertyAccessor(), \"id\", current\n+                  entityBinder.getPropertyAccessType(), \"id\", current\n             );\n \t\t\tHashMap<String, IdGenerator> localGenerators = new HashMap<String, IdGenerator>();\n \t\t\tboolean ignoreIdAnnotations = entityBinder.isIgnoreIdAnnotations();\n \t\t\tentityBinder.setIgnoreIdAnnotations( true );\n \t\t\tbindId(\n \t\t\t\t\tgeneratorType,\n \t\t\t\t\tgenerator,\n \t\t\t\t\tinferredData,\n \t\t\t\t\tbaseInferredData,\n \t\t\t\t\tnull,\n \t\t\t\t\tpropertyHolder,\n \t\t\t\t\tlocalGenerators,\n \t\t\t\t\tisComponent,\n \t\t\t\t\tpropertyAccessor, entityBinder,\n \t\t\t\t\ttrue,\n \t\t\t\t\tfalse, mappings, inheritanceStatePerClass\n \t\t\t);\n \t\t\tinferredData = new PropertyPreloadedData(\n \t\t\t\t\tpropertyAccessor, \"_identifierMapper\", compositeClass\n \t\t\t);\n \t\t\tComponent mapper = fillComponent(\n \t\t\t\t\tpropertyHolder,\n \t\t\t\t\tinferredData,\n \t\t\t\t\tbaseInferredData,\n \t\t\t\t\tpropertyAccessor, false,\n \t\t\t\t\tentityBinder,\n \t\t\t\t\ttrue, true,\n \t\t\t\t\tfalse, mappings, inheritanceStatePerClass\n \t\t\t);\n \t\t\tentityBinder.setIgnoreIdAnnotations( ignoreIdAnnotations );\n \t\t\tpersistentClass.setIdentifierMapper( mapper );\n \n \t\t\t//If id definition is on a mapped superclass, update the mapping\n \t\t\tfinal org.hibernate.mapping.MappedSuperclass superclass = BinderHelper.getMappedSuperclassOrNull(\n \t\t\t\t\tinferredData.getDeclaringClass(),\n \t\t\t\t\tinheritanceStatePerClass,\n \t\t\t\t\tmappings\n \t\t\t);\n \t\t\tif (superclass != null) {\n \t\t\t\tsuperclass.setDeclaredIdentifierMapper(mapper);\n \t\t\t}\n \t\t\telse {\n \t\t\t\t//we are for sure on the entity\n \t\t\t\tpersistentClass.setDeclaredIdentifierMapper( mapper );\n \t\t\t}\n \n \t\t\tProperty property = new Property();\n \t\t\tproperty.setName( \"_identifierMapper\" );\n \t\t\tproperty.setNodeName( \"id\" );\n \t\t\tproperty.setUpdateable( false );\n \t\t\tproperty.setInsertable( false );\n \t\t\tproperty.setValue( mapper );\n \t\t\tproperty.setPropertyAccessorName( \"embedded\" );\n \t\t\tpersistentClass.addProperty( property );\n \t\t\tentityBinder.setIgnoreIdAnnotations( true );\n \n \t\t\tIterator properties = mapper.getPropertyIterator();\n \t\t\twhile ( properties.hasNext() ) {\n \t\t\t\tidProperties.add( ( (Property) properties.next() ).getName() );\n \t\t\t}\n \t\t}\n \t\tSet<String> missingIdProperties = new HashSet<String>( idProperties );\n \t\tfor (PropertyData propertyAnnotatedElement : elements) {\n \t\t\tString propertyName = propertyAnnotatedElement.getPropertyName();\n \t\t\tif ( !idProperties.contains( propertyName ) ) {\n \t\t\t\tprocessElementAnnotations(\n \t\t\t\t\t\tpropertyHolder,\n \t\t\t\t\t\tsubclassAndSingleTableStrategy ?\n \t\t\t\t\t\t\t\tNullability.FORCED_NULL :\n \t\t\t\t\t\t\t\tNullability.NO_CONSTRAINT,\n \t\t\t\t\t\tpropertyAnnotatedElement.getProperty(),\n \t\t\t\t\t\tpropertyAnnotatedElement, classGenerators, entityBinder,\n \t\t\t\t\t\tfalse, false, false, mappings, inheritanceStatePerClass\n \t\t\t\t);\n \t\t\t}\n \t\t\telse {\n \t\t\t\tmissingIdProperties.remove( propertyName );\n \t\t\t}\n \t\t}\n \n \t\tif ( missingIdProperties.size() != 0 ) {\n \t\t\tStringBuilder missings = new StringBuilder();\n \t\t\tfor (String property : missingIdProperties) {\n \t\t\t\tmissings.append( property ).append( \", \" );\n \t\t\t}\n \t\t\tthrow new AnnotationException(\n \t\t\t\t\t\"Unable to find properties (\"\n \t\t\t\t\t\t\t+ missings.substring( 0, missings.length() - 2 )\n \t\t\t\t\t\t\t+ \") in entity annotated with @IdClass:\" + persistentClass.getEntityName()\n \t\t\t);\n \t\t}\n \n \t\tif ( !inheritanceState.hasParents() ) {\n \t\t\tfinal RootClass rootClass = (RootClass) persistentClass;\n \t\t\tmappings.addSecondPass( new CreateKeySecondPass( rootClass ) );\n \t\t}\n \t\telse {\n \t\t\tsuperEntity.addSubclass( (Subclass) persistentClass );\n \t\t}\n \n \t\tmappings.addClass( persistentClass );\n \n \t\t//Process secondary tables and complementary definitions (ie o.h.a.Table)\n \t\tmappings.addSecondPass( new SecondaryTableSecondPass( entityBinder, propertyHolder, clazzToProcess ) );\n \n \t\t//add process complementary Table definition (index & all)\n \t\tentityBinder.processComplementaryTableDefinitions( clazzToProcess.getAnnotation( org.hibernate.annotations.Table.class ) );\n \t\tentityBinder.processComplementaryTableDefinitions( clazzToProcess.getAnnotation( org.hibernate.annotations.Tables.class ) );\n \n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"4a9d8dcf0b054d4dc769b463145c1fdecede6e09": {
			"type": "Ybodychange",
			"commitMessage": " HHH-4527 - first cut for supporting JPA2 @Access annotation. Not quite complete and needs some more tests.\n\ngit-svn-id: https://svn.jboss.org/repos/hibernate/core/trunk@18260 1b8cb986-b30d-0410-93ca-fae66ebed9b2\n",
			"commitDate": "2009-12-17, 1:14 PM",
			"commitName": "4a9d8dcf0b054d4dc769b463145c1fdecede6e09",
			"commitAuthor": "Hardy Ferentschik",
			"commitDateOld": "2009-12-11, 11:14 AM",
			"commitNameOld": "025b3cc14180d0459856bc45a6cac7acce3e1265",
			"commitAuthorOld": "Hardy Ferentschik",
			"daysBetweenCommits": 6.08,
			"commitsBetweenForRepo": 27,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,346 +1,343 @@\n \tpublic static void bindClass(\n \t\t\tXClass clazzToProcess, Map<XClass, InheritanceState> inheritanceStatePerClass, ExtendedMappings mappings\n \t) throws MappingException {\n \t\t//TODO: be more strict with secondarytable allowance (not for ids, not for secondary table join columns etc)\n \t\tInheritanceState inheritanceState = inheritanceStatePerClass.get( clazzToProcess );\n \t\tAnnotatedClassType classType = mappings.getClassType( clazzToProcess );\n \n \t\t//Queries declared in MappedSuperclass should be usable in Subclasses\n \t\tif ( AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals( classType ) ) {\n \t\t\tbindQueries( clazzToProcess, mappings );\n \t\t\tbindTypeDefs(clazzToProcess, mappings);\n \t\t\tbindFilterDefs(clazzToProcess, mappings);\n \t\t}\n \n \t\tif( !isEntityClassType( clazzToProcess, classType ) ) {\n \t\t\treturn;\n \t\t}\n \n \t\tlog.info( \"Binding entity from annotated class: {}\", clazzToProcess.getName() );\n \n \t\tPersistentClass superEntity = getSuperEntity(clazzToProcess, inheritanceStatePerClass, mappings, inheritanceState);\n \n \t\tbindQueries( clazzToProcess, mappings );\n \t\tbindFilterDefs( clazzToProcess, mappings );\n \t\tbindTypeDefs( clazzToProcess, mappings );\n \t\tBinderHelper.bindAnyMetaDefs( clazzToProcess, mappings );\n \n \t\tString schema = \"\";\n \t\tString table = \"\"; //might be no @Table annotation on the annotated class\n \t\tString catalog = \"\";\n \t\tList<UniqueConstraintHolder> uniqueConstraints = new ArrayList<UniqueConstraintHolder>();\n \t\tif ( clazzToProcess.isAnnotationPresent( javax.persistence.Table.class ) ) {\n \t\t\tjavax.persistence.Table tabAnn = clazzToProcess.getAnnotation( javax.persistence.Table.class );\n \t\t\ttable = tabAnn.name();\n \t\t\tschema = tabAnn.schema();\n \t\t\tcatalog = tabAnn.catalog();\n \t\t\tuniqueConstraints = TableBinder.buildUniqueConstraintHolders( tabAnn.uniqueConstraints() );\n \t\t}\n \n \t\tEjb3JoinColumn[] inheritanceJoinedColumns = makeInheritanceJoinColumns( clazzToProcess, mappings, inheritanceState, superEntity );\n \t\tEjb3DiscriminatorColumn discriminatorColumn = null;\n \t\tString discrimValue = null;\n \t\tif ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.getType() ) ) {\n \t\t\tjavax.persistence.DiscriminatorColumn discAnn = clazzToProcess.getAnnotation(\n \t\t\t\t\tjavax.persistence.DiscriminatorColumn.class\n \t\t\t);\n \t\t\tDiscriminatorType discriminatorType = discAnn != null ?\n \t\t\t\t\tdiscAnn.discriminatorType() :\n \t\t\t\t\tDiscriminatorType.STRING;\n \n \t\t\torg.hibernate.annotations.DiscriminatorFormula discFormulaAnn = clazzToProcess.getAnnotation(\n \t\t\t\t\torg.hibernate.annotations.DiscriminatorFormula.class\n \t\t\t);\n \t\t\tif ( !inheritanceState.hasParents() ) {\n \t\t\t\tdiscriminatorColumn = Ejb3DiscriminatorColumn.buildDiscriminatorColumn(\n \t\t\t\t\t\tdiscriminatorType, discAnn, discFormulaAnn, mappings\n \t\t\t\t);\n \t\t\t}\n \t\t\tif ( discAnn != null && inheritanceState.hasParents() ) {\n \t\t\t\tlog.warn(\n \t\t\t\t\t\t\"Discriminator column has to be defined in the root entity, it will be ignored in subclass: {}\",\n \t\t\t\t\t\tclazzToProcess.getName()\n \t\t\t\t);\n \t\t\t}\n \n \t\t\tdiscrimValue = clazzToProcess.isAnnotationPresent( DiscriminatorValue.class ) ?\n \t\t\t\t\tclazzToProcess.getAnnotation( DiscriminatorValue.class ).value() :\n \t\t\t\t\tnull;\n \t\t}\n \n \t\tPersistentClass persistentClass = makePersistentClass( inheritanceState, superEntity );\n \n \t\tProxy proxyAnn = clazzToProcess.getAnnotation( Proxy.class );\n \t\tBatchSize sizeAnn = clazzToProcess.getAnnotation( BatchSize.class );\n \t\tWhere whereAnn = clazzToProcess.getAnnotation( Where.class );\n \t\tEntity entityAnn = clazzToProcess.getAnnotation( Entity.class );\n \t\torg.hibernate.annotations.Entity hibEntityAnn = clazzToProcess.getAnnotation(\n \t\t\t\torg.hibernate.annotations.Entity.class\n \t\t);\n \t\torg.hibernate.annotations.Cache cacheAnn = clazzToProcess.getAnnotation(\n \t\t\t\torg.hibernate.annotations.Cache.class\n \t\t);\n \t\tEntityBinder entityBinder = new EntityBinder(\n \t\t\t\tentityAnn, hibEntityAnn, clazzToProcess, persistentClass, mappings\n \t\t);\n \t\tentityBinder.setDiscriminatorValue( discrimValue );\n \t\tentityBinder.setBatchSize( sizeAnn );\n \t\tentityBinder.setProxy( proxyAnn );\n \t\tentityBinder.setWhere( whereAnn );\n \t\tentityBinder.setCache( cacheAnn );\n \t\tentityBinder.setInheritanceState( inheritanceState );\n-\t\t\n+\n \t\t//Filters are not allowed on subclasses\n \t\tif ( !inheritanceState.hasParents() ) {\n \t\t\tbindFilters(clazzToProcess, entityBinder, mappings);\n \t\t}\n-\t\t\n+\n \t\tentityBinder.bindEntity();\n \n \t\tif ( inheritanceState.hasTable() ) {\n \t\t\tCheck checkAnn = clazzToProcess.getAnnotation( Check.class );\n \t\t\tString constraints = checkAnn == null ?\n \t\t\t\t\tnull :\n \t\t\t\t\tcheckAnn.constraints();\n \t\t\tentityBinder.bindTable(\n \t\t\t\t\tschema, catalog, table, uniqueConstraints,\n \t\t\t\t\tconstraints, inheritanceState.hasDenormalizedTable() ?\n \t\t\t\t\tsuperEntity.getTable() :\n \t\t\t\t\tnull\n \t\t\t);\n \t\t}\n \t\telse {\n \t\t\tif ( clazzToProcess.isAnnotationPresent( Table.class ) ) {\n \t\t\t\tlog.warn( \"Illegal use of @Table in a subclass of a SINGLE_TABLE hierarchy: \" + clazzToProcess\n \t\t\t\t\t\t.getName() );\n \t\t\t}\n \t\t}\n \n \t\tPropertyHolder propertyHolder = PropertyHolderBuilder.buildPropertyHolder(\n \t\t\t\tclazzToProcess,\n \t\t\t\tpersistentClass,\n \t\t\t\tentityBinder, mappings, inheritanceStatePerClass\n \t\t);\n \n \t\tjavax.persistence.SecondaryTable secTabAnn = clazzToProcess.getAnnotation(\n \t\t\t\tjavax.persistence.SecondaryTable.class\n \t\t);\n \t\tjavax.persistence.SecondaryTables secTabsAnn = clazzToProcess.getAnnotation(\n \t\t\t\tjavax.persistence.SecondaryTables.class\n \t\t);\n \t\tentityBinder.firstLevelSecondaryTablesBinding( secTabAnn, secTabsAnn );\n \n \t\tOnDelete onDeleteAnn = clazzToProcess.getAnnotation( OnDelete.class );\n \t\tboolean onDeleteAppropriate = false;\n \t\tif ( InheritanceType.JOINED.equals( inheritanceState.getType() ) && inheritanceState.hasParents() ) {\n \t\t\tonDeleteAppropriate = true;\n \t\t\tfinal JoinedSubclass jsc = (JoinedSubclass) persistentClass;\n \t\t\tif ( persistentClass.getEntityPersisterClass() == null ) {\n \t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( JoinedSubclassEntityPersister.class );\n \t\t\t}\n \t\t\tSimpleValue key = new DependantValue( jsc.getTable(), jsc.getIdentifier() );\n \t\t\tjsc.setKey( key );\n \t\t\tForeignKey fk = clazzToProcess.getAnnotation( ForeignKey.class );\n \t\t\tif ( fk != null && !BinderHelper.isDefault( fk.name() ) ) {\n \t\t\t\tkey.setForeignKeyName( fk.name() );\n \t\t\t}\n \t\t\tif ( onDeleteAnn != null ) {\n \t\t\t\tkey.setCascadeDeleteEnabled( OnDeleteAction.CASCADE.equals( onDeleteAnn.action() ) );\n \t\t\t}\n \t\t\telse {\n \t\t\t\tkey.setCascadeDeleteEnabled( false );\n \t\t\t}\n \t\t\t//we are never in a second pass at that stage, so queue it\n \t\t\tSecondPass sp = new JoinedSubclassFkSecondPass( jsc, inheritanceJoinedColumns, key, mappings );\n \t\t\tmappings.addSecondPass( sp );\n \t\t\tmappings.addSecondPass( new CreateKeySecondPass( jsc ) );\n \n \t\t}\n \t\telse if ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.getType() ) ) {\n \t\t\tif ( inheritanceState.hasParents() ) {\n \t\t\t\tif ( persistentClass.getEntityPersisterClass() == null ) {\n \t\t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( SingleTableEntityPersister.class );\n \t\t\t\t}\n \t\t\t}\n \t\t\telse {\n \t\t\t\tif ( inheritanceState.hasSiblings() || !discriminatorColumn.isImplicit() ) {\n \t\t\t\t\t//need a discriminator column\n \t\t\t\t\tbindDiscriminatorToPersistentClass(\n \t\t\t\t\t\t\t(RootClass) persistentClass,\n \t\t\t\t\t\t\tdiscriminatorColumn,\n \t\t\t\t\t\t\tentityBinder.getSecondaryTables(),\n \t\t\t\t\t\t\tpropertyHolder\n \t\t\t\t\t);\n \t\t\t\t\tentityBinder.bindDiscriminatorValue();//bind it again since the type might have changed\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\telse if ( InheritanceType.TABLE_PER_CLASS.equals( inheritanceState.getType() ) ) {\n \t\t\tif ( inheritanceState.hasParents() ) {\n \t\t\t\tif ( persistentClass.getEntityPersisterClass() == null ) {\n \t\t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( UnionSubclassEntityPersister.class );\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\tif ( onDeleteAnn != null && !onDeleteAppropriate ) {\n \t\t\tlog.warn(\n \t\t\t\t\t\"Inapropriate use of @OnDelete on entity, annotation ignored: {}\", propertyHolder.getEntityName()\n \t\t\t);\n \t\t}\n \n \t\t//try to find class level generators\n \t\tHashMap<String, IdGenerator> classGenerators = buildLocalGenerators( clazzToProcess, mappings );\n \n \t\t// check properties\n \t\tList<PropertyData> elements =\n \t\t\t\tgetElementsToProcess(\n-\t\t\t\t\t\tpersistentClass, clazzToProcess, inheritanceStatePerClass, propertyHolder, entityBinder, mappings\n+\t\t\t\t\t\tpersistentClass, clazzToProcess, inheritanceStatePerClass, entityBinder, mappings\n \t\t\t\t);\n \t\tif ( elements == null ) {\n \t\t\tthrow new AnnotationException( \"No identifier specified for entity: \" + propertyHolder.getEntityName() );\n \t\t}\n \t\tfinal boolean subclassAndSingleTableStrategy = inheritanceState.getType() == InheritanceType.SINGLE_TABLE\n \t\t\t\t&& inheritanceState.hasParents();\n \t\t//process idclass if any\n \t\tSet<String> idProperties = new HashSet<String>();\n \t\tIdClass idClass = null;\n \t\tXClass current = null;\n \t\tif ( !inheritanceState.hasParents() ) {\n \t\t\t//look for idClass\n \t\t\tInheritanceState state = inheritanceState;\n \t\t\tdo {\n \t\t\t\tcurrent = state.getClazz();\n \t\t\t\tif ( current.isAnnotationPresent( IdClass.class ) ) {\n \t\t\t\t\tidClass = current.getAnnotation( IdClass.class );\n \t\t\t\t\tbreak;\n \t\t\t\t}\n \t\t\t\tstate = InheritanceState.getSuperclassInheritanceState(\n \t\t\t\t\t\tcurrent, inheritanceStatePerClass, mappings.getReflectionManager()\n \t\t\t\t);\n \t\t\t}\n \t\t\twhile ( state != null );\n \t\t}\n \t\tif ( idClass != null ) {\n \t\t\tXClass compositeClass = mappings.getReflectionManager().toXClass( idClass.value() );\n \t\t\tboolean isComponent = true;\n-\t\t\tboolean propertyAnnotated = entityBinder.isPropertyAnnotated( compositeClass );\n-\t\t\tString propertyAccessor = entityBinder.getPropertyAccessor( compositeClass );\n+\t\t\tAccessType propertyAccessor = entityBinder.getPropertyAccessor( compositeClass );\n \t\t\tString generatorType = \"assigned\";\n \t\t\tString generator = BinderHelper.ANNOTATION_STRING_DEFAULT;\n \t\t\tPropertyData inferredData = new PropertyPreloadedData(\n \t\t\t\t\tentityBinder.getPropertyAccessor(), \"id\", compositeClass\n \t\t\t);\n \t\t\tPropertyData baseInferredData = new PropertyPreloadedData(\n                   entityBinder.getPropertyAccessor(), \"id\", current\n             );\n \t\t\tHashMap<String, IdGenerator> localGenerators = new HashMap<String, IdGenerator>();\n \t\t\tboolean ignoreIdAnnotations = entityBinder.isIgnoreIdAnnotations();\n \t\t\tentityBinder.setIgnoreIdAnnotations( true );\n \t\t\tbindId(\n \t\t\t\t\tgeneratorType,\n \t\t\t\t\tgenerator,\n \t\t\t\t\tinferredData,\n \t\t\t\t\tbaseInferredData,\n \t\t\t\t\tnull,\n \t\t\t\t\tpropertyHolder,\n \t\t\t\t\tlocalGenerators,\n \t\t\t\t\tisComponent,\n-\t\t\t\t\tpropertyAnnotated,\n \t\t\t\t\tpropertyAccessor, entityBinder,\n \t\t\t\t\ttrue,\n \t\t\t\t\tfalse, mappings, inheritanceStatePerClass\n \t\t\t);\n \t\t\tinferredData = new PropertyPreloadedData(\n \t\t\t\t\tpropertyAccessor, \"_identifierMapper\", compositeClass\n \t\t\t);\n \t\t\tComponent mapper = fillComponent(\n \t\t\t\t\tpropertyHolder,\n \t\t\t\t\tinferredData,\n \t\t\t\t\tbaseInferredData,\n-\t\t\t\t\tpropertyAnnotated,\n \t\t\t\t\tpropertyAccessor, false,\n \t\t\t\t\tentityBinder,\n \t\t\t\t\ttrue, true,\n \t\t\t\t\tfalse, mappings, inheritanceStatePerClass\n \t\t\t);\n \t\t\tentityBinder.setIgnoreIdAnnotations( ignoreIdAnnotations );\n \t\t\tpersistentClass.setIdentifierMapper( mapper );\n \n \t\t\t//If id definition is on a mapped superclass, update the mapping\n \t\t\tfinal org.hibernate.mapping.MappedSuperclass superclass = BinderHelper.getMappedSuperclassOrNull(\n \t\t\t\t\tinferredData.getDeclaringClass(),\n \t\t\t\t\tinheritanceStatePerClass,\n \t\t\t\t\tmappings\n \t\t\t);\n \t\t\tif (superclass != null) {\n \t\t\t\tsuperclass.setDeclaredIdentifierMapper(mapper);\n \t\t\t}\n \t\t\telse {\n \t\t\t\t//we are for sure on the entity\n \t\t\t\tpersistentClass.setDeclaredIdentifierMapper( mapper );\n \t\t\t}\n \n \t\t\tProperty property = new Property();\n \t\t\tproperty.setName( \"_identifierMapper\" );\n \t\t\tproperty.setNodeName( \"id\" );\n \t\t\tproperty.setUpdateable( false );\n \t\t\tproperty.setInsertable( false );\n \t\t\tproperty.setValue( mapper );\n \t\t\tproperty.setPropertyAccessorName( \"embedded\" );\n \t\t\tpersistentClass.addProperty( property );\n \t\t\tentityBinder.setIgnoreIdAnnotations( true );\n \n \t\t\tIterator properties = mapper.getPropertyIterator();\n \t\t\twhile ( properties.hasNext() ) {\n \t\t\t\tidProperties.add( ( (Property) properties.next() ).getName() );\n \t\t\t}\n \t\t}\n \t\tSet<String> missingIdProperties = new HashSet<String>( idProperties );\n \t\tfor (PropertyData propertyAnnotatedElement : elements) {\n \t\t\tString propertyName = propertyAnnotatedElement.getPropertyName();\n \t\t\tif ( !idProperties.contains( propertyName ) ) {\n \t\t\t\tprocessElementAnnotations(\n \t\t\t\t\t\tpropertyHolder,\n \t\t\t\t\t\tsubclassAndSingleTableStrategy ?\n \t\t\t\t\t\t\t\tNullability.FORCED_NULL :\n \t\t\t\t\t\t\t\tNullability.NO_CONSTRAINT,\n \t\t\t\t\t\tpropertyAnnotatedElement.getProperty(),\n \t\t\t\t\t\tpropertyAnnotatedElement, classGenerators, entityBinder,\n \t\t\t\t\t\tfalse, false, false, mappings, inheritanceStatePerClass\n \t\t\t\t);\n \t\t\t}\n \t\t\telse {\n \t\t\t\tmissingIdProperties.remove( propertyName );\n \t\t\t}\n \t\t}\n \n \t\tif ( missingIdProperties.size() != 0 ) {\n \t\t\tStringBuilder missings = new StringBuilder();\n \t\t\tfor (String property : missingIdProperties) {\n \t\t\t\tmissings.append( property ).append( \", \" );\n \t\t\t}\n \t\t\tthrow new AnnotationException(\n \t\t\t\t\t\"Unable to find properties (\"\n \t\t\t\t\t\t\t+ missings.substring( 0, missings.length() - 2 )\n \t\t\t\t\t\t\t+ \") in entity annotated with @IdClass:\" + persistentClass.getEntityName()\n \t\t\t);\n \t\t}\n \n \t\tif ( !inheritanceState.hasParents() ) {\n \t\t\tfinal RootClass rootClass = (RootClass) persistentClass;\n \t\t\tmappings.addSecondPass( new CreateKeySecondPass( rootClass ) );\n \t\t}\n \t\telse {\n \t\t\tsuperEntity.addSubclass( (Subclass) persistentClass );\n \t\t}\n \n \t\tmappings.addClass( persistentClass );\n \n \t\t//Process secondary tables and complementary definitions (ie o.h.a.Table)\n \t\tmappings.addSecondPass( new SecondaryTableSecondPass( entityBinder, propertyHolder, clazzToProcess ) );\n \n \t\t//add process complementary Table definition (index & all)\n \t\tentityBinder.processComplementaryTableDefinitions( clazzToProcess.getAnnotation( org.hibernate.annotations.Table.class ) );\n \t\tentityBinder.processComplementaryTableDefinitions( clazzToProcess.getAnnotation( org.hibernate.annotations.Tables.class ) );\n \n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"025b3cc14180d0459856bc45a6cac7acce3e1265": {
			"type": "Ybodychange",
			"commitMessage": " HHH-4527\nNo functional changes yet. Just some cleanup and refactoring (extract method, encapsulate field)\n\ngit-svn-id: https://svn.jboss.org/repos/hibernate/core/trunk@18211 1b8cb986-b30d-0410-93ca-fae66ebed9b2\n",
			"commitDate": "2009-12-11, 11:14 AM",
			"commitName": "025b3cc14180d0459856bc45a6cac7acce3e1265",
			"commitAuthor": "Hardy Ferentschik",
			"commitDateOld": "2009-12-10, 1:32 AM",
			"commitNameOld": "ba3639a25a2e3a59b2252aab1d20b0addb178864",
			"commitAuthorOld": "Emmanuel Bernard",
			"daysBetweenCommits": 1.4,
			"commitsBetweenForRepo": 12,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,431 +1,346 @@\n \tpublic static void bindClass(\n \t\t\tXClass clazzToProcess, Map<XClass, InheritanceState> inheritanceStatePerClass, ExtendedMappings mappings\n \t) throws MappingException {\n \t\t//TODO: be more strict with secondarytable allowance (not for ids, not for secondary table join columns etc)\n \t\tInheritanceState inheritanceState = inheritanceStatePerClass.get( clazzToProcess );\n \t\tAnnotatedClassType classType = mappings.getClassType( clazzToProcess );\n \n \t\t//Queries declared in MappedSuperclass should be usable in Subclasses\n \t\tif ( AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals( classType ) ) {\n \t\t\tbindQueries( clazzToProcess, mappings );\n \t\t\tbindTypeDefs(clazzToProcess, mappings);\n \t\t\tbindFilterDefs(clazzToProcess, mappings);\n \t\t}\n \n-\t\tif ( AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals( classType ) //will be processed by their subentities\n-\t\t\t\t|| AnnotatedClassType.NONE.equals( classType ) //to be ignored\n-\t\t\t\t|| AnnotatedClassType.EMBEDDABLE.equals( classType ) //allow embeddable element declaration\n-\t\t\t\t) {\n-\t\t\tif ( AnnotatedClassType.NONE.equals( classType )\n-\t\t\t\t\t&& clazzToProcess.isAnnotationPresent( org.hibernate.annotations.Entity.class ) ) {\n-\t\t\t\tlog.warn( \"Class annotated @org.hibernate.annotations.Entity but not javax.persistence.Entity \"\n-\t\t\t\t\t\t+ \"(most likely a user error): {}\", clazzToProcess.getName() );\n-\t\t\t}\n+\t\tif( !isEntityClassType( clazzToProcess, classType ) ) {\n \t\t\treturn;\n \t\t}\n-\t\tif ( !classType.equals( AnnotatedClassType.ENTITY ) ) {\n-\t\t\t//TODO make this test accurate by removing the none elements artifically added\n-\t\t\tthrow new AnnotationException(\n-\t\t\t\t\t\"Annotated class should have a @javax.persistence.Entity, @javax.persistence.Embeddable or @javax.persistence.EmbeddedSuperclass annotation: \" + clazzToProcess\n-\t\t\t\t\t\t\t.getName()\n-\t\t\t);\n-\t\t}\n-\t\tXAnnotatedElement annotatedClass = clazzToProcess;\n+\n \t\tlog.info( \"Binding entity from annotated class: {}\", clazzToProcess.getName() );\n-\t\tfinal ReflectionManager reflectionManager = mappings.getReflectionManager();\n-\t\tInheritanceState superEntityState =\n-\t\t\t\tInheritanceState.getSuperEntityInheritanceState(\n-\t\t\t\t\t\tclazzToProcess, inheritanceStatePerClass, reflectionManager\n-\t\t\t\t);\n-\t\tPersistentClass superEntity = superEntityState != null ?\n-\t\t\t\tmappings.getClass(\n-\t\t\t\t\t\tsuperEntityState.clazz.getName()\n-\t\t\t\t) :\n-\t\t\t\tnull;\n-\t\tif ( superEntity == null ) {\n-\t\t\t//check if superclass is not a potential persistent class\n-\t\t\tif ( inheritanceState.hasParents ) {\n-\t\t\t\tthrow new AssertionFailure(\n-\t\t\t\t\t\t\"Subclass has to be binded after it's mother class: \"\n-\t\t\t\t\t\t\t\t+ superEntityState.clazz.getName()\n-\t\t\t\t);\n-\t\t\t}\n-\t\t}\n-\t\tbindQueries( annotatedClass, mappings );\n-\t\tbindFilterDefs( annotatedClass, mappings );\n-\t\tbindTypeDefs( annotatedClass, mappings );\n-\t\tBinderHelper.bindAnyMetaDefs( annotatedClass, mappings );\n+\n+\t\tPersistentClass superEntity = getSuperEntity(clazzToProcess, inheritanceStatePerClass, mappings, inheritanceState);\n+\n+\t\tbindQueries( clazzToProcess, mappings );\n+\t\tbindFilterDefs( clazzToProcess, mappings );\n+\t\tbindTypeDefs( clazzToProcess, mappings );\n+\t\tBinderHelper.bindAnyMetaDefs( clazzToProcess, mappings );\n \n \t\tString schema = \"\";\n \t\tString table = \"\"; //might be no @Table annotation on the annotated class\n \t\tString catalog = \"\";\n-\t\tString discrimValue = null;\n \t\tList<UniqueConstraintHolder> uniqueConstraints = new ArrayList<UniqueConstraintHolder>();\n-\t\tEjb3DiscriminatorColumn discriminatorColumn = null;\n-\t\tEjb3JoinColumn[] inheritanceJoinedColumns = null;\n-\n-\t\tif ( annotatedClass.isAnnotationPresent( javax.persistence.Table.class ) ) {\n-\t\t\tjavax.persistence.Table tabAnn = annotatedClass.getAnnotation( javax.persistence.Table.class );\n+\t\tif ( clazzToProcess.isAnnotationPresent( javax.persistence.Table.class ) ) {\n+\t\t\tjavax.persistence.Table tabAnn = clazzToProcess.getAnnotation( javax.persistence.Table.class );\n \t\t\ttable = tabAnn.name();\n \t\t\tschema = tabAnn.schema();\n \t\t\tcatalog = tabAnn.catalog();\n \t\t\tuniqueConstraints = TableBinder.buildUniqueConstraintHolders( tabAnn.uniqueConstraints() );\n \t\t}\n-\t\tfinal boolean hasJoinedColumns = inheritanceState.hasParents\n-\t\t\t\t&& InheritanceType.JOINED.equals( inheritanceState.type );\n-\t\tif ( hasJoinedColumns ) {\n-\t\t\t//@Inheritance(JOINED) subclass need to link back to the super entity\n-\t\t\tPrimaryKeyJoinColumns jcsAnn = annotatedClass.getAnnotation( PrimaryKeyJoinColumns.class );\n-\t\t\tboolean explicitInheritanceJoinedColumns = jcsAnn != null && jcsAnn.value().length != 0;\n-\t\t\tif ( explicitInheritanceJoinedColumns ) {\n-\t\t\t\tint nbrOfInhJoinedColumns = jcsAnn.value().length;\n-\t\t\t\tPrimaryKeyJoinColumn jcAnn;\n-\t\t\t\tinheritanceJoinedColumns = new Ejb3JoinColumn[nbrOfInhJoinedColumns];\n-\t\t\t\tfor (int colIndex = 0; colIndex < nbrOfInhJoinedColumns; colIndex++) {\n-\t\t\t\t\tjcAnn = jcsAnn.value()[colIndex];\n-\t\t\t\t\tinheritanceJoinedColumns[colIndex] = Ejb3JoinColumn.buildJoinColumn(\n-\t\t\t\t\t\t\tjcAnn, null, superEntity.getIdentifier(),\n-\t\t\t\t\t\t\t(Map<String, Join>) null, (PropertyHolder) null, mappings\n-\t\t\t\t\t);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\telse {\n-\t\t\t\tPrimaryKeyJoinColumn jcAnn = annotatedClass.getAnnotation( PrimaryKeyJoinColumn.class );\n-\t\t\t\tinheritanceJoinedColumns = new Ejb3JoinColumn[1];\n-\t\t\t\tinheritanceJoinedColumns[0] = Ejb3JoinColumn.buildJoinColumn(\n-\t\t\t\t\t\tjcAnn, null, superEntity.getIdentifier(),\n-\t\t\t\t\t\t(Map<String, Join>) null, (PropertyHolder) null, mappings\n-\t\t\t\t);\n-\t\t\t}\n-\t\t\tlog.debug( \"Subclass joined column(s) created\" );\n-\t\t}\n-\t\telse {\n-\t\t\tif ( annotatedClass.isAnnotationPresent( javax.persistence.PrimaryKeyJoinColumns.class )\n-\t\t\t\t\t|| annotatedClass.isAnnotationPresent( javax.persistence.PrimaryKeyJoinColumn.class ) ) {\n-\t\t\t\tlog.warn( \"Root entity should not hold an PrimaryKeyJoinColum(s), will be ignored\" );\n-\t\t\t}\n-\t\t}\n \n-\t\tif ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.type ) ) {\n-\t\t\tjavax.persistence.DiscriminatorColumn discAnn = annotatedClass.getAnnotation(\n+\t\tEjb3JoinColumn[] inheritanceJoinedColumns = makeInheritanceJoinColumns( clazzToProcess, mappings, inheritanceState, superEntity );\n+\t\tEjb3DiscriminatorColumn discriminatorColumn = null;\n+\t\tString discrimValue = null;\n+\t\tif ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.getType() ) ) {\n+\t\t\tjavax.persistence.DiscriminatorColumn discAnn = clazzToProcess.getAnnotation(\n \t\t\t\t\tjavax.persistence.DiscriminatorColumn.class\n \t\t\t);\n \t\t\tDiscriminatorType discriminatorType = discAnn != null ?\n \t\t\t\t\tdiscAnn.discriminatorType() :\n \t\t\t\t\tDiscriminatorType.STRING;\n \n-\t\t\torg.hibernate.annotations.DiscriminatorFormula discFormulaAnn = annotatedClass.getAnnotation(\n+\t\t\torg.hibernate.annotations.DiscriminatorFormula discFormulaAnn = clazzToProcess.getAnnotation(\n \t\t\t\t\torg.hibernate.annotations.DiscriminatorFormula.class\n \t\t\t);\n-\t\t\tif ( !inheritanceState.hasParents ) {\n+\t\t\tif ( !inheritanceState.hasParents() ) {\n \t\t\t\tdiscriminatorColumn = Ejb3DiscriminatorColumn.buildDiscriminatorColumn(\n \t\t\t\t\t\tdiscriminatorType, discAnn, discFormulaAnn, mappings\n \t\t\t\t);\n \t\t\t}\n-\t\t\tif ( discAnn != null && inheritanceState.hasParents ) {\n+\t\t\tif ( discAnn != null && inheritanceState.hasParents() ) {\n \t\t\t\tlog.warn(\n \t\t\t\t\t\t\"Discriminator column has to be defined in the root entity, it will be ignored in subclass: {}\",\n \t\t\t\t\t\tclazzToProcess.getName()\n \t\t\t\t);\n \t\t\t}\n-\t\t\tdiscrimValue = annotatedClass.isAnnotationPresent( DiscriminatorValue.class ) ?\n-\t\t\t\t\tannotatedClass.getAnnotation( DiscriminatorValue.class ).value() :\n+\n+\t\t\tdiscrimValue = clazzToProcess.isAnnotationPresent( DiscriminatorValue.class ) ?\n+\t\t\t\t\tclazzToProcess.getAnnotation( DiscriminatorValue.class ).value() :\n \t\t\t\t\tnull;\n \t\t}\n \n-\t\t//we now know what kind of persistent entity it is\n-\t\tPersistentClass persistentClass;\n-\t\t//create persistent class\n-\t\tif ( !inheritanceState.hasParents ) {\n-\t\t\tpersistentClass = new RootClass();\n-\t\t}\n-\t\telse if ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.type ) ) {\n-\t\t\tpersistentClass = new SingleTableSubclass( superEntity );\n-\t\t}\n-\t\telse if ( InheritanceType.JOINED.equals( inheritanceState.type ) ) {\n-\t\t\tpersistentClass = new JoinedSubclass( superEntity );\n-\t\t}\n-\t\telse if ( InheritanceType.TABLE_PER_CLASS.equals( inheritanceState.type ) ) {\n-\t\t\tpersistentClass = new UnionSubclass( superEntity );\n-\t\t}\n-\t\telse {\n-\t\t\tthrow new AssertionFailure( \"Unknown inheritance type: \" + inheritanceState.type );\n-\t\t}\n-\t\tProxy proxyAnn = annotatedClass.getAnnotation( Proxy.class );\n-\t\tBatchSize sizeAnn = annotatedClass.getAnnotation( BatchSize.class );\n-\t\tWhere whereAnn = annotatedClass.getAnnotation( Where.class );\n-\t\tEntity entityAnn = annotatedClass.getAnnotation( Entity.class );\n-\t\torg.hibernate.annotations.Entity hibEntityAnn = annotatedClass.getAnnotation(\n+\t\tPersistentClass persistentClass = makePersistentClass( inheritanceState, superEntity );\n+\n+\t\tProxy proxyAnn = clazzToProcess.getAnnotation( Proxy.class );\n+\t\tBatchSize sizeAnn = clazzToProcess.getAnnotation( BatchSize.class );\n+\t\tWhere whereAnn = clazzToProcess.getAnnotation( Where.class );\n+\t\tEntity entityAnn = clazzToProcess.getAnnotation( Entity.class );\n+\t\torg.hibernate.annotations.Entity hibEntityAnn = clazzToProcess.getAnnotation(\n \t\t\t\torg.hibernate.annotations.Entity.class\n \t\t);\n-\t\torg.hibernate.annotations.Cache cacheAnn = annotatedClass.getAnnotation(\n+\t\torg.hibernate.annotations.Cache cacheAnn = clazzToProcess.getAnnotation(\n \t\t\t\torg.hibernate.annotations.Cache.class\n \t\t);\n \t\tEntityBinder entityBinder = new EntityBinder(\n \t\t\t\tentityAnn, hibEntityAnn, clazzToProcess, persistentClass, mappings\n \t\t);\n \t\tentityBinder.setDiscriminatorValue( discrimValue );\n \t\tentityBinder.setBatchSize( sizeAnn );\n \t\tentityBinder.setProxy( proxyAnn );\n \t\tentityBinder.setWhere( whereAnn );\n \t\tentityBinder.setCache( cacheAnn );\n \t\tentityBinder.setInheritanceState( inheritanceState );\n \t\t\n \t\t//Filters are not allowed on subclasses\n-\t\tif ( !inheritanceState.hasParents ) {\n+\t\tif ( !inheritanceState.hasParents() ) {\n \t\t\tbindFilters(clazzToProcess, entityBinder, mappings);\n \t\t}\n \t\t\n \t\tentityBinder.bindEntity();\n \n \t\tif ( inheritanceState.hasTable() ) {\n-\t\t\tCheck checkAnn = annotatedClass.getAnnotation( Check.class );\n+\t\t\tCheck checkAnn = clazzToProcess.getAnnotation( Check.class );\n \t\t\tString constraints = checkAnn == null ?\n \t\t\t\t\tnull :\n \t\t\t\t\tcheckAnn.constraints();\n \t\t\tentityBinder.bindTable(\n \t\t\t\t\tschema, catalog, table, uniqueConstraints,\n \t\t\t\t\tconstraints, inheritanceState.hasDenormalizedTable() ?\n \t\t\t\t\tsuperEntity.getTable() :\n \t\t\t\t\tnull\n \t\t\t);\n \t\t}\n \t\telse {\n-\t\t\tif ( annotatedClass.isAnnotationPresent( Table.class ) ) {\n+\t\t\tif ( clazzToProcess.isAnnotationPresent( Table.class ) ) {\n \t\t\t\tlog.warn( \"Illegal use of @Table in a subclass of a SINGLE_TABLE hierarchy: \" + clazzToProcess\n \t\t\t\t\t\t.getName() );\n \t\t\t}\n \t\t}\n-//\t\tMap<String, Column[]> columnOverride = PropertyHolderBuilder.buildHierarchyColumnOverride(\n-//\t\t\t\tclazzToProcess,\n-//\t\t\t\tpersistentClass.getClassName()\n-//\t\t);\n+\n \t\tPropertyHolder propertyHolder = PropertyHolderBuilder.buildPropertyHolder(\n \t\t\t\tclazzToProcess,\n \t\t\t\tpersistentClass,\n \t\t\t\tentityBinder, mappings, inheritanceStatePerClass\n \t\t);\n \n-\t\tjavax.persistence.SecondaryTable secTabAnn = annotatedClass.getAnnotation(\n+\t\tjavax.persistence.SecondaryTable secTabAnn = clazzToProcess.getAnnotation(\n \t\t\t\tjavax.persistence.SecondaryTable.class\n \t\t);\n-\t\tjavax.persistence.SecondaryTables secTabsAnn = annotatedClass.getAnnotation(\n+\t\tjavax.persistence.SecondaryTables secTabsAnn = clazzToProcess.getAnnotation(\n \t\t\t\tjavax.persistence.SecondaryTables.class\n \t\t);\n \t\tentityBinder.firstLevelSecondaryTablesBinding( secTabAnn, secTabsAnn );\n \n-\t\tOnDelete onDeleteAnn = annotatedClass.getAnnotation( OnDelete.class );\n+\t\tOnDelete onDeleteAnn = clazzToProcess.getAnnotation( OnDelete.class );\n \t\tboolean onDeleteAppropriate = false;\n-\t\tif ( InheritanceType.JOINED.equals( inheritanceState.type ) && inheritanceState.hasParents ) {\n+\t\tif ( InheritanceType.JOINED.equals( inheritanceState.getType() ) && inheritanceState.hasParents() ) {\n \t\t\tonDeleteAppropriate = true;\n \t\t\tfinal JoinedSubclass jsc = (JoinedSubclass) persistentClass;\n \t\t\tif ( persistentClass.getEntityPersisterClass() == null ) {\n \t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( JoinedSubclassEntityPersister.class );\n \t\t\t}\n \t\t\tSimpleValue key = new DependantValue( jsc.getTable(), jsc.getIdentifier() );\n \t\t\tjsc.setKey( key );\n-\t\t\tForeignKey fk = annotatedClass.getAnnotation( ForeignKey.class );\n+\t\t\tForeignKey fk = clazzToProcess.getAnnotation( ForeignKey.class );\n \t\t\tif ( fk != null && !BinderHelper.isDefault( fk.name() ) ) {\n \t\t\t\tkey.setForeignKeyName( fk.name() );\n \t\t\t}\n \t\t\tif ( onDeleteAnn != null ) {\n \t\t\t\tkey.setCascadeDeleteEnabled( OnDeleteAction.CASCADE.equals( onDeleteAnn.action() ) );\n \t\t\t}\n \t\t\telse {\n \t\t\t\tkey.setCascadeDeleteEnabled( false );\n \t\t\t}\n \t\t\t//we are never in a second pass at that stage, so queue it\n \t\t\tSecondPass sp = new JoinedSubclassFkSecondPass( jsc, inheritanceJoinedColumns, key, mappings );\n \t\t\tmappings.addSecondPass( sp );\n \t\t\tmappings.addSecondPass( new CreateKeySecondPass( jsc ) );\n \n \t\t}\n-\t\telse if ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.type ) ) {\n-\t\t\tif ( inheritanceState.hasParents ) {\n+\t\telse if ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.getType() ) ) {\n+\t\t\tif ( inheritanceState.hasParents() ) {\n \t\t\t\tif ( persistentClass.getEntityPersisterClass() == null ) {\n \t\t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( SingleTableEntityPersister.class );\n \t\t\t\t}\n \t\t\t}\n \t\t\telse {\n-\t\t\t\tif ( inheritanceState.hasSons || !discriminatorColumn.isImplicit() ) {\n+\t\t\t\tif ( inheritanceState.hasSiblings() || !discriminatorColumn.isImplicit() ) {\n \t\t\t\t\t//need a discriminator column\n \t\t\t\t\tbindDiscriminatorToPersistentClass(\n \t\t\t\t\t\t\t(RootClass) persistentClass,\n \t\t\t\t\t\t\tdiscriminatorColumn,\n \t\t\t\t\t\t\tentityBinder.getSecondaryTables(),\n \t\t\t\t\t\t\tpropertyHolder\n \t\t\t\t\t);\n \t\t\t\t\tentityBinder.bindDiscriminatorValue();//bind it again since the type might have changed\n \t\t\t\t}\n \t\t\t}\n \t\t}\n-\t\telse if ( InheritanceType.TABLE_PER_CLASS.equals( inheritanceState.type ) ) {\n-\t\t\tif ( inheritanceState.hasParents ) {\n+\t\telse if ( InheritanceType.TABLE_PER_CLASS.equals( inheritanceState.getType() ) ) {\n+\t\t\tif ( inheritanceState.hasParents() ) {\n \t\t\t\tif ( persistentClass.getEntityPersisterClass() == null ) {\n \t\t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( UnionSubclassEntityPersister.class );\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\tif ( onDeleteAnn != null && !onDeleteAppropriate ) {\n \t\t\tlog.warn(\n \t\t\t\t\t\"Inapropriate use of @OnDelete on entity, annotation ignored: {}\", propertyHolder.getEntityName()\n \t\t\t);\n \t\t}\n \n \t\t//try to find class level generators\n-\t\tHashMap<String, IdGenerator> classGenerators = buildLocalGenerators( annotatedClass, mappings );\n+\t\tHashMap<String, IdGenerator> classGenerators = buildLocalGenerators( clazzToProcess, mappings );\n \n \t\t// check properties\n \t\tList<PropertyData> elements =\n \t\t\t\tgetElementsToProcess(\n \t\t\t\t\t\tpersistentClass, clazzToProcess, inheritanceStatePerClass, propertyHolder, entityBinder, mappings\n \t\t\t\t);\n \t\tif ( elements == null ) {\n \t\t\tthrow new AnnotationException( \"No identifier specified for entity: \" + propertyHolder.getEntityName() );\n \t\t}\n-\t\tfinal boolean subclassAndSingleTableStrategy = inheritanceState.type == InheritanceType.SINGLE_TABLE\n-\t\t\t\t&& inheritanceState.hasParents;\n+\t\tfinal boolean subclassAndSingleTableStrategy = inheritanceState.getType() == InheritanceType.SINGLE_TABLE\n+\t\t\t\t&& inheritanceState.hasParents();\n \t\t//process idclass if any\n \t\tSet<String> idProperties = new HashSet<String>();\n \t\tIdClass idClass = null;\n \t\tXClass current = null;\n-\t\tif ( !inheritanceState.hasParents ) {\n+\t\tif ( !inheritanceState.hasParents() ) {\n \t\t\t//look for idClass\n-\t\t\tcurrent = inheritanceState.clazz;\n \t\t\tInheritanceState state = inheritanceState;\n \t\t\tdo {\n-\t\t\t\tcurrent = state.clazz;\n+\t\t\t\tcurrent = state.getClazz();\n \t\t\t\tif ( current.isAnnotationPresent( IdClass.class ) ) {\n \t\t\t\t\tidClass = current.getAnnotation( IdClass.class );\n \t\t\t\t\tbreak;\n \t\t\t\t}\n \t\t\t\tstate = InheritanceState.getSuperclassInheritanceState(\n-\t\t\t\t\t\tcurrent, inheritanceStatePerClass, reflectionManager\n+\t\t\t\t\t\tcurrent, inheritanceStatePerClass, mappings.getReflectionManager()\n \t\t\t\t);\n \t\t\t}\n \t\t\twhile ( state != null );\n \t\t}\n \t\tif ( idClass != null ) {\n-\t\t\tXClass compositeClass = reflectionManager.toXClass( idClass.value() );\n+\t\t\tXClass compositeClass = mappings.getReflectionManager().toXClass( idClass.value() );\n \t\t\tboolean isComponent = true;\n \t\t\tboolean propertyAnnotated = entityBinder.isPropertyAnnotated( compositeClass );\n \t\t\tString propertyAccessor = entityBinder.getPropertyAccessor( compositeClass );\n \t\t\tString generatorType = \"assigned\";\n \t\t\tString generator = BinderHelper.ANNOTATION_STRING_DEFAULT;\n \t\t\tPropertyData inferredData = new PropertyPreloadedData(\n \t\t\t\t\tentityBinder.getPropertyAccessor(), \"id\", compositeClass\n \t\t\t);\n \t\t\tPropertyData baseInferredData = new PropertyPreloadedData(\n                   entityBinder.getPropertyAccessor(), \"id\", current\n             );\n \t\t\tHashMap<String, IdGenerator> localGenerators = new HashMap<String, IdGenerator>();\n \t\t\tboolean ignoreIdAnnotations = entityBinder.isIgnoreIdAnnotations();\n \t\t\tentityBinder.setIgnoreIdAnnotations( true );\n \t\t\tbindId(\n \t\t\t\t\tgeneratorType,\n \t\t\t\t\tgenerator,\n \t\t\t\t\tinferredData,\n \t\t\t\t\tbaseInferredData,\n \t\t\t\t\tnull,\n \t\t\t\t\tpropertyHolder,\n \t\t\t\t\tlocalGenerators,\n \t\t\t\t\tisComponent,\n \t\t\t\t\tpropertyAnnotated,\n \t\t\t\t\tpropertyAccessor, entityBinder,\n \t\t\t\t\ttrue,\n \t\t\t\t\tfalse, mappings, inheritanceStatePerClass\n \t\t\t);\n \t\t\tinferredData = new PropertyPreloadedData(\n \t\t\t\t\tpropertyAccessor, \"_identifierMapper\", compositeClass\n \t\t\t);\n \t\t\tComponent mapper = fillComponent(\n \t\t\t\t\tpropertyHolder,\n \t\t\t\t\tinferredData,\n \t\t\t\t\tbaseInferredData,\n \t\t\t\t\tpropertyAnnotated,\n \t\t\t\t\tpropertyAccessor, false,\n \t\t\t\t\tentityBinder,\n \t\t\t\t\ttrue, true,\n \t\t\t\t\tfalse, mappings, inheritanceStatePerClass\n \t\t\t);\n \t\t\tentityBinder.setIgnoreIdAnnotations( ignoreIdAnnotations );\n \t\t\tpersistentClass.setIdentifierMapper( mapper );\n \n \t\t\t//If id definition is on a mapped superclass, update the mapping\n \t\t\tfinal org.hibernate.mapping.MappedSuperclass superclass = BinderHelper.getMappedSuperclassOrNull(\n \t\t\t\t\tinferredData.getDeclaringClass(),\n \t\t\t\t\tinheritanceStatePerClass,\n \t\t\t\t\tmappings\n \t\t\t);\n \t\t\tif (superclass != null) {\n \t\t\t\tsuperclass.setDeclaredIdentifierMapper(mapper);\n \t\t\t}\n \t\t\telse {\n \t\t\t\t//we are for sure on the entity\n \t\t\t\tpersistentClass.setDeclaredIdentifierMapper( mapper );\n \t\t\t}\n \n \t\t\tProperty property = new Property();\n \t\t\tproperty.setName( \"_identifierMapper\" );\n \t\t\tproperty.setNodeName( \"id\" );\n \t\t\tproperty.setUpdateable( false );\n \t\t\tproperty.setInsertable( false );\n \t\t\tproperty.setValue( mapper );\n \t\t\tproperty.setPropertyAccessorName( \"embedded\" );\n \t\t\tpersistentClass.addProperty( property );\n \t\t\tentityBinder.setIgnoreIdAnnotations( true );\n \n \t\t\tIterator properties = mapper.getPropertyIterator();\n \t\t\twhile ( properties.hasNext() ) {\n \t\t\t\tidProperties.add( ( (Property) properties.next() ).getName() );\n \t\t\t}\n \t\t}\n \t\tSet<String> missingIdProperties = new HashSet<String>( idProperties );\n \t\tfor (PropertyData propertyAnnotatedElement : elements) {\n \t\t\tString propertyName = propertyAnnotatedElement.getPropertyName();\n \t\t\tif ( !idProperties.contains( propertyName ) ) {\n \t\t\t\tprocessElementAnnotations(\n \t\t\t\t\t\tpropertyHolder,\n \t\t\t\t\t\tsubclassAndSingleTableStrategy ?\n \t\t\t\t\t\t\t\tNullability.FORCED_NULL :\n \t\t\t\t\t\t\t\tNullability.NO_CONSTRAINT,\n \t\t\t\t\t\tpropertyAnnotatedElement.getProperty(),\n \t\t\t\t\t\tpropertyAnnotatedElement, classGenerators, entityBinder,\n \t\t\t\t\t\tfalse, false, false, mappings, inheritanceStatePerClass\n \t\t\t\t);\n \t\t\t}\n \t\t\telse {\n \t\t\t\tmissingIdProperties.remove( propertyName );\n \t\t\t}\n \t\t}\n \n \t\tif ( missingIdProperties.size() != 0 ) {\n \t\t\tStringBuilder missings = new StringBuilder();\n \t\t\tfor (String property : missingIdProperties) {\n \t\t\t\tmissings.append( property ).append( \", \" );\n \t\t\t}\n \t\t\tthrow new AnnotationException(\n \t\t\t\t\t\"Unable to find properties (\"\n \t\t\t\t\t\t\t+ missings.substring( 0, missings.length() - 2 )\n \t\t\t\t\t\t\t+ \") in entity annotated with @IdClass:\" + persistentClass.getEntityName()\n \t\t\t);\n \t\t}\n \n-\t\tif ( !inheritanceState.hasParents ) {\n+\t\tif ( !inheritanceState.hasParents() ) {\n \t\t\tfinal RootClass rootClass = (RootClass) persistentClass;\n \t\t\tmappings.addSecondPass( new CreateKeySecondPass( rootClass ) );\n \t\t}\n \t\telse {\n \t\t\tsuperEntity.addSubclass( (Subclass) persistentClass );\n \t\t}\n \n \t\tmappings.addClass( persistentClass );\n \n \t\t//Process secondary tables and complementary definitions (ie o.h.a.Table)\n-\t\tmappings.addSecondPass( new SecondaryTableSecondPass( entityBinder, propertyHolder, annotatedClass ) );\n+\t\tmappings.addSecondPass( new SecondaryTableSecondPass( entityBinder, propertyHolder, clazzToProcess ) );\n \n \t\t//add process complementary Table definition (index & all)\n-\t\tentityBinder.processComplementaryTableDefinitions( annotatedClass.getAnnotation( org.hibernate.annotations.Table.class ) );\n-\t\tentityBinder.processComplementaryTableDefinitions( annotatedClass.getAnnotation( org.hibernate.annotations.Tables.class ) );\n+\t\tentityBinder.processComplementaryTableDefinitions( clazzToProcess.getAnnotation( org.hibernate.annotations.Table.class ) );\n+\t\tentityBinder.processComplementaryTableDefinitions( clazzToProcess.getAnnotation( org.hibernate.annotations.Tables.class ) );\n \n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"a2bf14ae7c2ed7b2b0a6eb558dad08bcfc69c489": {
			"type": "Ybodychange",
			"commitMessage": "HHH-4553 - Hibernate doesn't support official JPA2 escape char for table name\n\n\ngit-svn-id: https://svn.jboss.org/repos/hibernate/core/trunk@18148 1b8cb986-b30d-0410-93ca-fae66ebed9b2\n",
			"commitDate": "2009-12-06, 2:20 PM",
			"commitName": "a2bf14ae7c2ed7b2b0a6eb558dad08bcfc69c489",
			"commitAuthor": "Steve Ebersole",
			"commitDateOld": "2009-11-30, 8:50 AM",
			"commitNameOld": "6458ff4771ab9ed37bddb783148aff82e40cd600",
			"commitAuthorOld": "Emmanuel Bernard",
			"daysBetweenCommits": 6.23,
			"commitsBetweenForRepo": 16,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,431 +1,431 @@\n \tpublic static void bindClass(\n \t\t\tXClass clazzToProcess, Map<XClass, InheritanceState> inheritanceStatePerClass, ExtendedMappings mappings\n \t) throws MappingException {\n \t\t//TODO: be more strict with secondarytable allowance (not for ids, not for secondary table join columns etc)\n \t\tInheritanceState inheritanceState = inheritanceStatePerClass.get( clazzToProcess );\n \t\tAnnotatedClassType classType = mappings.getClassType( clazzToProcess );\n \n \t\t//Queries declared in MappedSuperclass should be usable in Subclasses\n \t\tif ( AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals( classType ) ) {\n \t\t\tbindQueries( clazzToProcess, mappings );\n \t\t\tbindTypeDefs(clazzToProcess, mappings);\n \t\t\tbindFilterDefs(clazzToProcess, mappings);\n \t\t}\n \n \t\tif ( AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals( classType ) //will be processed by their subentities\n \t\t\t\t|| AnnotatedClassType.NONE.equals( classType ) //to be ignored\n \t\t\t\t|| AnnotatedClassType.EMBEDDABLE.equals( classType ) //allow embeddable element declaration\n \t\t\t\t) {\n \t\t\tif ( AnnotatedClassType.NONE.equals( classType )\n \t\t\t\t\t&& clazzToProcess.isAnnotationPresent( org.hibernate.annotations.Entity.class ) ) {\n \t\t\t\tlog.warn( \"Class annotated @org.hibernate.annotations.Entity but not javax.persistence.Entity \"\n \t\t\t\t\t\t+ \"(most likely a user error): {}\", clazzToProcess.getName() );\n \t\t\t}\n \t\t\treturn;\n \t\t}\n \t\tif ( !classType.equals( AnnotatedClassType.ENTITY ) ) {\n \t\t\t//TODO make this test accurate by removing the none elements artifically added\n \t\t\tthrow new AnnotationException(\n \t\t\t\t\t\"Annotated class should have a @javax.persistence.Entity, @javax.persistence.Embeddable or @javax.persistence.EmbeddedSuperclass annotation: \" + clazzToProcess\n \t\t\t\t\t\t\t.getName()\n \t\t\t);\n \t\t}\n \t\tXAnnotatedElement annotatedClass = clazzToProcess;\n \t\tlog.info( \"Binding entity from annotated class: {}\", clazzToProcess.getName() );\n \t\tfinal ReflectionManager reflectionManager = mappings.getReflectionManager();\n \t\tInheritanceState superEntityState =\n \t\t\t\tInheritanceState.getSuperEntityInheritanceState(\n \t\t\t\t\t\tclazzToProcess, inheritanceStatePerClass, reflectionManager\n \t\t\t\t);\n \t\tPersistentClass superEntity = superEntityState != null ?\n \t\t\t\tmappings.getClass(\n \t\t\t\t\t\tsuperEntityState.clazz.getName()\n \t\t\t\t) :\n \t\t\t\tnull;\n \t\tif ( superEntity == null ) {\n \t\t\t//check if superclass is not a potential persistent class\n \t\t\tif ( inheritanceState.hasParents ) {\n \t\t\t\tthrow new AssertionFailure(\n \t\t\t\t\t\t\"Subclass has to be binded after it's mother class: \"\n \t\t\t\t\t\t\t\t+ superEntityState.clazz.getName()\n \t\t\t\t);\n \t\t\t}\n \t\t}\n \t\tbindQueries( annotatedClass, mappings );\n \t\tbindFilterDefs( annotatedClass, mappings );\n \t\tbindTypeDefs( annotatedClass, mappings );\n \t\tBinderHelper.bindAnyMetaDefs( annotatedClass, mappings );\n \n \t\tString schema = \"\";\n \t\tString table = \"\"; //might be no @Table annotation on the annotated class\n \t\tString catalog = \"\";\n \t\tString discrimValue = null;\n-\t\tList<String[]> uniqueConstraints = new ArrayList<String[]>();\n+\t\tList<UniqueConstraintHolder> uniqueConstraints = new ArrayList<UniqueConstraintHolder>();\n \t\tEjb3DiscriminatorColumn discriminatorColumn = null;\n \t\tEjb3JoinColumn[] inheritanceJoinedColumns = null;\n \n \t\tif ( annotatedClass.isAnnotationPresent( javax.persistence.Table.class ) ) {\n \t\t\tjavax.persistence.Table tabAnn = annotatedClass.getAnnotation( javax.persistence.Table.class );\n \t\t\ttable = tabAnn.name();\n \t\t\tschema = tabAnn.schema();\n \t\t\tcatalog = tabAnn.catalog();\n-\t\t\tuniqueConstraints = TableBinder.buildUniqueConstraints( tabAnn.uniqueConstraints() );\n+\t\t\tuniqueConstraints = TableBinder.buildUniqueConstraintHolders( tabAnn.uniqueConstraints() );\n \t\t}\n \t\tfinal boolean hasJoinedColumns = inheritanceState.hasParents\n \t\t\t\t&& InheritanceType.JOINED.equals( inheritanceState.type );\n \t\tif ( hasJoinedColumns ) {\n \t\t\t//@Inheritance(JOINED) subclass need to link back to the super entity\n \t\t\tPrimaryKeyJoinColumns jcsAnn = annotatedClass.getAnnotation( PrimaryKeyJoinColumns.class );\n \t\t\tboolean explicitInheritanceJoinedColumns = jcsAnn != null && jcsAnn.value().length != 0;\n \t\t\tif ( explicitInheritanceJoinedColumns ) {\n \t\t\t\tint nbrOfInhJoinedColumns = jcsAnn.value().length;\n \t\t\t\tPrimaryKeyJoinColumn jcAnn;\n \t\t\t\tinheritanceJoinedColumns = new Ejb3JoinColumn[nbrOfInhJoinedColumns];\n \t\t\t\tfor (int colIndex = 0; colIndex < nbrOfInhJoinedColumns; colIndex++) {\n \t\t\t\t\tjcAnn = jcsAnn.value()[colIndex];\n \t\t\t\t\tinheritanceJoinedColumns[colIndex] = Ejb3JoinColumn.buildJoinColumn(\n \t\t\t\t\t\t\tjcAnn, null, superEntity.getIdentifier(),\n \t\t\t\t\t\t\t(Map<String, Join>) null, (PropertyHolder) null, mappings\n \t\t\t\t\t);\n \t\t\t\t}\n \t\t\t}\n \t\t\telse {\n \t\t\t\tPrimaryKeyJoinColumn jcAnn = annotatedClass.getAnnotation( PrimaryKeyJoinColumn.class );\n \t\t\t\tinheritanceJoinedColumns = new Ejb3JoinColumn[1];\n \t\t\t\tinheritanceJoinedColumns[0] = Ejb3JoinColumn.buildJoinColumn(\n \t\t\t\t\t\tjcAnn, null, superEntity.getIdentifier(),\n \t\t\t\t\t\t(Map<String, Join>) null, (PropertyHolder) null, mappings\n \t\t\t\t);\n \t\t\t}\n \t\t\tlog.debug( \"Subclass joined column(s) created\" );\n \t\t}\n \t\telse {\n \t\t\tif ( annotatedClass.isAnnotationPresent( javax.persistence.PrimaryKeyJoinColumns.class )\n \t\t\t\t\t|| annotatedClass.isAnnotationPresent( javax.persistence.PrimaryKeyJoinColumn.class ) ) {\n \t\t\t\tlog.warn( \"Root entity should not hold an PrimaryKeyJoinColum(s), will be ignored\" );\n \t\t\t}\n \t\t}\n \n \t\tif ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.type ) ) {\n \t\t\tjavax.persistence.DiscriminatorColumn discAnn = annotatedClass.getAnnotation(\n \t\t\t\t\tjavax.persistence.DiscriminatorColumn.class\n \t\t\t);\n \t\t\tDiscriminatorType discriminatorType = discAnn != null ?\n \t\t\t\t\tdiscAnn.discriminatorType() :\n \t\t\t\t\tDiscriminatorType.STRING;\n \n \t\t\torg.hibernate.annotations.DiscriminatorFormula discFormulaAnn = annotatedClass.getAnnotation(\n \t\t\t\t\torg.hibernate.annotations.DiscriminatorFormula.class\n \t\t\t);\n \t\t\tif ( !inheritanceState.hasParents ) {\n \t\t\t\tdiscriminatorColumn = Ejb3DiscriminatorColumn.buildDiscriminatorColumn(\n \t\t\t\t\t\tdiscriminatorType, discAnn, discFormulaAnn, mappings\n \t\t\t\t);\n \t\t\t}\n \t\t\tif ( discAnn != null && inheritanceState.hasParents ) {\n \t\t\t\tlog.warn(\n \t\t\t\t\t\t\"Discriminator column has to be defined in the root entity, it will be ignored in subclass: {}\",\n \t\t\t\t\t\tclazzToProcess.getName()\n \t\t\t\t);\n \t\t\t}\n \t\t\tdiscrimValue = annotatedClass.isAnnotationPresent( DiscriminatorValue.class ) ?\n \t\t\t\t\tannotatedClass.getAnnotation( DiscriminatorValue.class ).value() :\n \t\t\t\t\tnull;\n \t\t}\n \n \t\t//we now know what kind of persistent entity it is\n \t\tPersistentClass persistentClass;\n \t\t//create persistent class\n \t\tif ( !inheritanceState.hasParents ) {\n \t\t\tpersistentClass = new RootClass();\n \t\t}\n \t\telse if ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.type ) ) {\n \t\t\tpersistentClass = new SingleTableSubclass( superEntity );\n \t\t}\n \t\telse if ( InheritanceType.JOINED.equals( inheritanceState.type ) ) {\n \t\t\tpersistentClass = new JoinedSubclass( superEntity );\n \t\t}\n \t\telse if ( InheritanceType.TABLE_PER_CLASS.equals( inheritanceState.type ) ) {\n \t\t\tpersistentClass = new UnionSubclass( superEntity );\n \t\t}\n \t\telse {\n \t\t\tthrow new AssertionFailure( \"Unknown inheritance type: \" + inheritanceState.type );\n \t\t}\n \t\tProxy proxyAnn = annotatedClass.getAnnotation( Proxy.class );\n \t\tBatchSize sizeAnn = annotatedClass.getAnnotation( BatchSize.class );\n \t\tWhere whereAnn = annotatedClass.getAnnotation( Where.class );\n \t\tEntity entityAnn = annotatedClass.getAnnotation( Entity.class );\n \t\torg.hibernate.annotations.Entity hibEntityAnn = annotatedClass.getAnnotation(\n \t\t\t\torg.hibernate.annotations.Entity.class\n \t\t);\n \t\torg.hibernate.annotations.Cache cacheAnn = annotatedClass.getAnnotation(\n \t\t\t\torg.hibernate.annotations.Cache.class\n \t\t);\n \t\tEntityBinder entityBinder = new EntityBinder(\n \t\t\t\tentityAnn, hibEntityAnn, clazzToProcess, persistentClass, mappings\n \t\t);\n \t\tentityBinder.setDiscriminatorValue( discrimValue );\n \t\tentityBinder.setBatchSize( sizeAnn );\n \t\tentityBinder.setProxy( proxyAnn );\n \t\tentityBinder.setWhere( whereAnn );\n \t\tentityBinder.setCache( cacheAnn );\n \t\tentityBinder.setInheritanceState( inheritanceState );\n \t\t\n \t\t//Filters are not allowed on subclasses\n \t\tif ( !inheritanceState.hasParents ) {\n \t\t\tbindFilters(clazzToProcess, entityBinder, mappings);\n \t\t}\n \t\t\n \t\tentityBinder.bindEntity();\n \n \t\tif ( inheritanceState.hasTable() ) {\n \t\t\tCheck checkAnn = annotatedClass.getAnnotation( Check.class );\n \t\t\tString constraints = checkAnn == null ?\n \t\t\t\t\tnull :\n \t\t\t\t\tcheckAnn.constraints();\n \t\t\tentityBinder.bindTable(\n \t\t\t\t\tschema, catalog, table, uniqueConstraints,\n \t\t\t\t\tconstraints, inheritanceState.hasDenormalizedTable() ?\n \t\t\t\t\tsuperEntity.getTable() :\n \t\t\t\t\tnull\n \t\t\t);\n \t\t}\n \t\telse {\n \t\t\tif ( annotatedClass.isAnnotationPresent( Table.class ) ) {\n \t\t\t\tlog.warn( \"Illegal use of @Table in a subclass of a SINGLE_TABLE hierarchy: \" + clazzToProcess\n \t\t\t\t\t\t.getName() );\n \t\t\t}\n \t\t}\n //\t\tMap<String, Column[]> columnOverride = PropertyHolderBuilder.buildHierarchyColumnOverride(\n //\t\t\t\tclazzToProcess,\n //\t\t\t\tpersistentClass.getClassName()\n //\t\t);\n \t\tPropertyHolder propertyHolder = PropertyHolderBuilder.buildPropertyHolder(\n \t\t\t\tclazzToProcess,\n \t\t\t\tpersistentClass,\n \t\t\t\tentityBinder, mappings, inheritanceStatePerClass\n \t\t);\n \n \t\tjavax.persistence.SecondaryTable secTabAnn = annotatedClass.getAnnotation(\n \t\t\t\tjavax.persistence.SecondaryTable.class\n \t\t);\n \t\tjavax.persistence.SecondaryTables secTabsAnn = annotatedClass.getAnnotation(\n \t\t\t\tjavax.persistence.SecondaryTables.class\n \t\t);\n \t\tentityBinder.firstLevelSecondaryTablesBinding( secTabAnn, secTabsAnn );\n \n \t\tOnDelete onDeleteAnn = annotatedClass.getAnnotation( OnDelete.class );\n \t\tboolean onDeleteAppropriate = false;\n \t\tif ( InheritanceType.JOINED.equals( inheritanceState.type ) && inheritanceState.hasParents ) {\n \t\t\tonDeleteAppropriate = true;\n \t\t\tfinal JoinedSubclass jsc = (JoinedSubclass) persistentClass;\n \t\t\tif ( persistentClass.getEntityPersisterClass() == null ) {\n \t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( JoinedSubclassEntityPersister.class );\n \t\t\t}\n \t\t\tSimpleValue key = new DependantValue( jsc.getTable(), jsc.getIdentifier() );\n \t\t\tjsc.setKey( key );\n \t\t\tForeignKey fk = annotatedClass.getAnnotation( ForeignKey.class );\n \t\t\tif ( fk != null && !BinderHelper.isDefault( fk.name() ) ) {\n \t\t\t\tkey.setForeignKeyName( fk.name() );\n \t\t\t}\n \t\t\tif ( onDeleteAnn != null ) {\n \t\t\t\tkey.setCascadeDeleteEnabled( OnDeleteAction.CASCADE.equals( onDeleteAnn.action() ) );\n \t\t\t}\n \t\t\telse {\n \t\t\t\tkey.setCascadeDeleteEnabled( false );\n \t\t\t}\n \t\t\t//we are never in a second pass at that stage, so queue it\n \t\t\tSecondPass sp = new JoinedSubclassFkSecondPass( jsc, inheritanceJoinedColumns, key, mappings );\n \t\t\tmappings.addSecondPass( sp );\n \t\t\tmappings.addSecondPass( new CreateKeySecondPass( jsc ) );\n \n \t\t}\n \t\telse if ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.type ) ) {\n \t\t\tif ( inheritanceState.hasParents ) {\n \t\t\t\tif ( persistentClass.getEntityPersisterClass() == null ) {\n \t\t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( SingleTableEntityPersister.class );\n \t\t\t\t}\n \t\t\t}\n \t\t\telse {\n \t\t\t\tif ( inheritanceState.hasSons || !discriminatorColumn.isImplicit() ) {\n \t\t\t\t\t//need a discriminator column\n \t\t\t\t\tbindDiscriminatorToPersistentClass(\n \t\t\t\t\t\t\t(RootClass) persistentClass,\n \t\t\t\t\t\t\tdiscriminatorColumn,\n \t\t\t\t\t\t\tentityBinder.getSecondaryTables(),\n \t\t\t\t\t\t\tpropertyHolder\n \t\t\t\t\t);\n \t\t\t\t\tentityBinder.bindDiscriminatorValue();//bind it again since the type might have changed\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\telse if ( InheritanceType.TABLE_PER_CLASS.equals( inheritanceState.type ) ) {\n \t\t\tif ( inheritanceState.hasParents ) {\n \t\t\t\tif ( persistentClass.getEntityPersisterClass() == null ) {\n \t\t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( UnionSubclassEntityPersister.class );\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\tif ( onDeleteAnn != null && !onDeleteAppropriate ) {\n \t\t\tlog.warn(\n \t\t\t\t\t\"Inapropriate use of @OnDelete on entity, annotation ignored: {}\", propertyHolder.getEntityName()\n \t\t\t);\n \t\t}\n \n \t\t//try to find class level generators\n \t\tHashMap<String, IdGenerator> classGenerators = buildLocalGenerators( annotatedClass, mappings );\n \n \t\t// check properties\n \t\tList<PropertyData> elements =\n \t\t\t\tgetElementsToProcess(\n \t\t\t\t\t\tpersistentClass, clazzToProcess, inheritanceStatePerClass, propertyHolder, entityBinder, mappings\n \t\t\t\t);\n \t\tif ( elements == null ) {\n \t\t\tthrow new AnnotationException( \"No identifier specified for entity: \" + propertyHolder.getEntityName() );\n \t\t}\n \t\tfinal boolean subclassAndSingleTableStrategy = inheritanceState.type == InheritanceType.SINGLE_TABLE\n \t\t\t\t&& inheritanceState.hasParents;\n \t\t//process idclass if any\n \t\tSet<String> idProperties = new HashSet<String>();\n \t\tIdClass idClass = null;\n \t\tXClass current = null;\n \t\tif ( !inheritanceState.hasParents ) {\n \t\t\t//look for idClass\n \t\t\tcurrent = inheritanceState.clazz;\n \t\t\tInheritanceState state = inheritanceState;\n \t\t\tdo {\n \t\t\t\tcurrent = state.clazz;\n \t\t\t\tif ( current.isAnnotationPresent( IdClass.class ) ) {\n \t\t\t\t\tidClass = current.getAnnotation( IdClass.class );\n \t\t\t\t\tbreak;\n \t\t\t\t}\n \t\t\t\tstate = InheritanceState.getSuperclassInheritanceState(\n \t\t\t\t\t\tcurrent, inheritanceStatePerClass, reflectionManager\n \t\t\t\t);\n \t\t\t}\n \t\t\twhile ( state != null );\n \t\t}\n \t\tif ( idClass != null ) {\n \t\t\tXClass compositeClass = reflectionManager.toXClass( idClass.value() );\n \t\t\tboolean isComponent = true;\n \t\t\tboolean propertyAnnotated = entityBinder.isPropertyAnnotated( compositeClass );\n \t\t\tString propertyAccessor = entityBinder.getPropertyAccessor( compositeClass );\n \t\t\tString generatorType = \"assigned\";\n \t\t\tString generator = BinderHelper.ANNOTATION_STRING_DEFAULT;\n \t\t\tPropertyData inferredData = new PropertyPreloadedData(\n \t\t\t\t\tentityBinder.getPropertyAccessor(), \"id\", compositeClass\n \t\t\t);\n \t\t\tPropertyData baseInferredData = new PropertyPreloadedData(\n                   entityBinder.getPropertyAccessor(), \"id\", current\n             );\n \t\t\tHashMap<String, IdGenerator> localGenerators = new HashMap<String, IdGenerator>();\n \t\t\tboolean ignoreIdAnnotations = entityBinder.isIgnoreIdAnnotations();\n \t\t\tentityBinder.setIgnoreIdAnnotations( true );\n \t\t\tbindId(\n \t\t\t\t\tgeneratorType,\n \t\t\t\t\tgenerator,\n \t\t\t\t\tinferredData,\n \t\t\t\t\tbaseInferredData,\n \t\t\t\t\tnull,\n \t\t\t\t\tpropertyHolder,\n \t\t\t\t\tlocalGenerators,\n \t\t\t\t\tisComponent,\n \t\t\t\t\tpropertyAnnotated,\n \t\t\t\t\tpropertyAccessor, entityBinder,\n \t\t\t\t\ttrue,\n \t\t\t\t\tfalse, mappings, inheritanceStatePerClass\n \t\t\t);\n \t\t\tinferredData = new PropertyPreloadedData(\n \t\t\t\t\tpropertyAccessor, \"_identifierMapper\", compositeClass\n \t\t\t);\n \t\t\tComponent mapper = fillComponent(\n \t\t\t\t\tpropertyHolder,\n \t\t\t\t\tinferredData,\n \t\t\t\t\tbaseInferredData,\n \t\t\t\t\tpropertyAnnotated,\n \t\t\t\t\tpropertyAccessor, false,\n \t\t\t\t\tentityBinder,\n \t\t\t\t\ttrue, true,\n \t\t\t\t\tfalse, mappings, inheritanceStatePerClass\n \t\t\t);\n \t\t\tentityBinder.setIgnoreIdAnnotations( ignoreIdAnnotations );\n \t\t\tpersistentClass.setIdentifierMapper( mapper );\n \n \t\t\t//If id definition is on a mapped superclass, update the mapping\n \t\t\tfinal org.hibernate.mapping.MappedSuperclass superclass = BinderHelper.getMappedSuperclassOrNull(\n \t\t\t\t\tinferredData.getDeclaringClass(),\n \t\t\t\t\tinheritanceStatePerClass,\n \t\t\t\t\tmappings\n \t\t\t);\n \t\t\tif (superclass != null) {\n \t\t\t\tsuperclass.setDeclaredIdentifierMapper(mapper);\n \t\t\t}\n \t\t\telse {\n \t\t\t\t//we are for sure on the entity\n \t\t\t\tpersistentClass.setDeclaredIdentifierMapper( mapper );\n \t\t\t}\n \n \t\t\tProperty property = new Property();\n \t\t\tproperty.setName( \"_identifierMapper\" );\n \t\t\tproperty.setNodeName( \"id\" );\n \t\t\tproperty.setUpdateable( false );\n \t\t\tproperty.setInsertable( false );\n \t\t\tproperty.setValue( mapper );\n \t\t\tproperty.setPropertyAccessorName( \"embedded\" );\n \t\t\tpersistentClass.addProperty( property );\n \t\t\tentityBinder.setIgnoreIdAnnotations( true );\n \n \t\t\tIterator properties = mapper.getPropertyIterator();\n \t\t\twhile ( properties.hasNext() ) {\n \t\t\t\tidProperties.add( ( (Property) properties.next() ).getName() );\n \t\t\t}\n \t\t}\n \t\tSet<String> missingIdProperties = new HashSet<String>( idProperties );\n \t\tfor (PropertyData propertyAnnotatedElement : elements) {\n \t\t\tString propertyName = propertyAnnotatedElement.getPropertyName();\n \t\t\tif ( !idProperties.contains( propertyName ) ) {\n \t\t\t\tprocessElementAnnotations(\n \t\t\t\t\t\tpropertyHolder,\n \t\t\t\t\t\tsubclassAndSingleTableStrategy ?\n \t\t\t\t\t\t\t\tNullability.FORCED_NULL :\n \t\t\t\t\t\t\t\tNullability.NO_CONSTRAINT,\n \t\t\t\t\t\tpropertyAnnotatedElement.getProperty(),\n \t\t\t\t\t\tpropertyAnnotatedElement, classGenerators, entityBinder,\n \t\t\t\t\t\tfalse, false, false, mappings, inheritanceStatePerClass\n \t\t\t\t);\n \t\t\t}\n \t\t\telse {\n \t\t\t\tmissingIdProperties.remove( propertyName );\n \t\t\t}\n \t\t}\n \n \t\tif ( missingIdProperties.size() != 0 ) {\n \t\t\tStringBuilder missings = new StringBuilder();\n \t\t\tfor (String property : missingIdProperties) {\n \t\t\t\tmissings.append( property ).append( \", \" );\n \t\t\t}\n \t\t\tthrow new AnnotationException(\n \t\t\t\t\t\"Unable to find properties (\"\n \t\t\t\t\t\t\t+ missings.substring( 0, missings.length() - 2 )\n \t\t\t\t\t\t\t+ \") in entity annotated with @IdClass:\" + persistentClass.getEntityName()\n \t\t\t);\n \t\t}\n \n \t\tif ( !inheritanceState.hasParents ) {\n \t\t\tfinal RootClass rootClass = (RootClass) persistentClass;\n \t\t\tmappings.addSecondPass( new CreateKeySecondPass( rootClass ) );\n \t\t}\n \t\telse {\n \t\t\tsuperEntity.addSubclass( (Subclass) persistentClass );\n \t\t}\n \n \t\tmappings.addClass( persistentClass );\n \n \t\t//Process secondary tables and complementary definitions (ie o.h.a.Table)\n \t\tmappings.addSecondPass( new SecondaryTableSecondPass( entityBinder, propertyHolder, annotatedClass ) );\n \n \t\t//add process complementary Table definition (index & all)\n \t\tentityBinder.processComplementaryTableDefinitions( annotatedClass.getAnnotation( org.hibernate.annotations.Table.class ) );\n \t\tentityBinder.processComplementaryTableDefinitions( annotatedClass.getAnnotation( org.hibernate.annotations.Tables.class ) );\n \n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"fb9bdb7f387a4c8e100e2a8109e3c9b8706f4fed": {
			"type": "Ybodychange",
			"commitMessage": "HHH-4533 Populate the JPA 2 metamodel with the new mapping.MappedSuperclass metadata\n\ngit-svn-id: https://svn.jboss.org/repos/hibernate/core/trunk@17879 1b8cb986-b30d-0410-93ca-fae66ebed9b2\n",
			"commitDate": "2009-10-29, 11:57 AM",
			"commitName": "fb9bdb7f387a4c8e100e2a8109e3c9b8706f4fed",
			"commitAuthor": "Emmanuel Bernard",
			"commitDateOld": "2009-10-28, 5:36 PM",
			"commitNameOld": "1352b5e25f330f2838e27fb8b5ba1c05d4b8c8ab",
			"commitAuthorOld": "Emmanuel Bernard",
			"daysBetweenCommits": 0.76,
			"commitsBetweenForRepo": 5,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,416 +1,431 @@\n \tpublic static void bindClass(\n \t\t\tXClass clazzToProcess, Map<XClass, InheritanceState> inheritanceStatePerClass, ExtendedMappings mappings\n \t) throws MappingException {\n \t\t//TODO: be more strict with secondarytable allowance (not for ids, not for secondary table join columns etc)\n \t\tInheritanceState inheritanceState = inheritanceStatePerClass.get( clazzToProcess );\n \t\tAnnotatedClassType classType = mappings.getClassType( clazzToProcess );\n \n \t\t//Queries declared in MappedSuperclass should be usable in Subclasses\n \t\tif ( AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals( classType ) ) {\n \t\t\tbindQueries( clazzToProcess, mappings );\n \t\t\tbindTypeDefs(clazzToProcess, mappings);\n \t\t\tbindFilterDefs(clazzToProcess, mappings);\n \t\t}\n \n \t\tif ( AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals( classType ) //will be processed by their subentities\n \t\t\t\t|| AnnotatedClassType.NONE.equals( classType ) //to be ignored\n \t\t\t\t|| AnnotatedClassType.EMBEDDABLE.equals( classType ) //allow embeddable element declaration\n \t\t\t\t) {\n \t\t\tif ( AnnotatedClassType.NONE.equals( classType )\n \t\t\t\t\t&& clazzToProcess.isAnnotationPresent( org.hibernate.annotations.Entity.class ) ) {\n \t\t\t\tlog.warn( \"Class annotated @org.hibernate.annotations.Entity but not javax.persistence.Entity \"\n \t\t\t\t\t\t+ \"(most likely a user error): {}\", clazzToProcess.getName() );\n \t\t\t}\n \t\t\treturn;\n \t\t}\n \t\tif ( !classType.equals( AnnotatedClassType.ENTITY ) ) {\n \t\t\t//TODO make this test accurate by removing the none elements artifically added\n \t\t\tthrow new AnnotationException(\n \t\t\t\t\t\"Annotated class should have a @javax.persistence.Entity, @javax.persistence.Embeddable or @javax.persistence.EmbeddedSuperclass annotation: \" + clazzToProcess\n \t\t\t\t\t\t\t.getName()\n \t\t\t);\n \t\t}\n \t\tXAnnotatedElement annotatedClass = clazzToProcess;\n \t\tlog.info( \"Binding entity from annotated class: {}\", clazzToProcess.getName() );\n \t\tfinal ReflectionManager reflectionManager = mappings.getReflectionManager();\n \t\tInheritanceState superEntityState =\n \t\t\t\tInheritanceState.getSuperEntityInheritanceState(\n \t\t\t\t\t\tclazzToProcess, inheritanceStatePerClass, reflectionManager\n \t\t\t\t);\n \t\tPersistentClass superEntity = superEntityState != null ?\n \t\t\t\tmappings.getClass(\n \t\t\t\t\t\tsuperEntityState.clazz.getName()\n \t\t\t\t) :\n \t\t\t\tnull;\n \t\tif ( superEntity == null ) {\n \t\t\t//check if superclass is not a potential persistent class\n \t\t\tif ( inheritanceState.hasParents ) {\n \t\t\t\tthrow new AssertionFailure(\n \t\t\t\t\t\t\"Subclass has to be binded after it's mother class: \"\n \t\t\t\t\t\t\t\t+ superEntityState.clazz.getName()\n \t\t\t\t);\n \t\t\t}\n \t\t}\n \t\tbindQueries( annotatedClass, mappings );\n \t\tbindFilterDefs( annotatedClass, mappings );\n \t\tbindTypeDefs( annotatedClass, mappings );\n \t\tBinderHelper.bindAnyMetaDefs( annotatedClass, mappings );\n \n \t\tString schema = \"\";\n \t\tString table = \"\"; //might be no @Table annotation on the annotated class\n \t\tString catalog = \"\";\n \t\tString discrimValue = null;\n \t\tList<String[]> uniqueConstraints = new ArrayList<String[]>();\n \t\tEjb3DiscriminatorColumn discriminatorColumn = null;\n \t\tEjb3JoinColumn[] inheritanceJoinedColumns = null;\n \n \t\tif ( annotatedClass.isAnnotationPresent( javax.persistence.Table.class ) ) {\n \t\t\tjavax.persistence.Table tabAnn = annotatedClass.getAnnotation( javax.persistence.Table.class );\n \t\t\ttable = tabAnn.name();\n \t\t\tschema = tabAnn.schema();\n \t\t\tcatalog = tabAnn.catalog();\n \t\t\tuniqueConstraints = TableBinder.buildUniqueConstraints( tabAnn.uniqueConstraints() );\n \t\t}\n \t\tfinal boolean hasJoinedColumns = inheritanceState.hasParents\n \t\t\t\t&& InheritanceType.JOINED.equals( inheritanceState.type );\n \t\tif ( hasJoinedColumns ) {\n \t\t\t//@Inheritance(JOINED) subclass need to link back to the super entity\n \t\t\tPrimaryKeyJoinColumns jcsAnn = annotatedClass.getAnnotation( PrimaryKeyJoinColumns.class );\n \t\t\tboolean explicitInheritanceJoinedColumns = jcsAnn != null && jcsAnn.value().length != 0;\n \t\t\tif ( explicitInheritanceJoinedColumns ) {\n \t\t\t\tint nbrOfInhJoinedColumns = jcsAnn.value().length;\n \t\t\t\tPrimaryKeyJoinColumn jcAnn;\n \t\t\t\tinheritanceJoinedColumns = new Ejb3JoinColumn[nbrOfInhJoinedColumns];\n \t\t\t\tfor (int colIndex = 0; colIndex < nbrOfInhJoinedColumns; colIndex++) {\n \t\t\t\t\tjcAnn = jcsAnn.value()[colIndex];\n \t\t\t\t\tinheritanceJoinedColumns[colIndex] = Ejb3JoinColumn.buildJoinColumn(\n \t\t\t\t\t\t\tjcAnn, null, superEntity.getIdentifier(),\n \t\t\t\t\t\t\t(Map<String, Join>) null, (PropertyHolder) null, mappings\n \t\t\t\t\t);\n \t\t\t\t}\n \t\t\t}\n \t\t\telse {\n \t\t\t\tPrimaryKeyJoinColumn jcAnn = annotatedClass.getAnnotation( PrimaryKeyJoinColumn.class );\n \t\t\t\tinheritanceJoinedColumns = new Ejb3JoinColumn[1];\n \t\t\t\tinheritanceJoinedColumns[0] = Ejb3JoinColumn.buildJoinColumn(\n \t\t\t\t\t\tjcAnn, null, superEntity.getIdentifier(),\n \t\t\t\t\t\t(Map<String, Join>) null, (PropertyHolder) null, mappings\n \t\t\t\t);\n \t\t\t}\n \t\t\tlog.debug( \"Subclass joined column(s) created\" );\n \t\t}\n \t\telse {\n \t\t\tif ( annotatedClass.isAnnotationPresent( javax.persistence.PrimaryKeyJoinColumns.class )\n \t\t\t\t\t|| annotatedClass.isAnnotationPresent( javax.persistence.PrimaryKeyJoinColumn.class ) ) {\n \t\t\t\tlog.warn( \"Root entity should not hold an PrimaryKeyJoinColum(s), will be ignored\" );\n \t\t\t}\n \t\t}\n \n \t\tif ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.type ) ) {\n \t\t\tjavax.persistence.DiscriminatorColumn discAnn = annotatedClass.getAnnotation(\n \t\t\t\t\tjavax.persistence.DiscriminatorColumn.class\n \t\t\t);\n \t\t\tDiscriminatorType discriminatorType = discAnn != null ?\n \t\t\t\t\tdiscAnn.discriminatorType() :\n \t\t\t\t\tDiscriminatorType.STRING;\n \n \t\t\torg.hibernate.annotations.DiscriminatorFormula discFormulaAnn = annotatedClass.getAnnotation(\n \t\t\t\t\torg.hibernate.annotations.DiscriminatorFormula.class\n \t\t\t);\n \t\t\tif ( !inheritanceState.hasParents ) {\n \t\t\t\tdiscriminatorColumn = Ejb3DiscriminatorColumn.buildDiscriminatorColumn(\n \t\t\t\t\t\tdiscriminatorType, discAnn, discFormulaAnn, mappings\n \t\t\t\t);\n \t\t\t}\n \t\t\tif ( discAnn != null && inheritanceState.hasParents ) {\n \t\t\t\tlog.warn(\n \t\t\t\t\t\t\"Discriminator column has to be defined in the root entity, it will be ignored in subclass: {}\",\n \t\t\t\t\t\tclazzToProcess.getName()\n \t\t\t\t);\n \t\t\t}\n \t\t\tdiscrimValue = annotatedClass.isAnnotationPresent( DiscriminatorValue.class ) ?\n \t\t\t\t\tannotatedClass.getAnnotation( DiscriminatorValue.class ).value() :\n \t\t\t\t\tnull;\n \t\t}\n \n \t\t//we now know what kind of persistent entity it is\n \t\tPersistentClass persistentClass;\n \t\t//create persistent class\n \t\tif ( !inheritanceState.hasParents ) {\n \t\t\tpersistentClass = new RootClass();\n \t\t}\n \t\telse if ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.type ) ) {\n \t\t\tpersistentClass = new SingleTableSubclass( superEntity );\n \t\t}\n \t\telse if ( InheritanceType.JOINED.equals( inheritanceState.type ) ) {\n \t\t\tpersistentClass = new JoinedSubclass( superEntity );\n \t\t}\n \t\telse if ( InheritanceType.TABLE_PER_CLASS.equals( inheritanceState.type ) ) {\n \t\t\tpersistentClass = new UnionSubclass( superEntity );\n \t\t}\n \t\telse {\n \t\t\tthrow new AssertionFailure( \"Unknown inheritance type: \" + inheritanceState.type );\n \t\t}\n \t\tProxy proxyAnn = annotatedClass.getAnnotation( Proxy.class );\n \t\tBatchSize sizeAnn = annotatedClass.getAnnotation( BatchSize.class );\n \t\tWhere whereAnn = annotatedClass.getAnnotation( Where.class );\n \t\tEntity entityAnn = annotatedClass.getAnnotation( Entity.class );\n \t\torg.hibernate.annotations.Entity hibEntityAnn = annotatedClass.getAnnotation(\n \t\t\t\torg.hibernate.annotations.Entity.class\n \t\t);\n \t\torg.hibernate.annotations.Cache cacheAnn = annotatedClass.getAnnotation(\n \t\t\t\torg.hibernate.annotations.Cache.class\n \t\t);\n \t\tEntityBinder entityBinder = new EntityBinder(\n \t\t\t\tentityAnn, hibEntityAnn, clazzToProcess, persistentClass, mappings\n \t\t);\n \t\tentityBinder.setDiscriminatorValue( discrimValue );\n \t\tentityBinder.setBatchSize( sizeAnn );\n \t\tentityBinder.setProxy( proxyAnn );\n \t\tentityBinder.setWhere( whereAnn );\n \t\tentityBinder.setCache( cacheAnn );\n \t\tentityBinder.setInheritanceState( inheritanceState );\n \t\t\n \t\t//Filters are not allowed on subclasses\n \t\tif ( !inheritanceState.hasParents ) {\n \t\t\tbindFilters(clazzToProcess, entityBinder, mappings);\n \t\t}\n \t\t\n \t\tentityBinder.bindEntity();\n \n \t\tif ( inheritanceState.hasTable() ) {\n \t\t\tCheck checkAnn = annotatedClass.getAnnotation( Check.class );\n \t\t\tString constraints = checkAnn == null ?\n \t\t\t\t\tnull :\n \t\t\t\t\tcheckAnn.constraints();\n \t\t\tentityBinder.bindTable(\n \t\t\t\t\tschema, catalog, table, uniqueConstraints,\n \t\t\t\t\tconstraints, inheritanceState.hasDenormalizedTable() ?\n \t\t\t\t\tsuperEntity.getTable() :\n \t\t\t\t\tnull\n \t\t\t);\n \t\t}\n \t\telse {\n \t\t\tif ( annotatedClass.isAnnotationPresent( Table.class ) ) {\n \t\t\t\tlog.warn( \"Illegal use of @Table in a subclass of a SINGLE_TABLE hierarchy: \" + clazzToProcess\n \t\t\t\t\t\t.getName() );\n \t\t\t}\n \t\t}\n //\t\tMap<String, Column[]> columnOverride = PropertyHolderBuilder.buildHierarchyColumnOverride(\n //\t\t\t\tclazzToProcess,\n //\t\t\t\tpersistentClass.getClassName()\n //\t\t);\n \t\tPropertyHolder propertyHolder = PropertyHolderBuilder.buildPropertyHolder(\n \t\t\t\tclazzToProcess,\n \t\t\t\tpersistentClass,\n \t\t\t\tentityBinder, mappings, inheritanceStatePerClass\n \t\t);\n \n \t\tjavax.persistence.SecondaryTable secTabAnn = annotatedClass.getAnnotation(\n \t\t\t\tjavax.persistence.SecondaryTable.class\n \t\t);\n \t\tjavax.persistence.SecondaryTables secTabsAnn = annotatedClass.getAnnotation(\n \t\t\t\tjavax.persistence.SecondaryTables.class\n \t\t);\n \t\tentityBinder.firstLevelSecondaryTablesBinding( secTabAnn, secTabsAnn );\n \n \t\tOnDelete onDeleteAnn = annotatedClass.getAnnotation( OnDelete.class );\n \t\tboolean onDeleteAppropriate = false;\n \t\tif ( InheritanceType.JOINED.equals( inheritanceState.type ) && inheritanceState.hasParents ) {\n \t\t\tonDeleteAppropriate = true;\n \t\t\tfinal JoinedSubclass jsc = (JoinedSubclass) persistentClass;\n \t\t\tif ( persistentClass.getEntityPersisterClass() == null ) {\n \t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( JoinedSubclassEntityPersister.class );\n \t\t\t}\n \t\t\tSimpleValue key = new DependantValue( jsc.getTable(), jsc.getIdentifier() );\n \t\t\tjsc.setKey( key );\n \t\t\tForeignKey fk = annotatedClass.getAnnotation( ForeignKey.class );\n \t\t\tif ( fk != null && !BinderHelper.isDefault( fk.name() ) ) {\n \t\t\t\tkey.setForeignKeyName( fk.name() );\n \t\t\t}\n \t\t\tif ( onDeleteAnn != null ) {\n \t\t\t\tkey.setCascadeDeleteEnabled( OnDeleteAction.CASCADE.equals( onDeleteAnn.action() ) );\n \t\t\t}\n \t\t\telse {\n \t\t\t\tkey.setCascadeDeleteEnabled( false );\n \t\t\t}\n \t\t\t//we are never in a second pass at that stage, so queue it\n \t\t\tSecondPass sp = new JoinedSubclassFkSecondPass( jsc, inheritanceJoinedColumns, key, mappings );\n \t\t\tmappings.addSecondPass( sp );\n \t\t\tmappings.addSecondPass( new CreateKeySecondPass( jsc ) );\n \n \t\t}\n \t\telse if ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.type ) ) {\n \t\t\tif ( inheritanceState.hasParents ) {\n \t\t\t\tif ( persistentClass.getEntityPersisterClass() == null ) {\n \t\t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( SingleTableEntityPersister.class );\n \t\t\t\t}\n \t\t\t}\n \t\t\telse {\n \t\t\t\tif ( inheritanceState.hasSons || !discriminatorColumn.isImplicit() ) {\n \t\t\t\t\t//need a discriminator column\n \t\t\t\t\tbindDiscriminatorToPersistentClass(\n \t\t\t\t\t\t\t(RootClass) persistentClass,\n \t\t\t\t\t\t\tdiscriminatorColumn,\n \t\t\t\t\t\t\tentityBinder.getSecondaryTables(),\n \t\t\t\t\t\t\tpropertyHolder\n \t\t\t\t\t);\n \t\t\t\t\tentityBinder.bindDiscriminatorValue();//bind it again since the type might have changed\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\telse if ( InheritanceType.TABLE_PER_CLASS.equals( inheritanceState.type ) ) {\n \t\t\tif ( inheritanceState.hasParents ) {\n \t\t\t\tif ( persistentClass.getEntityPersisterClass() == null ) {\n \t\t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( UnionSubclassEntityPersister.class );\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\tif ( onDeleteAnn != null && !onDeleteAppropriate ) {\n \t\t\tlog.warn(\n \t\t\t\t\t\"Inapropriate use of @OnDelete on entity, annotation ignored: {}\", propertyHolder.getEntityName()\n \t\t\t);\n \t\t}\n \n \t\t//try to find class level generators\n \t\tHashMap<String, IdGenerator> classGenerators = buildLocalGenerators( annotatedClass, mappings );\n \n \t\t// check properties\n \t\tList<PropertyData> elements =\n \t\t\t\tgetElementsToProcess(\n \t\t\t\t\t\tpersistentClass, clazzToProcess, inheritanceStatePerClass, propertyHolder, entityBinder, mappings\n \t\t\t\t);\n \t\tif ( elements == null ) {\n \t\t\tthrow new AnnotationException( \"No identifier specified for entity: \" + propertyHolder.getEntityName() );\n \t\t}\n \t\tfinal boolean subclassAndSingleTableStrategy = inheritanceState.type == InheritanceType.SINGLE_TABLE\n \t\t\t\t&& inheritanceState.hasParents;\n \t\t//process idclass if any\n \t\tSet<String> idProperties = new HashSet<String>();\n \t\tIdClass idClass = null;\n \t\tXClass current = null;\n \t\tif ( !inheritanceState.hasParents ) {\n \t\t\t//look for idClass\n \t\t\tcurrent = inheritanceState.clazz;\n \t\t\tInheritanceState state = inheritanceState;\n \t\t\tdo {\n \t\t\t\tcurrent = state.clazz;\n \t\t\t\tif ( current.isAnnotationPresent( IdClass.class ) ) {\n \t\t\t\t\tidClass = current.getAnnotation( IdClass.class );\n \t\t\t\t\tbreak;\n \t\t\t\t}\n \t\t\t\tstate = InheritanceState.getSuperclassInheritanceState(\n \t\t\t\t\t\tcurrent, inheritanceStatePerClass, reflectionManager\n \t\t\t\t);\n \t\t\t}\n \t\t\twhile ( state != null );\n \t\t}\n \t\tif ( idClass != null ) {\n \t\t\tXClass compositeClass = reflectionManager.toXClass( idClass.value() );\n \t\t\tboolean isComponent = true;\n \t\t\tboolean propertyAnnotated = entityBinder.isPropertyAnnotated( compositeClass );\n \t\t\tString propertyAccessor = entityBinder.getPropertyAccessor( compositeClass );\n \t\t\tString generatorType = \"assigned\";\n \t\t\tString generator = BinderHelper.ANNOTATION_STRING_DEFAULT;\n \t\t\tPropertyData inferredData = new PropertyPreloadedData(\n \t\t\t\t\tentityBinder.getPropertyAccessor(), \"id\", compositeClass\n \t\t\t);\n \t\t\tPropertyData baseInferredData = new PropertyPreloadedData(\n                   entityBinder.getPropertyAccessor(), \"id\", current\n             );\n \t\t\tHashMap<String, IdGenerator> localGenerators = new HashMap<String, IdGenerator>();\n \t\t\tboolean ignoreIdAnnotations = entityBinder.isIgnoreIdAnnotations();\n \t\t\tentityBinder.setIgnoreIdAnnotations( true );\n \t\t\tbindId(\n \t\t\t\t\tgeneratorType,\n \t\t\t\t\tgenerator,\n \t\t\t\t\tinferredData,\n \t\t\t\t\tbaseInferredData,\n \t\t\t\t\tnull,\n \t\t\t\t\tpropertyHolder,\n \t\t\t\t\tlocalGenerators,\n \t\t\t\t\tisComponent,\n \t\t\t\t\tpropertyAnnotated,\n \t\t\t\t\tpropertyAccessor, entityBinder,\n \t\t\t\t\ttrue,\n \t\t\t\t\tfalse, mappings, inheritanceStatePerClass\n \t\t\t);\n \t\t\tinferredData = new PropertyPreloadedData(\n \t\t\t\t\tpropertyAccessor, \"_identifierMapper\", compositeClass\n \t\t\t);\n \t\t\tComponent mapper = fillComponent(\n \t\t\t\t\tpropertyHolder,\n \t\t\t\t\tinferredData,\n \t\t\t\t\tbaseInferredData,\n \t\t\t\t\tpropertyAnnotated,\n \t\t\t\t\tpropertyAccessor, false,\n \t\t\t\t\tentityBinder,\n \t\t\t\t\ttrue, true,\n \t\t\t\t\tfalse, mappings, inheritanceStatePerClass\n \t\t\t);\n \t\t\tentityBinder.setIgnoreIdAnnotations( ignoreIdAnnotations );\n \t\t\tpersistentClass.setIdentifierMapper( mapper );\n+\n+\t\t\t//If id definition is on a mapped superclass, update the mapping\n+\t\t\tfinal org.hibernate.mapping.MappedSuperclass superclass = BinderHelper.getMappedSuperclassOrNull(\n+\t\t\t\t\tinferredData.getDeclaringClass(),\n+\t\t\t\t\tinheritanceStatePerClass,\n+\t\t\t\t\tmappings\n+\t\t\t);\n+\t\t\tif (superclass != null) {\n+\t\t\t\tsuperclass.setDeclaredIdentifierMapper(mapper);\n+\t\t\t}\n+\t\t\telse {\n+\t\t\t\t//we are for sure on the entity\n+\t\t\t\tpersistentClass.setDeclaredIdentifierMapper( mapper );\n+\t\t\t}\n+\n \t\t\tProperty property = new Property();\n \t\t\tproperty.setName( \"_identifierMapper\" );\n \t\t\tproperty.setNodeName( \"id\" );\n \t\t\tproperty.setUpdateable( false );\n \t\t\tproperty.setInsertable( false );\n \t\t\tproperty.setValue( mapper );\n \t\t\tproperty.setPropertyAccessorName( \"embedded\" );\n \t\t\tpersistentClass.addProperty( property );\n \t\t\tentityBinder.setIgnoreIdAnnotations( true );\n \n \t\t\tIterator properties = mapper.getPropertyIterator();\n \t\t\twhile ( properties.hasNext() ) {\n \t\t\t\tidProperties.add( ( (Property) properties.next() ).getName() );\n \t\t\t}\n \t\t}\n \t\tSet<String> missingIdProperties = new HashSet<String>( idProperties );\n \t\tfor (PropertyData propertyAnnotatedElement : elements) {\n \t\t\tString propertyName = propertyAnnotatedElement.getPropertyName();\n \t\t\tif ( !idProperties.contains( propertyName ) ) {\n \t\t\t\tprocessElementAnnotations(\n \t\t\t\t\t\tpropertyHolder,\n \t\t\t\t\t\tsubclassAndSingleTableStrategy ?\n \t\t\t\t\t\t\t\tNullability.FORCED_NULL :\n \t\t\t\t\t\t\t\tNullability.NO_CONSTRAINT,\n \t\t\t\t\t\tpropertyAnnotatedElement.getProperty(),\n \t\t\t\t\t\tpropertyAnnotatedElement, classGenerators, entityBinder,\n \t\t\t\t\t\tfalse, false, false, mappings, inheritanceStatePerClass\n \t\t\t\t);\n \t\t\t}\n \t\t\telse {\n \t\t\t\tmissingIdProperties.remove( propertyName );\n \t\t\t}\n \t\t}\n \n \t\tif ( missingIdProperties.size() != 0 ) {\n \t\t\tStringBuilder missings = new StringBuilder();\n \t\t\tfor (String property : missingIdProperties) {\n \t\t\t\tmissings.append( property ).append( \", \" );\n \t\t\t}\n \t\t\tthrow new AnnotationException(\n \t\t\t\t\t\"Unable to find properties (\"\n \t\t\t\t\t\t\t+ missings.substring( 0, missings.length() - 2 )\n \t\t\t\t\t\t\t+ \") in entity annotated with @IdClass:\" + persistentClass.getEntityName()\n \t\t\t);\n \t\t}\n \n \t\tif ( !inheritanceState.hasParents ) {\n \t\t\tfinal RootClass rootClass = (RootClass) persistentClass;\n \t\t\tmappings.addSecondPass( new CreateKeySecondPass( rootClass ) );\n \t\t}\n \t\telse {\n \t\t\tsuperEntity.addSubclass( (Subclass) persistentClass );\n \t\t}\n \n \t\tmappings.addClass( persistentClass );\n \n \t\t//Process secondary tables and complementary definitions (ie o.h.a.Table)\n \t\tmappings.addSecondPass( new SecondaryTableSecondPass( entityBinder, propertyHolder, annotatedClass ) );\n \n \t\t//add process complementary Table definition (index & all)\n \t\tentityBinder.processComplementaryTableDefinitions( annotatedClass.getAnnotation( org.hibernate.annotations.Table.class ) );\n \t\tentityBinder.processComplementaryTableDefinitions( annotatedClass.getAnnotation( org.hibernate.annotations.Tables.class ) );\n \n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"c7c6981a558e35f01ff8d27938e98aa83896765c": {
			"type": "Ybodychange",
			"commitMessage": "HHH-4533 add representation for @MappedSuperclass in the Hibernate Core metamodel and properly populate this model extension in Hibernate Annotations\n\ngit-svn-id: https://svn.jboss.org/repos/hibernate/core/trunk@17871 1b8cb986-b30d-0410-93ca-fae66ebed9b2\n",
			"commitDate": "2009-10-28, 11:14 AM",
			"commitName": "c7c6981a558e35f01ff8d27938e98aa83896765c",
			"commitAuthor": "Emmanuel Bernard",
			"commitDateOld": "2009-10-28, 3:57 AM",
			"commitNameOld": "a1e8d7cb0dcb4bd58fc5d210031bd0fb28196034",
			"commitAuthorOld": "Sharath Reddy",
			"daysBetweenCommits": 0.3,
			"commitsBetweenForRepo": 5,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,415 +1,416 @@\n \tpublic static void bindClass(\n \t\t\tXClass clazzToProcess, Map<XClass, InheritanceState> inheritanceStatePerClass, ExtendedMappings mappings\n \t) throws MappingException {\n \t\t//TODO: be more strict with secondarytable allowance (not for ids, not for secondary table join columns etc)\n \t\tInheritanceState inheritanceState = inheritanceStatePerClass.get( clazzToProcess );\n \t\tAnnotatedClassType classType = mappings.getClassType( clazzToProcess );\n \n \t\t//Queries declared in MappedSuperclass should be usable in Subclasses\n \t\tif ( AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals( classType ) ) {\n \t\t\tbindQueries( clazzToProcess, mappings );\n \t\t\tbindTypeDefs(clazzToProcess, mappings);\n \t\t\tbindFilterDefs(clazzToProcess, mappings);\n \t\t}\n \n \t\tif ( AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals( classType ) //will be processed by their subentities\n \t\t\t\t|| AnnotatedClassType.NONE.equals( classType ) //to be ignored\n \t\t\t\t|| AnnotatedClassType.EMBEDDABLE.equals( classType ) //allow embeddable element declaration\n \t\t\t\t) {\n \t\t\tif ( AnnotatedClassType.NONE.equals( classType )\n \t\t\t\t\t&& clazzToProcess.isAnnotationPresent( org.hibernate.annotations.Entity.class ) ) {\n \t\t\t\tlog.warn( \"Class annotated @org.hibernate.annotations.Entity but not javax.persistence.Entity \"\n \t\t\t\t\t\t+ \"(most likely a user error): {}\", clazzToProcess.getName() );\n \t\t\t}\n \t\t\treturn;\n \t\t}\n \t\tif ( !classType.equals( AnnotatedClassType.ENTITY ) ) {\n \t\t\t//TODO make this test accurate by removing the none elements artifically added\n \t\t\tthrow new AnnotationException(\n \t\t\t\t\t\"Annotated class should have a @javax.persistence.Entity, @javax.persistence.Embeddable or @javax.persistence.EmbeddedSuperclass annotation: \" + clazzToProcess\n \t\t\t\t\t\t\t.getName()\n \t\t\t);\n \t\t}\n \t\tXAnnotatedElement annotatedClass = clazzToProcess;\n \t\tlog.info( \"Binding entity from annotated class: {}\", clazzToProcess.getName() );\n+\t\tfinal ReflectionManager reflectionManager = mappings.getReflectionManager();\n \t\tInheritanceState superEntityState =\n \t\t\t\tInheritanceState.getSuperEntityInheritanceState(\n-\t\t\t\t\t\tclazzToProcess, inheritanceStatePerClass, mappings.getReflectionManager()\n+\t\t\t\t\t\tclazzToProcess, inheritanceStatePerClass, reflectionManager\n \t\t\t\t);\n \t\tPersistentClass superEntity = superEntityState != null ?\n \t\t\t\tmappings.getClass(\n \t\t\t\t\t\tsuperEntityState.clazz.getName()\n \t\t\t\t) :\n \t\t\t\tnull;\n \t\tif ( superEntity == null ) {\n \t\t\t//check if superclass is not a potential persistent class\n \t\t\tif ( inheritanceState.hasParents ) {\n \t\t\t\tthrow new AssertionFailure(\n \t\t\t\t\t\t\"Subclass has to be binded after it's mother class: \"\n \t\t\t\t\t\t\t\t+ superEntityState.clazz.getName()\n \t\t\t\t);\n \t\t\t}\n \t\t}\n \t\tbindQueries( annotatedClass, mappings );\n \t\tbindFilterDefs( annotatedClass, mappings );\n \t\tbindTypeDefs( annotatedClass, mappings );\n \t\tBinderHelper.bindAnyMetaDefs( annotatedClass, mappings );\n \n \t\tString schema = \"\";\n \t\tString table = \"\"; //might be no @Table annotation on the annotated class\n \t\tString catalog = \"\";\n \t\tString discrimValue = null;\n \t\tList<String[]> uniqueConstraints = new ArrayList<String[]>();\n \t\tEjb3DiscriminatorColumn discriminatorColumn = null;\n \t\tEjb3JoinColumn[] inheritanceJoinedColumns = null;\n \n \t\tif ( annotatedClass.isAnnotationPresent( javax.persistence.Table.class ) ) {\n \t\t\tjavax.persistence.Table tabAnn = annotatedClass.getAnnotation( javax.persistence.Table.class );\n \t\t\ttable = tabAnn.name();\n \t\t\tschema = tabAnn.schema();\n \t\t\tcatalog = tabAnn.catalog();\n \t\t\tuniqueConstraints = TableBinder.buildUniqueConstraints( tabAnn.uniqueConstraints() );\n \t\t}\n \t\tfinal boolean hasJoinedColumns = inheritanceState.hasParents\n \t\t\t\t&& InheritanceType.JOINED.equals( inheritanceState.type );\n \t\tif ( hasJoinedColumns ) {\n \t\t\t//@Inheritance(JOINED) subclass need to link back to the super entity\n \t\t\tPrimaryKeyJoinColumns jcsAnn = annotatedClass.getAnnotation( PrimaryKeyJoinColumns.class );\n \t\t\tboolean explicitInheritanceJoinedColumns = jcsAnn != null && jcsAnn.value().length != 0;\n \t\t\tif ( explicitInheritanceJoinedColumns ) {\n \t\t\t\tint nbrOfInhJoinedColumns = jcsAnn.value().length;\n \t\t\t\tPrimaryKeyJoinColumn jcAnn;\n \t\t\t\tinheritanceJoinedColumns = new Ejb3JoinColumn[nbrOfInhJoinedColumns];\n \t\t\t\tfor (int colIndex = 0; colIndex < nbrOfInhJoinedColumns; colIndex++) {\n \t\t\t\t\tjcAnn = jcsAnn.value()[colIndex];\n \t\t\t\t\tinheritanceJoinedColumns[colIndex] = Ejb3JoinColumn.buildJoinColumn(\n \t\t\t\t\t\t\tjcAnn, null, superEntity.getIdentifier(),\n \t\t\t\t\t\t\t(Map<String, Join>) null, (PropertyHolder) null, mappings\n \t\t\t\t\t);\n \t\t\t\t}\n \t\t\t}\n \t\t\telse {\n \t\t\t\tPrimaryKeyJoinColumn jcAnn = annotatedClass.getAnnotation( PrimaryKeyJoinColumn.class );\n \t\t\t\tinheritanceJoinedColumns = new Ejb3JoinColumn[1];\n \t\t\t\tinheritanceJoinedColumns[0] = Ejb3JoinColumn.buildJoinColumn(\n \t\t\t\t\t\tjcAnn, null, superEntity.getIdentifier(),\n \t\t\t\t\t\t(Map<String, Join>) null, (PropertyHolder) null, mappings\n \t\t\t\t);\n \t\t\t}\n \t\t\tlog.debug( \"Subclass joined column(s) created\" );\n \t\t}\n \t\telse {\n \t\t\tif ( annotatedClass.isAnnotationPresent( javax.persistence.PrimaryKeyJoinColumns.class )\n \t\t\t\t\t|| annotatedClass.isAnnotationPresent( javax.persistence.PrimaryKeyJoinColumn.class ) ) {\n \t\t\t\tlog.warn( \"Root entity should not hold an PrimaryKeyJoinColum(s), will be ignored\" );\n \t\t\t}\n \t\t}\n \n \t\tif ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.type ) ) {\n \t\t\tjavax.persistence.DiscriminatorColumn discAnn = annotatedClass.getAnnotation(\n \t\t\t\t\tjavax.persistence.DiscriminatorColumn.class\n \t\t\t);\n \t\t\tDiscriminatorType discriminatorType = discAnn != null ?\n \t\t\t\t\tdiscAnn.discriminatorType() :\n \t\t\t\t\tDiscriminatorType.STRING;\n \n \t\t\torg.hibernate.annotations.DiscriminatorFormula discFormulaAnn = annotatedClass.getAnnotation(\n \t\t\t\t\torg.hibernate.annotations.DiscriminatorFormula.class\n \t\t\t);\n \t\t\tif ( !inheritanceState.hasParents ) {\n \t\t\t\tdiscriminatorColumn = Ejb3DiscriminatorColumn.buildDiscriminatorColumn(\n \t\t\t\t\t\tdiscriminatorType, discAnn, discFormulaAnn, mappings\n \t\t\t\t);\n \t\t\t}\n \t\t\tif ( discAnn != null && inheritanceState.hasParents ) {\n \t\t\t\tlog.warn(\n \t\t\t\t\t\t\"Discriminator column has to be defined in the root entity, it will be ignored in subclass: {}\",\n \t\t\t\t\t\tclazzToProcess.getName()\n \t\t\t\t);\n \t\t\t}\n \t\t\tdiscrimValue = annotatedClass.isAnnotationPresent( DiscriminatorValue.class ) ?\n \t\t\t\t\tannotatedClass.getAnnotation( DiscriminatorValue.class ).value() :\n \t\t\t\t\tnull;\n \t\t}\n \n \t\t//we now know what kind of persistent entity it is\n \t\tPersistentClass persistentClass;\n \t\t//create persistent class\n \t\tif ( !inheritanceState.hasParents ) {\n \t\t\tpersistentClass = new RootClass();\n \t\t}\n \t\telse if ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.type ) ) {\n \t\t\tpersistentClass = new SingleTableSubclass( superEntity );\n \t\t}\n \t\telse if ( InheritanceType.JOINED.equals( inheritanceState.type ) ) {\n \t\t\tpersistentClass = new JoinedSubclass( superEntity );\n \t\t}\n \t\telse if ( InheritanceType.TABLE_PER_CLASS.equals( inheritanceState.type ) ) {\n \t\t\tpersistentClass = new UnionSubclass( superEntity );\n \t\t}\n \t\telse {\n \t\t\tthrow new AssertionFailure( \"Unknown inheritance type: \" + inheritanceState.type );\n \t\t}\n \t\tProxy proxyAnn = annotatedClass.getAnnotation( Proxy.class );\n \t\tBatchSize sizeAnn = annotatedClass.getAnnotation( BatchSize.class );\n \t\tWhere whereAnn = annotatedClass.getAnnotation( Where.class );\n \t\tEntity entityAnn = annotatedClass.getAnnotation( Entity.class );\n \t\torg.hibernate.annotations.Entity hibEntityAnn = annotatedClass.getAnnotation(\n \t\t\t\torg.hibernate.annotations.Entity.class\n \t\t);\n \t\torg.hibernate.annotations.Cache cacheAnn = annotatedClass.getAnnotation(\n \t\t\t\torg.hibernate.annotations.Cache.class\n \t\t);\n \t\tEntityBinder entityBinder = new EntityBinder(\n \t\t\t\tentityAnn, hibEntityAnn, clazzToProcess, persistentClass, mappings\n \t\t);\n \t\tentityBinder.setDiscriminatorValue( discrimValue );\n \t\tentityBinder.setBatchSize( sizeAnn );\n \t\tentityBinder.setProxy( proxyAnn );\n \t\tentityBinder.setWhere( whereAnn );\n \t\tentityBinder.setCache( cacheAnn );\n \t\tentityBinder.setInheritanceState( inheritanceState );\n \t\t\n \t\t//Filters are not allowed on subclasses\n \t\tif ( !inheritanceState.hasParents ) {\n \t\t\tbindFilters(clazzToProcess, entityBinder, mappings);\n \t\t}\n \t\t\n \t\tentityBinder.bindEntity();\n \n \t\tif ( inheritanceState.hasTable() ) {\n \t\t\tCheck checkAnn = annotatedClass.getAnnotation( Check.class );\n \t\t\tString constraints = checkAnn == null ?\n \t\t\t\t\tnull :\n \t\t\t\t\tcheckAnn.constraints();\n \t\t\tentityBinder.bindTable(\n \t\t\t\t\tschema, catalog, table, uniqueConstraints,\n \t\t\t\t\tconstraints, inheritanceState.hasDenormalizedTable() ?\n \t\t\t\t\tsuperEntity.getTable() :\n \t\t\t\t\tnull\n \t\t\t);\n \t\t}\n \t\telse {\n \t\t\tif ( annotatedClass.isAnnotationPresent( Table.class ) ) {\n \t\t\t\tlog.warn( \"Illegal use of @Table in a subclass of a SINGLE_TABLE hierarchy: \" + clazzToProcess\n \t\t\t\t\t\t.getName() );\n \t\t\t}\n \t\t}\n //\t\tMap<String, Column[]> columnOverride = PropertyHolderBuilder.buildHierarchyColumnOverride(\n //\t\t\t\tclazzToProcess,\n //\t\t\t\tpersistentClass.getClassName()\n //\t\t);\n \t\tPropertyHolder propertyHolder = PropertyHolderBuilder.buildPropertyHolder(\n \t\t\t\tclazzToProcess,\n \t\t\t\tpersistentClass,\n-\t\t\t\tentityBinder, mappings\n+\t\t\t\tentityBinder, mappings, inheritanceStatePerClass\n \t\t);\n \n \t\tjavax.persistence.SecondaryTable secTabAnn = annotatedClass.getAnnotation(\n \t\t\t\tjavax.persistence.SecondaryTable.class\n \t\t);\n \t\tjavax.persistence.SecondaryTables secTabsAnn = annotatedClass.getAnnotation(\n \t\t\t\tjavax.persistence.SecondaryTables.class\n \t\t);\n \t\tentityBinder.firstLevelSecondaryTablesBinding( secTabAnn, secTabsAnn );\n \n \t\tOnDelete onDeleteAnn = annotatedClass.getAnnotation( OnDelete.class );\n \t\tboolean onDeleteAppropriate = false;\n \t\tif ( InheritanceType.JOINED.equals( inheritanceState.type ) && inheritanceState.hasParents ) {\n \t\t\tonDeleteAppropriate = true;\n \t\t\tfinal JoinedSubclass jsc = (JoinedSubclass) persistentClass;\n \t\t\tif ( persistentClass.getEntityPersisterClass() == null ) {\n \t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( JoinedSubclassEntityPersister.class );\n \t\t\t}\n \t\t\tSimpleValue key = new DependantValue( jsc.getTable(), jsc.getIdentifier() );\n \t\t\tjsc.setKey( key );\n \t\t\tForeignKey fk = annotatedClass.getAnnotation( ForeignKey.class );\n \t\t\tif ( fk != null && !BinderHelper.isDefault( fk.name() ) ) {\n \t\t\t\tkey.setForeignKeyName( fk.name() );\n \t\t\t}\n \t\t\tif ( onDeleteAnn != null ) {\n \t\t\t\tkey.setCascadeDeleteEnabled( OnDeleteAction.CASCADE.equals( onDeleteAnn.action() ) );\n \t\t\t}\n \t\t\telse {\n \t\t\t\tkey.setCascadeDeleteEnabled( false );\n \t\t\t}\n \t\t\t//we are never in a second pass at that stage, so queue it\n \t\t\tSecondPass sp = new JoinedSubclassFkSecondPass( jsc, inheritanceJoinedColumns, key, mappings );\n \t\t\tmappings.addSecondPass( sp );\n \t\t\tmappings.addSecondPass( new CreateKeySecondPass( jsc ) );\n \n \t\t}\n \t\telse if ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.type ) ) {\n \t\t\tif ( inheritanceState.hasParents ) {\n \t\t\t\tif ( persistentClass.getEntityPersisterClass() == null ) {\n \t\t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( SingleTableEntityPersister.class );\n \t\t\t\t}\n \t\t\t}\n \t\t\telse {\n \t\t\t\tif ( inheritanceState.hasSons || !discriminatorColumn.isImplicit() ) {\n \t\t\t\t\t//need a discriminator column\n \t\t\t\t\tbindDiscriminatorToPersistentClass(\n \t\t\t\t\t\t\t(RootClass) persistentClass,\n \t\t\t\t\t\t\tdiscriminatorColumn,\n \t\t\t\t\t\t\tentityBinder.getSecondaryTables(),\n \t\t\t\t\t\t\tpropertyHolder\n \t\t\t\t\t);\n \t\t\t\t\tentityBinder.bindDiscriminatorValue();//bind it again since the type might have changed\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\telse if ( InheritanceType.TABLE_PER_CLASS.equals( inheritanceState.type ) ) {\n \t\t\tif ( inheritanceState.hasParents ) {\n \t\t\t\tif ( persistentClass.getEntityPersisterClass() == null ) {\n \t\t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( UnionSubclassEntityPersister.class );\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\tif ( onDeleteAnn != null && !onDeleteAppropriate ) {\n \t\t\tlog.warn(\n \t\t\t\t\t\"Inapropriate use of @OnDelete on entity, annotation ignored: {}\", propertyHolder.getEntityName()\n \t\t\t);\n \t\t}\n \n \t\t//try to find class level generators\n \t\tHashMap<String, IdGenerator> classGenerators = buildLocalGenerators( annotatedClass, mappings );\n \n \t\t// check properties\n \t\tList<PropertyData> elements =\n \t\t\t\tgetElementsToProcess(\n-\t\t\t\t\t\tclazzToProcess, inheritanceStatePerClass, propertyHolder, entityBinder, mappings\n+\t\t\t\t\t\tpersistentClass, clazzToProcess, inheritanceStatePerClass, propertyHolder, entityBinder, mappings\n \t\t\t\t);\n \t\tif ( elements == null ) {\n \t\t\tthrow new AnnotationException( \"No identifier specified for entity: \" + propertyHolder.getEntityName() );\n \t\t}\n \t\tfinal boolean subclassAndSingleTableStrategy = inheritanceState.type == InheritanceType.SINGLE_TABLE\n \t\t\t\t&& inheritanceState.hasParents;\n \t\t//process idclass if any\n \t\tSet<String> idProperties = new HashSet<String>();\n \t\tIdClass idClass = null;\n \t\tXClass current = null;\n \t\tif ( !inheritanceState.hasParents ) {\n \t\t\t//look for idClass\n \t\t\tcurrent = inheritanceState.clazz;\n \t\t\tInheritanceState state = inheritanceState;\n \t\t\tdo {\n \t\t\t\tcurrent = state.clazz;\n \t\t\t\tif ( current.isAnnotationPresent( IdClass.class ) ) {\n \t\t\t\t\tidClass = current.getAnnotation( IdClass.class );\n \t\t\t\t\tbreak;\n \t\t\t\t}\n \t\t\t\tstate = InheritanceState.getSuperclassInheritanceState(\n-\t\t\t\t\t\tcurrent, inheritanceStatePerClass, mappings.getReflectionManager()\n+\t\t\t\t\t\tcurrent, inheritanceStatePerClass, reflectionManager\n \t\t\t\t);\n \t\t\t}\n \t\t\twhile ( state != null );\n \t\t}\n \t\tif ( idClass != null ) {\n-\t\t\tXClass compositeClass = mappings.getReflectionManager().toXClass( idClass.value() );\n+\t\t\tXClass compositeClass = reflectionManager.toXClass( idClass.value() );\n \t\t\tboolean isComponent = true;\n \t\t\tboolean propertyAnnotated = entityBinder.isPropertyAnnotated( compositeClass );\n \t\t\tString propertyAccessor = entityBinder.getPropertyAccessor( compositeClass );\n \t\t\tString generatorType = \"assigned\";\n \t\t\tString generator = BinderHelper.ANNOTATION_STRING_DEFAULT;\n \t\t\tPropertyData inferredData = new PropertyPreloadedData(\n \t\t\t\t\tentityBinder.getPropertyAccessor(), \"id\", compositeClass\n \t\t\t);\n \t\t\tPropertyData baseInferredData = new PropertyPreloadedData(\n                   entityBinder.getPropertyAccessor(), \"id\", current\n             );\n \t\t\tHashMap<String, IdGenerator> localGenerators = new HashMap<String, IdGenerator>();\n \t\t\tboolean ignoreIdAnnotations = entityBinder.isIgnoreIdAnnotations();\n \t\t\tentityBinder.setIgnoreIdAnnotations( true );\n \t\t\tbindId(\n \t\t\t\t\tgeneratorType,\n \t\t\t\t\tgenerator,\n \t\t\t\t\tinferredData,\n \t\t\t\t\tbaseInferredData,\n \t\t\t\t\tnull,\n \t\t\t\t\tpropertyHolder,\n \t\t\t\t\tlocalGenerators,\n \t\t\t\t\tisComponent,\n \t\t\t\t\tpropertyAnnotated,\n \t\t\t\t\tpropertyAccessor, entityBinder,\n \t\t\t\t\ttrue,\n-\t\t\t\t\tfalse, mappings\n+\t\t\t\t\tfalse, mappings, inheritanceStatePerClass\n \t\t\t);\n \t\t\tinferredData = new PropertyPreloadedData(\n \t\t\t\t\tpropertyAccessor, \"_identifierMapper\", compositeClass\n \t\t\t);\n \t\t\tComponent mapper = fillComponent(\n \t\t\t\t\tpropertyHolder,\n \t\t\t\t\tinferredData,\n \t\t\t\t\tbaseInferredData,\n \t\t\t\t\tpropertyAnnotated,\n \t\t\t\t\tpropertyAccessor, false,\n \t\t\t\t\tentityBinder,\n \t\t\t\t\ttrue, true,\n-\t\t\t\t\tfalse, mappings\n+\t\t\t\t\tfalse, mappings, inheritanceStatePerClass\n \t\t\t);\n \t\t\tentityBinder.setIgnoreIdAnnotations( ignoreIdAnnotations );\n \t\t\tpersistentClass.setIdentifierMapper( mapper );\n \t\t\tProperty property = new Property();\n \t\t\tproperty.setName( \"_identifierMapper\" );\n \t\t\tproperty.setNodeName( \"id\" );\n \t\t\tproperty.setUpdateable( false );\n \t\t\tproperty.setInsertable( false );\n \t\t\tproperty.setValue( mapper );\n \t\t\tproperty.setPropertyAccessorName( \"embedded\" );\n \t\t\tpersistentClass.addProperty( property );\n \t\t\tentityBinder.setIgnoreIdAnnotations( true );\n \n \t\t\tIterator properties = mapper.getPropertyIterator();\n \t\t\twhile ( properties.hasNext() ) {\n \t\t\t\tidProperties.add( ( (Property) properties.next() ).getName() );\n \t\t\t}\n \t\t}\n \t\tSet<String> missingIdProperties = new HashSet<String>( idProperties );\n \t\tfor (PropertyData propertyAnnotatedElement : elements) {\n \t\t\tString propertyName = propertyAnnotatedElement.getPropertyName();\n \t\t\tif ( !idProperties.contains( propertyName ) ) {\n \t\t\t\tprocessElementAnnotations(\n \t\t\t\t\t\tpropertyHolder,\n \t\t\t\t\t\tsubclassAndSingleTableStrategy ?\n \t\t\t\t\t\t\t\tNullability.FORCED_NULL :\n \t\t\t\t\t\t\t\tNullability.NO_CONSTRAINT,\n \t\t\t\t\t\tpropertyAnnotatedElement.getProperty(),\n \t\t\t\t\t\tpropertyAnnotatedElement, classGenerators, entityBinder,\n-\t\t\t\t\t\tfalse, false, false, mappings\n+\t\t\t\t\t\tfalse, false, false, mappings, inheritanceStatePerClass\n \t\t\t\t);\n \t\t\t}\n \t\t\telse {\n \t\t\t\tmissingIdProperties.remove( propertyName );\n \t\t\t}\n \t\t}\n \n \t\tif ( missingIdProperties.size() != 0 ) {\n \t\t\tStringBuilder missings = new StringBuilder();\n \t\t\tfor (String property : missingIdProperties) {\n \t\t\t\tmissings.append( property ).append( \", \" );\n \t\t\t}\n \t\t\tthrow new AnnotationException(\n \t\t\t\t\t\"Unable to find properties (\"\n \t\t\t\t\t\t\t+ missings.substring( 0, missings.length() - 2 )\n \t\t\t\t\t\t\t+ \") in entity annotated with @IdClass:\" + persistentClass.getEntityName()\n \t\t\t);\n \t\t}\n \n \t\tif ( !inheritanceState.hasParents ) {\n \t\t\tfinal RootClass rootClass = (RootClass) persistentClass;\n \t\t\tmappings.addSecondPass( new CreateKeySecondPass( rootClass ) );\n \t\t}\n \t\telse {\n \t\t\tsuperEntity.addSubclass( (Subclass) persistentClass );\n \t\t}\n \n \t\tmappings.addClass( persistentClass );\n \n \t\t//Process secondary tables and complementary definitions (ie o.h.a.Table)\n \t\tmappings.addSecondPass( new SecondaryTableSecondPass( entityBinder, propertyHolder, annotatedClass ) );\n \n \t\t//add process complementary Table definition (index & all)\n \t\tentityBinder.processComplementaryTableDefinitions( annotatedClass.getAnnotation( org.hibernate.annotations.Table.class ) );\n \t\tentityBinder.processComplementaryTableDefinitions( annotatedClass.getAnnotation( org.hibernate.annotations.Tables.class ) );\n \n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"a1e8d7cb0dcb4bd58fc5d210031bd0fb28196034": {
			"type": "Ybodychange",
			"commitMessage": "HHH-4332 Filters for MappedSuperClass\n\n\ngit-svn-id: https://svn.jboss.org/repos/hibernate/core/trunk@17859 1b8cb986-b30d-0410-93ca-fae66ebed9b2\n",
			"commitDate": "2009-10-28, 3:57 AM",
			"commitName": "a1e8d7cb0dcb4bd58fc5d210031bd0fb28196034",
			"commitAuthor": "Sharath Reddy",
			"commitDateOld": "2009-10-27, 8:05 AM",
			"commitNameOld": "2176af11442c702aefa1900cdba4c32e6338b620",
			"commitAuthorOld": "Hardy Ferentschik",
			"daysBetweenCommits": 0.83,
			"commitsBetweenForRepo": 4,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,418 +1,415 @@\n \tpublic static void bindClass(\n \t\t\tXClass clazzToProcess, Map<XClass, InheritanceState> inheritanceStatePerClass, ExtendedMappings mappings\n \t) throws MappingException {\n \t\t//TODO: be more strict with secondarytable allowance (not for ids, not for secondary table join columns etc)\n \t\tInheritanceState inheritanceState = inheritanceStatePerClass.get( clazzToProcess );\n \t\tAnnotatedClassType classType = mappings.getClassType( clazzToProcess );\n \n \t\t//Queries declared in MappedSuperclass should be usable in Subclasses\n \t\tif ( AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals( classType ) ) {\n \t\t\tbindQueries( clazzToProcess, mappings );\n \t\t\tbindTypeDefs(clazzToProcess, mappings);\n+\t\t\tbindFilterDefs(clazzToProcess, mappings);\n \t\t}\n \n \t\tif ( AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals( classType ) //will be processed by their subentities\n \t\t\t\t|| AnnotatedClassType.NONE.equals( classType ) //to be ignored\n \t\t\t\t|| AnnotatedClassType.EMBEDDABLE.equals( classType ) //allow embeddable element declaration\n \t\t\t\t) {\n \t\t\tif ( AnnotatedClassType.NONE.equals( classType )\n \t\t\t\t\t&& clazzToProcess.isAnnotationPresent( org.hibernate.annotations.Entity.class ) ) {\n \t\t\t\tlog.warn( \"Class annotated @org.hibernate.annotations.Entity but not javax.persistence.Entity \"\n \t\t\t\t\t\t+ \"(most likely a user error): {}\", clazzToProcess.getName() );\n \t\t\t}\n \t\t\treturn;\n \t\t}\n \t\tif ( !classType.equals( AnnotatedClassType.ENTITY ) ) {\n \t\t\t//TODO make this test accurate by removing the none elements artifically added\n \t\t\tthrow new AnnotationException(\n \t\t\t\t\t\"Annotated class should have a @javax.persistence.Entity, @javax.persistence.Embeddable or @javax.persistence.EmbeddedSuperclass annotation: \" + clazzToProcess\n \t\t\t\t\t\t\t.getName()\n \t\t\t);\n \t\t}\n \t\tXAnnotatedElement annotatedClass = clazzToProcess;\n \t\tlog.info( \"Binding entity from annotated class: {}\", clazzToProcess.getName() );\n \t\tInheritanceState superEntityState =\n \t\t\t\tInheritanceState.getSuperEntityInheritanceState(\n \t\t\t\t\t\tclazzToProcess, inheritanceStatePerClass, mappings.getReflectionManager()\n \t\t\t\t);\n \t\tPersistentClass superEntity = superEntityState != null ?\n \t\t\t\tmappings.getClass(\n \t\t\t\t\t\tsuperEntityState.clazz.getName()\n \t\t\t\t) :\n \t\t\t\tnull;\n \t\tif ( superEntity == null ) {\n \t\t\t//check if superclass is not a potential persistent class\n \t\t\tif ( inheritanceState.hasParents ) {\n \t\t\t\tthrow new AssertionFailure(\n \t\t\t\t\t\t\"Subclass has to be binded after it's mother class: \"\n \t\t\t\t\t\t\t\t+ superEntityState.clazz.getName()\n \t\t\t\t);\n \t\t\t}\n \t\t}\n \t\tbindQueries( annotatedClass, mappings );\n \t\tbindFilterDefs( annotatedClass, mappings );\n \t\tbindTypeDefs( annotatedClass, mappings );\n \t\tBinderHelper.bindAnyMetaDefs( annotatedClass, mappings );\n \n \t\tString schema = \"\";\n \t\tString table = \"\"; //might be no @Table annotation on the annotated class\n \t\tString catalog = \"\";\n \t\tString discrimValue = null;\n \t\tList<String[]> uniqueConstraints = new ArrayList<String[]>();\n \t\tEjb3DiscriminatorColumn discriminatorColumn = null;\n \t\tEjb3JoinColumn[] inheritanceJoinedColumns = null;\n \n \t\tif ( annotatedClass.isAnnotationPresent( javax.persistence.Table.class ) ) {\n \t\t\tjavax.persistence.Table tabAnn = annotatedClass.getAnnotation( javax.persistence.Table.class );\n \t\t\ttable = tabAnn.name();\n \t\t\tschema = tabAnn.schema();\n \t\t\tcatalog = tabAnn.catalog();\n \t\t\tuniqueConstraints = TableBinder.buildUniqueConstraints( tabAnn.uniqueConstraints() );\n \t\t}\n \t\tfinal boolean hasJoinedColumns = inheritanceState.hasParents\n \t\t\t\t&& InheritanceType.JOINED.equals( inheritanceState.type );\n \t\tif ( hasJoinedColumns ) {\n \t\t\t//@Inheritance(JOINED) subclass need to link back to the super entity\n \t\t\tPrimaryKeyJoinColumns jcsAnn = annotatedClass.getAnnotation( PrimaryKeyJoinColumns.class );\n \t\t\tboolean explicitInheritanceJoinedColumns = jcsAnn != null && jcsAnn.value().length != 0;\n \t\t\tif ( explicitInheritanceJoinedColumns ) {\n \t\t\t\tint nbrOfInhJoinedColumns = jcsAnn.value().length;\n \t\t\t\tPrimaryKeyJoinColumn jcAnn;\n \t\t\t\tinheritanceJoinedColumns = new Ejb3JoinColumn[nbrOfInhJoinedColumns];\n \t\t\t\tfor (int colIndex = 0; colIndex < nbrOfInhJoinedColumns; colIndex++) {\n \t\t\t\t\tjcAnn = jcsAnn.value()[colIndex];\n \t\t\t\t\tinheritanceJoinedColumns[colIndex] = Ejb3JoinColumn.buildJoinColumn(\n \t\t\t\t\t\t\tjcAnn, null, superEntity.getIdentifier(),\n \t\t\t\t\t\t\t(Map<String, Join>) null, (PropertyHolder) null, mappings\n \t\t\t\t\t);\n \t\t\t\t}\n \t\t\t}\n \t\t\telse {\n \t\t\t\tPrimaryKeyJoinColumn jcAnn = annotatedClass.getAnnotation( PrimaryKeyJoinColumn.class );\n \t\t\t\tinheritanceJoinedColumns = new Ejb3JoinColumn[1];\n \t\t\t\tinheritanceJoinedColumns[0] = Ejb3JoinColumn.buildJoinColumn(\n \t\t\t\t\t\tjcAnn, null, superEntity.getIdentifier(),\n \t\t\t\t\t\t(Map<String, Join>) null, (PropertyHolder) null, mappings\n \t\t\t\t);\n \t\t\t}\n \t\t\tlog.debug( \"Subclass joined column(s) created\" );\n \t\t}\n \t\telse {\n \t\t\tif ( annotatedClass.isAnnotationPresent( javax.persistence.PrimaryKeyJoinColumns.class )\n \t\t\t\t\t|| annotatedClass.isAnnotationPresent( javax.persistence.PrimaryKeyJoinColumn.class ) ) {\n \t\t\t\tlog.warn( \"Root entity should not hold an PrimaryKeyJoinColum(s), will be ignored\" );\n \t\t\t}\n \t\t}\n \n \t\tif ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.type ) ) {\n \t\t\tjavax.persistence.DiscriminatorColumn discAnn = annotatedClass.getAnnotation(\n \t\t\t\t\tjavax.persistence.DiscriminatorColumn.class\n \t\t\t);\n \t\t\tDiscriminatorType discriminatorType = discAnn != null ?\n \t\t\t\t\tdiscAnn.discriminatorType() :\n \t\t\t\t\tDiscriminatorType.STRING;\n \n \t\t\torg.hibernate.annotations.DiscriminatorFormula discFormulaAnn = annotatedClass.getAnnotation(\n \t\t\t\t\torg.hibernate.annotations.DiscriminatorFormula.class\n \t\t\t);\n \t\t\tif ( !inheritanceState.hasParents ) {\n \t\t\t\tdiscriminatorColumn = Ejb3DiscriminatorColumn.buildDiscriminatorColumn(\n \t\t\t\t\t\tdiscriminatorType, discAnn, discFormulaAnn, mappings\n \t\t\t\t);\n \t\t\t}\n \t\t\tif ( discAnn != null && inheritanceState.hasParents ) {\n \t\t\t\tlog.warn(\n \t\t\t\t\t\t\"Discriminator column has to be defined in the root entity, it will be ignored in subclass: {}\",\n \t\t\t\t\t\tclazzToProcess.getName()\n \t\t\t\t);\n \t\t\t}\n \t\t\tdiscrimValue = annotatedClass.isAnnotationPresent( DiscriminatorValue.class ) ?\n \t\t\t\t\tannotatedClass.getAnnotation( DiscriminatorValue.class ).value() :\n \t\t\t\t\tnull;\n \t\t}\n \n \t\t//we now know what kind of persistent entity it is\n \t\tPersistentClass persistentClass;\n \t\t//create persistent class\n \t\tif ( !inheritanceState.hasParents ) {\n \t\t\tpersistentClass = new RootClass();\n \t\t}\n \t\telse if ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.type ) ) {\n \t\t\tpersistentClass = new SingleTableSubclass( superEntity );\n \t\t}\n \t\telse if ( InheritanceType.JOINED.equals( inheritanceState.type ) ) {\n \t\t\tpersistentClass = new JoinedSubclass( superEntity );\n \t\t}\n \t\telse if ( InheritanceType.TABLE_PER_CLASS.equals( inheritanceState.type ) ) {\n \t\t\tpersistentClass = new UnionSubclass( superEntity );\n \t\t}\n \t\telse {\n \t\t\tthrow new AssertionFailure( \"Unknown inheritance type: \" + inheritanceState.type );\n \t\t}\n \t\tProxy proxyAnn = annotatedClass.getAnnotation( Proxy.class );\n \t\tBatchSize sizeAnn = annotatedClass.getAnnotation( BatchSize.class );\n \t\tWhere whereAnn = annotatedClass.getAnnotation( Where.class );\n \t\tEntity entityAnn = annotatedClass.getAnnotation( Entity.class );\n \t\torg.hibernate.annotations.Entity hibEntityAnn = annotatedClass.getAnnotation(\n \t\t\t\torg.hibernate.annotations.Entity.class\n \t\t);\n \t\torg.hibernate.annotations.Cache cacheAnn = annotatedClass.getAnnotation(\n \t\t\t\torg.hibernate.annotations.Cache.class\n \t\t);\n \t\tEntityBinder entityBinder = new EntityBinder(\n \t\t\t\tentityAnn, hibEntityAnn, clazzToProcess, persistentClass, mappings\n \t\t);\n \t\tentityBinder.setDiscriminatorValue( discrimValue );\n \t\tentityBinder.setBatchSize( sizeAnn );\n \t\tentityBinder.setProxy( proxyAnn );\n \t\tentityBinder.setWhere( whereAnn );\n \t\tentityBinder.setCache( cacheAnn );\n \t\tentityBinder.setInheritanceState( inheritanceState );\n-\t\tFilter filterAnn = annotatedClass.getAnnotation( Filter.class );\n-\t\tif ( filterAnn != null ) {\n-\t\t\tentityBinder.addFilter( filterAnn.name(), filterAnn.condition() );\n+\t\t\n+\t\t//Filters are not allowed on subclasses\n+\t\tif ( !inheritanceState.hasParents ) {\n+\t\t\tbindFilters(clazzToProcess, entityBinder, mappings);\n \t\t}\n-\t\tFilters filtersAnn = annotatedClass.getAnnotation( Filters.class );\n-\t\tif ( filtersAnn != null ) {\n-\t\t\tfor (Filter filter : filtersAnn.value()) {\n-\t\t\t\tentityBinder.addFilter( filter.name(), filter.condition() );\n-\t\t\t}\n-\t\t}\n+\t\t\n \t\tentityBinder.bindEntity();\n \n \t\tif ( inheritanceState.hasTable() ) {\n \t\t\tCheck checkAnn = annotatedClass.getAnnotation( Check.class );\n \t\t\tString constraints = checkAnn == null ?\n \t\t\t\t\tnull :\n \t\t\t\t\tcheckAnn.constraints();\n \t\t\tentityBinder.bindTable(\n \t\t\t\t\tschema, catalog, table, uniqueConstraints,\n \t\t\t\t\tconstraints, inheritanceState.hasDenormalizedTable() ?\n \t\t\t\t\tsuperEntity.getTable() :\n \t\t\t\t\tnull\n \t\t\t);\n \t\t}\n \t\telse {\n \t\t\tif ( annotatedClass.isAnnotationPresent( Table.class ) ) {\n \t\t\t\tlog.warn( \"Illegal use of @Table in a subclass of a SINGLE_TABLE hierarchy: \" + clazzToProcess\n \t\t\t\t\t\t.getName() );\n \t\t\t}\n \t\t}\n //\t\tMap<String, Column[]> columnOverride = PropertyHolderBuilder.buildHierarchyColumnOverride(\n //\t\t\t\tclazzToProcess,\n //\t\t\t\tpersistentClass.getClassName()\n //\t\t);\n \t\tPropertyHolder propertyHolder = PropertyHolderBuilder.buildPropertyHolder(\n \t\t\t\tclazzToProcess,\n \t\t\t\tpersistentClass,\n \t\t\t\tentityBinder, mappings\n \t\t);\n \n \t\tjavax.persistence.SecondaryTable secTabAnn = annotatedClass.getAnnotation(\n \t\t\t\tjavax.persistence.SecondaryTable.class\n \t\t);\n \t\tjavax.persistence.SecondaryTables secTabsAnn = annotatedClass.getAnnotation(\n \t\t\t\tjavax.persistence.SecondaryTables.class\n \t\t);\n \t\tentityBinder.firstLevelSecondaryTablesBinding( secTabAnn, secTabsAnn );\n \n \t\tOnDelete onDeleteAnn = annotatedClass.getAnnotation( OnDelete.class );\n \t\tboolean onDeleteAppropriate = false;\n \t\tif ( InheritanceType.JOINED.equals( inheritanceState.type ) && inheritanceState.hasParents ) {\n \t\t\tonDeleteAppropriate = true;\n \t\t\tfinal JoinedSubclass jsc = (JoinedSubclass) persistentClass;\n \t\t\tif ( persistentClass.getEntityPersisterClass() == null ) {\n \t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( JoinedSubclassEntityPersister.class );\n \t\t\t}\n \t\t\tSimpleValue key = new DependantValue( jsc.getTable(), jsc.getIdentifier() );\n \t\t\tjsc.setKey( key );\n \t\t\tForeignKey fk = annotatedClass.getAnnotation( ForeignKey.class );\n \t\t\tif ( fk != null && !BinderHelper.isDefault( fk.name() ) ) {\n \t\t\t\tkey.setForeignKeyName( fk.name() );\n \t\t\t}\n \t\t\tif ( onDeleteAnn != null ) {\n \t\t\t\tkey.setCascadeDeleteEnabled( OnDeleteAction.CASCADE.equals( onDeleteAnn.action() ) );\n \t\t\t}\n \t\t\telse {\n \t\t\t\tkey.setCascadeDeleteEnabled( false );\n \t\t\t}\n \t\t\t//we are never in a second pass at that stage, so queue it\n \t\t\tSecondPass sp = new JoinedSubclassFkSecondPass( jsc, inheritanceJoinedColumns, key, mappings );\n \t\t\tmappings.addSecondPass( sp );\n \t\t\tmappings.addSecondPass( new CreateKeySecondPass( jsc ) );\n \n \t\t}\n \t\telse if ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.type ) ) {\n \t\t\tif ( inheritanceState.hasParents ) {\n \t\t\t\tif ( persistentClass.getEntityPersisterClass() == null ) {\n \t\t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( SingleTableEntityPersister.class );\n \t\t\t\t}\n \t\t\t}\n \t\t\telse {\n \t\t\t\tif ( inheritanceState.hasSons || !discriminatorColumn.isImplicit() ) {\n \t\t\t\t\t//need a discriminator column\n \t\t\t\t\tbindDiscriminatorToPersistentClass(\n \t\t\t\t\t\t\t(RootClass) persistentClass,\n \t\t\t\t\t\t\tdiscriminatorColumn,\n \t\t\t\t\t\t\tentityBinder.getSecondaryTables(),\n \t\t\t\t\t\t\tpropertyHolder\n \t\t\t\t\t);\n \t\t\t\t\tentityBinder.bindDiscriminatorValue();//bind it again since the type might have changed\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\telse if ( InheritanceType.TABLE_PER_CLASS.equals( inheritanceState.type ) ) {\n \t\t\tif ( inheritanceState.hasParents ) {\n \t\t\t\tif ( persistentClass.getEntityPersisterClass() == null ) {\n \t\t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( UnionSubclassEntityPersister.class );\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\tif ( onDeleteAnn != null && !onDeleteAppropriate ) {\n \t\t\tlog.warn(\n \t\t\t\t\t\"Inapropriate use of @OnDelete on entity, annotation ignored: {}\", propertyHolder.getEntityName()\n \t\t\t);\n \t\t}\n \n \t\t//try to find class level generators\n \t\tHashMap<String, IdGenerator> classGenerators = buildLocalGenerators( annotatedClass, mappings );\n \n \t\t// check properties\n \t\tList<PropertyData> elements =\n \t\t\t\tgetElementsToProcess(\n \t\t\t\t\t\tclazzToProcess, inheritanceStatePerClass, propertyHolder, entityBinder, mappings\n \t\t\t\t);\n \t\tif ( elements == null ) {\n \t\t\tthrow new AnnotationException( \"No identifier specified for entity: \" + propertyHolder.getEntityName() );\n \t\t}\n \t\tfinal boolean subclassAndSingleTableStrategy = inheritanceState.type == InheritanceType.SINGLE_TABLE\n \t\t\t\t&& inheritanceState.hasParents;\n \t\t//process idclass if any\n \t\tSet<String> idProperties = new HashSet<String>();\n \t\tIdClass idClass = null;\n \t\tXClass current = null;\n \t\tif ( !inheritanceState.hasParents ) {\n \t\t\t//look for idClass\n \t\t\tcurrent = inheritanceState.clazz;\n \t\t\tInheritanceState state = inheritanceState;\n \t\t\tdo {\n \t\t\t\tcurrent = state.clazz;\n \t\t\t\tif ( current.isAnnotationPresent( IdClass.class ) ) {\n \t\t\t\t\tidClass = current.getAnnotation( IdClass.class );\n \t\t\t\t\tbreak;\n \t\t\t\t}\n \t\t\t\tstate = InheritanceState.getSuperclassInheritanceState(\n \t\t\t\t\t\tcurrent, inheritanceStatePerClass, mappings.getReflectionManager()\n \t\t\t\t);\n \t\t\t}\n \t\t\twhile ( state != null );\n \t\t}\n \t\tif ( idClass != null ) {\n \t\t\tXClass compositeClass = mappings.getReflectionManager().toXClass( idClass.value() );\n \t\t\tboolean isComponent = true;\n \t\t\tboolean propertyAnnotated = entityBinder.isPropertyAnnotated( compositeClass );\n \t\t\tString propertyAccessor = entityBinder.getPropertyAccessor( compositeClass );\n \t\t\tString generatorType = \"assigned\";\n \t\t\tString generator = BinderHelper.ANNOTATION_STRING_DEFAULT;\n \t\t\tPropertyData inferredData = new PropertyPreloadedData(\n \t\t\t\t\tentityBinder.getPropertyAccessor(), \"id\", compositeClass\n \t\t\t);\n \t\t\tPropertyData baseInferredData = new PropertyPreloadedData(\n                   entityBinder.getPropertyAccessor(), \"id\", current\n             );\n \t\t\tHashMap<String, IdGenerator> localGenerators = new HashMap<String, IdGenerator>();\n \t\t\tboolean ignoreIdAnnotations = entityBinder.isIgnoreIdAnnotations();\n \t\t\tentityBinder.setIgnoreIdAnnotations( true );\n \t\t\tbindId(\n \t\t\t\t\tgeneratorType,\n \t\t\t\t\tgenerator,\n \t\t\t\t\tinferredData,\n \t\t\t\t\tbaseInferredData,\n \t\t\t\t\tnull,\n \t\t\t\t\tpropertyHolder,\n \t\t\t\t\tlocalGenerators,\n \t\t\t\t\tisComponent,\n \t\t\t\t\tpropertyAnnotated,\n \t\t\t\t\tpropertyAccessor, entityBinder,\n \t\t\t\t\ttrue,\n \t\t\t\t\tfalse, mappings\n \t\t\t);\n \t\t\tinferredData = new PropertyPreloadedData(\n \t\t\t\t\tpropertyAccessor, \"_identifierMapper\", compositeClass\n \t\t\t);\n \t\t\tComponent mapper = fillComponent(\n \t\t\t\t\tpropertyHolder,\n \t\t\t\t\tinferredData,\n \t\t\t\t\tbaseInferredData,\n \t\t\t\t\tpropertyAnnotated,\n \t\t\t\t\tpropertyAccessor, false,\n \t\t\t\t\tentityBinder,\n \t\t\t\t\ttrue, true,\n \t\t\t\t\tfalse, mappings\n \t\t\t);\n \t\t\tentityBinder.setIgnoreIdAnnotations( ignoreIdAnnotations );\n \t\t\tpersistentClass.setIdentifierMapper( mapper );\n \t\t\tProperty property = new Property();\n \t\t\tproperty.setName( \"_identifierMapper\" );\n \t\t\tproperty.setNodeName( \"id\" );\n \t\t\tproperty.setUpdateable( false );\n \t\t\tproperty.setInsertable( false );\n \t\t\tproperty.setValue( mapper );\n \t\t\tproperty.setPropertyAccessorName( \"embedded\" );\n \t\t\tpersistentClass.addProperty( property );\n \t\t\tentityBinder.setIgnoreIdAnnotations( true );\n \n \t\t\tIterator properties = mapper.getPropertyIterator();\n \t\t\twhile ( properties.hasNext() ) {\n \t\t\t\tidProperties.add( ( (Property) properties.next() ).getName() );\n \t\t\t}\n \t\t}\n \t\tSet<String> missingIdProperties = new HashSet<String>( idProperties );\n \t\tfor (PropertyData propertyAnnotatedElement : elements) {\n \t\t\tString propertyName = propertyAnnotatedElement.getPropertyName();\n \t\t\tif ( !idProperties.contains( propertyName ) ) {\n \t\t\t\tprocessElementAnnotations(\n \t\t\t\t\t\tpropertyHolder,\n \t\t\t\t\t\tsubclassAndSingleTableStrategy ?\n \t\t\t\t\t\t\t\tNullability.FORCED_NULL :\n \t\t\t\t\t\t\t\tNullability.NO_CONSTRAINT,\n \t\t\t\t\t\tpropertyAnnotatedElement.getProperty(),\n \t\t\t\t\t\tpropertyAnnotatedElement, classGenerators, entityBinder,\n \t\t\t\t\t\tfalse, false, false, mappings\n \t\t\t\t);\n \t\t\t}\n \t\t\telse {\n \t\t\t\tmissingIdProperties.remove( propertyName );\n \t\t\t}\n \t\t}\n \n \t\tif ( missingIdProperties.size() != 0 ) {\n \t\t\tStringBuilder missings = new StringBuilder();\n \t\t\tfor (String property : missingIdProperties) {\n \t\t\t\tmissings.append( property ).append( \", \" );\n \t\t\t}\n \t\t\tthrow new AnnotationException(\n \t\t\t\t\t\"Unable to find properties (\"\n \t\t\t\t\t\t\t+ missings.substring( 0, missings.length() - 2 )\n \t\t\t\t\t\t\t+ \") in entity annotated with @IdClass:\" + persistentClass.getEntityName()\n \t\t\t);\n \t\t}\n \n \t\tif ( !inheritanceState.hasParents ) {\n \t\t\tfinal RootClass rootClass = (RootClass) persistentClass;\n \t\t\tmappings.addSecondPass( new CreateKeySecondPass( rootClass ) );\n \t\t}\n \t\telse {\n \t\t\tsuperEntity.addSubclass( (Subclass) persistentClass );\n \t\t}\n \n \t\tmappings.addClass( persistentClass );\n \n \t\t//Process secondary tables and complementary definitions (ie o.h.a.Table)\n \t\tmappings.addSecondPass( new SecondaryTableSecondPass( entityBinder, propertyHolder, annotatedClass ) );\n \n \t\t//add process complementary Table definition (index & all)\n \t\tentityBinder.processComplementaryTableDefinitions( annotatedClass.getAnnotation( org.hibernate.annotations.Table.class ) );\n \t\tentityBinder.processComplementaryTableDefinitions( annotatedClass.getAnnotation( org.hibernate.annotations.Tables.class ) );\n \n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"2176af11442c702aefa1900cdba4c32e6338b620": {
			"type": "Ybodychange",
			"commitMessage": "HHH-4528 - Applied patch (with minor cleanup)\n\ngit-svn-id: https://svn.jboss.org/repos/hibernate/core/trunk@17849 1b8cb986-b30d-0410-93ca-fae66ebed9b2\n",
			"commitDate": "2009-10-27, 8:05 AM",
			"commitName": "2176af11442c702aefa1900cdba4c32e6338b620",
			"commitAuthor": "Hardy Ferentschik",
			"commitDateOld": "2009-10-21, 10:16 AM",
			"commitNameOld": "d26c00225847f5b4e869146188e3e80914367d7a",
			"commitAuthorOld": "Sharath Reddy",
			"daysBetweenCommits": 5.91,
			"commitsBetweenForRepo": 23,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,412 +1,418 @@\n \tpublic static void bindClass(\n \t\t\tXClass clazzToProcess, Map<XClass, InheritanceState> inheritanceStatePerClass, ExtendedMappings mappings\n \t) throws MappingException {\n \t\t//TODO: be more strict with secondarytable allowance (not for ids, not for secondary table join columns etc)\n \t\tInheritanceState inheritanceState = inheritanceStatePerClass.get( clazzToProcess );\n \t\tAnnotatedClassType classType = mappings.getClassType( clazzToProcess );\n \n \t\t//Queries declared in MappedSuperclass should be usable in Subclasses\n \t\tif ( AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals( classType ) ) {\n \t\t\tbindQueries( clazzToProcess, mappings );\n \t\t\tbindTypeDefs(clazzToProcess, mappings);\n \t\t}\n \n \t\tif ( AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals( classType ) //will be processed by their subentities\n \t\t\t\t|| AnnotatedClassType.NONE.equals( classType ) //to be ignored\n \t\t\t\t|| AnnotatedClassType.EMBEDDABLE.equals( classType ) //allow embeddable element declaration\n \t\t\t\t) {\n \t\t\tif ( AnnotatedClassType.NONE.equals( classType )\n \t\t\t\t\t&& clazzToProcess.isAnnotationPresent( org.hibernate.annotations.Entity.class ) ) {\n \t\t\t\tlog.warn( \"Class annotated @org.hibernate.annotations.Entity but not javax.persistence.Entity \"\n \t\t\t\t\t\t+ \"(most likely a user error): {}\", clazzToProcess.getName() );\n \t\t\t}\n \t\t\treturn;\n \t\t}\n \t\tif ( !classType.equals( AnnotatedClassType.ENTITY ) ) {\n \t\t\t//TODO make this test accurate by removing the none elements artifically added\n \t\t\tthrow new AnnotationException(\n \t\t\t\t\t\"Annotated class should have a @javax.persistence.Entity, @javax.persistence.Embeddable or @javax.persistence.EmbeddedSuperclass annotation: \" + clazzToProcess\n \t\t\t\t\t\t\t.getName()\n \t\t\t);\n \t\t}\n \t\tXAnnotatedElement annotatedClass = clazzToProcess;\n \t\tlog.info( \"Binding entity from annotated class: {}\", clazzToProcess.getName() );\n \t\tInheritanceState superEntityState =\n \t\t\t\tInheritanceState.getSuperEntityInheritanceState(\n \t\t\t\t\t\tclazzToProcess, inheritanceStatePerClass, mappings.getReflectionManager()\n \t\t\t\t);\n \t\tPersistentClass superEntity = superEntityState != null ?\n \t\t\t\tmappings.getClass(\n \t\t\t\t\t\tsuperEntityState.clazz.getName()\n \t\t\t\t) :\n \t\t\t\tnull;\n \t\tif ( superEntity == null ) {\n \t\t\t//check if superclass is not a potential persistent class\n \t\t\tif ( inheritanceState.hasParents ) {\n \t\t\t\tthrow new AssertionFailure(\n \t\t\t\t\t\t\"Subclass has to be binded after it's mother class: \"\n \t\t\t\t\t\t\t\t+ superEntityState.clazz.getName()\n \t\t\t\t);\n \t\t\t}\n \t\t}\n \t\tbindQueries( annotatedClass, mappings );\n \t\tbindFilterDefs( annotatedClass, mappings );\n \t\tbindTypeDefs( annotatedClass, mappings );\n \t\tBinderHelper.bindAnyMetaDefs( annotatedClass, mappings );\n \n \t\tString schema = \"\";\n \t\tString table = \"\"; //might be no @Table annotation on the annotated class\n \t\tString catalog = \"\";\n \t\tString discrimValue = null;\n \t\tList<String[]> uniqueConstraints = new ArrayList<String[]>();\n \t\tEjb3DiscriminatorColumn discriminatorColumn = null;\n \t\tEjb3JoinColumn[] inheritanceJoinedColumns = null;\n \n \t\tif ( annotatedClass.isAnnotationPresent( javax.persistence.Table.class ) ) {\n \t\t\tjavax.persistence.Table tabAnn = annotatedClass.getAnnotation( javax.persistence.Table.class );\n \t\t\ttable = tabAnn.name();\n \t\t\tschema = tabAnn.schema();\n \t\t\tcatalog = tabAnn.catalog();\n \t\t\tuniqueConstraints = TableBinder.buildUniqueConstraints( tabAnn.uniqueConstraints() );\n \t\t}\n \t\tfinal boolean hasJoinedColumns = inheritanceState.hasParents\n \t\t\t\t&& InheritanceType.JOINED.equals( inheritanceState.type );\n \t\tif ( hasJoinedColumns ) {\n \t\t\t//@Inheritance(JOINED) subclass need to link back to the super entity\n \t\t\tPrimaryKeyJoinColumns jcsAnn = annotatedClass.getAnnotation( PrimaryKeyJoinColumns.class );\n \t\t\tboolean explicitInheritanceJoinedColumns = jcsAnn != null && jcsAnn.value().length != 0;\n \t\t\tif ( explicitInheritanceJoinedColumns ) {\n \t\t\t\tint nbrOfInhJoinedColumns = jcsAnn.value().length;\n \t\t\t\tPrimaryKeyJoinColumn jcAnn;\n \t\t\t\tinheritanceJoinedColumns = new Ejb3JoinColumn[nbrOfInhJoinedColumns];\n \t\t\t\tfor (int colIndex = 0; colIndex < nbrOfInhJoinedColumns; colIndex++) {\n \t\t\t\t\tjcAnn = jcsAnn.value()[colIndex];\n \t\t\t\t\tinheritanceJoinedColumns[colIndex] = Ejb3JoinColumn.buildJoinColumn(\n \t\t\t\t\t\t\tjcAnn, null, superEntity.getIdentifier(),\n \t\t\t\t\t\t\t(Map<String, Join>) null, (PropertyHolder) null, mappings\n \t\t\t\t\t);\n \t\t\t\t}\n \t\t\t}\n \t\t\telse {\n \t\t\t\tPrimaryKeyJoinColumn jcAnn = annotatedClass.getAnnotation( PrimaryKeyJoinColumn.class );\n \t\t\t\tinheritanceJoinedColumns = new Ejb3JoinColumn[1];\n \t\t\t\tinheritanceJoinedColumns[0] = Ejb3JoinColumn.buildJoinColumn(\n \t\t\t\t\t\tjcAnn, null, superEntity.getIdentifier(),\n \t\t\t\t\t\t(Map<String, Join>) null, (PropertyHolder) null, mappings\n \t\t\t\t);\n \t\t\t}\n \t\t\tlog.debug( \"Subclass joined column(s) created\" );\n \t\t}\n \t\telse {\n \t\t\tif ( annotatedClass.isAnnotationPresent( javax.persistence.PrimaryKeyJoinColumns.class )\n \t\t\t\t\t|| annotatedClass.isAnnotationPresent( javax.persistence.PrimaryKeyJoinColumn.class ) ) {\n \t\t\t\tlog.warn( \"Root entity should not hold an PrimaryKeyJoinColum(s), will be ignored\" );\n \t\t\t}\n \t\t}\n \n \t\tif ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.type ) ) {\n \t\t\tjavax.persistence.DiscriminatorColumn discAnn = annotatedClass.getAnnotation(\n \t\t\t\t\tjavax.persistence.DiscriminatorColumn.class\n \t\t\t);\n \t\t\tDiscriminatorType discriminatorType = discAnn != null ?\n \t\t\t\t\tdiscAnn.discriminatorType() :\n \t\t\t\t\tDiscriminatorType.STRING;\n \n \t\t\torg.hibernate.annotations.DiscriminatorFormula discFormulaAnn = annotatedClass.getAnnotation(\n \t\t\t\t\torg.hibernate.annotations.DiscriminatorFormula.class\n \t\t\t);\n \t\t\tif ( !inheritanceState.hasParents ) {\n \t\t\t\tdiscriminatorColumn = Ejb3DiscriminatorColumn.buildDiscriminatorColumn(\n \t\t\t\t\t\tdiscriminatorType, discAnn, discFormulaAnn, mappings\n \t\t\t\t);\n \t\t\t}\n \t\t\tif ( discAnn != null && inheritanceState.hasParents ) {\n \t\t\t\tlog.warn(\n \t\t\t\t\t\t\"Discriminator column has to be defined in the root entity, it will be ignored in subclass: {}\",\n \t\t\t\t\t\tclazzToProcess.getName()\n \t\t\t\t);\n \t\t\t}\n \t\t\tdiscrimValue = annotatedClass.isAnnotationPresent( DiscriminatorValue.class ) ?\n \t\t\t\t\tannotatedClass.getAnnotation( DiscriminatorValue.class ).value() :\n \t\t\t\t\tnull;\n \t\t}\n \n \t\t//we now know what kind of persistent entity it is\n \t\tPersistentClass persistentClass;\n \t\t//create persistent class\n \t\tif ( !inheritanceState.hasParents ) {\n \t\t\tpersistentClass = new RootClass();\n \t\t}\n \t\telse if ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.type ) ) {\n \t\t\tpersistentClass = new SingleTableSubclass( superEntity );\n \t\t}\n \t\telse if ( InheritanceType.JOINED.equals( inheritanceState.type ) ) {\n \t\t\tpersistentClass = new JoinedSubclass( superEntity );\n \t\t}\n \t\telse if ( InheritanceType.TABLE_PER_CLASS.equals( inheritanceState.type ) ) {\n \t\t\tpersistentClass = new UnionSubclass( superEntity );\n \t\t}\n \t\telse {\n \t\t\tthrow new AssertionFailure( \"Unknown inheritance type: \" + inheritanceState.type );\n \t\t}\n \t\tProxy proxyAnn = annotatedClass.getAnnotation( Proxy.class );\n \t\tBatchSize sizeAnn = annotatedClass.getAnnotation( BatchSize.class );\n \t\tWhere whereAnn = annotatedClass.getAnnotation( Where.class );\n \t\tEntity entityAnn = annotatedClass.getAnnotation( Entity.class );\n \t\torg.hibernate.annotations.Entity hibEntityAnn = annotatedClass.getAnnotation(\n \t\t\t\torg.hibernate.annotations.Entity.class\n \t\t);\n \t\torg.hibernate.annotations.Cache cacheAnn = annotatedClass.getAnnotation(\n \t\t\t\torg.hibernate.annotations.Cache.class\n \t\t);\n \t\tEntityBinder entityBinder = new EntityBinder(\n \t\t\t\tentityAnn, hibEntityAnn, clazzToProcess, persistentClass, mappings\n \t\t);\n \t\tentityBinder.setDiscriminatorValue( discrimValue );\n \t\tentityBinder.setBatchSize( sizeAnn );\n \t\tentityBinder.setProxy( proxyAnn );\n \t\tentityBinder.setWhere( whereAnn );\n \t\tentityBinder.setCache( cacheAnn );\n \t\tentityBinder.setInheritanceState( inheritanceState );\n \t\tFilter filterAnn = annotatedClass.getAnnotation( Filter.class );\n \t\tif ( filterAnn != null ) {\n \t\t\tentityBinder.addFilter( filterAnn.name(), filterAnn.condition() );\n \t\t}\n \t\tFilters filtersAnn = annotatedClass.getAnnotation( Filters.class );\n \t\tif ( filtersAnn != null ) {\n \t\t\tfor (Filter filter : filtersAnn.value()) {\n \t\t\t\tentityBinder.addFilter( filter.name(), filter.condition() );\n \t\t\t}\n \t\t}\n \t\tentityBinder.bindEntity();\n \n \t\tif ( inheritanceState.hasTable() ) {\n \t\t\tCheck checkAnn = annotatedClass.getAnnotation( Check.class );\n \t\t\tString constraints = checkAnn == null ?\n \t\t\t\t\tnull :\n \t\t\t\t\tcheckAnn.constraints();\n \t\t\tentityBinder.bindTable(\n \t\t\t\t\tschema, catalog, table, uniqueConstraints,\n \t\t\t\t\tconstraints, inheritanceState.hasDenormalizedTable() ?\n \t\t\t\t\tsuperEntity.getTable() :\n \t\t\t\t\tnull\n \t\t\t);\n \t\t}\n \t\telse {\n \t\t\tif ( annotatedClass.isAnnotationPresent( Table.class ) ) {\n \t\t\t\tlog.warn( \"Illegal use of @Table in a subclass of a SINGLE_TABLE hierarchy: \" + clazzToProcess\n \t\t\t\t\t\t.getName() );\n \t\t\t}\n \t\t}\n //\t\tMap<String, Column[]> columnOverride = PropertyHolderBuilder.buildHierarchyColumnOverride(\n //\t\t\t\tclazzToProcess,\n //\t\t\t\tpersistentClass.getClassName()\n //\t\t);\n \t\tPropertyHolder propertyHolder = PropertyHolderBuilder.buildPropertyHolder(\n \t\t\t\tclazzToProcess,\n \t\t\t\tpersistentClass,\n \t\t\t\tentityBinder, mappings\n \t\t);\n \n \t\tjavax.persistence.SecondaryTable secTabAnn = annotatedClass.getAnnotation(\n \t\t\t\tjavax.persistence.SecondaryTable.class\n \t\t);\n \t\tjavax.persistence.SecondaryTables secTabsAnn = annotatedClass.getAnnotation(\n \t\t\t\tjavax.persistence.SecondaryTables.class\n \t\t);\n \t\tentityBinder.firstLevelSecondaryTablesBinding( secTabAnn, secTabsAnn );\n \n \t\tOnDelete onDeleteAnn = annotatedClass.getAnnotation( OnDelete.class );\n \t\tboolean onDeleteAppropriate = false;\n \t\tif ( InheritanceType.JOINED.equals( inheritanceState.type ) && inheritanceState.hasParents ) {\n \t\t\tonDeleteAppropriate = true;\n \t\t\tfinal JoinedSubclass jsc = (JoinedSubclass) persistentClass;\n \t\t\tif ( persistentClass.getEntityPersisterClass() == null ) {\n \t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( JoinedSubclassEntityPersister.class );\n \t\t\t}\n \t\t\tSimpleValue key = new DependantValue( jsc.getTable(), jsc.getIdentifier() );\n \t\t\tjsc.setKey( key );\n \t\t\tForeignKey fk = annotatedClass.getAnnotation( ForeignKey.class );\n \t\t\tif ( fk != null && !BinderHelper.isDefault( fk.name() ) ) {\n \t\t\t\tkey.setForeignKeyName( fk.name() );\n \t\t\t}\n \t\t\tif ( onDeleteAnn != null ) {\n \t\t\t\tkey.setCascadeDeleteEnabled( OnDeleteAction.CASCADE.equals( onDeleteAnn.action() ) );\n \t\t\t}\n \t\t\telse {\n \t\t\t\tkey.setCascadeDeleteEnabled( false );\n \t\t\t}\n \t\t\t//we are never in a second pass at that stage, so queue it\n \t\t\tSecondPass sp = new JoinedSubclassFkSecondPass( jsc, inheritanceJoinedColumns, key, mappings );\n \t\t\tmappings.addSecondPass( sp );\n \t\t\tmappings.addSecondPass( new CreateKeySecondPass( jsc ) );\n \n \t\t}\n \t\telse if ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.type ) ) {\n \t\t\tif ( inheritanceState.hasParents ) {\n \t\t\t\tif ( persistentClass.getEntityPersisterClass() == null ) {\n \t\t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( SingleTableEntityPersister.class );\n \t\t\t\t}\n \t\t\t}\n \t\t\telse {\n \t\t\t\tif ( inheritanceState.hasSons || !discriminatorColumn.isImplicit() ) {\n \t\t\t\t\t//need a discriminator column\n \t\t\t\t\tbindDiscriminatorToPersistentClass(\n \t\t\t\t\t\t\t(RootClass) persistentClass,\n \t\t\t\t\t\t\tdiscriminatorColumn,\n \t\t\t\t\t\t\tentityBinder.getSecondaryTables(),\n \t\t\t\t\t\t\tpropertyHolder\n \t\t\t\t\t);\n \t\t\t\t\tentityBinder.bindDiscriminatorValue();//bind it again since the type might have changed\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\telse if ( InheritanceType.TABLE_PER_CLASS.equals( inheritanceState.type ) ) {\n \t\t\tif ( inheritanceState.hasParents ) {\n \t\t\t\tif ( persistentClass.getEntityPersisterClass() == null ) {\n \t\t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( UnionSubclassEntityPersister.class );\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\tif ( onDeleteAnn != null && !onDeleteAppropriate ) {\n \t\t\tlog.warn(\n \t\t\t\t\t\"Inapropriate use of @OnDelete on entity, annotation ignored: {}\", propertyHolder.getEntityName()\n \t\t\t);\n \t\t}\n \n \t\t//try to find class level generators\n \t\tHashMap<String, IdGenerator> classGenerators = buildLocalGenerators( annotatedClass, mappings );\n \n \t\t// check properties\n \t\tList<PropertyData> elements =\n \t\t\t\tgetElementsToProcess(\n \t\t\t\t\t\tclazzToProcess, inheritanceStatePerClass, propertyHolder, entityBinder, mappings\n \t\t\t\t);\n \t\tif ( elements == null ) {\n \t\t\tthrow new AnnotationException( \"No identifier specified for entity: \" + propertyHolder.getEntityName() );\n \t\t}\n \t\tfinal boolean subclassAndSingleTableStrategy = inheritanceState.type == InheritanceType.SINGLE_TABLE\n \t\t\t\t&& inheritanceState.hasParents;\n \t\t//process idclass if any\n \t\tSet<String> idProperties = new HashSet<String>();\n \t\tIdClass idClass = null;\n+\t\tXClass current = null;\n \t\tif ( !inheritanceState.hasParents ) {\n \t\t\t//look for idClass\n-\t\t\tXClass current = inheritanceState.clazz;\n+\t\t\tcurrent = inheritanceState.clazz;\n \t\t\tInheritanceState state = inheritanceState;\n \t\t\tdo {\n \t\t\t\tcurrent = state.clazz;\n \t\t\t\tif ( current.isAnnotationPresent( IdClass.class ) ) {\n \t\t\t\t\tidClass = current.getAnnotation( IdClass.class );\n \t\t\t\t\tbreak;\n \t\t\t\t}\n \t\t\t\tstate = InheritanceState.getSuperclassInheritanceState(\n \t\t\t\t\t\tcurrent, inheritanceStatePerClass, mappings.getReflectionManager()\n \t\t\t\t);\n \t\t\t}\n \t\t\twhile ( state != null );\n \t\t}\n \t\tif ( idClass != null ) {\n \t\t\tXClass compositeClass = mappings.getReflectionManager().toXClass( idClass.value() );\n \t\t\tboolean isComponent = true;\n \t\t\tboolean propertyAnnotated = entityBinder.isPropertyAnnotated( compositeClass );\n \t\t\tString propertyAccessor = entityBinder.getPropertyAccessor( compositeClass );\n \t\t\tString generatorType = \"assigned\";\n \t\t\tString generator = BinderHelper.ANNOTATION_STRING_DEFAULT;\n \t\t\tPropertyData inferredData = new PropertyPreloadedData(\n \t\t\t\t\tentityBinder.getPropertyAccessor(), \"id\", compositeClass\n \t\t\t);\n+\t\t\tPropertyData baseInferredData = new PropertyPreloadedData(\n+                  entityBinder.getPropertyAccessor(), \"id\", current\n+            );\n \t\t\tHashMap<String, IdGenerator> localGenerators = new HashMap<String, IdGenerator>();\n \t\t\tboolean ignoreIdAnnotations = entityBinder.isIgnoreIdAnnotations();\n \t\t\tentityBinder.setIgnoreIdAnnotations( true );\n \t\t\tbindId(\n \t\t\t\t\tgeneratorType,\n \t\t\t\t\tgenerator,\n \t\t\t\t\tinferredData,\n+\t\t\t\t\tbaseInferredData,\n \t\t\t\t\tnull,\n \t\t\t\t\tpropertyHolder,\n \t\t\t\t\tlocalGenerators,\n \t\t\t\t\tisComponent,\n \t\t\t\t\tpropertyAnnotated,\n \t\t\t\t\tpropertyAccessor, entityBinder,\n \t\t\t\t\ttrue,\n \t\t\t\t\tfalse, mappings\n \t\t\t);\n \t\t\tinferredData = new PropertyPreloadedData(\n \t\t\t\t\tpropertyAccessor, \"_identifierMapper\", compositeClass\n \t\t\t);\n \t\t\tComponent mapper = fillComponent(\n \t\t\t\t\tpropertyHolder,\n \t\t\t\t\tinferredData,\n+\t\t\t\t\tbaseInferredData,\n \t\t\t\t\tpropertyAnnotated,\n \t\t\t\t\tpropertyAccessor, false,\n \t\t\t\t\tentityBinder,\n \t\t\t\t\ttrue, true,\n \t\t\t\t\tfalse, mappings\n \t\t\t);\n \t\t\tentityBinder.setIgnoreIdAnnotations( ignoreIdAnnotations );\n \t\t\tpersistentClass.setIdentifierMapper( mapper );\n \t\t\tProperty property = new Property();\n \t\t\tproperty.setName( \"_identifierMapper\" );\n \t\t\tproperty.setNodeName( \"id\" );\n \t\t\tproperty.setUpdateable( false );\n \t\t\tproperty.setInsertable( false );\n \t\t\tproperty.setValue( mapper );\n \t\t\tproperty.setPropertyAccessorName( \"embedded\" );\n \t\t\tpersistentClass.addProperty( property );\n \t\t\tentityBinder.setIgnoreIdAnnotations( true );\n \n \t\t\tIterator properties = mapper.getPropertyIterator();\n \t\t\twhile ( properties.hasNext() ) {\n \t\t\t\tidProperties.add( ( (Property) properties.next() ).getName() );\n \t\t\t}\n \t\t}\n \t\tSet<String> missingIdProperties = new HashSet<String>( idProperties );\n \t\tfor (PropertyData propertyAnnotatedElement : elements) {\n \t\t\tString propertyName = propertyAnnotatedElement.getPropertyName();\n \t\t\tif ( !idProperties.contains( propertyName ) ) {\n \t\t\t\tprocessElementAnnotations(\n \t\t\t\t\t\tpropertyHolder,\n \t\t\t\t\t\tsubclassAndSingleTableStrategy ?\n \t\t\t\t\t\t\t\tNullability.FORCED_NULL :\n \t\t\t\t\t\t\t\tNullability.NO_CONSTRAINT,\n \t\t\t\t\t\tpropertyAnnotatedElement.getProperty(),\n \t\t\t\t\t\tpropertyAnnotatedElement, classGenerators, entityBinder,\n \t\t\t\t\t\tfalse, false, false, mappings\n \t\t\t\t);\n \t\t\t}\n \t\t\telse {\n \t\t\t\tmissingIdProperties.remove( propertyName );\n \t\t\t}\n \t\t}\n \n \t\tif ( missingIdProperties.size() != 0 ) {\n \t\t\tStringBuilder missings = new StringBuilder();\n \t\t\tfor (String property : missingIdProperties) {\n \t\t\t\tmissings.append( property ).append( \", \" );\n \t\t\t}\n \t\t\tthrow new AnnotationException(\n \t\t\t\t\t\"Unable to find properties (\"\n \t\t\t\t\t\t\t+ missings.substring( 0, missings.length() - 2 )\n \t\t\t\t\t\t\t+ \") in entity annotated with @IdClass:\" + persistentClass.getEntityName()\n \t\t\t);\n \t\t}\n \n \t\tif ( !inheritanceState.hasParents ) {\n \t\t\tfinal RootClass rootClass = (RootClass) persistentClass;\n \t\t\tmappings.addSecondPass( new CreateKeySecondPass( rootClass ) );\n \t\t}\n \t\telse {\n \t\t\tsuperEntity.addSubclass( (Subclass) persistentClass );\n \t\t}\n \n \t\tmappings.addClass( persistentClass );\n \n \t\t//Process secondary tables and complementary definitions (ie o.h.a.Table)\n \t\tmappings.addSecondPass( new SecondaryTableSecondPass( entityBinder, propertyHolder, annotatedClass ) );\n \n \t\t//add process complementary Table definition (index & all)\n \t\tentityBinder.processComplementaryTableDefinitions( annotatedClass.getAnnotation( org.hibernate.annotations.Table.class ) );\n \t\tentityBinder.processComplementaryTableDefinitions( annotatedClass.getAnnotation( org.hibernate.annotations.Tables.class ) );\n \n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"8cc9e9d5fd2e13844ed222e144c48f7df4487fa4": {
			"type": "Ybodychange",
			"commitMessage": "HHH-4232 TypeDef support when used on @Embeddable or @MappedSuperClass classes\n\ngit-svn-id: https://svn.jboss.org/repos/hibernate/core/trunk@17531 1b8cb986-b30d-0410-93ca-fae66ebed9b2\n",
			"commitDate": "2009-09-22, 10:43 AM",
			"commitName": "8cc9e9d5fd2e13844ed222e144c48f7df4487fa4",
			"commitAuthor": "Emmanuel Bernard",
			"commitDateOld": "2009-09-22, 10:19 AM",
			"commitNameOld": "88caf4d9586e988675254c268f4e145d272a9499",
			"commitAuthorOld": "Emmanuel Bernard",
			"daysBetweenCommits": 0.02,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,411 +1,412 @@\n \tpublic static void bindClass(\n \t\t\tXClass clazzToProcess, Map<XClass, InheritanceState> inheritanceStatePerClass, ExtendedMappings mappings\n \t) throws MappingException {\n \t\t//TODO: be more strict with secondarytable allowance (not for ids, not for secondary table join columns etc)\n \t\tInheritanceState inheritanceState = inheritanceStatePerClass.get( clazzToProcess );\n \t\tAnnotatedClassType classType = mappings.getClassType( clazzToProcess );\n-\t\t\n+\n \t\t//Queries declared in MappedSuperclass should be usable in Subclasses\n-\t\tif ( AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals( classType )) {\n-\t\t\tbindQueries(clazzToProcess, mappings );\n+\t\tif ( AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals( classType ) ) {\n+\t\t\tbindQueries( clazzToProcess, mappings );\n+\t\t\tbindTypeDefs(clazzToProcess, mappings);\n \t\t}\n-\t\t\n+\n \t\tif ( AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals( classType ) //will be processed by their subentities\n \t\t\t\t|| AnnotatedClassType.NONE.equals( classType ) //to be ignored\n \t\t\t\t|| AnnotatedClassType.EMBEDDABLE.equals( classType ) //allow embeddable element declaration\n \t\t\t\t) {\n \t\t\tif ( AnnotatedClassType.NONE.equals( classType )\n \t\t\t\t\t&& clazzToProcess.isAnnotationPresent( org.hibernate.annotations.Entity.class ) ) {\n \t\t\t\tlog.warn( \"Class annotated @org.hibernate.annotations.Entity but not javax.persistence.Entity \"\n \t\t\t\t\t\t+ \"(most likely a user error): {}\", clazzToProcess.getName() );\n \t\t\t}\n \t\t\treturn;\n \t\t}\n \t\tif ( !classType.equals( AnnotatedClassType.ENTITY ) ) {\n \t\t\t//TODO make this test accurate by removing the none elements artifically added\n \t\t\tthrow new AnnotationException(\n \t\t\t\t\t\"Annotated class should have a @javax.persistence.Entity, @javax.persistence.Embeddable or @javax.persistence.EmbeddedSuperclass annotation: \" + clazzToProcess\n \t\t\t\t\t\t\t.getName()\n \t\t\t);\n \t\t}\n \t\tXAnnotatedElement annotatedClass = clazzToProcess;\n \t\tlog.info( \"Binding entity from annotated class: {}\", clazzToProcess.getName() );\n \t\tInheritanceState superEntityState =\n \t\t\t\tInheritanceState.getSuperEntityInheritanceState(\n \t\t\t\t\t\tclazzToProcess, inheritanceStatePerClass, mappings.getReflectionManager()\n \t\t\t\t);\n \t\tPersistentClass superEntity = superEntityState != null ?\n \t\t\t\tmappings.getClass(\n \t\t\t\t\t\tsuperEntityState.clazz.getName()\n \t\t\t\t) :\n \t\t\t\tnull;\n \t\tif ( superEntity == null ) {\n \t\t\t//check if superclass is not a potential persistent class\n \t\t\tif ( inheritanceState.hasParents ) {\n \t\t\t\tthrow new AssertionFailure(\n \t\t\t\t\t\t\"Subclass has to be binded after it's mother class: \"\n \t\t\t\t\t\t\t\t+ superEntityState.clazz.getName()\n \t\t\t\t);\n \t\t\t}\n \t\t}\n \t\tbindQueries( annotatedClass, mappings );\n \t\tbindFilterDefs( annotatedClass, mappings );\n \t\tbindTypeDefs( annotatedClass, mappings );\n \t\tBinderHelper.bindAnyMetaDefs( annotatedClass, mappings );\n \n \t\tString schema = \"\";\n \t\tString table = \"\"; //might be no @Table annotation on the annotated class\n \t\tString catalog = \"\";\n \t\tString discrimValue = null;\n \t\tList<String[]> uniqueConstraints = new ArrayList<String[]>();\n \t\tEjb3DiscriminatorColumn discriminatorColumn = null;\n \t\tEjb3JoinColumn[] inheritanceJoinedColumns = null;\n \n \t\tif ( annotatedClass.isAnnotationPresent( javax.persistence.Table.class ) ) {\n \t\t\tjavax.persistence.Table tabAnn = annotatedClass.getAnnotation( javax.persistence.Table.class );\n \t\t\ttable = tabAnn.name();\n \t\t\tschema = tabAnn.schema();\n \t\t\tcatalog = tabAnn.catalog();\n \t\t\tuniqueConstraints = TableBinder.buildUniqueConstraints( tabAnn.uniqueConstraints() );\n \t\t}\n \t\tfinal boolean hasJoinedColumns = inheritanceState.hasParents\n \t\t\t\t&& InheritanceType.JOINED.equals( inheritanceState.type );\n \t\tif ( hasJoinedColumns ) {\n \t\t\t//@Inheritance(JOINED) subclass need to link back to the super entity\n \t\t\tPrimaryKeyJoinColumns jcsAnn = annotatedClass.getAnnotation( PrimaryKeyJoinColumns.class );\n \t\t\tboolean explicitInheritanceJoinedColumns = jcsAnn != null && jcsAnn.value().length != 0;\n \t\t\tif ( explicitInheritanceJoinedColumns ) {\n \t\t\t\tint nbrOfInhJoinedColumns = jcsAnn.value().length;\n \t\t\t\tPrimaryKeyJoinColumn jcAnn;\n \t\t\t\tinheritanceJoinedColumns = new Ejb3JoinColumn[nbrOfInhJoinedColumns];\n \t\t\t\tfor (int colIndex = 0; colIndex < nbrOfInhJoinedColumns; colIndex++) {\n \t\t\t\t\tjcAnn = jcsAnn.value()[colIndex];\n \t\t\t\t\tinheritanceJoinedColumns[colIndex] = Ejb3JoinColumn.buildJoinColumn(\n \t\t\t\t\t\t\tjcAnn, null, superEntity.getIdentifier(),\n \t\t\t\t\t\t\t(Map<String, Join>) null, (PropertyHolder) null, mappings\n \t\t\t\t\t);\n \t\t\t\t}\n \t\t\t}\n \t\t\telse {\n \t\t\t\tPrimaryKeyJoinColumn jcAnn = annotatedClass.getAnnotation( PrimaryKeyJoinColumn.class );\n \t\t\t\tinheritanceJoinedColumns = new Ejb3JoinColumn[1];\n \t\t\t\tinheritanceJoinedColumns[0] = Ejb3JoinColumn.buildJoinColumn(\n \t\t\t\t\t\tjcAnn, null, superEntity.getIdentifier(),\n \t\t\t\t\t\t(Map<String, Join>) null, (PropertyHolder) null, mappings\n \t\t\t\t);\n \t\t\t}\n \t\t\tlog.debug( \"Subclass joined column(s) created\" );\n \t\t}\n \t\telse {\n \t\t\tif ( annotatedClass.isAnnotationPresent( javax.persistence.PrimaryKeyJoinColumns.class )\n \t\t\t\t\t|| annotatedClass.isAnnotationPresent( javax.persistence.PrimaryKeyJoinColumn.class ) ) {\n \t\t\t\tlog.warn( \"Root entity should not hold an PrimaryKeyJoinColum(s), will be ignored\" );\n \t\t\t}\n \t\t}\n \n \t\tif ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.type ) ) {\n \t\t\tjavax.persistence.DiscriminatorColumn discAnn = annotatedClass.getAnnotation(\n \t\t\t\t\tjavax.persistence.DiscriminatorColumn.class\n \t\t\t);\n \t\t\tDiscriminatorType discriminatorType = discAnn != null ?\n \t\t\t\t\tdiscAnn.discriminatorType() :\n \t\t\t\t\tDiscriminatorType.STRING;\n \n \t\t\torg.hibernate.annotations.DiscriminatorFormula discFormulaAnn = annotatedClass.getAnnotation(\n \t\t\t\t\torg.hibernate.annotations.DiscriminatorFormula.class\n \t\t\t);\n \t\t\tif ( !inheritanceState.hasParents ) {\n \t\t\t\tdiscriminatorColumn = Ejb3DiscriminatorColumn.buildDiscriminatorColumn(\n \t\t\t\t\t\tdiscriminatorType, discAnn, discFormulaAnn, mappings\n \t\t\t\t);\n \t\t\t}\n \t\t\tif ( discAnn != null && inheritanceState.hasParents ) {\n \t\t\t\tlog.warn(\n \t\t\t\t\t\t\"Discriminator column has to be defined in the root entity, it will be ignored in subclass: {}\",\n \t\t\t\t\t\tclazzToProcess.getName()\n \t\t\t\t);\n \t\t\t}\n \t\t\tdiscrimValue = annotatedClass.isAnnotationPresent( DiscriminatorValue.class ) ?\n \t\t\t\t\tannotatedClass.getAnnotation( DiscriminatorValue.class ).value() :\n \t\t\t\t\tnull;\n \t\t}\n \n \t\t//we now know what kind of persistent entity it is\n \t\tPersistentClass persistentClass;\n \t\t//create persistent class\n \t\tif ( !inheritanceState.hasParents ) {\n \t\t\tpersistentClass = new RootClass();\n \t\t}\n \t\telse if ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.type ) ) {\n \t\t\tpersistentClass = new SingleTableSubclass( superEntity );\n \t\t}\n \t\telse if ( InheritanceType.JOINED.equals( inheritanceState.type ) ) {\n \t\t\tpersistentClass = new JoinedSubclass( superEntity );\n \t\t}\n \t\telse if ( InheritanceType.TABLE_PER_CLASS.equals( inheritanceState.type ) ) {\n \t\t\tpersistentClass = new UnionSubclass( superEntity );\n \t\t}\n \t\telse {\n \t\t\tthrow new AssertionFailure( \"Unknown inheritance type: \" + inheritanceState.type );\n \t\t}\n \t\tProxy proxyAnn = annotatedClass.getAnnotation( Proxy.class );\n \t\tBatchSize sizeAnn = annotatedClass.getAnnotation( BatchSize.class );\n \t\tWhere whereAnn = annotatedClass.getAnnotation( Where.class );\n \t\tEntity entityAnn = annotatedClass.getAnnotation( Entity.class );\n \t\torg.hibernate.annotations.Entity hibEntityAnn = annotatedClass.getAnnotation(\n \t\t\t\torg.hibernate.annotations.Entity.class\n \t\t);\n \t\torg.hibernate.annotations.Cache cacheAnn = annotatedClass.getAnnotation(\n \t\t\t\torg.hibernate.annotations.Cache.class\n \t\t);\n \t\tEntityBinder entityBinder = new EntityBinder(\n \t\t\t\tentityAnn, hibEntityAnn, clazzToProcess, persistentClass, mappings\n \t\t);\n \t\tentityBinder.setDiscriminatorValue( discrimValue );\n \t\tentityBinder.setBatchSize( sizeAnn );\n \t\tentityBinder.setProxy( proxyAnn );\n \t\tentityBinder.setWhere( whereAnn );\n \t\tentityBinder.setCache( cacheAnn );\n \t\tentityBinder.setInheritanceState( inheritanceState );\n \t\tFilter filterAnn = annotatedClass.getAnnotation( Filter.class );\n \t\tif ( filterAnn != null ) {\n \t\t\tentityBinder.addFilter( filterAnn.name(), filterAnn.condition() );\n \t\t}\n \t\tFilters filtersAnn = annotatedClass.getAnnotation( Filters.class );\n \t\tif ( filtersAnn != null ) {\n \t\t\tfor (Filter filter : filtersAnn.value()) {\n \t\t\t\tentityBinder.addFilter( filter.name(), filter.condition() );\n \t\t\t}\n \t\t}\n \t\tentityBinder.bindEntity();\n \n \t\tif ( inheritanceState.hasTable() ) {\n \t\t\tCheck checkAnn = annotatedClass.getAnnotation( Check.class );\n \t\t\tString constraints = checkAnn == null ?\n \t\t\t\t\tnull :\n \t\t\t\t\tcheckAnn.constraints();\n \t\t\tentityBinder.bindTable(\n \t\t\t\t\tschema, catalog, table, uniqueConstraints,\n \t\t\t\t\tconstraints, inheritanceState.hasDenormalizedTable() ?\n \t\t\t\t\tsuperEntity.getTable() :\n \t\t\t\t\tnull\n \t\t\t);\n \t\t}\n \t\telse {\n \t\t\tif ( annotatedClass.isAnnotationPresent( Table.class ) ) {\n \t\t\t\tlog.warn( \"Illegal use of @Table in a subclass of a SINGLE_TABLE hierarchy: \" + clazzToProcess\n \t\t\t\t\t\t.getName() );\n \t\t\t}\n \t\t}\n //\t\tMap<String, Column[]> columnOverride = PropertyHolderBuilder.buildHierarchyColumnOverride(\n //\t\t\t\tclazzToProcess,\n //\t\t\t\tpersistentClass.getClassName()\n //\t\t);\n \t\tPropertyHolder propertyHolder = PropertyHolderBuilder.buildPropertyHolder(\n \t\t\t\tclazzToProcess,\n \t\t\t\tpersistentClass,\n \t\t\t\tentityBinder, mappings\n \t\t);\n \n \t\tjavax.persistence.SecondaryTable secTabAnn = annotatedClass.getAnnotation(\n \t\t\t\tjavax.persistence.SecondaryTable.class\n \t\t);\n \t\tjavax.persistence.SecondaryTables secTabsAnn = annotatedClass.getAnnotation(\n \t\t\t\tjavax.persistence.SecondaryTables.class\n \t\t);\n \t\tentityBinder.firstLevelSecondaryTablesBinding( secTabAnn, secTabsAnn );\n \n \t\tOnDelete onDeleteAnn = annotatedClass.getAnnotation( OnDelete.class );\n \t\tboolean onDeleteAppropriate = false;\n \t\tif ( InheritanceType.JOINED.equals( inheritanceState.type ) && inheritanceState.hasParents ) {\n \t\t\tonDeleteAppropriate = true;\n \t\t\tfinal JoinedSubclass jsc = (JoinedSubclass) persistentClass;\n \t\t\tif ( persistentClass.getEntityPersisterClass() == null ) {\n \t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( JoinedSubclassEntityPersister.class );\n \t\t\t}\n \t\t\tSimpleValue key = new DependantValue( jsc.getTable(), jsc.getIdentifier() );\n \t\t\tjsc.setKey( key );\n \t\t\tForeignKey fk = annotatedClass.getAnnotation( ForeignKey.class );\n \t\t\tif ( fk != null && !BinderHelper.isDefault( fk.name() ) ) {\n \t\t\t\tkey.setForeignKeyName( fk.name() );\n \t\t\t}\n \t\t\tif ( onDeleteAnn != null ) {\n \t\t\t\tkey.setCascadeDeleteEnabled( OnDeleteAction.CASCADE.equals( onDeleteAnn.action() ) );\n \t\t\t}\n \t\t\telse {\n \t\t\t\tkey.setCascadeDeleteEnabled( false );\n \t\t\t}\n \t\t\t//we are never in a second pass at that stage, so queue it\n \t\t\tSecondPass sp = new JoinedSubclassFkSecondPass( jsc, inheritanceJoinedColumns, key, mappings );\n \t\t\tmappings.addSecondPass( sp );\n \t\t\tmappings.addSecondPass( new CreateKeySecondPass( jsc ) );\n \n \t\t}\n \t\telse if ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.type ) ) {\n \t\t\tif ( inheritanceState.hasParents ) {\n \t\t\t\tif ( persistentClass.getEntityPersisterClass() == null ) {\n \t\t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( SingleTableEntityPersister.class );\n \t\t\t\t}\n \t\t\t}\n \t\t\telse {\n \t\t\t\tif ( inheritanceState.hasSons || !discriminatorColumn.isImplicit() ) {\n \t\t\t\t\t//need a discriminator column\n \t\t\t\t\tbindDiscriminatorToPersistentClass(\n \t\t\t\t\t\t\t(RootClass) persistentClass,\n \t\t\t\t\t\t\tdiscriminatorColumn,\n \t\t\t\t\t\t\tentityBinder.getSecondaryTables(),\n \t\t\t\t\t\t\tpropertyHolder\n \t\t\t\t\t);\n \t\t\t\t\tentityBinder.bindDiscriminatorValue();//bind it again since the type might have changed\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\telse if ( InheritanceType.TABLE_PER_CLASS.equals( inheritanceState.type ) ) {\n \t\t\tif ( inheritanceState.hasParents ) {\n \t\t\t\tif ( persistentClass.getEntityPersisterClass() == null ) {\n \t\t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( UnionSubclassEntityPersister.class );\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\tif ( onDeleteAnn != null && !onDeleteAppropriate ) {\n \t\t\tlog.warn(\n \t\t\t\t\t\"Inapropriate use of @OnDelete on entity, annotation ignored: {}\", propertyHolder.getEntityName()\n \t\t\t);\n \t\t}\n \n \t\t//try to find class level generators\n \t\tHashMap<String, IdGenerator> classGenerators = buildLocalGenerators( annotatedClass, mappings );\n \n \t\t// check properties\n \t\tList<PropertyData> elements =\n \t\t\t\tgetElementsToProcess(\n \t\t\t\t\t\tclazzToProcess, inheritanceStatePerClass, propertyHolder, entityBinder, mappings\n \t\t\t\t);\n \t\tif ( elements == null ) {\n \t\t\tthrow new AnnotationException( \"No identifier specified for entity: \" + propertyHolder.getEntityName() );\n \t\t}\n \t\tfinal boolean subclassAndSingleTableStrategy = inheritanceState.type == InheritanceType.SINGLE_TABLE\n \t\t\t\t&& inheritanceState.hasParents;\n \t\t//process idclass if any\n \t\tSet<String> idProperties = new HashSet<String>();\n \t\tIdClass idClass = null;\n \t\tif ( !inheritanceState.hasParents ) {\n \t\t\t//look for idClass\n \t\t\tXClass current = inheritanceState.clazz;\n \t\t\tInheritanceState state = inheritanceState;\n \t\t\tdo {\n \t\t\t\tcurrent = state.clazz;\n \t\t\t\tif ( current.isAnnotationPresent( IdClass.class ) ) {\n \t\t\t\t\tidClass = current.getAnnotation( IdClass.class );\n \t\t\t\t\tbreak;\n \t\t\t\t}\n \t\t\t\tstate = InheritanceState.getSuperclassInheritanceState(\n \t\t\t\t\t\tcurrent, inheritanceStatePerClass, mappings.getReflectionManager()\n \t\t\t\t);\n \t\t\t}\n \t\t\twhile ( state != null );\n \t\t}\n \t\tif ( idClass != null ) {\n \t\t\tXClass compositeClass = mappings.getReflectionManager().toXClass( idClass.value() );\n \t\t\tboolean isComponent = true;\n \t\t\tboolean propertyAnnotated = entityBinder.isPropertyAnnotated( compositeClass );\n \t\t\tString propertyAccessor = entityBinder.getPropertyAccessor( compositeClass );\n \t\t\tString generatorType = \"assigned\";\n \t\t\tString generator = BinderHelper.ANNOTATION_STRING_DEFAULT;\n \t\t\tPropertyData inferredData = new PropertyPreloadedData(\n \t\t\t\t\tentityBinder.getPropertyAccessor(), \"id\", compositeClass\n \t\t\t);\n \t\t\tHashMap<String, IdGenerator> localGenerators = new HashMap<String, IdGenerator>();\n \t\t\tboolean ignoreIdAnnotations = entityBinder.isIgnoreIdAnnotations();\n \t\t\tentityBinder.setIgnoreIdAnnotations( true );\n \t\t\tbindId(\n \t\t\t\t\tgeneratorType,\n \t\t\t\t\tgenerator,\n \t\t\t\t\tinferredData,\n \t\t\t\t\tnull,\n \t\t\t\t\tpropertyHolder,\n \t\t\t\t\tlocalGenerators,\n \t\t\t\t\tisComponent,\n \t\t\t\t\tpropertyAnnotated,\n \t\t\t\t\tpropertyAccessor, entityBinder,\n \t\t\t\t\ttrue,\n \t\t\t\t\tfalse, mappings\n \t\t\t);\n \t\t\tinferredData = new PropertyPreloadedData(\n \t\t\t\t\tpropertyAccessor, \"_identifierMapper\", compositeClass\n \t\t\t);\n \t\t\tComponent mapper = fillComponent(\n \t\t\t\t\tpropertyHolder,\n \t\t\t\t\tinferredData,\n \t\t\t\t\tpropertyAnnotated,\n \t\t\t\t\tpropertyAccessor, false,\n \t\t\t\t\tentityBinder,\n \t\t\t\t\ttrue, true,\n \t\t\t\t\tfalse, mappings\n \t\t\t);\n \t\t\tentityBinder.setIgnoreIdAnnotations( ignoreIdAnnotations );\n \t\t\tpersistentClass.setIdentifierMapper( mapper );\n \t\t\tProperty property = new Property();\n \t\t\tproperty.setName( \"_identifierMapper\" );\n \t\t\tproperty.setNodeName( \"id\" );\n \t\t\tproperty.setUpdateable( false );\n \t\t\tproperty.setInsertable( false );\n \t\t\tproperty.setValue( mapper );\n \t\t\tproperty.setPropertyAccessorName( \"embedded\" );\n \t\t\tpersistentClass.addProperty( property );\n \t\t\tentityBinder.setIgnoreIdAnnotations( true );\n \n \t\t\tIterator properties = mapper.getPropertyIterator();\n \t\t\twhile ( properties.hasNext() ) {\n \t\t\t\tidProperties.add( ( (Property) properties.next() ).getName() );\n \t\t\t}\n \t\t}\n \t\tSet<String> missingIdProperties = new HashSet<String>( idProperties );\n \t\tfor (PropertyData propertyAnnotatedElement : elements) {\n \t\t\tString propertyName = propertyAnnotatedElement.getPropertyName();\n \t\t\tif ( !idProperties.contains( propertyName ) ) {\n \t\t\t\tprocessElementAnnotations(\n \t\t\t\t\t\tpropertyHolder,\n \t\t\t\t\t\tsubclassAndSingleTableStrategy ?\n \t\t\t\t\t\t\t\tNullability.FORCED_NULL :\n \t\t\t\t\t\t\t\tNullability.NO_CONSTRAINT,\n \t\t\t\t\t\tpropertyAnnotatedElement.getProperty(),\n \t\t\t\t\t\tpropertyAnnotatedElement, classGenerators, entityBinder,\n \t\t\t\t\t\tfalse, false, false, mappings\n \t\t\t\t);\n \t\t\t}\n \t\t\telse {\n \t\t\t\tmissingIdProperties.remove( propertyName );\n \t\t\t}\n \t\t}\n \n \t\tif ( missingIdProperties.size() != 0 ) {\n \t\t\tStringBuilder missings = new StringBuilder();\n \t\t\tfor (String property : missingIdProperties) {\n \t\t\t\tmissings.append( property ).append( \", \" );\n \t\t\t}\n \t\t\tthrow new AnnotationException(\n \t\t\t\t\t\"Unable to find properties (\"\n \t\t\t\t\t\t\t+ missings.substring( 0, missings.length() - 2 )\n \t\t\t\t\t\t\t+ \") in entity annotated with @IdClass:\" + persistentClass.getEntityName()\n \t\t\t);\n \t\t}\n \n \t\tif ( !inheritanceState.hasParents ) {\n \t\t\tfinal RootClass rootClass = (RootClass) persistentClass;\n \t\t\tmappings.addSecondPass( new CreateKeySecondPass( rootClass ) );\n \t\t}\n \t\telse {\n \t\t\tsuperEntity.addSubclass( (Subclass) persistentClass );\n \t\t}\n \n \t\tmappings.addClass( persistentClass );\n \n \t\t//Process secondary tables and complementary definitions (ie o.h.a.Table)\n \t\tmappings.addSecondPass( new SecondaryTableSecondPass( entityBinder, propertyHolder, annotatedClass ) );\n \n \t\t//add process complementary Table definition (index & all)\n \t\tentityBinder.processComplementaryTableDefinitions( annotatedClass.getAnnotation( org.hibernate.annotations.Table.class ) );\n \t\tentityBinder.processComplementaryTableDefinitions( annotatedClass.getAnnotation( org.hibernate.annotations.Tables.class ) );\n \n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"88caf4d9586e988675254c268f4e145d272a9499": {
			"type": "Ybodychange",
			"commitMessage": "HHH-4364 support @NamedQuery on a @MappedSuperclass (Sharath Reddy)\n\ngit-svn-id: https://svn.jboss.org/repos/hibernate/core/trunk@17530 1b8cb986-b30d-0410-93ca-fae66ebed9b2\n",
			"commitDate": "2009-09-22, 10:19 AM",
			"commitName": "88caf4d9586e988675254c268f4e145d272a9499",
			"commitAuthor": "Emmanuel Bernard",
			"commitDateOld": "2009-07-22, 1:40 PM",
			"commitNameOld": "eeb136fa719fe007158d90ba011473ea7d1fa38b",
			"commitAuthorOld": "Emmanuel Bernard",
			"daysBetweenCommits": 61.86,
			"commitsBetweenForRepo": 90,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,405 +1,411 @@\n \tpublic static void bindClass(\n \t\t\tXClass clazzToProcess, Map<XClass, InheritanceState> inheritanceStatePerClass, ExtendedMappings mappings\n \t) throws MappingException {\n \t\t//TODO: be more strict with secondarytable allowance (not for ids, not for secondary table join columns etc)\n \t\tInheritanceState inheritanceState = inheritanceStatePerClass.get( clazzToProcess );\n \t\tAnnotatedClassType classType = mappings.getClassType( clazzToProcess );\n+\t\t\n+\t\t//Queries declared in MappedSuperclass should be usable in Subclasses\n+\t\tif ( AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals( classType )) {\n+\t\t\tbindQueries(clazzToProcess, mappings );\n+\t\t}\n+\t\t\n \t\tif ( AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals( classType ) //will be processed by their subentities\n \t\t\t\t|| AnnotatedClassType.NONE.equals( classType ) //to be ignored\n \t\t\t\t|| AnnotatedClassType.EMBEDDABLE.equals( classType ) //allow embeddable element declaration\n \t\t\t\t) {\n \t\t\tif ( AnnotatedClassType.NONE.equals( classType )\n \t\t\t\t\t&& clazzToProcess.isAnnotationPresent( org.hibernate.annotations.Entity.class ) ) {\n \t\t\t\tlog.warn( \"Class annotated @org.hibernate.annotations.Entity but not javax.persistence.Entity \"\n \t\t\t\t\t\t+ \"(most likely a user error): {}\", clazzToProcess.getName() );\n \t\t\t}\n \t\t\treturn;\n \t\t}\n \t\tif ( !classType.equals( AnnotatedClassType.ENTITY ) ) {\n \t\t\t//TODO make this test accurate by removing the none elements artifically added\n \t\t\tthrow new AnnotationException(\n \t\t\t\t\t\"Annotated class should have a @javax.persistence.Entity, @javax.persistence.Embeddable or @javax.persistence.EmbeddedSuperclass annotation: \" + clazzToProcess\n \t\t\t\t\t\t\t.getName()\n \t\t\t);\n \t\t}\n \t\tXAnnotatedElement annotatedClass = clazzToProcess;\n \t\tlog.info( \"Binding entity from annotated class: {}\", clazzToProcess.getName() );\n \t\tInheritanceState superEntityState =\n \t\t\t\tInheritanceState.getSuperEntityInheritanceState(\n \t\t\t\t\t\tclazzToProcess, inheritanceStatePerClass, mappings.getReflectionManager()\n \t\t\t\t);\n \t\tPersistentClass superEntity = superEntityState != null ?\n \t\t\t\tmappings.getClass(\n \t\t\t\t\t\tsuperEntityState.clazz.getName()\n \t\t\t\t) :\n \t\t\t\tnull;\n \t\tif ( superEntity == null ) {\n \t\t\t//check if superclass is not a potential persistent class\n \t\t\tif ( inheritanceState.hasParents ) {\n \t\t\t\tthrow new AssertionFailure(\n \t\t\t\t\t\t\"Subclass has to be binded after it's mother class: \"\n \t\t\t\t\t\t\t\t+ superEntityState.clazz.getName()\n \t\t\t\t);\n \t\t\t}\n \t\t}\n \t\tbindQueries( annotatedClass, mappings );\n \t\tbindFilterDefs( annotatedClass, mappings );\n \t\tbindTypeDefs( annotatedClass, mappings );\n \t\tBinderHelper.bindAnyMetaDefs( annotatedClass, mappings );\n \n \t\tString schema = \"\";\n \t\tString table = \"\"; //might be no @Table annotation on the annotated class\n \t\tString catalog = \"\";\n \t\tString discrimValue = null;\n \t\tList<String[]> uniqueConstraints = new ArrayList<String[]>();\n \t\tEjb3DiscriminatorColumn discriminatorColumn = null;\n \t\tEjb3JoinColumn[] inheritanceJoinedColumns = null;\n \n \t\tif ( annotatedClass.isAnnotationPresent( javax.persistence.Table.class ) ) {\n \t\t\tjavax.persistence.Table tabAnn = annotatedClass.getAnnotation( javax.persistence.Table.class );\n \t\t\ttable = tabAnn.name();\n \t\t\tschema = tabAnn.schema();\n \t\t\tcatalog = tabAnn.catalog();\n \t\t\tuniqueConstraints = TableBinder.buildUniqueConstraints( tabAnn.uniqueConstraints() );\n \t\t}\n \t\tfinal boolean hasJoinedColumns = inheritanceState.hasParents\n \t\t\t\t&& InheritanceType.JOINED.equals( inheritanceState.type );\n \t\tif ( hasJoinedColumns ) {\n \t\t\t//@Inheritance(JOINED) subclass need to link back to the super entity\n \t\t\tPrimaryKeyJoinColumns jcsAnn = annotatedClass.getAnnotation( PrimaryKeyJoinColumns.class );\n \t\t\tboolean explicitInheritanceJoinedColumns = jcsAnn != null && jcsAnn.value().length != 0;\n \t\t\tif ( explicitInheritanceJoinedColumns ) {\n \t\t\t\tint nbrOfInhJoinedColumns = jcsAnn.value().length;\n \t\t\t\tPrimaryKeyJoinColumn jcAnn;\n \t\t\t\tinheritanceJoinedColumns = new Ejb3JoinColumn[nbrOfInhJoinedColumns];\n \t\t\t\tfor (int colIndex = 0; colIndex < nbrOfInhJoinedColumns; colIndex++) {\n \t\t\t\t\tjcAnn = jcsAnn.value()[colIndex];\n \t\t\t\t\tinheritanceJoinedColumns[colIndex] = Ejb3JoinColumn.buildJoinColumn(\n \t\t\t\t\t\t\tjcAnn, null, superEntity.getIdentifier(),\n \t\t\t\t\t\t\t(Map<String, Join>) null, (PropertyHolder) null, mappings\n \t\t\t\t\t);\n \t\t\t\t}\n \t\t\t}\n \t\t\telse {\n \t\t\t\tPrimaryKeyJoinColumn jcAnn = annotatedClass.getAnnotation( PrimaryKeyJoinColumn.class );\n \t\t\t\tinheritanceJoinedColumns = new Ejb3JoinColumn[1];\n \t\t\t\tinheritanceJoinedColumns[0] = Ejb3JoinColumn.buildJoinColumn(\n \t\t\t\t\t\tjcAnn, null, superEntity.getIdentifier(),\n \t\t\t\t\t\t(Map<String, Join>) null, (PropertyHolder) null, mappings\n \t\t\t\t);\n \t\t\t}\n \t\t\tlog.debug( \"Subclass joined column(s) created\" );\n \t\t}\n \t\telse {\n \t\t\tif ( annotatedClass.isAnnotationPresent( javax.persistence.PrimaryKeyJoinColumns.class )\n \t\t\t\t\t|| annotatedClass.isAnnotationPresent( javax.persistence.PrimaryKeyJoinColumn.class ) ) {\n \t\t\t\tlog.warn( \"Root entity should not hold an PrimaryKeyJoinColum(s), will be ignored\" );\n \t\t\t}\n \t\t}\n \n \t\tif ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.type ) ) {\n \t\t\tjavax.persistence.DiscriminatorColumn discAnn = annotatedClass.getAnnotation(\n \t\t\t\t\tjavax.persistence.DiscriminatorColumn.class\n \t\t\t);\n \t\t\tDiscriminatorType discriminatorType = discAnn != null ?\n \t\t\t\t\tdiscAnn.discriminatorType() :\n \t\t\t\t\tDiscriminatorType.STRING;\n \n \t\t\torg.hibernate.annotations.DiscriminatorFormula discFormulaAnn = annotatedClass.getAnnotation(\n \t\t\t\t\torg.hibernate.annotations.DiscriminatorFormula.class\n \t\t\t);\n \t\t\tif ( !inheritanceState.hasParents ) {\n \t\t\t\tdiscriminatorColumn = Ejb3DiscriminatorColumn.buildDiscriminatorColumn(\n \t\t\t\t\t\tdiscriminatorType, discAnn, discFormulaAnn, mappings\n \t\t\t\t);\n \t\t\t}\n \t\t\tif ( discAnn != null && inheritanceState.hasParents ) {\n \t\t\t\tlog.warn(\n \t\t\t\t\t\t\"Discriminator column has to be defined in the root entity, it will be ignored in subclass: {}\",\n \t\t\t\t\t\tclazzToProcess.getName()\n \t\t\t\t);\n \t\t\t}\n \t\t\tdiscrimValue = annotatedClass.isAnnotationPresent( DiscriminatorValue.class ) ?\n \t\t\t\t\tannotatedClass.getAnnotation( DiscriminatorValue.class ).value() :\n \t\t\t\t\tnull;\n \t\t}\n \n \t\t//we now know what kind of persistent entity it is\n \t\tPersistentClass persistentClass;\n \t\t//create persistent class\n \t\tif ( !inheritanceState.hasParents ) {\n \t\t\tpersistentClass = new RootClass();\n \t\t}\n \t\telse if ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.type ) ) {\n \t\t\tpersistentClass = new SingleTableSubclass( superEntity );\n \t\t}\n \t\telse if ( InheritanceType.JOINED.equals( inheritanceState.type ) ) {\n \t\t\tpersistentClass = new JoinedSubclass( superEntity );\n \t\t}\n \t\telse if ( InheritanceType.TABLE_PER_CLASS.equals( inheritanceState.type ) ) {\n \t\t\tpersistentClass = new UnionSubclass( superEntity );\n \t\t}\n \t\telse {\n \t\t\tthrow new AssertionFailure( \"Unknown inheritance type: \" + inheritanceState.type );\n \t\t}\n \t\tProxy proxyAnn = annotatedClass.getAnnotation( Proxy.class );\n \t\tBatchSize sizeAnn = annotatedClass.getAnnotation( BatchSize.class );\n \t\tWhere whereAnn = annotatedClass.getAnnotation( Where.class );\n \t\tEntity entityAnn = annotatedClass.getAnnotation( Entity.class );\n \t\torg.hibernate.annotations.Entity hibEntityAnn = annotatedClass.getAnnotation(\n \t\t\t\torg.hibernate.annotations.Entity.class\n \t\t);\n \t\torg.hibernate.annotations.Cache cacheAnn = annotatedClass.getAnnotation(\n \t\t\t\torg.hibernate.annotations.Cache.class\n \t\t);\n \t\tEntityBinder entityBinder = new EntityBinder(\n \t\t\t\tentityAnn, hibEntityAnn, clazzToProcess, persistentClass, mappings\n \t\t);\n \t\tentityBinder.setDiscriminatorValue( discrimValue );\n \t\tentityBinder.setBatchSize( sizeAnn );\n \t\tentityBinder.setProxy( proxyAnn );\n \t\tentityBinder.setWhere( whereAnn );\n \t\tentityBinder.setCache( cacheAnn );\n \t\tentityBinder.setInheritanceState( inheritanceState );\n \t\tFilter filterAnn = annotatedClass.getAnnotation( Filter.class );\n \t\tif ( filterAnn != null ) {\n \t\t\tentityBinder.addFilter( filterAnn.name(), filterAnn.condition() );\n \t\t}\n \t\tFilters filtersAnn = annotatedClass.getAnnotation( Filters.class );\n \t\tif ( filtersAnn != null ) {\n \t\t\tfor (Filter filter : filtersAnn.value()) {\n \t\t\t\tentityBinder.addFilter( filter.name(), filter.condition() );\n \t\t\t}\n \t\t}\n \t\tentityBinder.bindEntity();\n \n \t\tif ( inheritanceState.hasTable() ) {\n \t\t\tCheck checkAnn = annotatedClass.getAnnotation( Check.class );\n \t\t\tString constraints = checkAnn == null ?\n \t\t\t\t\tnull :\n \t\t\t\t\tcheckAnn.constraints();\n \t\t\tentityBinder.bindTable(\n \t\t\t\t\tschema, catalog, table, uniqueConstraints,\n \t\t\t\t\tconstraints, inheritanceState.hasDenormalizedTable() ?\n \t\t\t\t\tsuperEntity.getTable() :\n \t\t\t\t\tnull\n \t\t\t);\n \t\t}\n \t\telse {\n \t\t\tif ( annotatedClass.isAnnotationPresent( Table.class ) ) {\n \t\t\t\tlog.warn( \"Illegal use of @Table in a subclass of a SINGLE_TABLE hierarchy: \" + clazzToProcess\n \t\t\t\t\t\t.getName() );\n \t\t\t}\n \t\t}\n //\t\tMap<String, Column[]> columnOverride = PropertyHolderBuilder.buildHierarchyColumnOverride(\n //\t\t\t\tclazzToProcess,\n //\t\t\t\tpersistentClass.getClassName()\n //\t\t);\n \t\tPropertyHolder propertyHolder = PropertyHolderBuilder.buildPropertyHolder(\n \t\t\t\tclazzToProcess,\n \t\t\t\tpersistentClass,\n \t\t\t\tentityBinder, mappings\n \t\t);\n \n \t\tjavax.persistence.SecondaryTable secTabAnn = annotatedClass.getAnnotation(\n \t\t\t\tjavax.persistence.SecondaryTable.class\n \t\t);\n \t\tjavax.persistence.SecondaryTables secTabsAnn = annotatedClass.getAnnotation(\n \t\t\t\tjavax.persistence.SecondaryTables.class\n \t\t);\n \t\tentityBinder.firstLevelSecondaryTablesBinding( secTabAnn, secTabsAnn );\n \n \t\tOnDelete onDeleteAnn = annotatedClass.getAnnotation( OnDelete.class );\n \t\tboolean onDeleteAppropriate = false;\n \t\tif ( InheritanceType.JOINED.equals( inheritanceState.type ) && inheritanceState.hasParents ) {\n \t\t\tonDeleteAppropriate = true;\n \t\t\tfinal JoinedSubclass jsc = (JoinedSubclass) persistentClass;\n \t\t\tif ( persistentClass.getEntityPersisterClass() == null ) {\n \t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( JoinedSubclassEntityPersister.class );\n \t\t\t}\n \t\t\tSimpleValue key = new DependantValue( jsc.getTable(), jsc.getIdentifier() );\n \t\t\tjsc.setKey( key );\n \t\t\tForeignKey fk = annotatedClass.getAnnotation( ForeignKey.class );\n \t\t\tif ( fk != null && !BinderHelper.isDefault( fk.name() ) ) {\n \t\t\t\tkey.setForeignKeyName( fk.name() );\n \t\t\t}\n \t\t\tif ( onDeleteAnn != null ) {\n \t\t\t\tkey.setCascadeDeleteEnabled( OnDeleteAction.CASCADE.equals( onDeleteAnn.action() ) );\n \t\t\t}\n \t\t\telse {\n \t\t\t\tkey.setCascadeDeleteEnabled( false );\n \t\t\t}\n \t\t\t//we are never in a second pass at that stage, so queue it\n \t\t\tSecondPass sp = new JoinedSubclassFkSecondPass( jsc, inheritanceJoinedColumns, key, mappings );\n \t\t\tmappings.addSecondPass( sp );\n \t\t\tmappings.addSecondPass( new CreateKeySecondPass( jsc ) );\n \n \t\t}\n \t\telse if ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.type ) ) {\n \t\t\tif ( inheritanceState.hasParents ) {\n \t\t\t\tif ( persistentClass.getEntityPersisterClass() == null ) {\n \t\t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( SingleTableEntityPersister.class );\n \t\t\t\t}\n \t\t\t}\n \t\t\telse {\n \t\t\t\tif ( inheritanceState.hasSons || !discriminatorColumn.isImplicit() ) {\n \t\t\t\t\t//need a discriminator column\n \t\t\t\t\tbindDiscriminatorToPersistentClass(\n \t\t\t\t\t\t\t(RootClass) persistentClass,\n \t\t\t\t\t\t\tdiscriminatorColumn,\n \t\t\t\t\t\t\tentityBinder.getSecondaryTables(),\n \t\t\t\t\t\t\tpropertyHolder\n \t\t\t\t\t);\n \t\t\t\t\tentityBinder.bindDiscriminatorValue();//bind it again since the type might have changed\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\telse if ( InheritanceType.TABLE_PER_CLASS.equals( inheritanceState.type ) ) {\n \t\t\tif ( inheritanceState.hasParents ) {\n \t\t\t\tif ( persistentClass.getEntityPersisterClass() == null ) {\n \t\t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( UnionSubclassEntityPersister.class );\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\tif ( onDeleteAnn != null && !onDeleteAppropriate ) {\n \t\t\tlog.warn(\n \t\t\t\t\t\"Inapropriate use of @OnDelete on entity, annotation ignored: {}\", propertyHolder.getEntityName()\n \t\t\t);\n \t\t}\n \n \t\t//try to find class level generators\n \t\tHashMap<String, IdGenerator> classGenerators = buildLocalGenerators( annotatedClass, mappings );\n \n \t\t// check properties\n \t\tList<PropertyData> elements =\n \t\t\t\tgetElementsToProcess(\n \t\t\t\t\t\tclazzToProcess, inheritanceStatePerClass, propertyHolder, entityBinder, mappings\n \t\t\t\t);\n \t\tif ( elements == null ) {\n \t\t\tthrow new AnnotationException( \"No identifier specified for entity: \" + propertyHolder.getEntityName() );\n \t\t}\n \t\tfinal boolean subclassAndSingleTableStrategy = inheritanceState.type == InheritanceType.SINGLE_TABLE\n \t\t\t\t&& inheritanceState.hasParents;\n \t\t//process idclass if any\n \t\tSet<String> idProperties = new HashSet<String>();\n \t\tIdClass idClass = null;\n \t\tif ( !inheritanceState.hasParents ) {\n \t\t\t//look for idClass\n \t\t\tXClass current = inheritanceState.clazz;\n \t\t\tInheritanceState state = inheritanceState;\n \t\t\tdo {\n \t\t\t\tcurrent = state.clazz;\n \t\t\t\tif ( current.isAnnotationPresent( IdClass.class ) ) {\n \t\t\t\t\tidClass = current.getAnnotation( IdClass.class );\n \t\t\t\t\tbreak;\n \t\t\t\t}\n \t\t\t\tstate = InheritanceState.getSuperclassInheritanceState(\n \t\t\t\t\t\tcurrent, inheritanceStatePerClass, mappings.getReflectionManager()\n \t\t\t\t);\n \t\t\t}\n \t\t\twhile ( state != null );\n \t\t}\n \t\tif ( idClass != null ) {\n \t\t\tXClass compositeClass = mappings.getReflectionManager().toXClass( idClass.value() );\n \t\t\tboolean isComponent = true;\n \t\t\tboolean propertyAnnotated = entityBinder.isPropertyAnnotated( compositeClass );\n \t\t\tString propertyAccessor = entityBinder.getPropertyAccessor( compositeClass );\n \t\t\tString generatorType = \"assigned\";\n \t\t\tString generator = BinderHelper.ANNOTATION_STRING_DEFAULT;\n \t\t\tPropertyData inferredData = new PropertyPreloadedData(\n \t\t\t\t\tentityBinder.getPropertyAccessor(), \"id\", compositeClass\n \t\t\t);\n \t\t\tHashMap<String, IdGenerator> localGenerators = new HashMap<String, IdGenerator>();\n \t\t\tboolean ignoreIdAnnotations = entityBinder.isIgnoreIdAnnotations();\n \t\t\tentityBinder.setIgnoreIdAnnotations( true );\n \t\t\tbindId(\n \t\t\t\t\tgeneratorType,\n \t\t\t\t\tgenerator,\n \t\t\t\t\tinferredData,\n \t\t\t\t\tnull,\n \t\t\t\t\tpropertyHolder,\n \t\t\t\t\tlocalGenerators,\n \t\t\t\t\tisComponent,\n \t\t\t\t\tpropertyAnnotated,\n \t\t\t\t\tpropertyAccessor, entityBinder,\n \t\t\t\t\ttrue,\n \t\t\t\t\tfalse, mappings\n \t\t\t);\n \t\t\tinferredData = new PropertyPreloadedData(\n \t\t\t\t\tpropertyAccessor, \"_identifierMapper\", compositeClass\n \t\t\t);\n \t\t\tComponent mapper = fillComponent(\n \t\t\t\t\tpropertyHolder,\n \t\t\t\t\tinferredData,\n \t\t\t\t\tpropertyAnnotated,\n \t\t\t\t\tpropertyAccessor, false,\n \t\t\t\t\tentityBinder,\n \t\t\t\t\ttrue, true,\n \t\t\t\t\tfalse, mappings\n \t\t\t);\n \t\t\tentityBinder.setIgnoreIdAnnotations( ignoreIdAnnotations );\n \t\t\tpersistentClass.setIdentifierMapper( mapper );\n \t\t\tProperty property = new Property();\n \t\t\tproperty.setName( \"_identifierMapper\" );\n \t\t\tproperty.setNodeName( \"id\" );\n \t\t\tproperty.setUpdateable( false );\n \t\t\tproperty.setInsertable( false );\n \t\t\tproperty.setValue( mapper );\n \t\t\tproperty.setPropertyAccessorName( \"embedded\" );\n \t\t\tpersistentClass.addProperty( property );\n \t\t\tentityBinder.setIgnoreIdAnnotations( true );\n \n \t\t\tIterator properties = mapper.getPropertyIterator();\n \t\t\twhile ( properties.hasNext() ) {\n \t\t\t\tidProperties.add( ( (Property) properties.next() ).getName() );\n \t\t\t}\n \t\t}\n \t\tSet<String> missingIdProperties = new HashSet<String>( idProperties );\n \t\tfor (PropertyData propertyAnnotatedElement : elements) {\n \t\t\tString propertyName = propertyAnnotatedElement.getPropertyName();\n \t\t\tif ( !idProperties.contains( propertyName ) ) {\n \t\t\t\tprocessElementAnnotations(\n \t\t\t\t\t\tpropertyHolder,\n \t\t\t\t\t\tsubclassAndSingleTableStrategy ?\n \t\t\t\t\t\t\t\tNullability.FORCED_NULL :\n \t\t\t\t\t\t\t\tNullability.NO_CONSTRAINT,\n \t\t\t\t\t\tpropertyAnnotatedElement.getProperty(),\n \t\t\t\t\t\tpropertyAnnotatedElement, classGenerators, entityBinder,\n \t\t\t\t\t\tfalse, false, false, mappings\n \t\t\t\t);\n \t\t\t}\n \t\t\telse {\n \t\t\t\tmissingIdProperties.remove( propertyName );\n \t\t\t}\n \t\t}\n \n \t\tif ( missingIdProperties.size() != 0 ) {\n \t\t\tStringBuilder missings = new StringBuilder();\n \t\t\tfor (String property : missingIdProperties) {\n \t\t\t\tmissings.append( property ).append( \", \" );\n \t\t\t}\n \t\t\tthrow new AnnotationException(\n \t\t\t\t\t\"Unable to find properties (\"\n \t\t\t\t\t\t\t+ missings.substring( 0, missings.length() - 2 )\n \t\t\t\t\t\t\t+ \") in entity annotated with @IdClass:\" + persistentClass.getEntityName()\n \t\t\t);\n \t\t}\n \n \t\tif ( !inheritanceState.hasParents ) {\n \t\t\tfinal RootClass rootClass = (RootClass) persistentClass;\n \t\t\tmappings.addSecondPass( new CreateKeySecondPass( rootClass ) );\n \t\t}\n \t\telse {\n \t\t\tsuperEntity.addSubclass( (Subclass) persistentClass );\n \t\t}\n \n \t\tmappings.addClass( persistentClass );\n \n \t\t//Process secondary tables and complementary definitions (ie o.h.a.Table)\n \t\tmappings.addSecondPass( new SecondaryTableSecondPass( entityBinder, propertyHolder, annotatedClass ) );\n \n \t\t//add process complementary Table definition (index & all)\n \t\tentityBinder.processComplementaryTableDefinitions( annotatedClass.getAnnotation( org.hibernate.annotations.Table.class ) );\n \t\tentityBinder.processComplementaryTableDefinitions( annotatedClass.getAnnotation( org.hibernate.annotations.Tables.class ) );\n \n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"9d7a03a5f7f03bc803d897baa590861154b39f5e": {
			"type": "Yfilerename",
			"commitMessage": "HHH-3550 : import annotations into core\n\ngit-svn-id: https://svn.jboss.org/repos/hibernate/core/trunk@15418 1b8cb986-b30d-0410-93ca-fae66ebed9b2\n",
			"commitDate": "2008-10-28, 11:53 AM",
			"commitName": "9d7a03a5f7f03bc803d897baa590861154b39f5e",
			"commitAuthor": "Steve Ebersole",
			"commitDateOld": "2008-10-28, 11:52 AM",
			"commitNameOld": "c457f2b3258fc48ef4010a9e58cd2fc3baaca6cc",
			"commitAuthorOld": "Steve Ebersole",
			"daysBetweenCommits": 0,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "",
			"extendedDetails": {
				"oldPath": "annotations/src/java/org/hibernate/cfg/AnnotationBinder.java",
				"newPath": "annotations/src/main/java/org/hibernate/cfg/AnnotationBinder.java"
			}
		},
		"7337743c93574823424ed6c399cfcf6bd75614f8": {
			"type": "Yintroduced",
			"commitMessage": "HHH-3550 : import annotations into core\n\ngit-svn-id: https://svn.jboss.org/repos/hibernate/core/trunk@15415 1b8cb986-b30d-0410-93ca-fae66ebed9b2\n",
			"commitDate": "2008-10-28, 11:41 AM",
			"commitName": "7337743c93574823424ed6c399cfcf6bd75614f8",
			"commitAuthor": "Steve Ebersole",
			"diff": "@@ -0,0 +1,405 @@\n+\tpublic static void bindClass(\n+\t\t\tXClass clazzToProcess, Map<XClass, InheritanceState> inheritanceStatePerClass, ExtendedMappings mappings\n+\t) throws MappingException {\n+\t\t//TODO: be more strict with secondarytable allowance (not for ids, not for secondary table join columns etc)\n+\t\tInheritanceState inheritanceState = inheritanceStatePerClass.get( clazzToProcess );\n+\t\tAnnotatedClassType classType = mappings.getClassType( clazzToProcess );\n+\t\tif ( AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals( classType ) //will be processed by their subentities\n+\t\t\t\t|| AnnotatedClassType.NONE.equals( classType ) //to be ignored\n+\t\t\t\t|| AnnotatedClassType.EMBEDDABLE.equals( classType ) //allow embeddable element declaration\n+\t\t\t\t) {\n+\t\t\tif ( AnnotatedClassType.NONE.equals( classType )\n+\t\t\t\t\t&& clazzToProcess.isAnnotationPresent( org.hibernate.annotations.Entity.class ) ) {\n+\t\t\t\tlog.warn( \"Class annotated @org.hibernate.annotations.Entity but not javax.persistence.Entity \"\n+\t\t\t\t\t\t+ \"(most likely a user error): {}\", clazzToProcess.getName() );\n+\t\t\t}\n+\t\t\treturn;\n+\t\t}\n+\t\tif ( !classType.equals( AnnotatedClassType.ENTITY ) ) {\n+\t\t\t//TODO make this test accurate by removing the none elements artifically added\n+\t\t\tthrow new AnnotationException(\n+\t\t\t\t\t\"Annotated class should have a @javax.persistence.Entity, @javax.persistence.Embeddable or @javax.persistence.EmbeddedSuperclass annotation: \" + clazzToProcess\n+\t\t\t\t\t\t\t.getName()\n+\t\t\t);\n+\t\t}\n+\t\tXAnnotatedElement annotatedClass = clazzToProcess;\n+\t\tlog.info( \"Binding entity from annotated class: {}\", clazzToProcess.getName() );\n+\t\tInheritanceState superEntityState =\n+\t\t\t\tInheritanceState.getSuperEntityInheritanceState(\n+\t\t\t\t\t\tclazzToProcess, inheritanceStatePerClass, mappings.getReflectionManager()\n+\t\t\t\t);\n+\t\tPersistentClass superEntity = superEntityState != null ?\n+\t\t\t\tmappings.getClass(\n+\t\t\t\t\t\tsuperEntityState.clazz.getName()\n+\t\t\t\t) :\n+\t\t\t\tnull;\n+\t\tif ( superEntity == null ) {\n+\t\t\t//check if superclass is not a potential persistent class\n+\t\t\tif ( inheritanceState.hasParents ) {\n+\t\t\t\tthrow new AssertionFailure(\n+\t\t\t\t\t\t\"Subclass has to be binded after it's mother class: \"\n+\t\t\t\t\t\t\t\t+ superEntityState.clazz.getName()\n+\t\t\t\t);\n+\t\t\t}\n+\t\t}\n+\t\tbindQueries( annotatedClass, mappings );\n+\t\tbindFilterDefs( annotatedClass, mappings );\n+\t\tbindTypeDefs( annotatedClass, mappings );\n+\t\tBinderHelper.bindAnyMetaDefs( annotatedClass, mappings );\n+\n+\t\tString schema = \"\";\n+\t\tString table = \"\"; //might be no @Table annotation on the annotated class\n+\t\tString catalog = \"\";\n+\t\tString discrimValue = null;\n+\t\tList<String[]> uniqueConstraints = new ArrayList<String[]>();\n+\t\tEjb3DiscriminatorColumn discriminatorColumn = null;\n+\t\tEjb3JoinColumn[] inheritanceJoinedColumns = null;\n+\n+\t\tif ( annotatedClass.isAnnotationPresent( javax.persistence.Table.class ) ) {\n+\t\t\tjavax.persistence.Table tabAnn = annotatedClass.getAnnotation( javax.persistence.Table.class );\n+\t\t\ttable = tabAnn.name();\n+\t\t\tschema = tabAnn.schema();\n+\t\t\tcatalog = tabAnn.catalog();\n+\t\t\tuniqueConstraints = TableBinder.buildUniqueConstraints( tabAnn.uniqueConstraints() );\n+\t\t}\n+\t\tfinal boolean hasJoinedColumns = inheritanceState.hasParents\n+\t\t\t\t&& InheritanceType.JOINED.equals( inheritanceState.type );\n+\t\tif ( hasJoinedColumns ) {\n+\t\t\t//@Inheritance(JOINED) subclass need to link back to the super entity\n+\t\t\tPrimaryKeyJoinColumns jcsAnn = annotatedClass.getAnnotation( PrimaryKeyJoinColumns.class );\n+\t\t\tboolean explicitInheritanceJoinedColumns = jcsAnn != null && jcsAnn.value().length != 0;\n+\t\t\tif ( explicitInheritanceJoinedColumns ) {\n+\t\t\t\tint nbrOfInhJoinedColumns = jcsAnn.value().length;\n+\t\t\t\tPrimaryKeyJoinColumn jcAnn;\n+\t\t\t\tinheritanceJoinedColumns = new Ejb3JoinColumn[nbrOfInhJoinedColumns];\n+\t\t\t\tfor (int colIndex = 0; colIndex < nbrOfInhJoinedColumns; colIndex++) {\n+\t\t\t\t\tjcAnn = jcsAnn.value()[colIndex];\n+\t\t\t\t\tinheritanceJoinedColumns[colIndex] = Ejb3JoinColumn.buildJoinColumn(\n+\t\t\t\t\t\t\tjcAnn, null, superEntity.getIdentifier(),\n+\t\t\t\t\t\t\t(Map<String, Join>) null, (PropertyHolder) null, mappings\n+\t\t\t\t\t);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\telse {\n+\t\t\t\tPrimaryKeyJoinColumn jcAnn = annotatedClass.getAnnotation( PrimaryKeyJoinColumn.class );\n+\t\t\t\tinheritanceJoinedColumns = new Ejb3JoinColumn[1];\n+\t\t\t\tinheritanceJoinedColumns[0] = Ejb3JoinColumn.buildJoinColumn(\n+\t\t\t\t\t\tjcAnn, null, superEntity.getIdentifier(),\n+\t\t\t\t\t\t(Map<String, Join>) null, (PropertyHolder) null, mappings\n+\t\t\t\t);\n+\t\t\t}\n+\t\t\tlog.debug( \"Subclass joined column(s) created\" );\n+\t\t}\n+\t\telse {\n+\t\t\tif ( annotatedClass.isAnnotationPresent( javax.persistence.PrimaryKeyJoinColumns.class )\n+\t\t\t\t\t|| annotatedClass.isAnnotationPresent( javax.persistence.PrimaryKeyJoinColumn.class ) ) {\n+\t\t\t\tlog.warn( \"Root entity should not hold an PrimaryKeyJoinColum(s), will be ignored\" );\n+\t\t\t}\n+\t\t}\n+\n+\t\tif ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.type ) ) {\n+\t\t\tjavax.persistence.DiscriminatorColumn discAnn = annotatedClass.getAnnotation(\n+\t\t\t\t\tjavax.persistence.DiscriminatorColumn.class\n+\t\t\t);\n+\t\t\tDiscriminatorType discriminatorType = discAnn != null ?\n+\t\t\t\t\tdiscAnn.discriminatorType() :\n+\t\t\t\t\tDiscriminatorType.STRING;\n+\n+\t\t\torg.hibernate.annotations.DiscriminatorFormula discFormulaAnn = annotatedClass.getAnnotation(\n+\t\t\t\t\torg.hibernate.annotations.DiscriminatorFormula.class\n+\t\t\t);\n+\t\t\tif ( !inheritanceState.hasParents ) {\n+\t\t\t\tdiscriminatorColumn = Ejb3DiscriminatorColumn.buildDiscriminatorColumn(\n+\t\t\t\t\t\tdiscriminatorType, discAnn, discFormulaAnn, mappings\n+\t\t\t\t);\n+\t\t\t}\n+\t\t\tif ( discAnn != null && inheritanceState.hasParents ) {\n+\t\t\t\tlog.warn(\n+\t\t\t\t\t\t\"Discriminator column has to be defined in the root entity, it will be ignored in subclass: {}\",\n+\t\t\t\t\t\tclazzToProcess.getName()\n+\t\t\t\t);\n+\t\t\t}\n+\t\t\tdiscrimValue = annotatedClass.isAnnotationPresent( DiscriminatorValue.class ) ?\n+\t\t\t\t\tannotatedClass.getAnnotation( DiscriminatorValue.class ).value() :\n+\t\t\t\t\tnull;\n+\t\t}\n+\n+\t\t//we now know what kind of persistent entity it is\n+\t\tPersistentClass persistentClass;\n+\t\t//create persistent class\n+\t\tif ( !inheritanceState.hasParents ) {\n+\t\t\tpersistentClass = new RootClass();\n+\t\t}\n+\t\telse if ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.type ) ) {\n+\t\t\tpersistentClass = new SingleTableSubclass( superEntity );\n+\t\t}\n+\t\telse if ( InheritanceType.JOINED.equals( inheritanceState.type ) ) {\n+\t\t\tpersistentClass = new JoinedSubclass( superEntity );\n+\t\t}\n+\t\telse if ( InheritanceType.TABLE_PER_CLASS.equals( inheritanceState.type ) ) {\n+\t\t\tpersistentClass = new UnionSubclass( superEntity );\n+\t\t}\n+\t\telse {\n+\t\t\tthrow new AssertionFailure( \"Unknown inheritance type: \" + inheritanceState.type );\n+\t\t}\n+\t\tProxy proxyAnn = annotatedClass.getAnnotation( Proxy.class );\n+\t\tBatchSize sizeAnn = annotatedClass.getAnnotation( BatchSize.class );\n+\t\tWhere whereAnn = annotatedClass.getAnnotation( Where.class );\n+\t\tEntity entityAnn = annotatedClass.getAnnotation( Entity.class );\n+\t\torg.hibernate.annotations.Entity hibEntityAnn = annotatedClass.getAnnotation(\n+\t\t\t\torg.hibernate.annotations.Entity.class\n+\t\t);\n+\t\torg.hibernate.annotations.Cache cacheAnn = annotatedClass.getAnnotation(\n+\t\t\t\torg.hibernate.annotations.Cache.class\n+\t\t);\n+\t\tEntityBinder entityBinder = new EntityBinder(\n+\t\t\t\tentityAnn, hibEntityAnn, clazzToProcess, persistentClass, mappings\n+\t\t);\n+\t\tentityBinder.setDiscriminatorValue( discrimValue );\n+\t\tentityBinder.setBatchSize( sizeAnn );\n+\t\tentityBinder.setProxy( proxyAnn );\n+\t\tentityBinder.setWhere( whereAnn );\n+\t\tentityBinder.setCache( cacheAnn );\n+\t\tentityBinder.setInheritanceState( inheritanceState );\n+\t\tFilter filterAnn = annotatedClass.getAnnotation( Filter.class );\n+\t\tif ( filterAnn != null ) {\n+\t\t\tentityBinder.addFilter( filterAnn.name(), filterAnn.condition() );\n+\t\t}\n+\t\tFilters filtersAnn = annotatedClass.getAnnotation( Filters.class );\n+\t\tif ( filtersAnn != null ) {\n+\t\t\tfor (Filter filter : filtersAnn.value()) {\n+\t\t\t\tentityBinder.addFilter( filter.name(), filter.condition() );\n+\t\t\t}\n+\t\t}\n+\t\tentityBinder.bindEntity();\n+\n+\t\tif ( inheritanceState.hasTable() ) {\n+\t\t\tCheck checkAnn = annotatedClass.getAnnotation( Check.class );\n+\t\t\tString constraints = checkAnn == null ?\n+\t\t\t\t\tnull :\n+\t\t\t\t\tcheckAnn.constraints();\n+\t\t\tentityBinder.bindTable(\n+\t\t\t\t\tschema, catalog, table, uniqueConstraints,\n+\t\t\t\t\tconstraints, inheritanceState.hasDenormalizedTable() ?\n+\t\t\t\t\tsuperEntity.getTable() :\n+\t\t\t\t\tnull\n+\t\t\t);\n+\t\t}\n+\t\telse {\n+\t\t\tif ( annotatedClass.isAnnotationPresent( Table.class ) ) {\n+\t\t\t\tlog.warn( \"Illegal use of @Table in a subclass of a SINGLE_TABLE hierarchy: \" + clazzToProcess\n+\t\t\t\t\t\t.getName() );\n+\t\t\t}\n+\t\t}\n+//\t\tMap<String, Column[]> columnOverride = PropertyHolderBuilder.buildHierarchyColumnOverride(\n+//\t\t\t\tclazzToProcess,\n+//\t\t\t\tpersistentClass.getClassName()\n+//\t\t);\n+\t\tPropertyHolder propertyHolder = PropertyHolderBuilder.buildPropertyHolder(\n+\t\t\t\tclazzToProcess,\n+\t\t\t\tpersistentClass,\n+\t\t\t\tentityBinder, mappings\n+\t\t);\n+\n+\t\tjavax.persistence.SecondaryTable secTabAnn = annotatedClass.getAnnotation(\n+\t\t\t\tjavax.persistence.SecondaryTable.class\n+\t\t);\n+\t\tjavax.persistence.SecondaryTables secTabsAnn = annotatedClass.getAnnotation(\n+\t\t\t\tjavax.persistence.SecondaryTables.class\n+\t\t);\n+\t\tentityBinder.firstLevelSecondaryTablesBinding( secTabAnn, secTabsAnn );\n+\n+\t\tOnDelete onDeleteAnn = annotatedClass.getAnnotation( OnDelete.class );\n+\t\tboolean onDeleteAppropriate = false;\n+\t\tif ( InheritanceType.JOINED.equals( inheritanceState.type ) && inheritanceState.hasParents ) {\n+\t\t\tonDeleteAppropriate = true;\n+\t\t\tfinal JoinedSubclass jsc = (JoinedSubclass) persistentClass;\n+\t\t\tif ( persistentClass.getEntityPersisterClass() == null ) {\n+\t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( JoinedSubclassEntityPersister.class );\n+\t\t\t}\n+\t\t\tSimpleValue key = new DependantValue( jsc.getTable(), jsc.getIdentifier() );\n+\t\t\tjsc.setKey( key );\n+\t\t\tForeignKey fk = annotatedClass.getAnnotation( ForeignKey.class );\n+\t\t\tif ( fk != null && !BinderHelper.isDefault( fk.name() ) ) {\n+\t\t\t\tkey.setForeignKeyName( fk.name() );\n+\t\t\t}\n+\t\t\tif ( onDeleteAnn != null ) {\n+\t\t\t\tkey.setCascadeDeleteEnabled( OnDeleteAction.CASCADE.equals( onDeleteAnn.action() ) );\n+\t\t\t}\n+\t\t\telse {\n+\t\t\t\tkey.setCascadeDeleteEnabled( false );\n+\t\t\t}\n+\t\t\t//we are never in a second pass at that stage, so queue it\n+\t\t\tSecondPass sp = new JoinedSubclassFkSecondPass( jsc, inheritanceJoinedColumns, key, mappings );\n+\t\t\tmappings.addSecondPass( sp );\n+\t\t\tmappings.addSecondPass( new CreateKeySecondPass( jsc ) );\n+\n+\t\t}\n+\t\telse if ( InheritanceType.SINGLE_TABLE.equals( inheritanceState.type ) ) {\n+\t\t\tif ( inheritanceState.hasParents ) {\n+\t\t\t\tif ( persistentClass.getEntityPersisterClass() == null ) {\n+\t\t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( SingleTableEntityPersister.class );\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\telse {\n+\t\t\t\tif ( inheritanceState.hasSons || !discriminatorColumn.isImplicit() ) {\n+\t\t\t\t\t//need a discriminator column\n+\t\t\t\t\tbindDiscriminatorToPersistentClass(\n+\t\t\t\t\t\t\t(RootClass) persistentClass,\n+\t\t\t\t\t\t\tdiscriminatorColumn,\n+\t\t\t\t\t\t\tentityBinder.getSecondaryTables(),\n+\t\t\t\t\t\t\tpropertyHolder\n+\t\t\t\t\t);\n+\t\t\t\t\tentityBinder.bindDiscriminatorValue();//bind it again since the type might have changed\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\telse if ( InheritanceType.TABLE_PER_CLASS.equals( inheritanceState.type ) ) {\n+\t\t\tif ( inheritanceState.hasParents ) {\n+\t\t\t\tif ( persistentClass.getEntityPersisterClass() == null ) {\n+\t\t\t\t\tpersistentClass.getRootClass().setEntityPersisterClass( UnionSubclassEntityPersister.class );\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\tif ( onDeleteAnn != null && !onDeleteAppropriate ) {\n+\t\t\tlog.warn(\n+\t\t\t\t\t\"Inapropriate use of @OnDelete on entity, annotation ignored: {}\", propertyHolder.getEntityName()\n+\t\t\t);\n+\t\t}\n+\n+\t\t//try to find class level generators\n+\t\tHashMap<String, IdGenerator> classGenerators = buildLocalGenerators( annotatedClass, mappings );\n+\n+\t\t// check properties\n+\t\tList<PropertyData> elements =\n+\t\t\t\tgetElementsToProcess(\n+\t\t\t\t\t\tclazzToProcess, inheritanceStatePerClass, propertyHolder, entityBinder, mappings\n+\t\t\t\t);\n+\t\tif ( elements == null ) {\n+\t\t\tthrow new AnnotationException( \"No identifier specified for entity: \" + propertyHolder.getEntityName() );\n+\t\t}\n+\t\tfinal boolean subclassAndSingleTableStrategy = inheritanceState.type == InheritanceType.SINGLE_TABLE\n+\t\t\t\t&& inheritanceState.hasParents;\n+\t\t//process idclass if any\n+\t\tSet<String> idProperties = new HashSet<String>();\n+\t\tIdClass idClass = null;\n+\t\tif ( !inheritanceState.hasParents ) {\n+\t\t\t//look for idClass\n+\t\t\tXClass current = inheritanceState.clazz;\n+\t\t\tInheritanceState state = inheritanceState;\n+\t\t\tdo {\n+\t\t\t\tcurrent = state.clazz;\n+\t\t\t\tif ( current.isAnnotationPresent( IdClass.class ) ) {\n+\t\t\t\t\tidClass = current.getAnnotation( IdClass.class );\n+\t\t\t\t\tbreak;\n+\t\t\t\t}\n+\t\t\t\tstate = InheritanceState.getSuperclassInheritanceState(\n+\t\t\t\t\t\tcurrent, inheritanceStatePerClass, mappings.getReflectionManager()\n+\t\t\t\t);\n+\t\t\t}\n+\t\t\twhile ( state != null );\n+\t\t}\n+\t\tif ( idClass != null ) {\n+\t\t\tXClass compositeClass = mappings.getReflectionManager().toXClass( idClass.value() );\n+\t\t\tboolean isComponent = true;\n+\t\t\tboolean propertyAnnotated = entityBinder.isPropertyAnnotated( compositeClass );\n+\t\t\tString propertyAccessor = entityBinder.getPropertyAccessor( compositeClass );\n+\t\t\tString generatorType = \"assigned\";\n+\t\t\tString generator = BinderHelper.ANNOTATION_STRING_DEFAULT;\n+\t\t\tPropertyData inferredData = new PropertyPreloadedData(\n+\t\t\t\t\tentityBinder.getPropertyAccessor(), \"id\", compositeClass\n+\t\t\t);\n+\t\t\tHashMap<String, IdGenerator> localGenerators = new HashMap<String, IdGenerator>();\n+\t\t\tboolean ignoreIdAnnotations = entityBinder.isIgnoreIdAnnotations();\n+\t\t\tentityBinder.setIgnoreIdAnnotations( true );\n+\t\t\tbindId(\n+\t\t\t\t\tgeneratorType,\n+\t\t\t\t\tgenerator,\n+\t\t\t\t\tinferredData,\n+\t\t\t\t\tnull,\n+\t\t\t\t\tpropertyHolder,\n+\t\t\t\t\tlocalGenerators,\n+\t\t\t\t\tisComponent,\n+\t\t\t\t\tpropertyAnnotated,\n+\t\t\t\t\tpropertyAccessor, entityBinder,\n+\t\t\t\t\ttrue,\n+\t\t\t\t\tfalse, mappings\n+\t\t\t);\n+\t\t\tinferredData = new PropertyPreloadedData(\n+\t\t\t\t\tpropertyAccessor, \"_identifierMapper\", compositeClass\n+\t\t\t);\n+\t\t\tComponent mapper = fillComponent(\n+\t\t\t\t\tpropertyHolder,\n+\t\t\t\t\tinferredData,\n+\t\t\t\t\tpropertyAnnotated,\n+\t\t\t\t\tpropertyAccessor, false,\n+\t\t\t\t\tentityBinder,\n+\t\t\t\t\ttrue, true,\n+\t\t\t\t\tfalse, mappings\n+\t\t\t);\n+\t\t\tentityBinder.setIgnoreIdAnnotations( ignoreIdAnnotations );\n+\t\t\tpersistentClass.setIdentifierMapper( mapper );\n+\t\t\tProperty property = new Property();\n+\t\t\tproperty.setName( \"_identifierMapper\" );\n+\t\t\tproperty.setNodeName( \"id\" );\n+\t\t\tproperty.setUpdateable( false );\n+\t\t\tproperty.setInsertable( false );\n+\t\t\tproperty.setValue( mapper );\n+\t\t\tproperty.setPropertyAccessorName( \"embedded\" );\n+\t\t\tpersistentClass.addProperty( property );\n+\t\t\tentityBinder.setIgnoreIdAnnotations( true );\n+\n+\t\t\tIterator properties = mapper.getPropertyIterator();\n+\t\t\twhile ( properties.hasNext() ) {\n+\t\t\t\tidProperties.add( ( (Property) properties.next() ).getName() );\n+\t\t\t}\n+\t\t}\n+\t\tSet<String> missingIdProperties = new HashSet<String>( idProperties );\n+\t\tfor (PropertyData propertyAnnotatedElement : elements) {\n+\t\t\tString propertyName = propertyAnnotatedElement.getPropertyName();\n+\t\t\tif ( !idProperties.contains( propertyName ) ) {\n+\t\t\t\tprocessElementAnnotations(\n+\t\t\t\t\t\tpropertyHolder,\n+\t\t\t\t\t\tsubclassAndSingleTableStrategy ?\n+\t\t\t\t\t\t\t\tNullability.FORCED_NULL :\n+\t\t\t\t\t\t\t\tNullability.NO_CONSTRAINT,\n+\t\t\t\t\t\tpropertyAnnotatedElement.getProperty(),\n+\t\t\t\t\t\tpropertyAnnotatedElement, classGenerators, entityBinder,\n+\t\t\t\t\t\tfalse, false, false, mappings\n+\t\t\t\t);\n+\t\t\t}\n+\t\t\telse {\n+\t\t\t\tmissingIdProperties.remove( propertyName );\n+\t\t\t}\n+\t\t}\n+\n+\t\tif ( missingIdProperties.size() != 0 ) {\n+\t\t\tStringBuilder missings = new StringBuilder();\n+\t\t\tfor (String property : missingIdProperties) {\n+\t\t\t\tmissings.append( property ).append( \", \" );\n+\t\t\t}\n+\t\t\tthrow new AnnotationException(\n+\t\t\t\t\t\"Unable to find properties (\"\n+\t\t\t\t\t\t\t+ missings.substring( 0, missings.length() - 2 )\n+\t\t\t\t\t\t\t+ \") in entity annotated with @IdClass:\" + persistentClass.getEntityName()\n+\t\t\t);\n+\t\t}\n+\n+\t\tif ( !inheritanceState.hasParents ) {\n+\t\t\tfinal RootClass rootClass = (RootClass) persistentClass;\n+\t\t\tmappings.addSecondPass( new CreateKeySecondPass( rootClass ) );\n+\t\t}\n+\t\telse {\n+\t\t\tsuperEntity.addSubclass( (Subclass) persistentClass );\n+\t\t}\n+\n+\t\tmappings.addClass( persistentClass );\n+\n+\t\t//Process secondary tables and complementary definitions (ie o.h.a.Table)\n+\t\tmappings.addSecondPass( new SecondaryTableSecondPass( entityBinder, propertyHolder, annotatedClass ) );\n+\n+\t\t//add process complementary Table definition (index & all)\n+\t\tentityBinder.processComplementaryTableDefinitions( annotatedClass.getAnnotation( org.hibernate.annotations.Table.class ) );\n+\t\tentityBinder.processComplementaryTableDefinitions( annotatedClass.getAnnotation( org.hibernate.annotations.Tables.class ) );\n+\n+\t}\n\\ No newline at end of file\n"
		}
	},
	"sha": "8bd79b29cfa7b2d539a746dc356d60b66e1e596b"
}