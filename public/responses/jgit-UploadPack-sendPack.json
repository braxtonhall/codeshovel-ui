{
	"repo": "https://github.com/eclipse/jgit.git",
	"file": "org.eclipse.jgit/src/org/eclipse/jgit/transport/UploadPack.java",
	"method": {
		"longName": "UploadPack::sendPack(boolean sideband, PackStatistics.Accumulator accumulator, Collection<Ref> allTags, List<ObjectId> unshallowCommits)",
		"startLine": 1983,
		"methodName": "sendPack",
		"isStatic": false,
		"isAbstract": false,
		"visibility": "private"
	},
	"history": {
		"cd0d69ffec9eedff24a2692d18024e752cadc7c8": {
			"type": "Yparameterchange",
			"commitMessage": "Refactor unshallowCommits to local variable\n\nThis reduces the amount of state held as instance variables in\nUploadPack, and makes it easier for a future patch to contain a clearer\nversion of UploadPack#processShallow.\n\nChange-Id: I6df80b42f9e5118fda1420692e02e417670cced3\nSigned-off-by: Jonathan Tan <jonathantanmy@google.com>\nSigned-off-by: Jonathan Nieder <jrn@google.com>\n",
			"commitDate": "2018-06-04, 11:04 PM",
			"commitName": "cd0d69ffec9eedff24a2692d18024e752cadc7c8",
			"commitAuthor": "Jonathan Tan",
			"commitDateOld": "2018-06-04, 10:59 PM",
			"commitNameOld": "f516c1df9d18ff9aaba1dd5668db1776d42dd2bb",
			"commitAuthorOld": "Jonathan Tan",
			"daysBetweenCommits": 0,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,145 +1,146 @@\n \tprivate void sendPack(final boolean sideband,\n \t\t\tPackStatistics.Accumulator accumulator,\n-\t\t\t@Nullable Collection<Ref> allTags) throws IOException {\n+\t\t\t@Nullable Collection<Ref> allTags,\n+\t\t\tList<ObjectId> unshallowCommits) throws IOException {\n \t\tProgressMonitor pm = NullProgressMonitor.INSTANCE;\n \t\tOutputStream packOut = rawOut;\n \n \t\tif (sideband) {\n \t\t\tint bufsz = SideBandOutputStream.SMALL_BUF;\n \t\t\tif (options.contains(OPTION_SIDE_BAND_64K))\n \t\t\t\tbufsz = SideBandOutputStream.MAX_BUF;\n \n \t\t\tpackOut = new SideBandOutputStream(SideBandOutputStream.CH_DATA,\n \t\t\t\t\tbufsz, rawOut);\n \t\t\tif (!options.contains(OPTION_NO_PROGRESS)) {\n \t\t\t\tmsgOut = new SideBandOutputStream(\n \t\t\t\t\t\tSideBandOutputStream.CH_PROGRESS, bufsz, rawOut);\n \t\t\t\tpm = new SideBandProgressMonitor(msgOut);\n \t\t\t}\n \t\t}\n \n \t\ttry {\n \t\t\tif (wantAll.isEmpty()) {\n \t\t\t\tpreUploadHook.onSendPack(this, wantIds, commonBase);\n \t\t\t} else {\n \t\t\t\tpreUploadHook.onSendPack(this, wantAll, commonBase);\n \t\t\t}\n \t\t\tmsgOut.flush();\n \t\t} catch (ServiceMayNotContinueException noPack) {\n \t\t\tif (sideband && noPack.getMessage() != null) {\n \t\t\t\tnoPack.setOutput();\n \t\t\t\t@SuppressWarnings(\"resource\" /* java 7 */)\n \t\t\t\tSideBandOutputStream err = new SideBandOutputStream(\n \t\t\t\t\t\tSideBandOutputStream.CH_ERROR,\n \t\t\t\t\t\tSideBandOutputStream.SMALL_BUF, rawOut);\n \t\t\t\terr.write(Constants.encode(noPack.getMessage()));\n \t\t\t\terr.flush();\n \t\t\t}\n \t\t\tthrow noPack;\n \t\t}\n \n \t\tPackConfig cfg = packConfig;\n \t\tif (cfg == null)\n \t\t\tcfg = new PackConfig(db);\n \t\t@SuppressWarnings(\"resource\") // PackWriter is referenced in the finally\n \t\t\t\t\t\t\t\t\t\t// block, and is closed there\n \t\tfinal PackWriter pw = new PackWriter(cfg, walk.getObjectReader(),\n \t\t\t\taccumulator);\n \t\ttry {\n \t\t\tpw.setIndexDisabled(true);\n \t\t\tif (filterBlobLimit >= 0) {\n \t\t\t\tpw.setFilterBlobLimit(filterBlobLimit);\n \t\t\t\tpw.setUseCachedPacks(false);\n \t\t\t} else {\n \t\t\t\tpw.setUseCachedPacks(true);\n \t\t\t}\n \t\t\tpw.setUseBitmaps(depth == 0 && clientShallowCommits.isEmpty());\n \t\t\tpw.setClientShallowCommits(clientShallowCommits);\n \t\t\tpw.setReuseDeltaCommits(true);\n \t\t\tpw.setDeltaBaseAsOffset(options.contains(OPTION_OFS_DELTA));\n \t\t\tpw.setThin(options.contains(OPTION_THIN_PACK));\n \t\t\tpw.setReuseValidatingObjects(false);\n \n \t\t\t// Objects named directly by references go at the beginning\n \t\t\t// of the pack.\n \t\t\tif (commonBase.isEmpty() && refs != null) {\n \t\t\t\tSet<ObjectId> tagTargets = new HashSet<>();\n \t\t\t\tfor (Ref ref : refs.values()) {\n \t\t\t\t\tif (ref.getPeeledObjectId() != null)\n \t\t\t\t\t\ttagTargets.add(ref.getPeeledObjectId());\n \t\t\t\t\telse if (ref.getObjectId() == null)\n \t\t\t\t\t\tcontinue;\n \t\t\t\t\telse if (ref.getName().startsWith(Constants.R_HEADS))\n \t\t\t\t\t\ttagTargets.add(ref.getObjectId());\n \t\t\t\t}\n \t\t\t\tpw.setTagTargets(tagTargets);\n \t\t\t}\n \n \t\t\tRevWalk rw = walk;\n \t\t\tif (depth > 0) {\n \t\t\t\tpw.setShallowPack(depth, unshallowCommits);\n \t\t\t\trw = new DepthWalk.RevWalk(walk.getObjectReader(), depth - 1);\n \t\t\t\trw.assumeShallow(clientShallowCommits);\n \t\t\t}\n \n \t\t\tif (wantAll.isEmpty()) {\n \t\t\t\tpw.preparePack(pm, wantIds, commonBase, clientShallowCommits);\n \t\t\t} else {\n \t\t\t\twalk.reset();\n \n \t\t\t\tObjectWalk ow = rw.toObjectWalkWithSameObjects();\n \t\t\t\tpw.preparePack(pm, ow, wantAll, commonBase, PackWriter.NONE);\n \t\t\t\trw = ow;\n \t\t\t}\n \n \t\t\tif (options.contains(OPTION_INCLUDE_TAG) && allTags != null) {\n \t\t\t\tfor (Ref ref : allTags) {\n \t\t\t\t\tObjectId objectId = ref.getObjectId();\n \t\t\t\t\tif (objectId == null) {\n \t\t\t\t\t\t// skip unborn branch\n \t\t\t\t\t\tcontinue;\n \t\t\t\t\t}\n \n \t\t\t\t\t// If the object was already requested, skip it.\n \t\t\t\t\tif (wantAll.isEmpty()) {\n \t\t\t\t\t\tif (wantIds.contains(objectId))\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t} else {\n \t\t\t\t\t\tRevObject obj = rw.lookupOrNull(objectId);\n \t\t\t\t\t\tif (obj != null && obj.has(WANT))\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t}\n \n \t\t\t\t\tif (!ref.isPeeled())\n \t\t\t\t\t\tref = db.getRefDatabase().peel(ref);\n \n \t\t\t\t\tObjectId peeledId = ref.getPeeledObjectId();\n \t\t\t\t\tobjectId = ref.getObjectId();\n \t\t\t\t\tif (peeledId == null || objectId == null)\n \t\t\t\t\t\tcontinue;\n \n \t\t\t\t\tif (pw.willInclude(peeledId) && !pw.willInclude(objectId)) {\n \t\t\t\t\t\tpw.addObject(rw.parseAny(objectId));\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tpw.writePack(pm, NullProgressMonitor.INSTANCE, packOut);\n \n \t\t\tif (msgOut != NullOutputStream.INSTANCE) {\n \t\t\t\tString msg = pw.getStatistics().getMessage() + '\\n';\n \t\t\t\tmsgOut.write(Constants.encode(msg));\n \t\t\t\tmsgOut.flush();\n \t\t\t}\n \n \t\t} finally {\n \t\t\tstatistics = pw.getStatistics();\n \t\t\tif (statistics != null) {\n \t\t\t\tpostUploadHook.onPostUpload(statistics);\n \t\t\t}\n \t\t\tpw.close();\n \t\t}\n \n \t\tif (sideband)\n \t\t\tpckOut.end();\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {
				"oldValue": "[sideband-boolean(modifiers-final), accumulator-PackStatistics.Accumulator, allTags-Collection<Ref>(annotations-@Nullable)]",
				"newValue": "[sideband-boolean(modifiers-final), accumulator-PackStatistics.Accumulator, allTags-Collection<Ref>(annotations-@Nullable), unshallowCommits-List<ObjectId>]"
			}
		},
		"f6c4a492d06e0dd345679bfba3399dabbf778f41": {
			"type": "Ybodychange",
			"commitMessage": "Repository: Deprecate #peel method\n\nCallers should use getRefDatabase().peel(ref) instead since it\ndoesn't swallow the IOException.\n\nAdapt all trivial callers to user the alternative.\n\nDescribeCommand still uses the deprecated method and is not adapted in\nthis change since it will require more refactoring to add handling of\nthe IOException.\n\nChange-Id: I14d4a95a5e0570548753b9fc5c03d024dc3ff832\nSigned-off-by: David Pursehouse <david.pursehouse@gmail.com>\n",
			"commitDate": "2018-05-21, 8:49 PM",
			"commitName": "f6c4a492d06e0dd345679bfba3399dabbf778f41",
			"commitAuthor": "David Pursehouse",
			"commitDateOld": "2018-05-17, 8:15 PM",
			"commitNameOld": "667e30678a6bad26f4d4d412e996b293e52e5b87",
			"commitAuthorOld": "Masaya Suzuki",
			"daysBetweenCommits": 4.02,
			"commitsBetweenForRepo": 10,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,145 +1,145 @@\n \tprivate void sendPack(final boolean sideband,\n \t\t\tPackStatistics.Accumulator accumulator,\n \t\t\t@Nullable Collection<Ref> allTags) throws IOException {\n \t\tProgressMonitor pm = NullProgressMonitor.INSTANCE;\n \t\tOutputStream packOut = rawOut;\n \n \t\tif (sideband) {\n \t\t\tint bufsz = SideBandOutputStream.SMALL_BUF;\n \t\t\tif (options.contains(OPTION_SIDE_BAND_64K))\n \t\t\t\tbufsz = SideBandOutputStream.MAX_BUF;\n \n \t\t\tpackOut = new SideBandOutputStream(SideBandOutputStream.CH_DATA,\n \t\t\t\t\tbufsz, rawOut);\n \t\t\tif (!options.contains(OPTION_NO_PROGRESS)) {\n \t\t\t\tmsgOut = new SideBandOutputStream(\n \t\t\t\t\t\tSideBandOutputStream.CH_PROGRESS, bufsz, rawOut);\n \t\t\t\tpm = new SideBandProgressMonitor(msgOut);\n \t\t\t}\n \t\t}\n \n \t\ttry {\n \t\t\tif (wantAll.isEmpty()) {\n \t\t\t\tpreUploadHook.onSendPack(this, wantIds, commonBase);\n \t\t\t} else {\n \t\t\t\tpreUploadHook.onSendPack(this, wantAll, commonBase);\n \t\t\t}\n \t\t\tmsgOut.flush();\n \t\t} catch (ServiceMayNotContinueException noPack) {\n \t\t\tif (sideband && noPack.getMessage() != null) {\n \t\t\t\tnoPack.setOutput();\n \t\t\t\t@SuppressWarnings(\"resource\" /* java 7 */)\n \t\t\t\tSideBandOutputStream err = new SideBandOutputStream(\n \t\t\t\t\t\tSideBandOutputStream.CH_ERROR,\n \t\t\t\t\t\tSideBandOutputStream.SMALL_BUF, rawOut);\n \t\t\t\terr.write(Constants.encode(noPack.getMessage()));\n \t\t\t\terr.flush();\n \t\t\t}\n \t\t\tthrow noPack;\n \t\t}\n \n \t\tPackConfig cfg = packConfig;\n \t\tif (cfg == null)\n \t\t\tcfg = new PackConfig(db);\n \t\t@SuppressWarnings(\"resource\") // PackWriter is referenced in the finally\n \t\t\t\t\t\t\t\t\t\t// block, and is closed there\n \t\tfinal PackWriter pw = new PackWriter(cfg, walk.getObjectReader(),\n \t\t\t\taccumulator);\n \t\ttry {\n \t\t\tpw.setIndexDisabled(true);\n \t\t\tif (filterBlobLimit >= 0) {\n \t\t\t\tpw.setFilterBlobLimit(filterBlobLimit);\n \t\t\t\tpw.setUseCachedPacks(false);\n \t\t\t} else {\n \t\t\t\tpw.setUseCachedPacks(true);\n \t\t\t}\n \t\t\tpw.setUseBitmaps(depth == 0 && clientShallowCommits.isEmpty());\n \t\t\tpw.setClientShallowCommits(clientShallowCommits);\n \t\t\tpw.setReuseDeltaCommits(true);\n \t\t\tpw.setDeltaBaseAsOffset(options.contains(OPTION_OFS_DELTA));\n \t\t\tpw.setThin(options.contains(OPTION_THIN_PACK));\n \t\t\tpw.setReuseValidatingObjects(false);\n \n \t\t\t// Objects named directly by references go at the beginning\n \t\t\t// of the pack.\n \t\t\tif (commonBase.isEmpty() && refs != null) {\n \t\t\t\tSet<ObjectId> tagTargets = new HashSet<>();\n \t\t\t\tfor (Ref ref : refs.values()) {\n \t\t\t\t\tif (ref.getPeeledObjectId() != null)\n \t\t\t\t\t\ttagTargets.add(ref.getPeeledObjectId());\n \t\t\t\t\telse if (ref.getObjectId() == null)\n \t\t\t\t\t\tcontinue;\n \t\t\t\t\telse if (ref.getName().startsWith(Constants.R_HEADS))\n \t\t\t\t\t\ttagTargets.add(ref.getObjectId());\n \t\t\t\t}\n \t\t\t\tpw.setTagTargets(tagTargets);\n \t\t\t}\n \n \t\t\tRevWalk rw = walk;\n \t\t\tif (depth > 0) {\n \t\t\t\tpw.setShallowPack(depth, unshallowCommits);\n \t\t\t\trw = new DepthWalk.RevWalk(walk.getObjectReader(), depth - 1);\n \t\t\t\trw.assumeShallow(clientShallowCommits);\n \t\t\t}\n \n \t\t\tif (wantAll.isEmpty()) {\n \t\t\t\tpw.preparePack(pm, wantIds, commonBase, clientShallowCommits);\n \t\t\t} else {\n \t\t\t\twalk.reset();\n \n \t\t\t\tObjectWalk ow = rw.toObjectWalkWithSameObjects();\n \t\t\t\tpw.preparePack(pm, ow, wantAll, commonBase, PackWriter.NONE);\n \t\t\t\trw = ow;\n \t\t\t}\n \n \t\t\tif (options.contains(OPTION_INCLUDE_TAG) && allTags != null) {\n \t\t\t\tfor (Ref ref : allTags) {\n \t\t\t\t\tObjectId objectId = ref.getObjectId();\n \t\t\t\t\tif (objectId == null) {\n \t\t\t\t\t\t// skip unborn branch\n \t\t\t\t\t\tcontinue;\n \t\t\t\t\t}\n \n \t\t\t\t\t// If the object was already requested, skip it.\n \t\t\t\t\tif (wantAll.isEmpty()) {\n \t\t\t\t\t\tif (wantIds.contains(objectId))\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t} else {\n \t\t\t\t\t\tRevObject obj = rw.lookupOrNull(objectId);\n \t\t\t\t\t\tif (obj != null && obj.has(WANT))\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t}\n \n \t\t\t\t\tif (!ref.isPeeled())\n-\t\t\t\t\t\tref = db.peel(ref);\n+\t\t\t\t\t\tref = db.getRefDatabase().peel(ref);\n \n \t\t\t\t\tObjectId peeledId = ref.getPeeledObjectId();\n \t\t\t\t\tobjectId = ref.getObjectId();\n \t\t\t\t\tif (peeledId == null || objectId == null)\n \t\t\t\t\t\tcontinue;\n \n \t\t\t\t\tif (pw.willInclude(peeledId) && !pw.willInclude(objectId)) {\n \t\t\t\t\t\tpw.addObject(rw.parseAny(objectId));\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tpw.writePack(pm, NullProgressMonitor.INSTANCE, packOut);\n \n \t\t\tif (msgOut != NullOutputStream.INSTANCE) {\n \t\t\t\tString msg = pw.getStatistics().getMessage() + '\\n';\n \t\t\t\tmsgOut.write(Constants.encode(msg));\n \t\t\t\tmsgOut.flush();\n \t\t\t}\n \n \t\t} finally {\n \t\t\tstatistics = pw.getStatistics();\n \t\t\tif (statistics != null) {\n \t\t\t\tpostUploadHook.onPostUpload(statistics);\n \t\t\t}\n \t\t\tpw.close();\n \t\t}\n \n \t\tif (sideband)\n \t\t\tpckOut.end();\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"c79e7f1c27c73732310bc64c2071a79902447dcc": {
			"type": "Ymultichange(Yparameterchange,Ybodychange)",
			"commitMessage": "Avoid using #refs in UploadPack#sendPack\n\nWhen OPTION_INCLUDE_TAG is set, UploadPack#sendPack uses the #refs\ninstance variable as a source of information of tags. A subsequent patch\nwill need to supply this information to #sendPack without\nmodifying #refs, so refactor #sendPack to take in this information\nthrough a parameter instead.\n\nNote that prior to this patch, #refs was used twice in #sendPack: once\nto generate the argument to PackWriter#setTagTargets, and once to\ndetermine if any tags need to be included in the packfile. This patch\nonly updates the latter use, since the former is meant not only for\n\"true\" tag targets but any object that should be hoisted earlier during\npacking (see the documentation of PackWriter#setTagTargets).\n\nThis patch does not introduce any functionality change.\n\nChange-Id: I70ed65a1041334abeda8d4bac98cce7cae7efcdf\nSigned-off-by: Jonathan Tan <jonathantanmy@google.com>\nSigned-off-by: Jonathan Nieder <jrn@google.com>\n",
			"commitDate": "2018-05-16, 5:57 PM",
			"commitName": "c79e7f1c27c73732310bc64c2071a79902447dcc",
			"commitAuthor": "Jonathan Tan",
			"subchanges": [
				{
					"type": "Yparameterchange",
					"commitMessage": "Avoid using #refs in UploadPack#sendPack\n\nWhen OPTION_INCLUDE_TAG is set, UploadPack#sendPack uses the #refs\ninstance variable as a source of information of tags. A subsequent patch\nwill need to supply this information to #sendPack without\nmodifying #refs, so refactor #sendPack to take in this information\nthrough a parameter instead.\n\nNote that prior to this patch, #refs was used twice in #sendPack: once\nto generate the argument to PackWriter#setTagTargets, and once to\ndetermine if any tags need to be included in the packfile. This patch\nonly updates the latter use, since the former is meant not only for\n\"true\" tag targets but any object that should be hoisted earlier during\npacking (see the documentation of PackWriter#setTagTargets).\n\nThis patch does not introduce any functionality change.\n\nChange-Id: I70ed65a1041334abeda8d4bac98cce7cae7efcdf\nSigned-off-by: Jonathan Tan <jonathantanmy@google.com>\nSigned-off-by: Jonathan Nieder <jrn@google.com>\n",
					"commitDate": "2018-05-16, 5:57 PM",
					"commitName": "c79e7f1c27c73732310bc64c2071a79902447dcc",
					"commitAuthor": "Jonathan Tan",
					"commitDateOld": "2018-05-15, 3:05 PM",
					"commitNameOld": "6d370d837c5faa7caff2e6e3e4723b887f2fbdca",
					"commitAuthorOld": "Han-Wen Nienhuys",
					"daysBetweenCommits": 1.12,
					"commitsBetweenForRepo": 3,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,142 +1,145 @@\n \tprivate void sendPack(final boolean sideband,\n-\t\t\tPackStatistics.Accumulator accumulator) throws IOException {\n+\t\t\tPackStatistics.Accumulator accumulator,\n+\t\t\t@Nullable Collection<Ref> allTags) throws IOException {\n \t\tProgressMonitor pm = NullProgressMonitor.INSTANCE;\n \t\tOutputStream packOut = rawOut;\n \n \t\tif (sideband) {\n \t\t\tint bufsz = SideBandOutputStream.SMALL_BUF;\n \t\t\tif (options.contains(OPTION_SIDE_BAND_64K))\n \t\t\t\tbufsz = SideBandOutputStream.MAX_BUF;\n \n \t\t\tpackOut = new SideBandOutputStream(SideBandOutputStream.CH_DATA,\n \t\t\t\t\tbufsz, rawOut);\n \t\t\tif (!options.contains(OPTION_NO_PROGRESS)) {\n \t\t\t\tmsgOut = new SideBandOutputStream(\n \t\t\t\t\t\tSideBandOutputStream.CH_PROGRESS, bufsz, rawOut);\n \t\t\t\tpm = new SideBandProgressMonitor(msgOut);\n \t\t\t}\n \t\t}\n \n \t\ttry {\n \t\t\tif (wantAll.isEmpty()) {\n \t\t\t\tpreUploadHook.onSendPack(this, wantIds, commonBase);\n \t\t\t} else {\n \t\t\t\tpreUploadHook.onSendPack(this, wantAll, commonBase);\n \t\t\t}\n \t\t\tmsgOut.flush();\n \t\t} catch (ServiceMayNotContinueException noPack) {\n \t\t\tif (sideband && noPack.getMessage() != null) {\n \t\t\t\tnoPack.setOutput();\n \t\t\t\t@SuppressWarnings(\"resource\" /* java 7 */)\n \t\t\t\tSideBandOutputStream err = new SideBandOutputStream(\n \t\t\t\t\t\tSideBandOutputStream.CH_ERROR,\n \t\t\t\t\t\tSideBandOutputStream.SMALL_BUF, rawOut);\n \t\t\t\terr.write(Constants.encode(noPack.getMessage()));\n \t\t\t\terr.flush();\n \t\t\t}\n \t\t\tthrow noPack;\n \t\t}\n \n \t\tPackConfig cfg = packConfig;\n \t\tif (cfg == null)\n \t\t\tcfg = new PackConfig(db);\n \t\t@SuppressWarnings(\"resource\") // PackWriter is referenced in the finally\n \t\t\t\t\t\t\t\t\t\t// block, and is closed there\n \t\tfinal PackWriter pw = new PackWriter(cfg, walk.getObjectReader(),\n \t\t\t\taccumulator);\n \t\ttry {\n \t\t\tpw.setIndexDisabled(true);\n \t\t\tif (filterBlobLimit >= 0) {\n \t\t\t\tpw.setFilterBlobLimit(filterBlobLimit);\n \t\t\t\tpw.setUseCachedPacks(false);\n \t\t\t} else {\n \t\t\t\tpw.setUseCachedPacks(true);\n \t\t\t}\n \t\t\tpw.setUseBitmaps(depth == 0 && clientShallowCommits.isEmpty());\n \t\t\tpw.setClientShallowCommits(clientShallowCommits);\n \t\t\tpw.setReuseDeltaCommits(true);\n \t\t\tpw.setDeltaBaseAsOffset(options.contains(OPTION_OFS_DELTA));\n \t\t\tpw.setThin(options.contains(OPTION_THIN_PACK));\n \t\t\tpw.setReuseValidatingObjects(false);\n \n+\t\t\t// Objects named directly by references go at the beginning\n+\t\t\t// of the pack.\n \t\t\tif (commonBase.isEmpty() && refs != null) {\n \t\t\t\tSet<ObjectId> tagTargets = new HashSet<>();\n \t\t\t\tfor (Ref ref : refs.values()) {\n \t\t\t\t\tif (ref.getPeeledObjectId() != null)\n \t\t\t\t\t\ttagTargets.add(ref.getPeeledObjectId());\n \t\t\t\t\telse if (ref.getObjectId() == null)\n \t\t\t\t\t\tcontinue;\n \t\t\t\t\telse if (ref.getName().startsWith(Constants.R_HEADS))\n \t\t\t\t\t\ttagTargets.add(ref.getObjectId());\n \t\t\t\t}\n \t\t\t\tpw.setTagTargets(tagTargets);\n \t\t\t}\n \n \t\t\tRevWalk rw = walk;\n \t\t\tif (depth > 0) {\n \t\t\t\tpw.setShallowPack(depth, unshallowCommits);\n \t\t\t\trw = new DepthWalk.RevWalk(walk.getObjectReader(), depth - 1);\n \t\t\t\trw.assumeShallow(clientShallowCommits);\n \t\t\t}\n \n \t\t\tif (wantAll.isEmpty()) {\n \t\t\t\tpw.preparePack(pm, wantIds, commonBase, clientShallowCommits);\n \t\t\t} else {\n \t\t\t\twalk.reset();\n \n \t\t\t\tObjectWalk ow = rw.toObjectWalkWithSameObjects();\n \t\t\t\tpw.preparePack(pm, ow, wantAll, commonBase, PackWriter.NONE);\n \t\t\t\trw = ow;\n \t\t\t}\n \n-\t\t\tif (options.contains(OPTION_INCLUDE_TAG) && refs != null) {\n-\t\t\t\tfor (Ref ref : refs.values()) {\n+\t\t\tif (options.contains(OPTION_INCLUDE_TAG) && allTags != null) {\n+\t\t\t\tfor (Ref ref : allTags) {\n \t\t\t\t\tObjectId objectId = ref.getObjectId();\n \t\t\t\t\tif (objectId == null) {\n \t\t\t\t\t\t// skip unborn branch\n \t\t\t\t\t\tcontinue;\n \t\t\t\t\t}\n \n \t\t\t\t\t// If the object was already requested, skip it.\n \t\t\t\t\tif (wantAll.isEmpty()) {\n \t\t\t\t\t\tif (wantIds.contains(objectId))\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t} else {\n \t\t\t\t\t\tRevObject obj = rw.lookupOrNull(objectId);\n \t\t\t\t\t\tif (obj != null && obj.has(WANT))\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t}\n \n \t\t\t\t\tif (!ref.isPeeled())\n \t\t\t\t\t\tref = db.peel(ref);\n \n \t\t\t\t\tObjectId peeledId = ref.getPeeledObjectId();\n \t\t\t\t\tobjectId = ref.getObjectId();\n \t\t\t\t\tif (peeledId == null || objectId == null)\n \t\t\t\t\t\tcontinue;\n \n \t\t\t\t\tif (pw.willInclude(peeledId) && !pw.willInclude(objectId)) {\n \t\t\t\t\t\tpw.addObject(rw.parseAny(objectId));\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tpw.writePack(pm, NullProgressMonitor.INSTANCE, packOut);\n \n \t\t\tif (msgOut != NullOutputStream.INSTANCE) {\n \t\t\t\tString msg = pw.getStatistics().getMessage() + '\\n';\n \t\t\t\tmsgOut.write(Constants.encode(msg));\n \t\t\t\tmsgOut.flush();\n \t\t\t}\n \n \t\t} finally {\n \t\t\tstatistics = pw.getStatistics();\n \t\t\tif (statistics != null) {\n \t\t\t\tpostUploadHook.onPostUpload(statistics);\n \t\t\t}\n \t\t\tpw.close();\n \t\t}\n \n \t\tif (sideband)\n \t\t\tpckOut.end();\n \t}\n\\ No newline at end of file\n",
					"extendedDetails": {
						"oldValue": "[sideband-boolean(modifiers-final), accumulator-PackStatistics.Accumulator]",
						"newValue": "[sideband-boolean(modifiers-final), accumulator-PackStatistics.Accumulator, allTags-Collection<Ref>(annotations-@Nullable)]"
					}
				},
				{
					"type": "Ybodychange",
					"commitMessage": "Avoid using #refs in UploadPack#sendPack\n\nWhen OPTION_INCLUDE_TAG is set, UploadPack#sendPack uses the #refs\ninstance variable as a source of information of tags. A subsequent patch\nwill need to supply this information to #sendPack without\nmodifying #refs, so refactor #sendPack to take in this information\nthrough a parameter instead.\n\nNote that prior to this patch, #refs was used twice in #sendPack: once\nto generate the argument to PackWriter#setTagTargets, and once to\ndetermine if any tags need to be included in the packfile. This patch\nonly updates the latter use, since the former is meant not only for\n\"true\" tag targets but any object that should be hoisted earlier during\npacking (see the documentation of PackWriter#setTagTargets).\n\nThis patch does not introduce any functionality change.\n\nChange-Id: I70ed65a1041334abeda8d4bac98cce7cae7efcdf\nSigned-off-by: Jonathan Tan <jonathantanmy@google.com>\nSigned-off-by: Jonathan Nieder <jrn@google.com>\n",
					"commitDate": "2018-05-16, 5:57 PM",
					"commitName": "c79e7f1c27c73732310bc64c2071a79902447dcc",
					"commitAuthor": "Jonathan Tan",
					"commitDateOld": "2018-05-15, 3:05 PM",
					"commitNameOld": "6d370d837c5faa7caff2e6e3e4723b887f2fbdca",
					"commitAuthorOld": "Han-Wen Nienhuys",
					"daysBetweenCommits": 1.12,
					"commitsBetweenForRepo": 3,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,142 +1,145 @@\n \tprivate void sendPack(final boolean sideband,\n-\t\t\tPackStatistics.Accumulator accumulator) throws IOException {\n+\t\t\tPackStatistics.Accumulator accumulator,\n+\t\t\t@Nullable Collection<Ref> allTags) throws IOException {\n \t\tProgressMonitor pm = NullProgressMonitor.INSTANCE;\n \t\tOutputStream packOut = rawOut;\n \n \t\tif (sideband) {\n \t\t\tint bufsz = SideBandOutputStream.SMALL_BUF;\n \t\t\tif (options.contains(OPTION_SIDE_BAND_64K))\n \t\t\t\tbufsz = SideBandOutputStream.MAX_BUF;\n \n \t\t\tpackOut = new SideBandOutputStream(SideBandOutputStream.CH_DATA,\n \t\t\t\t\tbufsz, rawOut);\n \t\t\tif (!options.contains(OPTION_NO_PROGRESS)) {\n \t\t\t\tmsgOut = new SideBandOutputStream(\n \t\t\t\t\t\tSideBandOutputStream.CH_PROGRESS, bufsz, rawOut);\n \t\t\t\tpm = new SideBandProgressMonitor(msgOut);\n \t\t\t}\n \t\t}\n \n \t\ttry {\n \t\t\tif (wantAll.isEmpty()) {\n \t\t\t\tpreUploadHook.onSendPack(this, wantIds, commonBase);\n \t\t\t} else {\n \t\t\t\tpreUploadHook.onSendPack(this, wantAll, commonBase);\n \t\t\t}\n \t\t\tmsgOut.flush();\n \t\t} catch (ServiceMayNotContinueException noPack) {\n \t\t\tif (sideband && noPack.getMessage() != null) {\n \t\t\t\tnoPack.setOutput();\n \t\t\t\t@SuppressWarnings(\"resource\" /* java 7 */)\n \t\t\t\tSideBandOutputStream err = new SideBandOutputStream(\n \t\t\t\t\t\tSideBandOutputStream.CH_ERROR,\n \t\t\t\t\t\tSideBandOutputStream.SMALL_BUF, rawOut);\n \t\t\t\terr.write(Constants.encode(noPack.getMessage()));\n \t\t\t\terr.flush();\n \t\t\t}\n \t\t\tthrow noPack;\n \t\t}\n \n \t\tPackConfig cfg = packConfig;\n \t\tif (cfg == null)\n \t\t\tcfg = new PackConfig(db);\n \t\t@SuppressWarnings(\"resource\") // PackWriter is referenced in the finally\n \t\t\t\t\t\t\t\t\t\t// block, and is closed there\n \t\tfinal PackWriter pw = new PackWriter(cfg, walk.getObjectReader(),\n \t\t\t\taccumulator);\n \t\ttry {\n \t\t\tpw.setIndexDisabled(true);\n \t\t\tif (filterBlobLimit >= 0) {\n \t\t\t\tpw.setFilterBlobLimit(filterBlobLimit);\n \t\t\t\tpw.setUseCachedPacks(false);\n \t\t\t} else {\n \t\t\t\tpw.setUseCachedPacks(true);\n \t\t\t}\n \t\t\tpw.setUseBitmaps(depth == 0 && clientShallowCommits.isEmpty());\n \t\t\tpw.setClientShallowCommits(clientShallowCommits);\n \t\t\tpw.setReuseDeltaCommits(true);\n \t\t\tpw.setDeltaBaseAsOffset(options.contains(OPTION_OFS_DELTA));\n \t\t\tpw.setThin(options.contains(OPTION_THIN_PACK));\n \t\t\tpw.setReuseValidatingObjects(false);\n \n+\t\t\t// Objects named directly by references go at the beginning\n+\t\t\t// of the pack.\n \t\t\tif (commonBase.isEmpty() && refs != null) {\n \t\t\t\tSet<ObjectId> tagTargets = new HashSet<>();\n \t\t\t\tfor (Ref ref : refs.values()) {\n \t\t\t\t\tif (ref.getPeeledObjectId() != null)\n \t\t\t\t\t\ttagTargets.add(ref.getPeeledObjectId());\n \t\t\t\t\telse if (ref.getObjectId() == null)\n \t\t\t\t\t\tcontinue;\n \t\t\t\t\telse if (ref.getName().startsWith(Constants.R_HEADS))\n \t\t\t\t\t\ttagTargets.add(ref.getObjectId());\n \t\t\t\t}\n \t\t\t\tpw.setTagTargets(tagTargets);\n \t\t\t}\n \n \t\t\tRevWalk rw = walk;\n \t\t\tif (depth > 0) {\n \t\t\t\tpw.setShallowPack(depth, unshallowCommits);\n \t\t\t\trw = new DepthWalk.RevWalk(walk.getObjectReader(), depth - 1);\n \t\t\t\trw.assumeShallow(clientShallowCommits);\n \t\t\t}\n \n \t\t\tif (wantAll.isEmpty()) {\n \t\t\t\tpw.preparePack(pm, wantIds, commonBase, clientShallowCommits);\n \t\t\t} else {\n \t\t\t\twalk.reset();\n \n \t\t\t\tObjectWalk ow = rw.toObjectWalkWithSameObjects();\n \t\t\t\tpw.preparePack(pm, ow, wantAll, commonBase, PackWriter.NONE);\n \t\t\t\trw = ow;\n \t\t\t}\n \n-\t\t\tif (options.contains(OPTION_INCLUDE_TAG) && refs != null) {\n-\t\t\t\tfor (Ref ref : refs.values()) {\n+\t\t\tif (options.contains(OPTION_INCLUDE_TAG) && allTags != null) {\n+\t\t\t\tfor (Ref ref : allTags) {\n \t\t\t\t\tObjectId objectId = ref.getObjectId();\n \t\t\t\t\tif (objectId == null) {\n \t\t\t\t\t\t// skip unborn branch\n \t\t\t\t\t\tcontinue;\n \t\t\t\t\t}\n \n \t\t\t\t\t// If the object was already requested, skip it.\n \t\t\t\t\tif (wantAll.isEmpty()) {\n \t\t\t\t\t\tif (wantIds.contains(objectId))\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t} else {\n \t\t\t\t\t\tRevObject obj = rw.lookupOrNull(objectId);\n \t\t\t\t\t\tif (obj != null && obj.has(WANT))\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t}\n \n \t\t\t\t\tif (!ref.isPeeled())\n \t\t\t\t\t\tref = db.peel(ref);\n \n \t\t\t\t\tObjectId peeledId = ref.getPeeledObjectId();\n \t\t\t\t\tobjectId = ref.getObjectId();\n \t\t\t\t\tif (peeledId == null || objectId == null)\n \t\t\t\t\t\tcontinue;\n \n \t\t\t\t\tif (pw.willInclude(peeledId) && !pw.willInclude(objectId)) {\n \t\t\t\t\t\tpw.addObject(rw.parseAny(objectId));\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tpw.writePack(pm, NullProgressMonitor.INSTANCE, packOut);\n \n \t\t\tif (msgOut != NullOutputStream.INSTANCE) {\n \t\t\t\tString msg = pw.getStatistics().getMessage() + '\\n';\n \t\t\t\tmsgOut.write(Constants.encode(msg));\n \t\t\t\tmsgOut.flush();\n \t\t\t}\n \n \t\t} finally {\n \t\t\tstatistics = pw.getStatistics();\n \t\t\tif (statistics != null) {\n \t\t\t\tpostUploadHook.onPostUpload(statistics);\n \t\t\t}\n \t\t\tpw.close();\n \t\t}\n \n \t\tif (sideband)\n \t\t\tpckOut.end();\n \t}\n\\ No newline at end of file\n",
					"extendedDetails": {}
				}
			]
		},
		"4ac32e79b751944107470d5f4cb290eacd1b7cf9": {
			"type": "Ybodychange",
			"commitMessage": "Teach UploadPack to support filtering by blob size\n\nTeach UploadPack to advertise the filter capability and support a\n\"filter\" line in the request, accepting blob sizes only, if the\nconfiguration variable \"uploadpack.allowfilter\" is true. This feature is\ncurrently in the \"master\" branch of Git, and as of the time of writing,\nthis feature is to be released in Git 2.17.\n\nThis is incomplete in that the filter-by-sparse-specification feature\nalso supported by Git is not included in this patch.\n\nIf a JGit server were to be patched with this commit, and a repository\non that server configured with RequestPolicy.ANY or\nRequestPolicy.REACHABLE_COMMIT_TIP, a Git client built from the \"master\"\nbranch would be able to perform a partial clone.\n\nChange-Id: If72b4b422c06ab432137e9e5272d353b14b73259\nSigned-off-by: Jonathan Tan <jonathantanmy@google.com>\n",
			"commitDate": "2018-03-15, 2:46 PM",
			"commitName": "4ac32e79b751944107470d5f4cb290eacd1b7cf9",
			"commitAuthor": "Jonathan Tan",
			"commitDateOld": "2018-03-13, 7:44 PM",
			"commitNameOld": "67df4986cef270144c7cae3485dc8541ca180649",
			"commitAuthorOld": "David Pursehouse",
			"daysBetweenCommits": 1.79,
			"commitsBetweenForRepo": 12,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,137 +1,142 @@\n \tprivate void sendPack(final boolean sideband,\n \t\t\tPackStatistics.Accumulator accumulator) throws IOException {\n \t\tProgressMonitor pm = NullProgressMonitor.INSTANCE;\n \t\tOutputStream packOut = rawOut;\n \n \t\tif (sideband) {\n \t\t\tint bufsz = SideBandOutputStream.SMALL_BUF;\n \t\t\tif (options.contains(OPTION_SIDE_BAND_64K))\n \t\t\t\tbufsz = SideBandOutputStream.MAX_BUF;\n \n \t\t\tpackOut = new SideBandOutputStream(SideBandOutputStream.CH_DATA,\n \t\t\t\t\tbufsz, rawOut);\n \t\t\tif (!options.contains(OPTION_NO_PROGRESS)) {\n \t\t\t\tmsgOut = new SideBandOutputStream(\n \t\t\t\t\t\tSideBandOutputStream.CH_PROGRESS, bufsz, rawOut);\n \t\t\t\tpm = new SideBandProgressMonitor(msgOut);\n \t\t\t}\n \t\t}\n \n \t\ttry {\n \t\t\tif (wantAll.isEmpty()) {\n \t\t\t\tpreUploadHook.onSendPack(this, wantIds, commonBase);\n \t\t\t} else {\n \t\t\t\tpreUploadHook.onSendPack(this, wantAll, commonBase);\n \t\t\t}\n \t\t\tmsgOut.flush();\n \t\t} catch (ServiceMayNotContinueException noPack) {\n \t\t\tif (sideband && noPack.getMessage() != null) {\n \t\t\t\tnoPack.setOutput();\n \t\t\t\t@SuppressWarnings(\"resource\" /* java 7 */)\n \t\t\t\tSideBandOutputStream err = new SideBandOutputStream(\n \t\t\t\t\t\tSideBandOutputStream.CH_ERROR,\n \t\t\t\t\t\tSideBandOutputStream.SMALL_BUF, rawOut);\n \t\t\t\terr.write(Constants.encode(noPack.getMessage()));\n \t\t\t\terr.flush();\n \t\t\t}\n \t\t\tthrow noPack;\n \t\t}\n \n \t\tPackConfig cfg = packConfig;\n \t\tif (cfg == null)\n \t\t\tcfg = new PackConfig(db);\n \t\t@SuppressWarnings(\"resource\") // PackWriter is referenced in the finally\n \t\t\t\t\t\t\t\t\t\t// block, and is closed there\n \t\tfinal PackWriter pw = new PackWriter(cfg, walk.getObjectReader(),\n \t\t\t\taccumulator);\n \t\ttry {\n \t\t\tpw.setIndexDisabled(true);\n-\t\t\tpw.setUseCachedPacks(true);\n+\t\t\tif (filterBlobLimit >= 0) {\n+\t\t\t\tpw.setFilterBlobLimit(filterBlobLimit);\n+\t\t\t\tpw.setUseCachedPacks(false);\n+\t\t\t} else {\n+\t\t\t\tpw.setUseCachedPacks(true);\n+\t\t\t}\n \t\t\tpw.setUseBitmaps(depth == 0 && clientShallowCommits.isEmpty());\n \t\t\tpw.setClientShallowCommits(clientShallowCommits);\n \t\t\tpw.setReuseDeltaCommits(true);\n \t\t\tpw.setDeltaBaseAsOffset(options.contains(OPTION_OFS_DELTA));\n \t\t\tpw.setThin(options.contains(OPTION_THIN_PACK));\n \t\t\tpw.setReuseValidatingObjects(false);\n \n \t\t\tif (commonBase.isEmpty() && refs != null) {\n \t\t\t\tSet<ObjectId> tagTargets = new HashSet<>();\n \t\t\t\tfor (Ref ref : refs.values()) {\n \t\t\t\t\tif (ref.getPeeledObjectId() != null)\n \t\t\t\t\t\ttagTargets.add(ref.getPeeledObjectId());\n \t\t\t\t\telse if (ref.getObjectId() == null)\n \t\t\t\t\t\tcontinue;\n \t\t\t\t\telse if (ref.getName().startsWith(Constants.R_HEADS))\n \t\t\t\t\t\ttagTargets.add(ref.getObjectId());\n \t\t\t\t}\n \t\t\t\tpw.setTagTargets(tagTargets);\n \t\t\t}\n \n \t\t\tRevWalk rw = walk;\n \t\t\tif (depth > 0) {\n \t\t\t\tpw.setShallowPack(depth, unshallowCommits);\n \t\t\t\trw = new DepthWalk.RevWalk(walk.getObjectReader(), depth - 1);\n \t\t\t\trw.assumeShallow(clientShallowCommits);\n \t\t\t}\n \n \t\t\tif (wantAll.isEmpty()) {\n \t\t\t\tpw.preparePack(pm, wantIds, commonBase, clientShallowCommits);\n \t\t\t} else {\n \t\t\t\twalk.reset();\n \n \t\t\t\tObjectWalk ow = rw.toObjectWalkWithSameObjects();\n \t\t\t\tpw.preparePack(pm, ow, wantAll, commonBase, PackWriter.NONE);\n \t\t\t\trw = ow;\n \t\t\t}\n \n \t\t\tif (options.contains(OPTION_INCLUDE_TAG) && refs != null) {\n \t\t\t\tfor (Ref ref : refs.values()) {\n \t\t\t\t\tObjectId objectId = ref.getObjectId();\n \t\t\t\t\tif (objectId == null) {\n \t\t\t\t\t\t// skip unborn branch\n \t\t\t\t\t\tcontinue;\n \t\t\t\t\t}\n \n \t\t\t\t\t// If the object was already requested, skip it.\n \t\t\t\t\tif (wantAll.isEmpty()) {\n \t\t\t\t\t\tif (wantIds.contains(objectId))\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t} else {\n \t\t\t\t\t\tRevObject obj = rw.lookupOrNull(objectId);\n \t\t\t\t\t\tif (obj != null && obj.has(WANT))\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t}\n \n \t\t\t\t\tif (!ref.isPeeled())\n \t\t\t\t\t\tref = db.peel(ref);\n \n \t\t\t\t\tObjectId peeledId = ref.getPeeledObjectId();\n \t\t\t\t\tobjectId = ref.getObjectId();\n \t\t\t\t\tif (peeledId == null || objectId == null)\n \t\t\t\t\t\tcontinue;\n \n \t\t\t\t\tif (pw.willInclude(peeledId) && !pw.willInclude(objectId)) {\n \t\t\t\t\t\tpw.addObject(rw.parseAny(objectId));\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tpw.writePack(pm, NullProgressMonitor.INSTANCE, packOut);\n \n \t\t\tif (msgOut != NullOutputStream.INSTANCE) {\n \t\t\t\tString msg = pw.getStatistics().getMessage() + '\\n';\n \t\t\t\tmsgOut.write(Constants.encode(msg));\n \t\t\t\tmsgOut.flush();\n \t\t\t}\n \n \t\t} finally {\n \t\t\tstatistics = pw.getStatistics();\n \t\t\tif (statistics != null) {\n \t\t\t\tpostUploadHook.onPostUpload(statistics);\n \t\t\t}\n \t\t\tpw.close();\n \t\t}\n \n \t\tif (sideband)\n \t\t\tpckOut.end();\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"67df4986cef270144c7cae3485dc8541ca180649": {
			"type": "Ybodychange",
			"commitMessage": "UploadPack: Suppress resource warning about PackWriter\n\nPackWriter is auto-closeable and should be opened in try-with-resource,\nbut this is not possible since the variable is being referenced in the\nfinally block before being explicitly closed there.\n\nSuppress the warning and add an explanatory comment.\n\nChange-Id: I161923f35142132234fd951c0146d3cb30920b7b\nSigned-off-by: David Pursehouse <david.pursehouse@gmail.com>\n",
			"commitDate": "2018-03-13, 7:44 PM",
			"commitName": "67df4986cef270144c7cae3485dc8541ca180649",
			"commitAuthor": "David Pursehouse",
			"commitDateOld": "2018-03-11, 7:52 PM",
			"commitNameOld": "d88d5b94c669b4c23af4e1de797a4d130b6612f8",
			"commitAuthorOld": "David Pursehouse",
			"daysBetweenCommits": 1.99,
			"commitsBetweenForRepo": 17,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,135 +1,137 @@\n \tprivate void sendPack(final boolean sideband,\n \t\t\tPackStatistics.Accumulator accumulator) throws IOException {\n \t\tProgressMonitor pm = NullProgressMonitor.INSTANCE;\n \t\tOutputStream packOut = rawOut;\n \n \t\tif (sideband) {\n \t\t\tint bufsz = SideBandOutputStream.SMALL_BUF;\n \t\t\tif (options.contains(OPTION_SIDE_BAND_64K))\n \t\t\t\tbufsz = SideBandOutputStream.MAX_BUF;\n \n \t\t\tpackOut = new SideBandOutputStream(SideBandOutputStream.CH_DATA,\n \t\t\t\t\tbufsz, rawOut);\n \t\t\tif (!options.contains(OPTION_NO_PROGRESS)) {\n \t\t\t\tmsgOut = new SideBandOutputStream(\n \t\t\t\t\t\tSideBandOutputStream.CH_PROGRESS, bufsz, rawOut);\n \t\t\t\tpm = new SideBandProgressMonitor(msgOut);\n \t\t\t}\n \t\t}\n \n \t\ttry {\n \t\t\tif (wantAll.isEmpty()) {\n \t\t\t\tpreUploadHook.onSendPack(this, wantIds, commonBase);\n \t\t\t} else {\n \t\t\t\tpreUploadHook.onSendPack(this, wantAll, commonBase);\n \t\t\t}\n \t\t\tmsgOut.flush();\n \t\t} catch (ServiceMayNotContinueException noPack) {\n \t\t\tif (sideband && noPack.getMessage() != null) {\n \t\t\t\tnoPack.setOutput();\n \t\t\t\t@SuppressWarnings(\"resource\" /* java 7 */)\n \t\t\t\tSideBandOutputStream err = new SideBandOutputStream(\n \t\t\t\t\t\tSideBandOutputStream.CH_ERROR,\n \t\t\t\t\t\tSideBandOutputStream.SMALL_BUF, rawOut);\n \t\t\t\terr.write(Constants.encode(noPack.getMessage()));\n \t\t\t\terr.flush();\n \t\t\t}\n \t\t\tthrow noPack;\n \t\t}\n \n \t\tPackConfig cfg = packConfig;\n \t\tif (cfg == null)\n \t\t\tcfg = new PackConfig(db);\n+\t\t@SuppressWarnings(\"resource\") // PackWriter is referenced in the finally\n+\t\t\t\t\t\t\t\t\t\t// block, and is closed there\n \t\tfinal PackWriter pw = new PackWriter(cfg, walk.getObjectReader(),\n \t\t\t\taccumulator);\n \t\ttry {\n \t\t\tpw.setIndexDisabled(true);\n \t\t\tpw.setUseCachedPacks(true);\n \t\t\tpw.setUseBitmaps(depth == 0 && clientShallowCommits.isEmpty());\n \t\t\tpw.setClientShallowCommits(clientShallowCommits);\n \t\t\tpw.setReuseDeltaCommits(true);\n \t\t\tpw.setDeltaBaseAsOffset(options.contains(OPTION_OFS_DELTA));\n \t\t\tpw.setThin(options.contains(OPTION_THIN_PACK));\n \t\t\tpw.setReuseValidatingObjects(false);\n \n \t\t\tif (commonBase.isEmpty() && refs != null) {\n \t\t\t\tSet<ObjectId> tagTargets = new HashSet<>();\n \t\t\t\tfor (Ref ref : refs.values()) {\n \t\t\t\t\tif (ref.getPeeledObjectId() != null)\n \t\t\t\t\t\ttagTargets.add(ref.getPeeledObjectId());\n \t\t\t\t\telse if (ref.getObjectId() == null)\n \t\t\t\t\t\tcontinue;\n \t\t\t\t\telse if (ref.getName().startsWith(Constants.R_HEADS))\n \t\t\t\t\t\ttagTargets.add(ref.getObjectId());\n \t\t\t\t}\n \t\t\t\tpw.setTagTargets(tagTargets);\n \t\t\t}\n \n \t\t\tRevWalk rw = walk;\n \t\t\tif (depth > 0) {\n \t\t\t\tpw.setShallowPack(depth, unshallowCommits);\n \t\t\t\trw = new DepthWalk.RevWalk(walk.getObjectReader(), depth - 1);\n \t\t\t\trw.assumeShallow(clientShallowCommits);\n \t\t\t}\n \n \t\t\tif (wantAll.isEmpty()) {\n \t\t\t\tpw.preparePack(pm, wantIds, commonBase, clientShallowCommits);\n \t\t\t} else {\n \t\t\t\twalk.reset();\n \n \t\t\t\tObjectWalk ow = rw.toObjectWalkWithSameObjects();\n \t\t\t\tpw.preparePack(pm, ow, wantAll, commonBase, PackWriter.NONE);\n \t\t\t\trw = ow;\n \t\t\t}\n \n \t\t\tif (options.contains(OPTION_INCLUDE_TAG) && refs != null) {\n \t\t\t\tfor (Ref ref : refs.values()) {\n \t\t\t\t\tObjectId objectId = ref.getObjectId();\n \t\t\t\t\tif (objectId == null) {\n \t\t\t\t\t\t// skip unborn branch\n \t\t\t\t\t\tcontinue;\n \t\t\t\t\t}\n \n \t\t\t\t\t// If the object was already requested, skip it.\n \t\t\t\t\tif (wantAll.isEmpty()) {\n \t\t\t\t\t\tif (wantIds.contains(objectId))\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t} else {\n \t\t\t\t\t\tRevObject obj = rw.lookupOrNull(objectId);\n \t\t\t\t\t\tif (obj != null && obj.has(WANT))\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t}\n \n \t\t\t\t\tif (!ref.isPeeled())\n \t\t\t\t\t\tref = db.peel(ref);\n \n \t\t\t\t\tObjectId peeledId = ref.getPeeledObjectId();\n \t\t\t\t\tobjectId = ref.getObjectId();\n \t\t\t\t\tif (peeledId == null || objectId == null)\n \t\t\t\t\t\tcontinue;\n \n \t\t\t\t\tif (pw.willInclude(peeledId) && !pw.willInclude(objectId)) {\n \t\t\t\t\t\tpw.addObject(rw.parseAny(objectId));\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tpw.writePack(pm, NullProgressMonitor.INSTANCE, packOut);\n \n \t\t\tif (msgOut != NullOutputStream.INSTANCE) {\n \t\t\t\tString msg = pw.getStatistics().getMessage() + '\\n';\n \t\t\t\tmsgOut.write(Constants.encode(msg));\n \t\t\t\tmsgOut.flush();\n \t\t\t}\n \n \t\t} finally {\n \t\t\tstatistics = pw.getStatistics();\n \t\t\tif (statistics != null) {\n \t\t\t\tpostUploadHook.onPostUpload(statistics);\n \t\t\t}\n \t\t\tpw.close();\n \t\t}\n \n \t\tif (sideband)\n \t\t\tpckOut.end();\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"cc19f649666704e5bf0184d3839be0c0c17439fc": {
			"type": "Ybodychange",
			"commitMessage": "Remove deprecated Statistics, UploadPackLogger, UploadPackLoggerChain\n\nUse PackStatistics and PostUploadHook and PostUploadHookChain instead.\nAlso remove\n- UploadPack#getPackStatistics replaced by #getStatistics\n- UploadPack#getLogger and UploadPack#setLogger\n\nChange-Id: I70881c539af3094d68d594f19983dea0973604e8\nSigned-off-by: Matthias Sohn <matthias.sohn@sap.com>",
			"commitDate": "2018-03-10, 11:38 AM",
			"commitName": "cc19f649666704e5bf0184d3839be0c0c17439fc",
			"commitAuthor": "Matthias Sohn",
			"commitDateOld": "2018-02-12, 2:59 PM",
			"commitNameOld": "302596cc675d00e41f0ff07efef58063afe20c79",
			"commitAuthorOld": "Terry Parker",
			"daysBetweenCommits": 25.86,
			"commitsBetweenForRepo": 125,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,136 +1,135 @@\n \tprivate void sendPack(final boolean sideband,\n \t\t\tPackStatistics.Accumulator accumulator) throws IOException {\n \t\tProgressMonitor pm = NullProgressMonitor.INSTANCE;\n \t\tOutputStream packOut = rawOut;\n \n \t\tif (sideband) {\n \t\t\tint bufsz = SideBandOutputStream.SMALL_BUF;\n \t\t\tif (options.contains(OPTION_SIDE_BAND_64K))\n \t\t\t\tbufsz = SideBandOutputStream.MAX_BUF;\n \n \t\t\tpackOut = new SideBandOutputStream(SideBandOutputStream.CH_DATA,\n \t\t\t\t\tbufsz, rawOut);\n \t\t\tif (!options.contains(OPTION_NO_PROGRESS)) {\n \t\t\t\tmsgOut = new SideBandOutputStream(\n \t\t\t\t\t\tSideBandOutputStream.CH_PROGRESS, bufsz, rawOut);\n \t\t\t\tpm = new SideBandProgressMonitor(msgOut);\n \t\t\t}\n \t\t}\n \n \t\ttry {\n \t\t\tif (wantAll.isEmpty()) {\n \t\t\t\tpreUploadHook.onSendPack(this, wantIds, commonBase);\n \t\t\t} else {\n \t\t\t\tpreUploadHook.onSendPack(this, wantAll, commonBase);\n \t\t\t}\n \t\t\tmsgOut.flush();\n \t\t} catch (ServiceMayNotContinueException noPack) {\n \t\t\tif (sideband && noPack.getMessage() != null) {\n \t\t\t\tnoPack.setOutput();\n \t\t\t\t@SuppressWarnings(\"resource\" /* java 7 */)\n \t\t\t\tSideBandOutputStream err = new SideBandOutputStream(\n \t\t\t\t\t\tSideBandOutputStream.CH_ERROR,\n \t\t\t\t\t\tSideBandOutputStream.SMALL_BUF, rawOut);\n \t\t\t\terr.write(Constants.encode(noPack.getMessage()));\n \t\t\t\terr.flush();\n \t\t\t}\n \t\t\tthrow noPack;\n \t\t}\n \n \t\tPackConfig cfg = packConfig;\n \t\tif (cfg == null)\n \t\t\tcfg = new PackConfig(db);\n \t\tfinal PackWriter pw = new PackWriter(cfg, walk.getObjectReader(),\n \t\t\t\taccumulator);\n \t\ttry {\n \t\t\tpw.setIndexDisabled(true);\n \t\t\tpw.setUseCachedPacks(true);\n \t\t\tpw.setUseBitmaps(depth == 0 && clientShallowCommits.isEmpty());\n \t\t\tpw.setClientShallowCommits(clientShallowCommits);\n \t\t\tpw.setReuseDeltaCommits(true);\n \t\t\tpw.setDeltaBaseAsOffset(options.contains(OPTION_OFS_DELTA));\n \t\t\tpw.setThin(options.contains(OPTION_THIN_PACK));\n \t\t\tpw.setReuseValidatingObjects(false);\n \n \t\t\tif (commonBase.isEmpty() && refs != null) {\n \t\t\t\tSet<ObjectId> tagTargets = new HashSet<>();\n \t\t\t\tfor (Ref ref : refs.values()) {\n \t\t\t\t\tif (ref.getPeeledObjectId() != null)\n \t\t\t\t\t\ttagTargets.add(ref.getPeeledObjectId());\n \t\t\t\t\telse if (ref.getObjectId() == null)\n \t\t\t\t\t\tcontinue;\n \t\t\t\t\telse if (ref.getName().startsWith(Constants.R_HEADS))\n \t\t\t\t\t\ttagTargets.add(ref.getObjectId());\n \t\t\t\t}\n \t\t\t\tpw.setTagTargets(tagTargets);\n \t\t\t}\n \n \t\t\tRevWalk rw = walk;\n \t\t\tif (depth > 0) {\n \t\t\t\tpw.setShallowPack(depth, unshallowCommits);\n \t\t\t\trw = new DepthWalk.RevWalk(walk.getObjectReader(), depth - 1);\n \t\t\t\trw.assumeShallow(clientShallowCommits);\n \t\t\t}\n \n \t\t\tif (wantAll.isEmpty()) {\n \t\t\t\tpw.preparePack(pm, wantIds, commonBase, clientShallowCommits);\n \t\t\t} else {\n \t\t\t\twalk.reset();\n \n \t\t\t\tObjectWalk ow = rw.toObjectWalkWithSameObjects();\n \t\t\t\tpw.preparePack(pm, ow, wantAll, commonBase, PackWriter.NONE);\n \t\t\t\trw = ow;\n \t\t\t}\n \n \t\t\tif (options.contains(OPTION_INCLUDE_TAG) && refs != null) {\n \t\t\t\tfor (Ref ref : refs.values()) {\n \t\t\t\t\tObjectId objectId = ref.getObjectId();\n \t\t\t\t\tif (objectId == null) {\n \t\t\t\t\t\t// skip unborn branch\n \t\t\t\t\t\tcontinue;\n \t\t\t\t\t}\n \n \t\t\t\t\t// If the object was already requested, skip it.\n \t\t\t\t\tif (wantAll.isEmpty()) {\n \t\t\t\t\t\tif (wantIds.contains(objectId))\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t} else {\n \t\t\t\t\t\tRevObject obj = rw.lookupOrNull(objectId);\n \t\t\t\t\t\tif (obj != null && obj.has(WANT))\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t}\n \n \t\t\t\t\tif (!ref.isPeeled())\n \t\t\t\t\t\tref = db.peel(ref);\n \n \t\t\t\t\tObjectId peeledId = ref.getPeeledObjectId();\n \t\t\t\t\tobjectId = ref.getObjectId();\n \t\t\t\t\tif (peeledId == null || objectId == null)\n \t\t\t\t\t\tcontinue;\n \n \t\t\t\t\tif (pw.willInclude(peeledId) && !pw.willInclude(objectId)) {\n \t\t\t\t\t\tpw.addObject(rw.parseAny(objectId));\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tpw.writePack(pm, NullProgressMonitor.INSTANCE, packOut);\n \n \t\t\tif (msgOut != NullOutputStream.INSTANCE) {\n \t\t\t\tString msg = pw.getStatistics().getMessage() + '\\n';\n \t\t\t\tmsgOut.write(Constants.encode(msg));\n \t\t\t\tmsgOut.flush();\n \t\t\t}\n \n \t\t} finally {\n \t\t\tstatistics = pw.getStatistics();\n \t\t\tif (statistics != null) {\n \t\t\t\tpostUploadHook.onPostUpload(statistics);\n-\t\t\t\tlogger.onPackStatistics(new PackWriter.Statistics(statistics));\n \t\t\t}\n \t\t\tpw.close();\n \t\t}\n \n \t\tif (sideband)\n \t\t\tpckOut.end();\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"302596cc675d00e41f0ff07efef58063afe20c79": {
			"type": "Ymultichange(Yparameterchange,Ybodychange)",
			"commitMessage": "Add negotiation statistics to PackStatistics\n\nAdd fetch statistics for the counts of advertised refs, wants and haves.\nAlso add the duration in milliseconds for the negotiation phase. For\nnon-bidirectional transports like HTTP, this is the time for the final\nround that sends the pack back to the user.\n\nChange-Id: I1af7ffd3cb7b62182340682e2a243691ea24ec2e\nSigned-off-by: Terry Parker <tparker@google.com>\n",
			"commitDate": "2018-02-12, 2:59 PM",
			"commitName": "302596cc675d00e41f0ff07efef58063afe20c79",
			"commitAuthor": "Terry Parker",
			"subchanges": [
				{
					"type": "Yparameterchange",
					"commitMessage": "Add negotiation statistics to PackStatistics\n\nAdd fetch statistics for the counts of advertised refs, wants and haves.\nAlso add the duration in milliseconds for the negotiation phase. For\nnon-bidirectional transports like HTTP, this is the time for the final\nround that sends the pack back to the user.\n\nChange-Id: I1af7ffd3cb7b62182340682e2a243691ea24ec2e\nSigned-off-by: Terry Parker <tparker@google.com>\n",
					"commitDate": "2018-02-12, 2:59 PM",
					"commitName": "302596cc675d00e41f0ff07efef58063afe20c79",
					"commitAuthor": "Terry Parker",
					"commitDateOld": "2018-01-03, 3:21 PM",
					"commitNameOld": "21d22e6f63a1adcfaeaee155f1be32f8123fd789",
					"commitAuthorOld": "Zhen Chen",
					"daysBetweenCommits": 39.99,
					"commitsBetweenForRepo": 46,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,134 +1,136 @@\n-\tprivate void sendPack(final boolean sideband) throws IOException {\n+\tprivate void sendPack(final boolean sideband,\n+\t\t\tPackStatistics.Accumulator accumulator) throws IOException {\n \t\tProgressMonitor pm = NullProgressMonitor.INSTANCE;\n \t\tOutputStream packOut = rawOut;\n \n \t\tif (sideband) {\n \t\t\tint bufsz = SideBandOutputStream.SMALL_BUF;\n \t\t\tif (options.contains(OPTION_SIDE_BAND_64K))\n \t\t\t\tbufsz = SideBandOutputStream.MAX_BUF;\n \n \t\t\tpackOut = new SideBandOutputStream(SideBandOutputStream.CH_DATA,\n \t\t\t\t\tbufsz, rawOut);\n \t\t\tif (!options.contains(OPTION_NO_PROGRESS)) {\n \t\t\t\tmsgOut = new SideBandOutputStream(\n \t\t\t\t\t\tSideBandOutputStream.CH_PROGRESS, bufsz, rawOut);\n \t\t\t\tpm = new SideBandProgressMonitor(msgOut);\n \t\t\t}\n \t\t}\n \n \t\ttry {\n \t\t\tif (wantAll.isEmpty()) {\n \t\t\t\tpreUploadHook.onSendPack(this, wantIds, commonBase);\n \t\t\t} else {\n \t\t\t\tpreUploadHook.onSendPack(this, wantAll, commonBase);\n \t\t\t}\n \t\t\tmsgOut.flush();\n \t\t} catch (ServiceMayNotContinueException noPack) {\n \t\t\tif (sideband && noPack.getMessage() != null) {\n \t\t\t\tnoPack.setOutput();\n \t\t\t\t@SuppressWarnings(\"resource\" /* java 7 */)\n \t\t\t\tSideBandOutputStream err = new SideBandOutputStream(\n \t\t\t\t\t\tSideBandOutputStream.CH_ERROR,\n \t\t\t\t\t\tSideBandOutputStream.SMALL_BUF, rawOut);\n \t\t\t\terr.write(Constants.encode(noPack.getMessage()));\n \t\t\t\terr.flush();\n \t\t\t}\n \t\t\tthrow noPack;\n \t\t}\n \n \t\tPackConfig cfg = packConfig;\n \t\tif (cfg == null)\n \t\t\tcfg = new PackConfig(db);\n-\t\tfinal PackWriter pw = new PackWriter(cfg, walk.getObjectReader());\n+\t\tfinal PackWriter pw = new PackWriter(cfg, walk.getObjectReader(),\n+\t\t\t\taccumulator);\n \t\ttry {\n \t\t\tpw.setIndexDisabled(true);\n \t\t\tpw.setUseCachedPacks(true);\n \t\t\tpw.setUseBitmaps(depth == 0 && clientShallowCommits.isEmpty());\n \t\t\tpw.setClientShallowCommits(clientShallowCommits);\n \t\t\tpw.setReuseDeltaCommits(true);\n \t\t\tpw.setDeltaBaseAsOffset(options.contains(OPTION_OFS_DELTA));\n \t\t\tpw.setThin(options.contains(OPTION_THIN_PACK));\n \t\t\tpw.setReuseValidatingObjects(false);\n \n \t\t\tif (commonBase.isEmpty() && refs != null) {\n \t\t\t\tSet<ObjectId> tagTargets = new HashSet<>();\n \t\t\t\tfor (Ref ref : refs.values()) {\n \t\t\t\t\tif (ref.getPeeledObjectId() != null)\n \t\t\t\t\t\ttagTargets.add(ref.getPeeledObjectId());\n \t\t\t\t\telse if (ref.getObjectId() == null)\n \t\t\t\t\t\tcontinue;\n \t\t\t\t\telse if (ref.getName().startsWith(Constants.R_HEADS))\n \t\t\t\t\t\ttagTargets.add(ref.getObjectId());\n \t\t\t\t}\n \t\t\t\tpw.setTagTargets(tagTargets);\n \t\t\t}\n \n \t\t\tRevWalk rw = walk;\n \t\t\tif (depth > 0) {\n \t\t\t\tpw.setShallowPack(depth, unshallowCommits);\n \t\t\t\trw = new DepthWalk.RevWalk(walk.getObjectReader(), depth - 1);\n \t\t\t\trw.assumeShallow(clientShallowCommits);\n \t\t\t}\n \n \t\t\tif (wantAll.isEmpty()) {\n \t\t\t\tpw.preparePack(pm, wantIds, commonBase, clientShallowCommits);\n \t\t\t} else {\n \t\t\t\twalk.reset();\n \n \t\t\t\tObjectWalk ow = rw.toObjectWalkWithSameObjects();\n \t\t\t\tpw.preparePack(pm, ow, wantAll, commonBase, PackWriter.NONE);\n \t\t\t\trw = ow;\n \t\t\t}\n \n \t\t\tif (options.contains(OPTION_INCLUDE_TAG) && refs != null) {\n \t\t\t\tfor (Ref ref : refs.values()) {\n \t\t\t\t\tObjectId objectId = ref.getObjectId();\n \t\t\t\t\tif (objectId == null) {\n \t\t\t\t\t\t// skip unborn branch\n \t\t\t\t\t\tcontinue;\n \t\t\t\t\t}\n \n \t\t\t\t\t// If the object was already requested, skip it.\n \t\t\t\t\tif (wantAll.isEmpty()) {\n \t\t\t\t\t\tif (wantIds.contains(objectId))\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t} else {\n \t\t\t\t\t\tRevObject obj = rw.lookupOrNull(objectId);\n \t\t\t\t\t\tif (obj != null && obj.has(WANT))\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t}\n \n \t\t\t\t\tif (!ref.isPeeled())\n \t\t\t\t\t\tref = db.peel(ref);\n \n \t\t\t\t\tObjectId peeledId = ref.getPeeledObjectId();\n \t\t\t\t\tobjectId = ref.getObjectId();\n \t\t\t\t\tif (peeledId == null || objectId == null)\n \t\t\t\t\t\tcontinue;\n \n \t\t\t\t\tif (pw.willInclude(peeledId) && !pw.willInclude(objectId)) {\n \t\t\t\t\t\tpw.addObject(rw.parseAny(objectId));\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tpw.writePack(pm, NullProgressMonitor.INSTANCE, packOut);\n \n \t\t\tif (msgOut != NullOutputStream.INSTANCE) {\n \t\t\t\tString msg = pw.getStatistics().getMessage() + '\\n';\n \t\t\t\tmsgOut.write(Constants.encode(msg));\n \t\t\t\tmsgOut.flush();\n \t\t\t}\n \n \t\t} finally {\n \t\t\tstatistics = pw.getStatistics();\n \t\t\tif (statistics != null) {\n \t\t\t\tpostUploadHook.onPostUpload(statistics);\n \t\t\t\tlogger.onPackStatistics(new PackWriter.Statistics(statistics));\n \t\t\t}\n \t\t\tpw.close();\n \t\t}\n \n \t\tif (sideband)\n \t\t\tpckOut.end();\n \t}\n\\ No newline at end of file\n",
					"extendedDetails": {
						"oldValue": "[sideband-boolean(modifiers-final)]",
						"newValue": "[sideband-boolean(modifiers-final), accumulator-PackStatistics.Accumulator]"
					}
				},
				{
					"type": "Ybodychange",
					"commitMessage": "Add negotiation statistics to PackStatistics\n\nAdd fetch statistics for the counts of advertised refs, wants and haves.\nAlso add the duration in milliseconds for the negotiation phase. For\nnon-bidirectional transports like HTTP, this is the time for the final\nround that sends the pack back to the user.\n\nChange-Id: I1af7ffd3cb7b62182340682e2a243691ea24ec2e\nSigned-off-by: Terry Parker <tparker@google.com>\n",
					"commitDate": "2018-02-12, 2:59 PM",
					"commitName": "302596cc675d00e41f0ff07efef58063afe20c79",
					"commitAuthor": "Terry Parker",
					"commitDateOld": "2018-01-03, 3:21 PM",
					"commitNameOld": "21d22e6f63a1adcfaeaee155f1be32f8123fd789",
					"commitAuthorOld": "Zhen Chen",
					"daysBetweenCommits": 39.99,
					"commitsBetweenForRepo": 46,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,134 +1,136 @@\n-\tprivate void sendPack(final boolean sideband) throws IOException {\n+\tprivate void sendPack(final boolean sideband,\n+\t\t\tPackStatistics.Accumulator accumulator) throws IOException {\n \t\tProgressMonitor pm = NullProgressMonitor.INSTANCE;\n \t\tOutputStream packOut = rawOut;\n \n \t\tif (sideband) {\n \t\t\tint bufsz = SideBandOutputStream.SMALL_BUF;\n \t\t\tif (options.contains(OPTION_SIDE_BAND_64K))\n \t\t\t\tbufsz = SideBandOutputStream.MAX_BUF;\n \n \t\t\tpackOut = new SideBandOutputStream(SideBandOutputStream.CH_DATA,\n \t\t\t\t\tbufsz, rawOut);\n \t\t\tif (!options.contains(OPTION_NO_PROGRESS)) {\n \t\t\t\tmsgOut = new SideBandOutputStream(\n \t\t\t\t\t\tSideBandOutputStream.CH_PROGRESS, bufsz, rawOut);\n \t\t\t\tpm = new SideBandProgressMonitor(msgOut);\n \t\t\t}\n \t\t}\n \n \t\ttry {\n \t\t\tif (wantAll.isEmpty()) {\n \t\t\t\tpreUploadHook.onSendPack(this, wantIds, commonBase);\n \t\t\t} else {\n \t\t\t\tpreUploadHook.onSendPack(this, wantAll, commonBase);\n \t\t\t}\n \t\t\tmsgOut.flush();\n \t\t} catch (ServiceMayNotContinueException noPack) {\n \t\t\tif (sideband && noPack.getMessage() != null) {\n \t\t\t\tnoPack.setOutput();\n \t\t\t\t@SuppressWarnings(\"resource\" /* java 7 */)\n \t\t\t\tSideBandOutputStream err = new SideBandOutputStream(\n \t\t\t\t\t\tSideBandOutputStream.CH_ERROR,\n \t\t\t\t\t\tSideBandOutputStream.SMALL_BUF, rawOut);\n \t\t\t\terr.write(Constants.encode(noPack.getMessage()));\n \t\t\t\terr.flush();\n \t\t\t}\n \t\t\tthrow noPack;\n \t\t}\n \n \t\tPackConfig cfg = packConfig;\n \t\tif (cfg == null)\n \t\t\tcfg = new PackConfig(db);\n-\t\tfinal PackWriter pw = new PackWriter(cfg, walk.getObjectReader());\n+\t\tfinal PackWriter pw = new PackWriter(cfg, walk.getObjectReader(),\n+\t\t\t\taccumulator);\n \t\ttry {\n \t\t\tpw.setIndexDisabled(true);\n \t\t\tpw.setUseCachedPacks(true);\n \t\t\tpw.setUseBitmaps(depth == 0 && clientShallowCommits.isEmpty());\n \t\t\tpw.setClientShallowCommits(clientShallowCommits);\n \t\t\tpw.setReuseDeltaCommits(true);\n \t\t\tpw.setDeltaBaseAsOffset(options.contains(OPTION_OFS_DELTA));\n \t\t\tpw.setThin(options.contains(OPTION_THIN_PACK));\n \t\t\tpw.setReuseValidatingObjects(false);\n \n \t\t\tif (commonBase.isEmpty() && refs != null) {\n \t\t\t\tSet<ObjectId> tagTargets = new HashSet<>();\n \t\t\t\tfor (Ref ref : refs.values()) {\n \t\t\t\t\tif (ref.getPeeledObjectId() != null)\n \t\t\t\t\t\ttagTargets.add(ref.getPeeledObjectId());\n \t\t\t\t\telse if (ref.getObjectId() == null)\n \t\t\t\t\t\tcontinue;\n \t\t\t\t\telse if (ref.getName().startsWith(Constants.R_HEADS))\n \t\t\t\t\t\ttagTargets.add(ref.getObjectId());\n \t\t\t\t}\n \t\t\t\tpw.setTagTargets(tagTargets);\n \t\t\t}\n \n \t\t\tRevWalk rw = walk;\n \t\t\tif (depth > 0) {\n \t\t\t\tpw.setShallowPack(depth, unshallowCommits);\n \t\t\t\trw = new DepthWalk.RevWalk(walk.getObjectReader(), depth - 1);\n \t\t\t\trw.assumeShallow(clientShallowCommits);\n \t\t\t}\n \n \t\t\tif (wantAll.isEmpty()) {\n \t\t\t\tpw.preparePack(pm, wantIds, commonBase, clientShallowCommits);\n \t\t\t} else {\n \t\t\t\twalk.reset();\n \n \t\t\t\tObjectWalk ow = rw.toObjectWalkWithSameObjects();\n \t\t\t\tpw.preparePack(pm, ow, wantAll, commonBase, PackWriter.NONE);\n \t\t\t\trw = ow;\n \t\t\t}\n \n \t\t\tif (options.contains(OPTION_INCLUDE_TAG) && refs != null) {\n \t\t\t\tfor (Ref ref : refs.values()) {\n \t\t\t\t\tObjectId objectId = ref.getObjectId();\n \t\t\t\t\tif (objectId == null) {\n \t\t\t\t\t\t// skip unborn branch\n \t\t\t\t\t\tcontinue;\n \t\t\t\t\t}\n \n \t\t\t\t\t// If the object was already requested, skip it.\n \t\t\t\t\tif (wantAll.isEmpty()) {\n \t\t\t\t\t\tif (wantIds.contains(objectId))\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t} else {\n \t\t\t\t\t\tRevObject obj = rw.lookupOrNull(objectId);\n \t\t\t\t\t\tif (obj != null && obj.has(WANT))\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t}\n \n \t\t\t\t\tif (!ref.isPeeled())\n \t\t\t\t\t\tref = db.peel(ref);\n \n \t\t\t\t\tObjectId peeledId = ref.getPeeledObjectId();\n \t\t\t\t\tobjectId = ref.getObjectId();\n \t\t\t\t\tif (peeledId == null || objectId == null)\n \t\t\t\t\t\tcontinue;\n \n \t\t\t\t\tif (pw.willInclude(peeledId) && !pw.willInclude(objectId)) {\n \t\t\t\t\t\tpw.addObject(rw.parseAny(objectId));\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tpw.writePack(pm, NullProgressMonitor.INSTANCE, packOut);\n \n \t\t\tif (msgOut != NullOutputStream.INSTANCE) {\n \t\t\t\tString msg = pw.getStatistics().getMessage() + '\\n';\n \t\t\t\tmsgOut.write(Constants.encode(msg));\n \t\t\t\tmsgOut.flush();\n \t\t\t}\n \n \t\t} finally {\n \t\t\tstatistics = pw.getStatistics();\n \t\t\tif (statistics != null) {\n \t\t\t\tpostUploadHook.onPostUpload(statistics);\n \t\t\t\tlogger.onPackStatistics(new PackWriter.Statistics(statistics));\n \t\t\t}\n \t\t\tpw.close();\n \t\t}\n \n \t\tif (sideband)\n \t\t\tpckOut.end();\n \t}\n\\ No newline at end of file\n",
					"extendedDetails": {}
				}
			]
		},
		"21d22e6f63a1adcfaeaee155f1be32f8123fd789": {
			"type": "Ybodychange",
			"commitMessage": "Skip unborn branches in UploadPack\n\nThe ObjectId of an unborn branch is null, skip those in UploadPack.\n\nChange-Id: I7cbf66b05dff98c4fe9f33e20a647ba6acf364b2\nSigned-off-by: Zhen Chen <czhen@google.com>\n",
			"commitDate": "2018-01-03, 3:21 PM",
			"commitName": "21d22e6f63a1adcfaeaee155f1be32f8123fd789",
			"commitAuthor": "Zhen Chen",
			"commitDateOld": "2017-12-20, 2:10 PM",
			"commitNameOld": "781e106a2607665a7a47b626fd5b67fa8b491d18",
			"commitAuthorOld": "Matthias Sohn",
			"daysBetweenCommits": 14.05,
			"commitsBetweenForRepo": 23,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,129 +1,134 @@\n \tprivate void sendPack(final boolean sideband) throws IOException {\n \t\tProgressMonitor pm = NullProgressMonitor.INSTANCE;\n \t\tOutputStream packOut = rawOut;\n \n \t\tif (sideband) {\n \t\t\tint bufsz = SideBandOutputStream.SMALL_BUF;\n \t\t\tif (options.contains(OPTION_SIDE_BAND_64K))\n \t\t\t\tbufsz = SideBandOutputStream.MAX_BUF;\n \n \t\t\tpackOut = new SideBandOutputStream(SideBandOutputStream.CH_DATA,\n \t\t\t\t\tbufsz, rawOut);\n \t\t\tif (!options.contains(OPTION_NO_PROGRESS)) {\n \t\t\t\tmsgOut = new SideBandOutputStream(\n \t\t\t\t\t\tSideBandOutputStream.CH_PROGRESS, bufsz, rawOut);\n \t\t\t\tpm = new SideBandProgressMonitor(msgOut);\n \t\t\t}\n \t\t}\n \n \t\ttry {\n \t\t\tif (wantAll.isEmpty()) {\n \t\t\t\tpreUploadHook.onSendPack(this, wantIds, commonBase);\n \t\t\t} else {\n \t\t\t\tpreUploadHook.onSendPack(this, wantAll, commonBase);\n \t\t\t}\n \t\t\tmsgOut.flush();\n \t\t} catch (ServiceMayNotContinueException noPack) {\n \t\t\tif (sideband && noPack.getMessage() != null) {\n \t\t\t\tnoPack.setOutput();\n \t\t\t\t@SuppressWarnings(\"resource\" /* java 7 */)\n \t\t\t\tSideBandOutputStream err = new SideBandOutputStream(\n \t\t\t\t\t\tSideBandOutputStream.CH_ERROR,\n \t\t\t\t\t\tSideBandOutputStream.SMALL_BUF, rawOut);\n \t\t\t\terr.write(Constants.encode(noPack.getMessage()));\n \t\t\t\terr.flush();\n \t\t\t}\n \t\t\tthrow noPack;\n \t\t}\n \n \t\tPackConfig cfg = packConfig;\n \t\tif (cfg == null)\n \t\t\tcfg = new PackConfig(db);\n \t\tfinal PackWriter pw = new PackWriter(cfg, walk.getObjectReader());\n \t\ttry {\n \t\t\tpw.setIndexDisabled(true);\n \t\t\tpw.setUseCachedPacks(true);\n \t\t\tpw.setUseBitmaps(depth == 0 && clientShallowCommits.isEmpty());\n \t\t\tpw.setClientShallowCommits(clientShallowCommits);\n \t\t\tpw.setReuseDeltaCommits(true);\n \t\t\tpw.setDeltaBaseAsOffset(options.contains(OPTION_OFS_DELTA));\n \t\t\tpw.setThin(options.contains(OPTION_THIN_PACK));\n \t\t\tpw.setReuseValidatingObjects(false);\n \n \t\t\tif (commonBase.isEmpty() && refs != null) {\n \t\t\t\tSet<ObjectId> tagTargets = new HashSet<>();\n \t\t\t\tfor (Ref ref : refs.values()) {\n \t\t\t\t\tif (ref.getPeeledObjectId() != null)\n \t\t\t\t\t\ttagTargets.add(ref.getPeeledObjectId());\n \t\t\t\t\telse if (ref.getObjectId() == null)\n \t\t\t\t\t\tcontinue;\n \t\t\t\t\telse if (ref.getName().startsWith(Constants.R_HEADS))\n \t\t\t\t\t\ttagTargets.add(ref.getObjectId());\n \t\t\t\t}\n \t\t\t\tpw.setTagTargets(tagTargets);\n \t\t\t}\n \n \t\t\tRevWalk rw = walk;\n \t\t\tif (depth > 0) {\n \t\t\t\tpw.setShallowPack(depth, unshallowCommits);\n \t\t\t\trw = new DepthWalk.RevWalk(walk.getObjectReader(), depth - 1);\n \t\t\t\trw.assumeShallow(clientShallowCommits);\n \t\t\t}\n \n \t\t\tif (wantAll.isEmpty()) {\n \t\t\t\tpw.preparePack(pm, wantIds, commonBase, clientShallowCommits);\n \t\t\t} else {\n \t\t\t\twalk.reset();\n \n \t\t\t\tObjectWalk ow = rw.toObjectWalkWithSameObjects();\n \t\t\t\tpw.preparePack(pm, ow, wantAll, commonBase, PackWriter.NONE);\n \t\t\t\trw = ow;\n \t\t\t}\n \n \t\t\tif (options.contains(OPTION_INCLUDE_TAG) && refs != null) {\n \t\t\t\tfor (Ref ref : refs.values()) {\n \t\t\t\t\tObjectId objectId = ref.getObjectId();\n+\t\t\t\t\tif (objectId == null) {\n+\t\t\t\t\t\t// skip unborn branch\n+\t\t\t\t\t\tcontinue;\n+\t\t\t\t\t}\n \n \t\t\t\t\t// If the object was already requested, skip it.\n \t\t\t\t\tif (wantAll.isEmpty()) {\n \t\t\t\t\t\tif (wantIds.contains(objectId))\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t} else {\n \t\t\t\t\t\tRevObject obj = rw.lookupOrNull(objectId);\n \t\t\t\t\t\tif (obj != null && obj.has(WANT))\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t}\n \n \t\t\t\t\tif (!ref.isPeeled())\n \t\t\t\t\t\tref = db.peel(ref);\n \n \t\t\t\t\tObjectId peeledId = ref.getPeeledObjectId();\n-\t\t\t\t\tif (peeledId == null)\n+\t\t\t\t\tobjectId = ref.getObjectId();\n+\t\t\t\t\tif (peeledId == null || objectId == null)\n \t\t\t\t\t\tcontinue;\n \n-\t\t\t\t\tobjectId = ref.getObjectId();\n-\t\t\t\t\tif (pw.willInclude(peeledId) && !pw.willInclude(objectId))\n+\t\t\t\t\tif (pw.willInclude(peeledId) && !pw.willInclude(objectId)) {\n \t\t\t\t\t\tpw.addObject(rw.parseAny(objectId));\n+\t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tpw.writePack(pm, NullProgressMonitor.INSTANCE, packOut);\n \n \t\t\tif (msgOut != NullOutputStream.INSTANCE) {\n \t\t\t\tString msg = pw.getStatistics().getMessage() + '\\n';\n \t\t\t\tmsgOut.write(Constants.encode(msg));\n \t\t\t\tmsgOut.flush();\n \t\t\t}\n \n \t\t} finally {\n \t\t\tstatistics = pw.getStatistics();\n \t\t\tif (statistics != null) {\n \t\t\t\tpostUploadHook.onPostUpload(statistics);\n \t\t\t\tlogger.onPackStatistics(new PackWriter.Statistics(statistics));\n \t\t\t}\n \t\t\tpw.close();\n \t\t}\n \n \t\tif (sideband)\n \t\t\tpckOut.end();\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"c46c720e99baa081bff0dd7bcc1ae8ca48b5e3d1": {
			"type": "Ybodychange",
			"commitMessage": "Exclude refs/tags from bitmap commit selection\n\nCommit db77610 ensured that all refs/tags commits are added to the\nprimary GC pack. It did that by adding all of the refs/tags commits\nto the primary GC pack PackWriter's \"interesting\" object set.\n\nUnfortunately, all commit objects in the \"interesting\" set are\nselected as commits for which bitmap indices will be built. In a\nrepository like chromium with lots of tags, this changed the number of\nbitmaps created from <700 to >10000. That puts huge memory pressure on\nthe GC task.\n\nThis change restores the original behavior of ignoring tags when\nselecting commits for bitmaps.\n\nIn the \"uninteresting\" set, commits for refs/heads and refs/tags for\nunannotated tags can not be differentiated. We instead identify\nrefs/tags commits by passing their ObjectIds as a new \"noBitmaps\"\nparameter to the PackWriter.preparePack() methods.\nPackWriterBitmapPreparer.setupTipCommitBitmaps() can then use that\n\"noBitmaps\" parameter to exclude those commits.\n\nChange-Id: Icd287c6b04fc1e48de773033fe432a9b0e904ac5\nSigned-off-by: Terry Parker <tparker@google.com>\n",
			"commitDate": "2017-05-18, 4:25 PM",
			"commitName": "c46c720e99baa081bff0dd7bcc1ae8ca48b5e3d1",
			"commitAuthor": "Terry Parker",
			"commitDateOld": "2017-04-05, 1:51 AM",
			"commitNameOld": "7476baebfc457e75c984de61dc8ae08a359b52e8",
			"commitAuthorOld": "Andrey Loskutov",
			"daysBetweenCommits": 43.61,
			"commitsBetweenForRepo": 47,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,129 +1,129 @@\n \tprivate void sendPack(final boolean sideband) throws IOException {\n \t\tProgressMonitor pm = NullProgressMonitor.INSTANCE;\n \t\tOutputStream packOut = rawOut;\n \n \t\tif (sideband) {\n \t\t\tint bufsz = SideBandOutputStream.SMALL_BUF;\n \t\t\tif (options.contains(OPTION_SIDE_BAND_64K))\n \t\t\t\tbufsz = SideBandOutputStream.MAX_BUF;\n \n \t\t\tpackOut = new SideBandOutputStream(SideBandOutputStream.CH_DATA,\n \t\t\t\t\tbufsz, rawOut);\n \t\t\tif (!options.contains(OPTION_NO_PROGRESS)) {\n \t\t\t\tmsgOut = new SideBandOutputStream(\n \t\t\t\t\t\tSideBandOutputStream.CH_PROGRESS, bufsz, rawOut);\n \t\t\t\tpm = new SideBandProgressMonitor(msgOut);\n \t\t\t}\n \t\t}\n \n \t\ttry {\n \t\t\tif (wantAll.isEmpty()) {\n \t\t\t\tpreUploadHook.onSendPack(this, wantIds, commonBase);\n \t\t\t} else {\n \t\t\t\tpreUploadHook.onSendPack(this, wantAll, commonBase);\n \t\t\t}\n \t\t\tmsgOut.flush();\n \t\t} catch (ServiceMayNotContinueException noPack) {\n \t\t\tif (sideband && noPack.getMessage() != null) {\n \t\t\t\tnoPack.setOutput();\n \t\t\t\t@SuppressWarnings(\"resource\" /* java 7 */)\n \t\t\t\tSideBandOutputStream err = new SideBandOutputStream(\n \t\t\t\t\t\tSideBandOutputStream.CH_ERROR,\n \t\t\t\t\t\tSideBandOutputStream.SMALL_BUF, rawOut);\n \t\t\t\terr.write(Constants.encode(noPack.getMessage()));\n \t\t\t\terr.flush();\n \t\t\t}\n \t\t\tthrow noPack;\n \t\t}\n \n \t\tPackConfig cfg = packConfig;\n \t\tif (cfg == null)\n \t\t\tcfg = new PackConfig(db);\n \t\tfinal PackWriter pw = new PackWriter(cfg, walk.getObjectReader());\n \t\ttry {\n \t\t\tpw.setIndexDisabled(true);\n \t\t\tpw.setUseCachedPacks(true);\n \t\t\tpw.setUseBitmaps(depth == 0 && clientShallowCommits.isEmpty());\n \t\t\tpw.setClientShallowCommits(clientShallowCommits);\n \t\t\tpw.setReuseDeltaCommits(true);\n \t\t\tpw.setDeltaBaseAsOffset(options.contains(OPTION_OFS_DELTA));\n \t\t\tpw.setThin(options.contains(OPTION_THIN_PACK));\n \t\t\tpw.setReuseValidatingObjects(false);\n \n \t\t\tif (commonBase.isEmpty() && refs != null) {\n \t\t\t\tSet<ObjectId> tagTargets = new HashSet<>();\n \t\t\t\tfor (Ref ref : refs.values()) {\n \t\t\t\t\tif (ref.getPeeledObjectId() != null)\n \t\t\t\t\t\ttagTargets.add(ref.getPeeledObjectId());\n \t\t\t\t\telse if (ref.getObjectId() == null)\n \t\t\t\t\t\tcontinue;\n \t\t\t\t\telse if (ref.getName().startsWith(Constants.R_HEADS))\n \t\t\t\t\t\ttagTargets.add(ref.getObjectId());\n \t\t\t\t}\n \t\t\t\tpw.setTagTargets(tagTargets);\n \t\t\t}\n \n \t\t\tRevWalk rw = walk;\n \t\t\tif (depth > 0) {\n \t\t\t\tpw.setShallowPack(depth, unshallowCommits);\n \t\t\t\trw = new DepthWalk.RevWalk(walk.getObjectReader(), depth - 1);\n \t\t\t\trw.assumeShallow(clientShallowCommits);\n \t\t\t}\n \n \t\t\tif (wantAll.isEmpty()) {\n \t\t\t\tpw.preparePack(pm, wantIds, commonBase, clientShallowCommits);\n \t\t\t} else {\n \t\t\t\twalk.reset();\n \n \t\t\t\tObjectWalk ow = rw.toObjectWalkWithSameObjects();\n-\t\t\t\tpw.preparePack(pm, ow, wantAll, commonBase);\n+\t\t\t\tpw.preparePack(pm, ow, wantAll, commonBase, PackWriter.NONE);\n \t\t\t\trw = ow;\n \t\t\t}\n \n \t\t\tif (options.contains(OPTION_INCLUDE_TAG) && refs != null) {\n \t\t\t\tfor (Ref ref : refs.values()) {\n \t\t\t\t\tObjectId objectId = ref.getObjectId();\n \n \t\t\t\t\t// If the object was already requested, skip it.\n \t\t\t\t\tif (wantAll.isEmpty()) {\n \t\t\t\t\t\tif (wantIds.contains(objectId))\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t} else {\n \t\t\t\t\t\tRevObject obj = rw.lookupOrNull(objectId);\n \t\t\t\t\t\tif (obj != null && obj.has(WANT))\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t}\n \n \t\t\t\t\tif (!ref.isPeeled())\n \t\t\t\t\t\tref = db.peel(ref);\n \n \t\t\t\t\tObjectId peeledId = ref.getPeeledObjectId();\n \t\t\t\t\tif (peeledId == null)\n \t\t\t\t\t\tcontinue;\n \n \t\t\t\t\tobjectId = ref.getObjectId();\n \t\t\t\t\tif (pw.willInclude(peeledId) && !pw.willInclude(objectId))\n \t\t\t\t\t\tpw.addObject(rw.parseAny(objectId));\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tpw.writePack(pm, NullProgressMonitor.INSTANCE, packOut);\n \n \t\t\tif (msgOut != NullOutputStream.INSTANCE) {\n \t\t\t\tString msg = pw.getStatistics().getMessage() + '\\n';\n \t\t\t\tmsgOut.write(Constants.encode(msg));\n \t\t\t\tmsgOut.flush();\n \t\t\t}\n \n \t\t} finally {\n \t\t\tstatistics = pw.getStatistics();\n \t\t\tif (statistics != null) {\n \t\t\t\tpostUploadHook.onPostUpload(statistics);\n \t\t\t\tlogger.onPackStatistics(new PackWriter.Statistics(statistics));\n \t\t\t}\n \t\t\tpw.close();\n \t\t}\n \n \t\tif (sideband)\n \t\t\tpckOut.end();\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"3b4448637fbb9d74e0c9d44048ba76bb7c1214ce": {
			"type": "Ybodychange",
			"commitMessage": "Enable and fix warnings about redundant specification of type arguments\n\nSince the introduction of generic type parameter inference in Java 7,\nit's not necessary to explicitly specify the type of generic parameters.\n\nEnable the warning in Eclipse, and fix all occurrences.\n\nChange-Id: I9158caf1beca5e4980b6240ac401f3868520aad0\nSigned-off-by: David Pursehouse <david.pursehouse@gmail.com>\n",
			"commitDate": "2017-02-20, 2:47 PM",
			"commitName": "3b4448637fbb9d74e0c9d44048ba76bb7c1214ce",
			"commitAuthor": "David Pursehouse",
			"commitDateOld": "2017-02-19, 5:05 PM",
			"commitNameOld": "7ac182f4e427e0d5a986b8ca67a56fc22828b1a0",
			"commitAuthorOld": "David Pursehouse",
			"daysBetweenCommits": 0.9,
			"commitsBetweenForRepo": 6,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,129 +1,129 @@\n \tprivate void sendPack(final boolean sideband) throws IOException {\n \t\tProgressMonitor pm = NullProgressMonitor.INSTANCE;\n \t\tOutputStream packOut = rawOut;\n \n \t\tif (sideband) {\n \t\t\tint bufsz = SideBandOutputStream.SMALL_BUF;\n \t\t\tif (options.contains(OPTION_SIDE_BAND_64K))\n \t\t\t\tbufsz = SideBandOutputStream.MAX_BUF;\n \n \t\t\tpackOut = new SideBandOutputStream(SideBandOutputStream.CH_DATA,\n \t\t\t\t\tbufsz, rawOut);\n \t\t\tif (!options.contains(OPTION_NO_PROGRESS)) {\n \t\t\t\tmsgOut = new SideBandOutputStream(\n \t\t\t\t\t\tSideBandOutputStream.CH_PROGRESS, bufsz, rawOut);\n \t\t\t\tpm = new SideBandProgressMonitor(msgOut);\n \t\t\t}\n \t\t}\n \n \t\ttry {\n \t\t\tif (wantAll.isEmpty()) {\n \t\t\t\tpreUploadHook.onSendPack(this, wantIds, commonBase);\n \t\t\t} else {\n \t\t\t\tpreUploadHook.onSendPack(this, wantAll, commonBase);\n \t\t\t}\n \t\t\tmsgOut.flush();\n \t\t} catch (ServiceMayNotContinueException noPack) {\n \t\t\tif (sideband && noPack.getMessage() != null) {\n \t\t\t\tnoPack.setOutput();\n \t\t\t\t@SuppressWarnings(\"resource\" /* java 7 */)\n \t\t\t\tSideBandOutputStream err = new SideBandOutputStream(\n \t\t\t\t\t\tSideBandOutputStream.CH_ERROR,\n \t\t\t\t\t\tSideBandOutputStream.SMALL_BUF, rawOut);\n \t\t\t\terr.write(Constants.encode(noPack.getMessage()));\n \t\t\t\terr.flush();\n \t\t\t}\n \t\t\tthrow noPack;\n \t\t}\n \n \t\tPackConfig cfg = packConfig;\n \t\tif (cfg == null)\n \t\t\tcfg = new PackConfig(db);\n \t\tfinal PackWriter pw = new PackWriter(cfg, walk.getObjectReader());\n \t\ttry {\n \t\t\tpw.setIndexDisabled(true);\n \t\t\tpw.setUseCachedPacks(true);\n \t\t\tpw.setUseBitmaps(depth == 0 && clientShallowCommits.isEmpty());\n \t\t\tpw.setClientShallowCommits(clientShallowCommits);\n \t\t\tpw.setReuseDeltaCommits(true);\n \t\t\tpw.setDeltaBaseAsOffset(options.contains(OPTION_OFS_DELTA));\n \t\t\tpw.setThin(options.contains(OPTION_THIN_PACK));\n \t\t\tpw.setReuseValidatingObjects(false);\n \n \t\t\tif (commonBase.isEmpty() && refs != null) {\n-\t\t\t\tSet<ObjectId> tagTargets = new HashSet<ObjectId>();\n+\t\t\t\tSet<ObjectId> tagTargets = new HashSet<>();\n \t\t\t\tfor (Ref ref : refs.values()) {\n \t\t\t\t\tif (ref.getPeeledObjectId() != null)\n \t\t\t\t\t\ttagTargets.add(ref.getPeeledObjectId());\n \t\t\t\t\telse if (ref.getObjectId() == null)\n \t\t\t\t\t\tcontinue;\n \t\t\t\t\telse if (ref.getName().startsWith(Constants.R_HEADS))\n \t\t\t\t\t\ttagTargets.add(ref.getObjectId());\n \t\t\t\t}\n \t\t\t\tpw.setTagTargets(tagTargets);\n \t\t\t}\n \n \t\t\tRevWalk rw = walk;\n \t\t\tif (depth > 0) {\n \t\t\t\tpw.setShallowPack(depth, unshallowCommits);\n \t\t\t\trw = new DepthWalk.RevWalk(walk.getObjectReader(), depth - 1);\n \t\t\t\trw.assumeShallow(clientShallowCommits);\n \t\t\t}\n \n \t\t\tif (wantAll.isEmpty()) {\n \t\t\t\tpw.preparePack(pm, wantIds, commonBase, clientShallowCommits);\n \t\t\t} else {\n \t\t\t\twalk.reset();\n \n \t\t\t\tObjectWalk ow = rw.toObjectWalkWithSameObjects();\n \t\t\t\tpw.preparePack(pm, ow, wantAll, commonBase);\n \t\t\t\trw = ow;\n \t\t\t}\n \n \t\t\tif (options.contains(OPTION_INCLUDE_TAG) && refs != null) {\n \t\t\t\tfor (Ref ref : refs.values()) {\n \t\t\t\t\tObjectId objectId = ref.getObjectId();\n \n \t\t\t\t\t// If the object was already requested, skip it.\n \t\t\t\t\tif (wantAll.isEmpty()) {\n \t\t\t\t\t\tif (wantIds.contains(objectId))\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t} else {\n \t\t\t\t\t\tRevObject obj = rw.lookupOrNull(objectId);\n \t\t\t\t\t\tif (obj != null && obj.has(WANT))\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t}\n \n \t\t\t\t\tif (!ref.isPeeled())\n \t\t\t\t\t\tref = db.peel(ref);\n \n \t\t\t\t\tObjectId peeledId = ref.getPeeledObjectId();\n \t\t\t\t\tif (peeledId == null)\n \t\t\t\t\t\tcontinue;\n \n \t\t\t\t\tobjectId = ref.getObjectId();\n \t\t\t\t\tif (pw.willInclude(peeledId) && !pw.willInclude(objectId))\n \t\t\t\t\t\tpw.addObject(rw.parseAny(objectId));\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tpw.writePack(pm, NullProgressMonitor.INSTANCE, packOut);\n \n \t\t\tif (msgOut != NullOutputStream.INSTANCE) {\n \t\t\t\tString msg = pw.getStatistics().getMessage() + '\\n';\n \t\t\t\tmsgOut.write(Constants.encode(msg));\n \t\t\t\tmsgOut.flush();\n \t\t\t}\n \n \t\t} finally {\n \t\t\tstatistics = pw.getStatistics();\n \t\t\tif (statistics != null) {\n \t\t\t\tpostUploadHook.onPostUpload(statistics);\n \t\t\t\tlogger.onPackStatistics(new PackWriter.Statistics(statistics));\n \t\t\t}\n \t\t\tpw.close();\n \t\t}\n \n \t\tif (sideband)\n \t\t\tpckOut.end();\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"b16e207742beb6a82b2b74df7bb87893a38bdd04": {
			"type": "Ybodychange",
			"commitMessage": "Shallow fetch: Pass along \"shallow\"s in unparsed-wants case, too\n\nSince 84d2738ff21c (Don't skip want validation when the client sends no\nhaves, 2013-06-21), this branch is not taken.  Process the\n\"shallow\"s anyway as a defensive measure in case the code path gets\nrevived.\n\nChange-Id: Idfb834825d77f51e17191c1635c9d78c78738cfd\nSigned-off-by: Jonathan Nieder <jrn@google.com>\n",
			"commitDate": "2016-08-08, 2:49 PM",
			"commitName": "b16e207742beb6a82b2b74df7bb87893a38bdd04",
			"commitAuthor": "Jonathan Nieder",
			"commitDateOld": "2016-08-08, 2:48 PM",
			"commitNameOld": "f84370feaaf319b7fe9bd272a7ceba235cc1e86a",
			"commitAuthorOld": "Jonathan Nieder",
			"daysBetweenCommits": 0,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,129 +1,129 @@\n \tprivate void sendPack(final boolean sideband) throws IOException {\n \t\tProgressMonitor pm = NullProgressMonitor.INSTANCE;\n \t\tOutputStream packOut = rawOut;\n \n \t\tif (sideband) {\n \t\t\tint bufsz = SideBandOutputStream.SMALL_BUF;\n \t\t\tif (options.contains(OPTION_SIDE_BAND_64K))\n \t\t\t\tbufsz = SideBandOutputStream.MAX_BUF;\n \n \t\t\tpackOut = new SideBandOutputStream(SideBandOutputStream.CH_DATA,\n \t\t\t\t\tbufsz, rawOut);\n \t\t\tif (!options.contains(OPTION_NO_PROGRESS)) {\n \t\t\t\tmsgOut = new SideBandOutputStream(\n \t\t\t\t\t\tSideBandOutputStream.CH_PROGRESS, bufsz, rawOut);\n \t\t\t\tpm = new SideBandProgressMonitor(msgOut);\n \t\t\t}\n \t\t}\n \n \t\ttry {\n \t\t\tif (wantAll.isEmpty()) {\n \t\t\t\tpreUploadHook.onSendPack(this, wantIds, commonBase);\n \t\t\t} else {\n \t\t\t\tpreUploadHook.onSendPack(this, wantAll, commonBase);\n \t\t\t}\n \t\t\tmsgOut.flush();\n \t\t} catch (ServiceMayNotContinueException noPack) {\n \t\t\tif (sideband && noPack.getMessage() != null) {\n \t\t\t\tnoPack.setOutput();\n \t\t\t\t@SuppressWarnings(\"resource\" /* java 7 */)\n \t\t\t\tSideBandOutputStream err = new SideBandOutputStream(\n \t\t\t\t\t\tSideBandOutputStream.CH_ERROR,\n \t\t\t\t\t\tSideBandOutputStream.SMALL_BUF, rawOut);\n \t\t\t\terr.write(Constants.encode(noPack.getMessage()));\n \t\t\t\terr.flush();\n \t\t\t}\n \t\t\tthrow noPack;\n \t\t}\n \n \t\tPackConfig cfg = packConfig;\n \t\tif (cfg == null)\n \t\t\tcfg = new PackConfig(db);\n \t\tfinal PackWriter pw = new PackWriter(cfg, walk.getObjectReader());\n \t\ttry {\n \t\t\tpw.setIndexDisabled(true);\n \t\t\tpw.setUseCachedPacks(true);\n \t\t\tpw.setUseBitmaps(depth == 0 && clientShallowCommits.isEmpty());\n \t\t\tpw.setClientShallowCommits(clientShallowCommits);\n \t\t\tpw.setReuseDeltaCommits(true);\n \t\t\tpw.setDeltaBaseAsOffset(options.contains(OPTION_OFS_DELTA));\n \t\t\tpw.setThin(options.contains(OPTION_THIN_PACK));\n \t\t\tpw.setReuseValidatingObjects(false);\n \n \t\t\tif (commonBase.isEmpty() && refs != null) {\n \t\t\t\tSet<ObjectId> tagTargets = new HashSet<ObjectId>();\n \t\t\t\tfor (Ref ref : refs.values()) {\n \t\t\t\t\tif (ref.getPeeledObjectId() != null)\n \t\t\t\t\t\ttagTargets.add(ref.getPeeledObjectId());\n \t\t\t\t\telse if (ref.getObjectId() == null)\n \t\t\t\t\t\tcontinue;\n \t\t\t\t\telse if (ref.getName().startsWith(Constants.R_HEADS))\n \t\t\t\t\t\ttagTargets.add(ref.getObjectId());\n \t\t\t\t}\n \t\t\t\tpw.setTagTargets(tagTargets);\n \t\t\t}\n \n \t\t\tRevWalk rw = walk;\n \t\t\tif (depth > 0) {\n \t\t\t\tpw.setShallowPack(depth, unshallowCommits);\n \t\t\t\trw = new DepthWalk.RevWalk(walk.getObjectReader(), depth);\n \t\t\t\trw.assumeShallow(clientShallowCommits);\n \t\t\t}\n \n \t\t\tif (wantAll.isEmpty()) {\n-\t\t\t\tpw.preparePack(pm, wantIds, commonBase);\n+\t\t\t\tpw.preparePack(pm, wantIds, commonBase, clientShallowCommits);\n \t\t\t} else {\n \t\t\t\twalk.reset();\n \n \t\t\t\tObjectWalk ow = rw.toObjectWalkWithSameObjects();\n \t\t\t\tpw.preparePack(pm, ow, wantAll, commonBase);\n \t\t\t\trw = ow;\n \t\t\t}\n \n \t\t\tif (options.contains(OPTION_INCLUDE_TAG) && refs != null) {\n \t\t\t\tfor (Ref ref : refs.values()) {\n \t\t\t\t\tObjectId objectId = ref.getObjectId();\n \n \t\t\t\t\t// If the object was already requested, skip it.\n \t\t\t\t\tif (wantAll.isEmpty()) {\n \t\t\t\t\t\tif (wantIds.contains(objectId))\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t} else {\n \t\t\t\t\t\tRevObject obj = rw.lookupOrNull(objectId);\n \t\t\t\t\t\tif (obj != null && obj.has(WANT))\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t}\n \n \t\t\t\t\tif (!ref.isPeeled())\n \t\t\t\t\t\tref = db.peel(ref);\n \n \t\t\t\t\tObjectId peeledId = ref.getPeeledObjectId();\n \t\t\t\t\tif (peeledId == null)\n \t\t\t\t\t\tcontinue;\n \n \t\t\t\t\tobjectId = ref.getObjectId();\n \t\t\t\t\tif (pw.willInclude(peeledId) && !pw.willInclude(objectId))\n \t\t\t\t\t\tpw.addObject(rw.parseAny(objectId));\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tpw.writePack(pm, NullProgressMonitor.INSTANCE, packOut);\n \n \t\t\tif (msgOut != NullOutputStream.INSTANCE) {\n \t\t\t\tString msg = pw.getStatistics().getMessage() + '\\n';\n \t\t\t\tmsgOut.write(Constants.encode(msg));\n \t\t\t\tmsgOut.flush();\n \t\t\t}\n \n \t\t} finally {\n \t\t\tstatistics = pw.getStatistics();\n \t\t\tif (statistics != null) {\n \t\t\t\tpostUploadHook.onPostUpload(statistics);\n \t\t\t\tlogger.onPackStatistics(new PackWriter.Statistics(statistics));\n \t\t\t}\n \t\t\tpw.close();\n \t\t}\n \n \t\tif (sideband)\n \t\t\tpckOut.end();\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"f84370feaaf319b7fe9bd272a7ceba235cc1e86a": {
			"type": "Ybodychange",
			"commitMessage": "Shallow fetch: Pass a DepthWalk to PackWriter\n\nd385a7a5e5ca (Shallow fetch: Respect \"shallow\" lines, 2016-08-03) forgot\nthat UploadPack wasn't passing a DepthWalk to PackWriter in the first\nplace.  As a result, shallow clones fail:\n\n  java.lang.IllegalArgumentException: Shallow packs require a DepthWalk\n        at org.eclipse.jgit.internal.storage.pack.PackWriter.preparePack(PackWriter.java:756)\n        at org.eclipse.jgit.transport.UploadPack.sendPack(UploadPack.java:1497)\n        at org.eclipse.jgit.transport.UploadPack.sendPack(UploadPack.java:1381)\n        at org.eclipse.jgit.transport.UploadPack.service(UploadPack.java:774)\n        at org.eclipse.jgit.transport.UploadPack.upload(UploadPack.java:667)\n        at org.eclipse.jgit.http.server.UploadPackServlet.doPost(UploadPackServlet.java:191)\n\nChange-Id: Ib0d8c2946eebfea910a2b767fb92e23da15d4749\n",
			"commitDate": "2016-08-08, 2:48 PM",
			"commitName": "f84370feaaf319b7fe9bd272a7ceba235cc1e86a",
			"commitAuthor": "Jonathan Nieder",
			"commitDateOld": "2016-07-05, 10:18 AM",
			"commitNameOld": "5196798cb743aa9e9a0e7d92c64e9c930656acaa",
			"commitAuthorOld": "Shawn Pearce",
			"daysBetweenCommits": 34.19,
			"commitsBetweenForRepo": 42,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,126 +1,129 @@\n \tprivate void sendPack(final boolean sideband) throws IOException {\n \t\tProgressMonitor pm = NullProgressMonitor.INSTANCE;\n \t\tOutputStream packOut = rawOut;\n \n \t\tif (sideband) {\n \t\t\tint bufsz = SideBandOutputStream.SMALL_BUF;\n \t\t\tif (options.contains(OPTION_SIDE_BAND_64K))\n \t\t\t\tbufsz = SideBandOutputStream.MAX_BUF;\n \n \t\t\tpackOut = new SideBandOutputStream(SideBandOutputStream.CH_DATA,\n \t\t\t\t\tbufsz, rawOut);\n \t\t\tif (!options.contains(OPTION_NO_PROGRESS)) {\n \t\t\t\tmsgOut = new SideBandOutputStream(\n \t\t\t\t\t\tSideBandOutputStream.CH_PROGRESS, bufsz, rawOut);\n \t\t\t\tpm = new SideBandProgressMonitor(msgOut);\n \t\t\t}\n \t\t}\n \n \t\ttry {\n \t\t\tif (wantAll.isEmpty()) {\n \t\t\t\tpreUploadHook.onSendPack(this, wantIds, commonBase);\n \t\t\t} else {\n \t\t\t\tpreUploadHook.onSendPack(this, wantAll, commonBase);\n \t\t\t}\n \t\t\tmsgOut.flush();\n \t\t} catch (ServiceMayNotContinueException noPack) {\n \t\t\tif (sideband && noPack.getMessage() != null) {\n \t\t\t\tnoPack.setOutput();\n \t\t\t\t@SuppressWarnings(\"resource\" /* java 7 */)\n \t\t\t\tSideBandOutputStream err = new SideBandOutputStream(\n \t\t\t\t\t\tSideBandOutputStream.CH_ERROR,\n \t\t\t\t\t\tSideBandOutputStream.SMALL_BUF, rawOut);\n \t\t\t\terr.write(Constants.encode(noPack.getMessage()));\n \t\t\t\terr.flush();\n \t\t\t}\n \t\t\tthrow noPack;\n \t\t}\n \n \t\tPackConfig cfg = packConfig;\n \t\tif (cfg == null)\n \t\t\tcfg = new PackConfig(db);\n \t\tfinal PackWriter pw = new PackWriter(cfg, walk.getObjectReader());\n \t\ttry {\n \t\t\tpw.setIndexDisabled(true);\n \t\t\tpw.setUseCachedPacks(true);\n \t\t\tpw.setUseBitmaps(depth == 0 && clientShallowCommits.isEmpty());\n \t\t\tpw.setClientShallowCommits(clientShallowCommits);\n \t\t\tpw.setReuseDeltaCommits(true);\n \t\t\tpw.setDeltaBaseAsOffset(options.contains(OPTION_OFS_DELTA));\n \t\t\tpw.setThin(options.contains(OPTION_THIN_PACK));\n \t\t\tpw.setReuseValidatingObjects(false);\n \n \t\t\tif (commonBase.isEmpty() && refs != null) {\n \t\t\t\tSet<ObjectId> tagTargets = new HashSet<ObjectId>();\n \t\t\t\tfor (Ref ref : refs.values()) {\n \t\t\t\t\tif (ref.getPeeledObjectId() != null)\n \t\t\t\t\t\ttagTargets.add(ref.getPeeledObjectId());\n \t\t\t\t\telse if (ref.getObjectId() == null)\n \t\t\t\t\t\tcontinue;\n \t\t\t\t\telse if (ref.getName().startsWith(Constants.R_HEADS))\n \t\t\t\t\t\ttagTargets.add(ref.getObjectId());\n \t\t\t\t}\n \t\t\t\tpw.setTagTargets(tagTargets);\n \t\t\t}\n \n-\t\t\tif (depth > 0)\n-\t\t\t\tpw.setShallowPack(depth, unshallowCommits);\n-\n \t\t\tRevWalk rw = walk;\n+\t\t\tif (depth > 0) {\n+\t\t\t\tpw.setShallowPack(depth, unshallowCommits);\n+\t\t\t\trw = new DepthWalk.RevWalk(walk.getObjectReader(), depth);\n+\t\t\t\trw.assumeShallow(clientShallowCommits);\n+\t\t\t}\n+\n \t\t\tif (wantAll.isEmpty()) {\n \t\t\t\tpw.preparePack(pm, wantIds, commonBase);\n \t\t\t} else {\n \t\t\t\twalk.reset();\n \n-\t\t\t\tObjectWalk ow = walk.toObjectWalkWithSameObjects();\n+\t\t\t\tObjectWalk ow = rw.toObjectWalkWithSameObjects();\n \t\t\t\tpw.preparePack(pm, ow, wantAll, commonBase);\n \t\t\t\trw = ow;\n \t\t\t}\n \n \t\t\tif (options.contains(OPTION_INCLUDE_TAG) && refs != null) {\n \t\t\t\tfor (Ref ref : refs.values()) {\n \t\t\t\t\tObjectId objectId = ref.getObjectId();\n \n \t\t\t\t\t// If the object was already requested, skip it.\n \t\t\t\t\tif (wantAll.isEmpty()) {\n \t\t\t\t\t\tif (wantIds.contains(objectId))\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t} else {\n \t\t\t\t\t\tRevObject obj = rw.lookupOrNull(objectId);\n \t\t\t\t\t\tif (obj != null && obj.has(WANT))\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t}\n \n \t\t\t\t\tif (!ref.isPeeled())\n \t\t\t\t\t\tref = db.peel(ref);\n \n \t\t\t\t\tObjectId peeledId = ref.getPeeledObjectId();\n \t\t\t\t\tif (peeledId == null)\n \t\t\t\t\t\tcontinue;\n \n \t\t\t\t\tobjectId = ref.getObjectId();\n \t\t\t\t\tif (pw.willInclude(peeledId) && !pw.willInclude(objectId))\n \t\t\t\t\t\tpw.addObject(rw.parseAny(objectId));\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tpw.writePack(pm, NullProgressMonitor.INSTANCE, packOut);\n \n \t\t\tif (msgOut != NullOutputStream.INSTANCE) {\n \t\t\t\tString msg = pw.getStatistics().getMessage() + '\\n';\n \t\t\t\tmsgOut.write(Constants.encode(msg));\n \t\t\t\tmsgOut.flush();\n \t\t\t}\n \n \t\t} finally {\n \t\t\tstatistics = pw.getStatistics();\n \t\t\tif (statistics != null) {\n \t\t\t\tpostUploadHook.onPostUpload(statistics);\n \t\t\t\tlogger.onPackStatistics(new PackWriter.Statistics(statistics));\n \t\t\t}\n \t\t\tpw.close();\n \t\t}\n \n \t\tif (sideband)\n \t\t\tpckOut.end();\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"1fa6f3a7509dc937551006e11dfd3bdaea921cd0": {
			"type": "Ybodychange",
			"commitMessage": "Revert \"Remove PackWriter.Statistics and other deprecated classes\"\n\nThis reverts commit bbcbcab8d39dd4bdf194cdba02c97a9eb70b2379.\nThese classes were part of the public API and should not be removed\nuntil JGit 5.0.\n\nChange-Id: Ife4bee69f82151de6ef8ea1a4c6c146d91bbf0d5\n",
			"commitDate": "2015-11-10, 6:14 PM",
			"commitName": "1fa6f3a7509dc937551006e11dfd3bdaea921cd0",
			"commitAuthor": "Jonathan Nieder",
			"commitDateOld": "2015-11-09, 7:55 PM",
			"commitNameOld": "bbcbcab8d39dd4bdf194cdba02c97a9eb70b2379",
			"commitAuthorOld": "Terry Parker",
			"daysBetweenCommits": 0.93,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,125 +1,126 @@\n \tprivate void sendPack(final boolean sideband) throws IOException {\n \t\tProgressMonitor pm = NullProgressMonitor.INSTANCE;\n \t\tOutputStream packOut = rawOut;\n \n \t\tif (sideband) {\n \t\t\tint bufsz = SideBandOutputStream.SMALL_BUF;\n \t\t\tif (options.contains(OPTION_SIDE_BAND_64K))\n \t\t\t\tbufsz = SideBandOutputStream.MAX_BUF;\n \n \t\t\tpackOut = new SideBandOutputStream(SideBandOutputStream.CH_DATA,\n \t\t\t\t\tbufsz, rawOut);\n \t\t\tif (!options.contains(OPTION_NO_PROGRESS)) {\n \t\t\t\tmsgOut = new SideBandOutputStream(\n \t\t\t\t\t\tSideBandOutputStream.CH_PROGRESS, bufsz, rawOut);\n \t\t\t\tpm = new SideBandProgressMonitor(msgOut);\n \t\t\t}\n \t\t}\n \n \t\ttry {\n \t\t\tif (wantAll.isEmpty()) {\n \t\t\t\tpreUploadHook.onSendPack(this, wantIds, commonBase);\n \t\t\t} else {\n \t\t\t\tpreUploadHook.onSendPack(this, wantAll, commonBase);\n \t\t\t}\n \t\t\tmsgOut.flush();\n \t\t} catch (ServiceMayNotContinueException noPack) {\n \t\t\tif (sideband && noPack.getMessage() != null) {\n \t\t\t\tnoPack.setOutput();\n \t\t\t\t@SuppressWarnings(\"resource\" /* java 7 */)\n \t\t\t\tSideBandOutputStream err = new SideBandOutputStream(\n \t\t\t\t\t\tSideBandOutputStream.CH_ERROR,\n \t\t\t\t\t\tSideBandOutputStream.SMALL_BUF, rawOut);\n \t\t\t\terr.write(Constants.encode(noPack.getMessage()));\n \t\t\t\terr.flush();\n \t\t\t}\n \t\t\tthrow noPack;\n \t\t}\n \n \t\tPackConfig cfg = packConfig;\n \t\tif (cfg == null)\n \t\t\tcfg = new PackConfig(db);\n \t\tfinal PackWriter pw = new PackWriter(cfg, walk.getObjectReader());\n \t\ttry {\n \t\t\tpw.setIndexDisabled(true);\n \t\t\tpw.setUseCachedPacks(true);\n \t\t\tpw.setUseBitmaps(depth == 0 && clientShallowCommits.isEmpty());\n \t\t\tpw.setClientShallowCommits(clientShallowCommits);\n \t\t\tpw.setReuseDeltaCommits(true);\n \t\t\tpw.setDeltaBaseAsOffset(options.contains(OPTION_OFS_DELTA));\n \t\t\tpw.setThin(options.contains(OPTION_THIN_PACK));\n \t\t\tpw.setReuseValidatingObjects(false);\n \n \t\t\tif (commonBase.isEmpty() && refs != null) {\n \t\t\t\tSet<ObjectId> tagTargets = new HashSet<ObjectId>();\n \t\t\t\tfor (Ref ref : refs.values()) {\n \t\t\t\t\tif (ref.getPeeledObjectId() != null)\n \t\t\t\t\t\ttagTargets.add(ref.getPeeledObjectId());\n \t\t\t\t\telse if (ref.getObjectId() == null)\n \t\t\t\t\t\tcontinue;\n \t\t\t\t\telse if (ref.getName().startsWith(Constants.R_HEADS))\n \t\t\t\t\t\ttagTargets.add(ref.getObjectId());\n \t\t\t\t}\n \t\t\t\tpw.setTagTargets(tagTargets);\n \t\t\t}\n \n \t\t\tif (depth > 0)\n \t\t\t\tpw.setShallowPack(depth, unshallowCommits);\n \n \t\t\tRevWalk rw = walk;\n \t\t\tif (wantAll.isEmpty()) {\n \t\t\t\tpw.preparePack(pm, wantIds, commonBase);\n \t\t\t} else {\n \t\t\t\twalk.reset();\n \n \t\t\t\tObjectWalk ow = walk.toObjectWalkWithSameObjects();\n \t\t\t\tpw.preparePack(pm, ow, wantAll, commonBase);\n \t\t\t\trw = ow;\n \t\t\t}\n \n \t\t\tif (options.contains(OPTION_INCLUDE_TAG) && refs != null) {\n \t\t\t\tfor (Ref ref : refs.values()) {\n \t\t\t\t\tObjectId objectId = ref.getObjectId();\n \n \t\t\t\t\t// If the object was already requested, skip it.\n \t\t\t\t\tif (wantAll.isEmpty()) {\n \t\t\t\t\t\tif (wantIds.contains(objectId))\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t} else {\n \t\t\t\t\t\tRevObject obj = rw.lookupOrNull(objectId);\n \t\t\t\t\t\tif (obj != null && obj.has(WANT))\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t}\n \n \t\t\t\t\tif (!ref.isPeeled())\n \t\t\t\t\t\tref = db.peel(ref);\n \n \t\t\t\t\tObjectId peeledId = ref.getPeeledObjectId();\n \t\t\t\t\tif (peeledId == null)\n \t\t\t\t\t\tcontinue;\n \n \t\t\t\t\tobjectId = ref.getObjectId();\n \t\t\t\t\tif (pw.willInclude(peeledId) && !pw.willInclude(objectId))\n \t\t\t\t\t\tpw.addObject(rw.parseAny(objectId));\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tpw.writePack(pm, NullProgressMonitor.INSTANCE, packOut);\n \n \t\t\tif (msgOut != NullOutputStream.INSTANCE) {\n \t\t\t\tString msg = pw.getStatistics().getMessage() + '\\n';\n \t\t\t\tmsgOut.write(Constants.encode(msg));\n \t\t\t\tmsgOut.flush();\n \t\t\t}\n \n \t\t} finally {\n \t\t\tstatistics = pw.getStatistics();\n \t\t\tif (statistics != null) {\n \t\t\t\tpostUploadHook.onPostUpload(statistics);\n+\t\t\t\tlogger.onPackStatistics(new PackWriter.Statistics(statistics));\n \t\t\t}\n \t\t\tpw.close();\n \t\t}\n \n \t\tif (sideband)\n \t\t\tpckOut.end();\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"bbcbcab8d39dd4bdf194cdba02c97a9eb70b2379": {
			"type": "Ybodychange",
			"commitMessage": "Remove PackWriter.Statistics and other deprecated classes\n\nThese classes make improper use of internal classes in the public API\nand were replaced by corresponding classes in the JGit 4.1 release.\n\nChange-Id: I3d474210e49089aa788314b4e08f505f0d26619b\nSigned-off-by: Terry Parker <tparker@google.com>\n",
			"commitDate": "2015-11-09, 7:55 PM",
			"commitName": "bbcbcab8d39dd4bdf194cdba02c97a9eb70b2379",
			"commitAuthor": "Terry Parker",
			"commitDateOld": "2015-09-14, 1:53 PM",
			"commitNameOld": "b46c4463959f45b32e471e4c10b5ddc71232949e",
			"commitAuthorOld": "Shawn Pearce",
			"daysBetweenCommits": 56.29,
			"commitsBetweenForRepo": 84,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,126 +1,125 @@\n \tprivate void sendPack(final boolean sideband) throws IOException {\n \t\tProgressMonitor pm = NullProgressMonitor.INSTANCE;\n \t\tOutputStream packOut = rawOut;\n \n \t\tif (sideband) {\n \t\t\tint bufsz = SideBandOutputStream.SMALL_BUF;\n \t\t\tif (options.contains(OPTION_SIDE_BAND_64K))\n \t\t\t\tbufsz = SideBandOutputStream.MAX_BUF;\n \n \t\t\tpackOut = new SideBandOutputStream(SideBandOutputStream.CH_DATA,\n \t\t\t\t\tbufsz, rawOut);\n \t\t\tif (!options.contains(OPTION_NO_PROGRESS)) {\n \t\t\t\tmsgOut = new SideBandOutputStream(\n \t\t\t\t\t\tSideBandOutputStream.CH_PROGRESS, bufsz, rawOut);\n \t\t\t\tpm = new SideBandProgressMonitor(msgOut);\n \t\t\t}\n \t\t}\n \n \t\ttry {\n \t\t\tif (wantAll.isEmpty()) {\n \t\t\t\tpreUploadHook.onSendPack(this, wantIds, commonBase);\n \t\t\t} else {\n \t\t\t\tpreUploadHook.onSendPack(this, wantAll, commonBase);\n \t\t\t}\n \t\t\tmsgOut.flush();\n \t\t} catch (ServiceMayNotContinueException noPack) {\n \t\t\tif (sideband && noPack.getMessage() != null) {\n \t\t\t\tnoPack.setOutput();\n \t\t\t\t@SuppressWarnings(\"resource\" /* java 7 */)\n \t\t\t\tSideBandOutputStream err = new SideBandOutputStream(\n \t\t\t\t\t\tSideBandOutputStream.CH_ERROR,\n \t\t\t\t\t\tSideBandOutputStream.SMALL_BUF, rawOut);\n \t\t\t\terr.write(Constants.encode(noPack.getMessage()));\n \t\t\t\terr.flush();\n \t\t\t}\n \t\t\tthrow noPack;\n \t\t}\n \n \t\tPackConfig cfg = packConfig;\n \t\tif (cfg == null)\n \t\t\tcfg = new PackConfig(db);\n \t\tfinal PackWriter pw = new PackWriter(cfg, walk.getObjectReader());\n \t\ttry {\n \t\t\tpw.setIndexDisabled(true);\n \t\t\tpw.setUseCachedPacks(true);\n \t\t\tpw.setUseBitmaps(depth == 0 && clientShallowCommits.isEmpty());\n \t\t\tpw.setClientShallowCommits(clientShallowCommits);\n \t\t\tpw.setReuseDeltaCommits(true);\n \t\t\tpw.setDeltaBaseAsOffset(options.contains(OPTION_OFS_DELTA));\n \t\t\tpw.setThin(options.contains(OPTION_THIN_PACK));\n \t\t\tpw.setReuseValidatingObjects(false);\n \n \t\t\tif (commonBase.isEmpty() && refs != null) {\n \t\t\t\tSet<ObjectId> tagTargets = new HashSet<ObjectId>();\n \t\t\t\tfor (Ref ref : refs.values()) {\n \t\t\t\t\tif (ref.getPeeledObjectId() != null)\n \t\t\t\t\t\ttagTargets.add(ref.getPeeledObjectId());\n \t\t\t\t\telse if (ref.getObjectId() == null)\n \t\t\t\t\t\tcontinue;\n \t\t\t\t\telse if (ref.getName().startsWith(Constants.R_HEADS))\n \t\t\t\t\t\ttagTargets.add(ref.getObjectId());\n \t\t\t\t}\n \t\t\t\tpw.setTagTargets(tagTargets);\n \t\t\t}\n \n \t\t\tif (depth > 0)\n \t\t\t\tpw.setShallowPack(depth, unshallowCommits);\n \n \t\t\tRevWalk rw = walk;\n \t\t\tif (wantAll.isEmpty()) {\n \t\t\t\tpw.preparePack(pm, wantIds, commonBase);\n \t\t\t} else {\n \t\t\t\twalk.reset();\n \n \t\t\t\tObjectWalk ow = walk.toObjectWalkWithSameObjects();\n \t\t\t\tpw.preparePack(pm, ow, wantAll, commonBase);\n \t\t\t\trw = ow;\n \t\t\t}\n \n \t\t\tif (options.contains(OPTION_INCLUDE_TAG) && refs != null) {\n \t\t\t\tfor (Ref ref : refs.values()) {\n \t\t\t\t\tObjectId objectId = ref.getObjectId();\n \n \t\t\t\t\t// If the object was already requested, skip it.\n \t\t\t\t\tif (wantAll.isEmpty()) {\n \t\t\t\t\t\tif (wantIds.contains(objectId))\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t} else {\n \t\t\t\t\t\tRevObject obj = rw.lookupOrNull(objectId);\n \t\t\t\t\t\tif (obj != null && obj.has(WANT))\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t}\n \n \t\t\t\t\tif (!ref.isPeeled())\n \t\t\t\t\t\tref = db.peel(ref);\n \n \t\t\t\t\tObjectId peeledId = ref.getPeeledObjectId();\n \t\t\t\t\tif (peeledId == null)\n \t\t\t\t\t\tcontinue;\n \n \t\t\t\t\tobjectId = ref.getObjectId();\n \t\t\t\t\tif (pw.willInclude(peeledId) && !pw.willInclude(objectId))\n \t\t\t\t\t\tpw.addObject(rw.parseAny(objectId));\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tpw.writePack(pm, NullProgressMonitor.INSTANCE, packOut);\n \n \t\t\tif (msgOut != NullOutputStream.INSTANCE) {\n \t\t\t\tString msg = pw.getStatistics().getMessage() + '\\n';\n \t\t\t\tmsgOut.write(Constants.encode(msg));\n \t\t\t\tmsgOut.flush();\n \t\t\t}\n \n \t\t} finally {\n \t\t\tstatistics = pw.getStatistics();\n \t\t\tif (statistics != null) {\n \t\t\t\tpostUploadHook.onPostUpload(statistics);\n-\t\t\t\tlogger.onPackStatistics(new PackWriter.Statistics(statistics));\n \t\t\t}\n \t\t\tpw.close();\n \t\t}\n \n \t\tif (sideband)\n \t\t\tpckOut.end();\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"6a415915c2dab31f9e69b9a55dcb87c579649bf5": {
			"type": "Ybodychange",
			"commitMessage": "Add the set of shallow commits to PackStatistics\n\nChange-Id: I976102e054369b045340d4b9209984b5243e3750\nSigned-off-by: Terry Parker <tparker@google.com>\n",
			"commitDate": "2015-06-15, 3:49 PM",
			"commitName": "6a415915c2dab31f9e69b9a55dcb87c579649bf5",
			"commitAuthor": "Terry Parker",
			"commitDateOld": "2015-06-12, 2:56 PM",
			"commitNameOld": "d9bbb04c3ef28db1d2e492506a819b7ac5c5f9df",
			"commitAuthorOld": "Terry Parker",
			"daysBetweenCommits": 3.04,
			"commitsBetweenForRepo": 2,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,125 +1,126 @@\n \tprivate void sendPack(final boolean sideband) throws IOException {\n \t\tProgressMonitor pm = NullProgressMonitor.INSTANCE;\n \t\tOutputStream packOut = rawOut;\n \n \t\tif (sideband) {\n \t\t\tint bufsz = SideBandOutputStream.SMALL_BUF;\n \t\t\tif (options.contains(OPTION_SIDE_BAND_64K))\n \t\t\t\tbufsz = SideBandOutputStream.MAX_BUF;\n \n \t\t\tpackOut = new SideBandOutputStream(SideBandOutputStream.CH_DATA,\n \t\t\t\t\tbufsz, rawOut);\n \t\t\tif (!options.contains(OPTION_NO_PROGRESS)) {\n \t\t\t\tmsgOut = new SideBandOutputStream(\n \t\t\t\t\t\tSideBandOutputStream.CH_PROGRESS, bufsz, rawOut);\n \t\t\t\tpm = new SideBandProgressMonitor(msgOut);\n \t\t\t}\n \t\t}\n \n \t\ttry {\n \t\t\tif (wantAll.isEmpty()) {\n \t\t\t\tpreUploadHook.onSendPack(this, wantIds, commonBase);\n \t\t\t} else {\n \t\t\t\tpreUploadHook.onSendPack(this, wantAll, commonBase);\n \t\t\t}\n \t\t\tmsgOut.flush();\n \t\t} catch (ServiceMayNotContinueException noPack) {\n \t\t\tif (sideband && noPack.getMessage() != null) {\n \t\t\t\tnoPack.setOutput();\n \t\t\t\t@SuppressWarnings(\"resource\" /* java 7 */)\n \t\t\t\tSideBandOutputStream err = new SideBandOutputStream(\n \t\t\t\t\t\tSideBandOutputStream.CH_ERROR,\n \t\t\t\t\t\tSideBandOutputStream.SMALL_BUF, rawOut);\n \t\t\t\terr.write(Constants.encode(noPack.getMessage()));\n \t\t\t\terr.flush();\n \t\t\t}\n \t\t\tthrow noPack;\n \t\t}\n \n \t\tPackConfig cfg = packConfig;\n \t\tif (cfg == null)\n \t\t\tcfg = new PackConfig(db);\n \t\tfinal PackWriter pw = new PackWriter(cfg, walk.getObjectReader());\n \t\ttry {\n \t\t\tpw.setIndexDisabled(true);\n \t\t\tpw.setUseCachedPacks(true);\n \t\t\tpw.setUseBitmaps(depth == 0 && clientShallowCommits.isEmpty());\n+\t\t\tpw.setClientShallowCommits(clientShallowCommits);\n \t\t\tpw.setReuseDeltaCommits(true);\n \t\t\tpw.setDeltaBaseAsOffset(options.contains(OPTION_OFS_DELTA));\n \t\t\tpw.setThin(options.contains(OPTION_THIN_PACK));\n \t\t\tpw.setReuseValidatingObjects(false);\n \n \t\t\tif (commonBase.isEmpty() && refs != null) {\n \t\t\t\tSet<ObjectId> tagTargets = new HashSet<ObjectId>();\n \t\t\t\tfor (Ref ref : refs.values()) {\n \t\t\t\t\tif (ref.getPeeledObjectId() != null)\n \t\t\t\t\t\ttagTargets.add(ref.getPeeledObjectId());\n \t\t\t\t\telse if (ref.getObjectId() == null)\n \t\t\t\t\t\tcontinue;\n \t\t\t\t\telse if (ref.getName().startsWith(Constants.R_HEADS))\n \t\t\t\t\t\ttagTargets.add(ref.getObjectId());\n \t\t\t\t}\n \t\t\t\tpw.setTagTargets(tagTargets);\n \t\t\t}\n \n \t\t\tif (depth > 0)\n \t\t\t\tpw.setShallowPack(depth, unshallowCommits);\n \n \t\t\tRevWalk rw = walk;\n \t\t\tif (wantAll.isEmpty()) {\n \t\t\t\tpw.preparePack(pm, wantIds, commonBase);\n \t\t\t} else {\n \t\t\t\twalk.reset();\n \n \t\t\t\tObjectWalk ow = walk.toObjectWalkWithSameObjects();\n \t\t\t\tpw.preparePack(pm, ow, wantAll, commonBase);\n \t\t\t\trw = ow;\n \t\t\t}\n \n \t\t\tif (options.contains(OPTION_INCLUDE_TAG) && refs != null) {\n \t\t\t\tfor (Ref ref : refs.values()) {\n \t\t\t\t\tObjectId objectId = ref.getObjectId();\n \n \t\t\t\t\t// If the object was already requested, skip it.\n \t\t\t\t\tif (wantAll.isEmpty()) {\n \t\t\t\t\t\tif (wantIds.contains(objectId))\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t} else {\n \t\t\t\t\t\tRevObject obj = rw.lookupOrNull(objectId);\n \t\t\t\t\t\tif (obj != null && obj.has(WANT))\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t}\n \n \t\t\t\t\tif (!ref.isPeeled())\n \t\t\t\t\t\tref = db.peel(ref);\n \n \t\t\t\t\tObjectId peeledId = ref.getPeeledObjectId();\n \t\t\t\t\tif (peeledId == null)\n \t\t\t\t\t\tcontinue;\n \n \t\t\t\t\tobjectId = ref.getObjectId();\n \t\t\t\t\tif (pw.willInclude(peeledId) && !pw.willInclude(objectId))\n \t\t\t\t\t\tpw.addObject(rw.parseAny(objectId));\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tpw.writePack(pm, NullProgressMonitor.INSTANCE, packOut);\n \n \t\t\tif (msgOut != NullOutputStream.INSTANCE) {\n \t\t\t\tString msg = pw.getStatistics().getMessage() + '\\n';\n \t\t\t\tmsgOut.write(Constants.encode(msg));\n \t\t\t\tmsgOut.flush();\n \t\t\t}\n \n \t\t} finally {\n \t\t\tstatistics = pw.getStatistics();\n \t\t\tif (statistics != null) {\n \t\t\t\tpostUploadHook.onPostUpload(statistics);\n \t\t\t\tlogger.onPackStatistics(new PackWriter.Statistics(statistics));\n \t\t\t}\n \t\t\tpw.close();\n \t\t}\n \n \t\tif (sideband)\n \t\t\tpckOut.end();\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"d9bbb04c3ef28db1d2e492506a819b7ac5c5f9df": {
			"type": "Ybodychange",
			"commitMessage": "Introduce PostUploadHook to replace UploadPackLogger\n\nUploadPackLogger is incorrectly named--it can be used to trigger any\npost upload action, such as GC/compaction. This change introduces\nPostUploadHook/PostUploadHookChain to replace\nUploadPackLogger/UploadPackLoggerChain and deprecates the latter.\n\nIt also introduces PackStatistics as a replacement for\nPackWriter.Statistics, since the latter is not public API.\nIt changes PackWriter to use PackStatistics and reimplements\nPackWriter.Statistics to delegate to PackStatistics.\n\nChange-Id: Ic51df1613e471f568ffee25ae67e118425b38986\nSigned-off-by: Terry Parker <tparker@google.com>\n",
			"commitDate": "2015-06-12, 2:56 PM",
			"commitName": "d9bbb04c3ef28db1d2e492506a819b7ac5c5f9df",
			"commitAuthor": "Terry Parker",
			"commitDateOld": "2015-06-09, 10:43 AM",
			"commitNameOld": "96f210f4b7172a0d427061d2f9624872efbcad39",
			"commitAuthorOld": "Fredrik Medley",
			"daysBetweenCommits": 3.18,
			"commitsBetweenForRepo": 13,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,123 +1,125 @@\n \tprivate void sendPack(final boolean sideband) throws IOException {\n \t\tProgressMonitor pm = NullProgressMonitor.INSTANCE;\n \t\tOutputStream packOut = rawOut;\n \n \t\tif (sideband) {\n \t\t\tint bufsz = SideBandOutputStream.SMALL_BUF;\n \t\t\tif (options.contains(OPTION_SIDE_BAND_64K))\n \t\t\t\tbufsz = SideBandOutputStream.MAX_BUF;\n \n \t\t\tpackOut = new SideBandOutputStream(SideBandOutputStream.CH_DATA,\n \t\t\t\t\tbufsz, rawOut);\n \t\t\tif (!options.contains(OPTION_NO_PROGRESS)) {\n \t\t\t\tmsgOut = new SideBandOutputStream(\n \t\t\t\t\t\tSideBandOutputStream.CH_PROGRESS, bufsz, rawOut);\n \t\t\t\tpm = new SideBandProgressMonitor(msgOut);\n \t\t\t}\n \t\t}\n \n \t\ttry {\n \t\t\tif (wantAll.isEmpty()) {\n \t\t\t\tpreUploadHook.onSendPack(this, wantIds, commonBase);\n \t\t\t} else {\n \t\t\t\tpreUploadHook.onSendPack(this, wantAll, commonBase);\n \t\t\t}\n \t\t\tmsgOut.flush();\n \t\t} catch (ServiceMayNotContinueException noPack) {\n \t\t\tif (sideband && noPack.getMessage() != null) {\n \t\t\t\tnoPack.setOutput();\n \t\t\t\t@SuppressWarnings(\"resource\" /* java 7 */)\n \t\t\t\tSideBandOutputStream err = new SideBandOutputStream(\n \t\t\t\t\t\tSideBandOutputStream.CH_ERROR,\n \t\t\t\t\t\tSideBandOutputStream.SMALL_BUF, rawOut);\n \t\t\t\terr.write(Constants.encode(noPack.getMessage()));\n \t\t\t\terr.flush();\n \t\t\t}\n \t\t\tthrow noPack;\n \t\t}\n \n \t\tPackConfig cfg = packConfig;\n \t\tif (cfg == null)\n \t\t\tcfg = new PackConfig(db);\n \t\tfinal PackWriter pw = new PackWriter(cfg, walk.getObjectReader());\n \t\ttry {\n \t\t\tpw.setIndexDisabled(true);\n \t\t\tpw.setUseCachedPacks(true);\n \t\t\tpw.setUseBitmaps(depth == 0 && clientShallowCommits.isEmpty());\n \t\t\tpw.setReuseDeltaCommits(true);\n \t\t\tpw.setDeltaBaseAsOffset(options.contains(OPTION_OFS_DELTA));\n \t\t\tpw.setThin(options.contains(OPTION_THIN_PACK));\n \t\t\tpw.setReuseValidatingObjects(false);\n \n \t\t\tif (commonBase.isEmpty() && refs != null) {\n \t\t\t\tSet<ObjectId> tagTargets = new HashSet<ObjectId>();\n \t\t\t\tfor (Ref ref : refs.values()) {\n \t\t\t\t\tif (ref.getPeeledObjectId() != null)\n \t\t\t\t\t\ttagTargets.add(ref.getPeeledObjectId());\n \t\t\t\t\telse if (ref.getObjectId() == null)\n \t\t\t\t\t\tcontinue;\n \t\t\t\t\telse if (ref.getName().startsWith(Constants.R_HEADS))\n \t\t\t\t\t\ttagTargets.add(ref.getObjectId());\n \t\t\t\t}\n \t\t\t\tpw.setTagTargets(tagTargets);\n \t\t\t}\n \n \t\t\tif (depth > 0)\n \t\t\t\tpw.setShallowPack(depth, unshallowCommits);\n \n \t\t\tRevWalk rw = walk;\n \t\t\tif (wantAll.isEmpty()) {\n \t\t\t\tpw.preparePack(pm, wantIds, commonBase);\n \t\t\t} else {\n \t\t\t\twalk.reset();\n \n \t\t\t\tObjectWalk ow = walk.toObjectWalkWithSameObjects();\n \t\t\t\tpw.preparePack(pm, ow, wantAll, commonBase);\n \t\t\t\trw = ow;\n \t\t\t}\n \n \t\t\tif (options.contains(OPTION_INCLUDE_TAG) && refs != null) {\n \t\t\t\tfor (Ref ref : refs.values()) {\n \t\t\t\t\tObjectId objectId = ref.getObjectId();\n \n \t\t\t\t\t// If the object was already requested, skip it.\n \t\t\t\t\tif (wantAll.isEmpty()) {\n \t\t\t\t\t\tif (wantIds.contains(objectId))\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t} else {\n \t\t\t\t\t\tRevObject obj = rw.lookupOrNull(objectId);\n \t\t\t\t\t\tif (obj != null && obj.has(WANT))\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t}\n \n \t\t\t\t\tif (!ref.isPeeled())\n \t\t\t\t\t\tref = db.peel(ref);\n \n \t\t\t\t\tObjectId peeledId = ref.getPeeledObjectId();\n \t\t\t\t\tif (peeledId == null)\n \t\t\t\t\t\tcontinue;\n \n \t\t\t\t\tobjectId = ref.getObjectId();\n \t\t\t\t\tif (pw.willInclude(peeledId) && !pw.willInclude(objectId))\n \t\t\t\t\t\tpw.addObject(rw.parseAny(objectId));\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tpw.writePack(pm, NullProgressMonitor.INSTANCE, packOut);\n \n \t\t\tif (msgOut != NullOutputStream.INSTANCE) {\n \t\t\t\tString msg = pw.getStatistics().getMessage() + '\\n';\n \t\t\t\tmsgOut.write(Constants.encode(msg));\n \t\t\t\tmsgOut.flush();\n \t\t\t}\n \n \t\t} finally {\n \t\t\tstatistics = pw.getStatistics();\n-\t\t\tif (statistics != null)\n-\t\t\t\tlogger.onPackStatistics(statistics);\n+\t\t\tif (statistics != null) {\n+\t\t\t\tpostUploadHook.onPostUpload(statistics);\n+\t\t\t\tlogger.onPackStatistics(new PackWriter.Statistics(statistics));\n+\t\t\t}\n \t\t\tpw.close();\n \t\t}\n \n \t\tif (sideband)\n \t\t\tpckOut.end();\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"0e73d395061d1bfee365acaa2f79c392175d13bf": {
			"type": "Ybodychange",
			"commitMessage": "Use AutoClosable to close resources in bundle org.eclipse.jgit\n\n- use try-with-resource where possible\n- replace use of deprecated release() by close()\n\nChange-Id: I0f139c3535679087b7fa09649166bca514750b81\nSigned-off-by: Matthias Sohn <matthias.sohn@sap.com>",
			"commitDate": "2015-05-20, 4:01 PM",
			"commitName": "0e73d395061d1bfee365acaa2f79c392175d13bf",
			"commitAuthor": "Matthias Sohn",
			"commitDateOld": "2015-04-30, 3:40 PM",
			"commitNameOld": "4a984e20332a765a81cadeaa4875b228ebf290fb",
			"commitAuthorOld": "Shawn Pearce",
			"daysBetweenCommits": 20.01,
			"commitsBetweenForRepo": 31,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,123 +1,123 @@\n \tprivate void sendPack(final boolean sideband) throws IOException {\n \t\tProgressMonitor pm = NullProgressMonitor.INSTANCE;\n \t\tOutputStream packOut = rawOut;\n \n \t\tif (sideband) {\n \t\t\tint bufsz = SideBandOutputStream.SMALL_BUF;\n \t\t\tif (options.contains(OPTION_SIDE_BAND_64K))\n \t\t\t\tbufsz = SideBandOutputStream.MAX_BUF;\n \n \t\t\tpackOut = new SideBandOutputStream(SideBandOutputStream.CH_DATA,\n \t\t\t\t\tbufsz, rawOut);\n \t\t\tif (!options.contains(OPTION_NO_PROGRESS)) {\n \t\t\t\tmsgOut = new SideBandOutputStream(\n \t\t\t\t\t\tSideBandOutputStream.CH_PROGRESS, bufsz, rawOut);\n \t\t\t\tpm = new SideBandProgressMonitor(msgOut);\n \t\t\t}\n \t\t}\n \n \t\ttry {\n \t\t\tif (wantAll.isEmpty()) {\n \t\t\t\tpreUploadHook.onSendPack(this, wantIds, commonBase);\n \t\t\t} else {\n \t\t\t\tpreUploadHook.onSendPack(this, wantAll, commonBase);\n \t\t\t}\n \t\t\tmsgOut.flush();\n \t\t} catch (ServiceMayNotContinueException noPack) {\n \t\t\tif (sideband && noPack.getMessage() != null) {\n \t\t\t\tnoPack.setOutput();\n \t\t\t\t@SuppressWarnings(\"resource\" /* java 7 */)\n \t\t\t\tSideBandOutputStream err = new SideBandOutputStream(\n \t\t\t\t\t\tSideBandOutputStream.CH_ERROR,\n \t\t\t\t\t\tSideBandOutputStream.SMALL_BUF, rawOut);\n \t\t\t\terr.write(Constants.encode(noPack.getMessage()));\n \t\t\t\terr.flush();\n \t\t\t}\n \t\t\tthrow noPack;\n \t\t}\n \n \t\tPackConfig cfg = packConfig;\n \t\tif (cfg == null)\n \t\t\tcfg = new PackConfig(db);\n \t\tfinal PackWriter pw = new PackWriter(cfg, walk.getObjectReader());\n \t\ttry {\n \t\t\tpw.setIndexDisabled(true);\n \t\t\tpw.setUseCachedPacks(true);\n \t\t\tpw.setUseBitmaps(depth == 0 && clientShallowCommits.isEmpty());\n \t\t\tpw.setReuseDeltaCommits(true);\n \t\t\tpw.setDeltaBaseAsOffset(options.contains(OPTION_OFS_DELTA));\n \t\t\tpw.setThin(options.contains(OPTION_THIN_PACK));\n \t\t\tpw.setReuseValidatingObjects(false);\n \n \t\t\tif (commonBase.isEmpty() && refs != null) {\n \t\t\t\tSet<ObjectId> tagTargets = new HashSet<ObjectId>();\n \t\t\t\tfor (Ref ref : refs.values()) {\n \t\t\t\t\tif (ref.getPeeledObjectId() != null)\n \t\t\t\t\t\ttagTargets.add(ref.getPeeledObjectId());\n \t\t\t\t\telse if (ref.getObjectId() == null)\n \t\t\t\t\t\tcontinue;\n \t\t\t\t\telse if (ref.getName().startsWith(Constants.R_HEADS))\n \t\t\t\t\t\ttagTargets.add(ref.getObjectId());\n \t\t\t\t}\n \t\t\t\tpw.setTagTargets(tagTargets);\n \t\t\t}\n \n \t\t\tif (depth > 0)\n \t\t\t\tpw.setShallowPack(depth, unshallowCommits);\n \n \t\t\tRevWalk rw = walk;\n \t\t\tif (wantAll.isEmpty()) {\n \t\t\t\tpw.preparePack(pm, wantIds, commonBase);\n \t\t\t} else {\n \t\t\t\twalk.reset();\n \n \t\t\t\tObjectWalk ow = walk.toObjectWalkWithSameObjects();\n \t\t\t\tpw.preparePack(pm, ow, wantAll, commonBase);\n \t\t\t\trw = ow;\n \t\t\t}\n \n \t\t\tif (options.contains(OPTION_INCLUDE_TAG) && refs != null) {\n \t\t\t\tfor (Ref ref : refs.values()) {\n \t\t\t\t\tObjectId objectId = ref.getObjectId();\n \n \t\t\t\t\t// If the object was already requested, skip it.\n \t\t\t\t\tif (wantAll.isEmpty()) {\n \t\t\t\t\t\tif (wantIds.contains(objectId))\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t} else {\n \t\t\t\t\t\tRevObject obj = rw.lookupOrNull(objectId);\n \t\t\t\t\t\tif (obj != null && obj.has(WANT))\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t}\n \n \t\t\t\t\tif (!ref.isPeeled())\n \t\t\t\t\t\tref = db.peel(ref);\n \n \t\t\t\t\tObjectId peeledId = ref.getPeeledObjectId();\n \t\t\t\t\tif (peeledId == null)\n \t\t\t\t\t\tcontinue;\n \n \t\t\t\t\tobjectId = ref.getObjectId();\n \t\t\t\t\tif (pw.willInclude(peeledId) && !pw.willInclude(objectId))\n \t\t\t\t\t\tpw.addObject(rw.parseAny(objectId));\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tpw.writePack(pm, NullProgressMonitor.INSTANCE, packOut);\n \n \t\t\tif (msgOut != NullOutputStream.INSTANCE) {\n \t\t\t\tString msg = pw.getStatistics().getMessage() + '\\n';\n \t\t\t\tmsgOut.write(Constants.encode(msg));\n \t\t\t\tmsgOut.flush();\n \t\t\t}\n \n \t\t} finally {\n \t\t\tstatistics = pw.getStatistics();\n \t\t\tif (statistics != null)\n \t\t\t\tlogger.onPackStatistics(statistics);\n-\t\t\tpw.release();\n+\t\t\tpw.close();\n \t\t}\n \n \t\tif (sideband)\n \t\t\tpckOut.end();\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"7b7d033ee1fdd8e81ae2ad7dc9e1ae12cbd9ddfa": {
			"type": "Ybodychange",
			"commitMessage": "UploadPack: Always make PackWriter.Statistics available\n\nIf the packer fails, still obtain the stats and make them available\nto the logger and the caller. Failures can frequently happen when\na client disconnects in the middle of a pack stream. Server admins\nmay still want to examine the timing metrics from counting and\ncompressing phases.\n\nChange-Id: Iceae4f68b5473f4223d85c9edfb57837fc818eed\n",
			"commitDate": "2014-08-29, 1:56 PM",
			"commitName": "7b7d033ee1fdd8e81ae2ad7dc9e1ae12cbd9ddfa",
			"commitAuthor": "Shawn Pearce",
			"commitDateOld": "2014-01-28, 6:29 PM",
			"commitNameOld": "b0174a089ce886d02c8d7fb80d63f0e50329bec3",
			"commitAuthorOld": "Shawn Pearce",
			"daysBetweenCommits": 212.77,
			"commitsBetweenForRepo": 300,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,124 +1,123 @@\n \tprivate void sendPack(final boolean sideband) throws IOException {\n \t\tProgressMonitor pm = NullProgressMonitor.INSTANCE;\n \t\tOutputStream packOut = rawOut;\n \n \t\tif (sideband) {\n \t\t\tint bufsz = SideBandOutputStream.SMALL_BUF;\n \t\t\tif (options.contains(OPTION_SIDE_BAND_64K))\n \t\t\t\tbufsz = SideBandOutputStream.MAX_BUF;\n \n \t\t\tpackOut = new SideBandOutputStream(SideBandOutputStream.CH_DATA,\n \t\t\t\t\tbufsz, rawOut);\n \t\t\tif (!options.contains(OPTION_NO_PROGRESS)) {\n \t\t\t\tmsgOut = new SideBandOutputStream(\n \t\t\t\t\t\tSideBandOutputStream.CH_PROGRESS, bufsz, rawOut);\n \t\t\t\tpm = new SideBandProgressMonitor(msgOut);\n \t\t\t}\n \t\t}\n \n \t\ttry {\n \t\t\tif (wantAll.isEmpty()) {\n \t\t\t\tpreUploadHook.onSendPack(this, wantIds, commonBase);\n \t\t\t} else {\n \t\t\t\tpreUploadHook.onSendPack(this, wantAll, commonBase);\n \t\t\t}\n \t\t\tmsgOut.flush();\n \t\t} catch (ServiceMayNotContinueException noPack) {\n \t\t\tif (sideband && noPack.getMessage() != null) {\n \t\t\t\tnoPack.setOutput();\n \t\t\t\t@SuppressWarnings(\"resource\" /* java 7 */)\n \t\t\t\tSideBandOutputStream err = new SideBandOutputStream(\n \t\t\t\t\t\tSideBandOutputStream.CH_ERROR,\n \t\t\t\t\t\tSideBandOutputStream.SMALL_BUF, rawOut);\n \t\t\t\terr.write(Constants.encode(noPack.getMessage()));\n \t\t\t\terr.flush();\n \t\t\t}\n \t\t\tthrow noPack;\n \t\t}\n \n \t\tPackConfig cfg = packConfig;\n \t\tif (cfg == null)\n \t\t\tcfg = new PackConfig(db);\n \t\tfinal PackWriter pw = new PackWriter(cfg, walk.getObjectReader());\n \t\ttry {\n \t\t\tpw.setIndexDisabled(true);\n \t\t\tpw.setUseCachedPacks(true);\n \t\t\tpw.setUseBitmaps(depth == 0 && clientShallowCommits.isEmpty());\n \t\t\tpw.setReuseDeltaCommits(true);\n \t\t\tpw.setDeltaBaseAsOffset(options.contains(OPTION_OFS_DELTA));\n \t\t\tpw.setThin(options.contains(OPTION_THIN_PACK));\n \t\t\tpw.setReuseValidatingObjects(false);\n \n \t\t\tif (commonBase.isEmpty() && refs != null) {\n \t\t\t\tSet<ObjectId> tagTargets = new HashSet<ObjectId>();\n \t\t\t\tfor (Ref ref : refs.values()) {\n \t\t\t\t\tif (ref.getPeeledObjectId() != null)\n \t\t\t\t\t\ttagTargets.add(ref.getPeeledObjectId());\n \t\t\t\t\telse if (ref.getObjectId() == null)\n \t\t\t\t\t\tcontinue;\n \t\t\t\t\telse if (ref.getName().startsWith(Constants.R_HEADS))\n \t\t\t\t\t\ttagTargets.add(ref.getObjectId());\n \t\t\t\t}\n \t\t\t\tpw.setTagTargets(tagTargets);\n \t\t\t}\n \n \t\t\tif (depth > 0)\n \t\t\t\tpw.setShallowPack(depth, unshallowCommits);\n \n \t\t\tRevWalk rw = walk;\n \t\t\tif (wantAll.isEmpty()) {\n \t\t\t\tpw.preparePack(pm, wantIds, commonBase);\n \t\t\t} else {\n \t\t\t\twalk.reset();\n \n \t\t\t\tObjectWalk ow = walk.toObjectWalkWithSameObjects();\n \t\t\t\tpw.preparePack(pm, ow, wantAll, commonBase);\n \t\t\t\trw = ow;\n \t\t\t}\n \n \t\t\tif (options.contains(OPTION_INCLUDE_TAG) && refs != null) {\n \t\t\t\tfor (Ref ref : refs.values()) {\n \t\t\t\t\tObjectId objectId = ref.getObjectId();\n \n \t\t\t\t\t// If the object was already requested, skip it.\n \t\t\t\t\tif (wantAll.isEmpty()) {\n \t\t\t\t\t\tif (wantIds.contains(objectId))\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t} else {\n \t\t\t\t\t\tRevObject obj = rw.lookupOrNull(objectId);\n \t\t\t\t\t\tif (obj != null && obj.has(WANT))\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t}\n \n \t\t\t\t\tif (!ref.isPeeled())\n \t\t\t\t\t\tref = db.peel(ref);\n \n \t\t\t\t\tObjectId peeledId = ref.getPeeledObjectId();\n \t\t\t\t\tif (peeledId == null)\n \t\t\t\t\t\tcontinue;\n \n \t\t\t\t\tobjectId = ref.getObjectId();\n \t\t\t\t\tif (pw.willInclude(peeledId) && !pw.willInclude(objectId))\n \t\t\t\t\t\tpw.addObject(rw.parseAny(objectId));\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tpw.writePack(pm, NullProgressMonitor.INSTANCE, packOut);\n-\t\t\tstatistics = pw.getStatistics();\n \n \t\t\tif (msgOut != NullOutputStream.INSTANCE) {\n \t\t\t\tString msg = pw.getStatistics().getMessage() + '\\n';\n \t\t\t\tmsgOut.write(Constants.encode(msg));\n \t\t\t\tmsgOut.flush();\n \t\t\t}\n \n \t\t} finally {\n+\t\t\tstatistics = pw.getStatistics();\n+\t\t\tif (statistics != null)\n+\t\t\t\tlogger.onPackStatistics(statistics);\n \t\t\tpw.release();\n \t\t}\n \n \t\tif (sideband)\n \t\t\tpckOut.end();\n-\n-\t\tif (statistics != null)\n-\t\t\tlogger.onPackStatistics(statistics);\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"b0174a089ce886d02c8d7fb80d63f0e50329bec3": {
			"type": "Ybodychange",
			"commitMessage": "Fix serving fetch of existing shallow client\n\nIn certain cases a JGit server updating an existing shallow client\nselected a common ancestor that was behind the shallow edge of\nthe client. This allowed the server to assume the client had some\nobjects it did not have and allowed creation of pack deltas the\nclient could never inflate.\n\nAny commit the client has advertised as shallow must be treated\nby UploadPack server as though it has no parents. With no parents\nthe walker cannot visit graph history the client does not have,\nand PackWriter cannot consider delta base candidates the client\nis lacking.\n\nChange-Id: I4922b9354df9f490966a586fb693762e897345a2\n",
			"commitDate": "2014-01-28, 6:29 PM",
			"commitName": "b0174a089ce886d02c8d7fb80d63f0e50329bec3",
			"commitAuthor": "Shawn Pearce",
			"commitDateOld": "2013-11-01, 8:57 PM",
			"commitNameOld": "b0dbb78e7d2287a5391a75e399009bf2203c4f24",
			"commitAuthorOld": "Shawn Pearce",
			"daysBetweenCommits": 87.94,
			"commitsBetweenForRepo": 66,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,124 +1,124 @@\n \tprivate void sendPack(final boolean sideband) throws IOException {\n \t\tProgressMonitor pm = NullProgressMonitor.INSTANCE;\n \t\tOutputStream packOut = rawOut;\n \n \t\tif (sideband) {\n \t\t\tint bufsz = SideBandOutputStream.SMALL_BUF;\n \t\t\tif (options.contains(OPTION_SIDE_BAND_64K))\n \t\t\t\tbufsz = SideBandOutputStream.MAX_BUF;\n \n \t\t\tpackOut = new SideBandOutputStream(SideBandOutputStream.CH_DATA,\n \t\t\t\t\tbufsz, rawOut);\n \t\t\tif (!options.contains(OPTION_NO_PROGRESS)) {\n \t\t\t\tmsgOut = new SideBandOutputStream(\n \t\t\t\t\t\tSideBandOutputStream.CH_PROGRESS, bufsz, rawOut);\n \t\t\t\tpm = new SideBandProgressMonitor(msgOut);\n \t\t\t}\n \t\t}\n \n \t\ttry {\n \t\t\tif (wantAll.isEmpty()) {\n \t\t\t\tpreUploadHook.onSendPack(this, wantIds, commonBase);\n \t\t\t} else {\n \t\t\t\tpreUploadHook.onSendPack(this, wantAll, commonBase);\n \t\t\t}\n \t\t\tmsgOut.flush();\n \t\t} catch (ServiceMayNotContinueException noPack) {\n \t\t\tif (sideband && noPack.getMessage() != null) {\n \t\t\t\tnoPack.setOutput();\n \t\t\t\t@SuppressWarnings(\"resource\" /* java 7 */)\n \t\t\t\tSideBandOutputStream err = new SideBandOutputStream(\n \t\t\t\t\t\tSideBandOutputStream.CH_ERROR,\n \t\t\t\t\t\tSideBandOutputStream.SMALL_BUF, rawOut);\n \t\t\t\terr.write(Constants.encode(noPack.getMessage()));\n \t\t\t\terr.flush();\n \t\t\t}\n \t\t\tthrow noPack;\n \t\t}\n \n \t\tPackConfig cfg = packConfig;\n \t\tif (cfg == null)\n \t\t\tcfg = new PackConfig(db);\n \t\tfinal PackWriter pw = new PackWriter(cfg, walk.getObjectReader());\n \t\ttry {\n \t\t\tpw.setIndexDisabled(true);\n \t\t\tpw.setUseCachedPacks(true);\n-\t\t\tpw.setUseBitmaps(true);\n+\t\t\tpw.setUseBitmaps(depth == 0 && clientShallowCommits.isEmpty());\n \t\t\tpw.setReuseDeltaCommits(true);\n \t\t\tpw.setDeltaBaseAsOffset(options.contains(OPTION_OFS_DELTA));\n \t\t\tpw.setThin(options.contains(OPTION_THIN_PACK));\n \t\t\tpw.setReuseValidatingObjects(false);\n \n \t\t\tif (commonBase.isEmpty() && refs != null) {\n \t\t\t\tSet<ObjectId> tagTargets = new HashSet<ObjectId>();\n \t\t\t\tfor (Ref ref : refs.values()) {\n \t\t\t\t\tif (ref.getPeeledObjectId() != null)\n \t\t\t\t\t\ttagTargets.add(ref.getPeeledObjectId());\n \t\t\t\t\telse if (ref.getObjectId() == null)\n \t\t\t\t\t\tcontinue;\n \t\t\t\t\telse if (ref.getName().startsWith(Constants.R_HEADS))\n \t\t\t\t\t\ttagTargets.add(ref.getObjectId());\n \t\t\t\t}\n \t\t\t\tpw.setTagTargets(tagTargets);\n \t\t\t}\n \n \t\t\tif (depth > 0)\n \t\t\t\tpw.setShallowPack(depth, unshallowCommits);\n \n \t\t\tRevWalk rw = walk;\n \t\t\tif (wantAll.isEmpty()) {\n \t\t\t\tpw.preparePack(pm, wantIds, commonBase);\n \t\t\t} else {\n \t\t\t\twalk.reset();\n \n \t\t\t\tObjectWalk ow = walk.toObjectWalkWithSameObjects();\n \t\t\t\tpw.preparePack(pm, ow, wantAll, commonBase);\n \t\t\t\trw = ow;\n \t\t\t}\n \n \t\t\tif (options.contains(OPTION_INCLUDE_TAG) && refs != null) {\n \t\t\t\tfor (Ref ref : refs.values()) {\n \t\t\t\t\tObjectId objectId = ref.getObjectId();\n \n \t\t\t\t\t// If the object was already requested, skip it.\n \t\t\t\t\tif (wantAll.isEmpty()) {\n \t\t\t\t\t\tif (wantIds.contains(objectId))\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t} else {\n \t\t\t\t\t\tRevObject obj = rw.lookupOrNull(objectId);\n \t\t\t\t\t\tif (obj != null && obj.has(WANT))\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t}\n \n \t\t\t\t\tif (!ref.isPeeled())\n \t\t\t\t\t\tref = db.peel(ref);\n \n \t\t\t\t\tObjectId peeledId = ref.getPeeledObjectId();\n \t\t\t\t\tif (peeledId == null)\n \t\t\t\t\t\tcontinue;\n \n \t\t\t\t\tobjectId = ref.getObjectId();\n \t\t\t\t\tif (pw.willInclude(peeledId) && !pw.willInclude(objectId))\n \t\t\t\t\t\tpw.addObject(rw.parseAny(objectId));\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tpw.writePack(pm, NullProgressMonitor.INSTANCE, packOut);\n \t\t\tstatistics = pw.getStatistics();\n \n \t\t\tif (msgOut != NullOutputStream.INSTANCE) {\n \t\t\t\tString msg = pw.getStatistics().getMessage() + '\\n';\n \t\t\t\tmsgOut.write(Constants.encode(msg));\n \t\t\t\tmsgOut.flush();\n \t\t\t}\n \n \t\t} finally {\n \t\t\tpw.release();\n \t\t}\n \n \t\tif (sideband)\n \t\t\tpckOut.end();\n \n \t\tif (statistics != null)\n \t\t\tlogger.onPackStatistics(statistics);\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"557471da2eee6752ad4305a883843bcdc8d66536": {
			"type": "Ybodychange",
			"commitMessage": "Use NullOutputStream not DisabledOutputStream in UploadPack\n\nThe stream should not throw IllegalStateException if it is off.\nFlush the stream after the hook runs, in case any messages need\nto be sent ahead of the pack.\n\nChange-Id: I21c7a0258ab1308406d226293fa0e7da69b4f57b\n",
			"commitDate": "2013-05-23, 2:07 PM",
			"commitName": "557471da2eee6752ad4305a883843bcdc8d66536",
			"commitAuthor": "Shawn Pearce",
			"commitDateOld": "2013-05-22, 1:14 PM",
			"commitNameOld": "6e896ba66ba095b97a89a622d43f05ce9ad501e7",
			"commitAuthorOld": "Shawn Pearce",
			"daysBetweenCommits": 1.04,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,123 +1,124 @@\n \tprivate void sendPack(final boolean sideband) throws IOException {\n \t\tProgressMonitor pm = NullProgressMonitor.INSTANCE;\n \t\tOutputStream packOut = rawOut;\n \n \t\tif (sideband) {\n \t\t\tint bufsz = SideBandOutputStream.SMALL_BUF;\n \t\t\tif (options.contains(OPTION_SIDE_BAND_64K))\n \t\t\t\tbufsz = SideBandOutputStream.MAX_BUF;\n \n \t\t\tpackOut = new SideBandOutputStream(SideBandOutputStream.CH_DATA,\n \t\t\t\t\tbufsz, rawOut);\n \t\t\tif (!options.contains(OPTION_NO_PROGRESS)) {\n \t\t\t\tmsgOut = new SideBandOutputStream(\n \t\t\t\t\t\tSideBandOutputStream.CH_PROGRESS, bufsz, rawOut);\n \t\t\t\tpm = new SideBandProgressMonitor(msgOut);\n \t\t\t}\n \t\t}\n \n \t\ttry {\n \t\t\tif (wantAll.isEmpty()) {\n \t\t\t\tpreUploadHook.onSendPack(this, wantIds, commonBase);\n \t\t\t} else {\n \t\t\t\tpreUploadHook.onSendPack(this, wantAll, commonBase);\n \t\t\t}\n+\t\t\tmsgOut.flush();\n \t\t} catch (ServiceMayNotContinueException noPack) {\n \t\t\tif (sideband && noPack.getMessage() != null) {\n \t\t\t\tnoPack.setOutput();\n \t\t\t\t@SuppressWarnings(\"resource\" /* java 7 */)\n \t\t\t\tSideBandOutputStream err = new SideBandOutputStream(\n \t\t\t\t\t\tSideBandOutputStream.CH_ERROR,\n \t\t\t\t\t\tSideBandOutputStream.SMALL_BUF, rawOut);\n \t\t\t\terr.write(Constants.encode(noPack.getMessage()));\n \t\t\t\terr.flush();\n \t\t\t}\n \t\t\tthrow noPack;\n \t\t}\n \n \t\tPackConfig cfg = packConfig;\n \t\tif (cfg == null)\n \t\t\tcfg = new PackConfig(db);\n \t\tfinal PackWriter pw = new PackWriter(cfg, walk.getObjectReader());\n \t\ttry {\n \t\t\tpw.setIndexDisabled(true);\n \t\t\tpw.setUseCachedPacks(true);\n \t\t\tpw.setUseBitmaps(true);\n \t\t\tpw.setReuseDeltaCommits(true);\n \t\t\tpw.setDeltaBaseAsOffset(options.contains(OPTION_OFS_DELTA));\n \t\t\tpw.setThin(options.contains(OPTION_THIN_PACK));\n \t\t\tpw.setReuseValidatingObjects(false);\n \n \t\t\tif (commonBase.isEmpty() && refs != null) {\n \t\t\t\tSet<ObjectId> tagTargets = new HashSet<ObjectId>();\n \t\t\t\tfor (Ref ref : refs.values()) {\n \t\t\t\t\tif (ref.getPeeledObjectId() != null)\n \t\t\t\t\t\ttagTargets.add(ref.getPeeledObjectId());\n \t\t\t\t\telse if (ref.getObjectId() == null)\n \t\t\t\t\t\tcontinue;\n \t\t\t\t\telse if (ref.getName().startsWith(Constants.R_HEADS))\n \t\t\t\t\t\ttagTargets.add(ref.getObjectId());\n \t\t\t\t}\n \t\t\t\tpw.setTagTargets(tagTargets);\n \t\t\t}\n \n \t\t\tif (depth > 0)\n \t\t\t\tpw.setShallowPack(depth, unshallowCommits);\n \n \t\t\tRevWalk rw = walk;\n \t\t\tif (wantAll.isEmpty()) {\n \t\t\t\tpw.preparePack(pm, wantIds, commonBase);\n \t\t\t} else {\n \t\t\t\twalk.reset();\n \n \t\t\t\tObjectWalk ow = walk.toObjectWalkWithSameObjects();\n \t\t\t\tpw.preparePack(pm, ow, wantAll, commonBase);\n \t\t\t\trw = ow;\n \t\t\t}\n \n \t\t\tif (options.contains(OPTION_INCLUDE_TAG) && refs != null) {\n \t\t\t\tfor (Ref ref : refs.values()) {\n \t\t\t\t\tObjectId objectId = ref.getObjectId();\n \n \t\t\t\t\t// If the object was already requested, skip it.\n \t\t\t\t\tif (wantAll.isEmpty()) {\n \t\t\t\t\t\tif (wantIds.contains(objectId))\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t} else {\n \t\t\t\t\t\tRevObject obj = rw.lookupOrNull(objectId);\n \t\t\t\t\t\tif (obj != null && obj.has(WANT))\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t}\n \n \t\t\t\t\tif (!ref.isPeeled())\n \t\t\t\t\t\tref = db.peel(ref);\n \n \t\t\t\t\tObjectId peeledId = ref.getPeeledObjectId();\n \t\t\t\t\tif (peeledId == null)\n \t\t\t\t\t\tcontinue;\n \n \t\t\t\t\tobjectId = ref.getObjectId();\n \t\t\t\t\tif (pw.willInclude(peeledId) && !pw.willInclude(objectId))\n \t\t\t\t\t\tpw.addObject(rw.parseAny(objectId));\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tpw.writePack(pm, NullProgressMonitor.INSTANCE, packOut);\n \t\t\tstatistics = pw.getStatistics();\n \n-\t\t\tif (msgOut != DisabledOutputStream.INSTANCE) {\n+\t\t\tif (msgOut != NullOutputStream.INSTANCE) {\n \t\t\t\tString msg = pw.getStatistics().getMessage() + '\\n';\n \t\t\t\tmsgOut.write(Constants.encode(msg));\n \t\t\t\tmsgOut.flush();\n \t\t\t}\n \n \t\t} finally {\n \t\t\tpw.release();\n \t\t}\n \n \t\tif (sideband)\n \t\t\tpckOut.end();\n \n \t\tif (statistics != null)\n \t\t\tlogger.onPackStatistics(statistics);\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"6e896ba66ba095b97a89a622d43f05ce9ad501e7": {
			"type": "Ybodychange",
			"commitMessage": "Allow PreUploadHook.onSendPack to send messages to the client\n\nBefore transmitting to the client a hook may want to send along\na text message ahead of the pack, such as a \"message of the day\".\nEnable this usage by mirroring the message sending API from\nReceivePack on the UploadPack instance, using the side band.\n\nChange-Id: I31cd254a4ddb816641397a3e9c2c20212471c37f\n",
			"commitDate": "2013-05-22, 1:14 PM",
			"commitName": "6e896ba66ba095b97a89a622d43f05ce9ad501e7",
			"commitAuthor": "Shawn Pearce",
			"commitDateOld": "2013-04-10, 1:58 PM",
			"commitNameOld": "eb17495ca4ce95c63bacf81af16ab19ff042b65c",
			"commitAuthorOld": "Shawn Pearce",
			"daysBetweenCommits": 41.97,
			"commitsBetweenForRepo": 60,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,124 +1,123 @@\n \tprivate void sendPack(final boolean sideband) throws IOException {\n \t\tProgressMonitor pm = NullProgressMonitor.INSTANCE;\n \t\tOutputStream packOut = rawOut;\n-\t\tSideBandOutputStream msgOut = null;\n \n \t\tif (sideband) {\n \t\t\tint bufsz = SideBandOutputStream.SMALL_BUF;\n \t\t\tif (options.contains(OPTION_SIDE_BAND_64K))\n \t\t\t\tbufsz = SideBandOutputStream.MAX_BUF;\n \n \t\t\tpackOut = new SideBandOutputStream(SideBandOutputStream.CH_DATA,\n \t\t\t\t\tbufsz, rawOut);\n \t\t\tif (!options.contains(OPTION_NO_PROGRESS)) {\n \t\t\t\tmsgOut = new SideBandOutputStream(\n \t\t\t\t\t\tSideBandOutputStream.CH_PROGRESS, bufsz, rawOut);\n \t\t\t\tpm = new SideBandProgressMonitor(msgOut);\n \t\t\t}\n \t\t}\n \n \t\ttry {\n \t\t\tif (wantAll.isEmpty()) {\n \t\t\t\tpreUploadHook.onSendPack(this, wantIds, commonBase);\n \t\t\t} else {\n \t\t\t\tpreUploadHook.onSendPack(this, wantAll, commonBase);\n \t\t\t}\n \t\t} catch (ServiceMayNotContinueException noPack) {\n \t\t\tif (sideband && noPack.getMessage() != null) {\n \t\t\t\tnoPack.setOutput();\n \t\t\t\t@SuppressWarnings(\"resource\" /* java 7 */)\n \t\t\t\tSideBandOutputStream err = new SideBandOutputStream(\n \t\t\t\t\t\tSideBandOutputStream.CH_ERROR,\n \t\t\t\t\t\tSideBandOutputStream.SMALL_BUF, rawOut);\n \t\t\t\terr.write(Constants.encode(noPack.getMessage()));\n \t\t\t\terr.flush();\n \t\t\t}\n \t\t\tthrow noPack;\n \t\t}\n \n \t\tPackConfig cfg = packConfig;\n \t\tif (cfg == null)\n \t\t\tcfg = new PackConfig(db);\n \t\tfinal PackWriter pw = new PackWriter(cfg, walk.getObjectReader());\n \t\ttry {\n \t\t\tpw.setIndexDisabled(true);\n \t\t\tpw.setUseCachedPacks(true);\n \t\t\tpw.setUseBitmaps(true);\n \t\t\tpw.setReuseDeltaCommits(true);\n \t\t\tpw.setDeltaBaseAsOffset(options.contains(OPTION_OFS_DELTA));\n \t\t\tpw.setThin(options.contains(OPTION_THIN_PACK));\n \t\t\tpw.setReuseValidatingObjects(false);\n \n \t\t\tif (commonBase.isEmpty() && refs != null) {\n \t\t\t\tSet<ObjectId> tagTargets = new HashSet<ObjectId>();\n \t\t\t\tfor (Ref ref : refs.values()) {\n \t\t\t\t\tif (ref.getPeeledObjectId() != null)\n \t\t\t\t\t\ttagTargets.add(ref.getPeeledObjectId());\n \t\t\t\t\telse if (ref.getObjectId() == null)\n \t\t\t\t\t\tcontinue;\n \t\t\t\t\telse if (ref.getName().startsWith(Constants.R_HEADS))\n \t\t\t\t\t\ttagTargets.add(ref.getObjectId());\n \t\t\t\t}\n \t\t\t\tpw.setTagTargets(tagTargets);\n \t\t\t}\n \n \t\t\tif (depth > 0)\n \t\t\t\tpw.setShallowPack(depth, unshallowCommits);\n \n \t\t\tRevWalk rw = walk;\n \t\t\tif (wantAll.isEmpty()) {\n \t\t\t\tpw.preparePack(pm, wantIds, commonBase);\n \t\t\t} else {\n \t\t\t\twalk.reset();\n \n \t\t\t\tObjectWalk ow = walk.toObjectWalkWithSameObjects();\n \t\t\t\tpw.preparePack(pm, ow, wantAll, commonBase);\n \t\t\t\trw = ow;\n \t\t\t}\n \n \t\t\tif (options.contains(OPTION_INCLUDE_TAG) && refs != null) {\n \t\t\t\tfor (Ref ref : refs.values()) {\n \t\t\t\t\tObjectId objectId = ref.getObjectId();\n \n \t\t\t\t\t// If the object was already requested, skip it.\n \t\t\t\t\tif (wantAll.isEmpty()) {\n \t\t\t\t\t\tif (wantIds.contains(objectId))\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t} else {\n \t\t\t\t\t\tRevObject obj = rw.lookupOrNull(objectId);\n \t\t\t\t\t\tif (obj != null && obj.has(WANT))\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t}\n \n \t\t\t\t\tif (!ref.isPeeled())\n \t\t\t\t\t\tref = db.peel(ref);\n \n \t\t\t\t\tObjectId peeledId = ref.getPeeledObjectId();\n \t\t\t\t\tif (peeledId == null)\n \t\t\t\t\t\tcontinue;\n \n \t\t\t\t\tobjectId = ref.getObjectId();\n \t\t\t\t\tif (pw.willInclude(peeledId) && !pw.willInclude(objectId))\n \t\t\t\t\t\tpw.addObject(rw.parseAny(objectId));\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tpw.writePack(pm, NullProgressMonitor.INSTANCE, packOut);\n \t\t\tstatistics = pw.getStatistics();\n \n-\t\t\tif (msgOut != null) {\n+\t\t\tif (msgOut != DisabledOutputStream.INSTANCE) {\n \t\t\t\tString msg = pw.getStatistics().getMessage() + '\\n';\n \t\t\t\tmsgOut.write(Constants.encode(msg));\n \t\t\t\tmsgOut.flush();\n \t\t\t}\n \n \t\t} finally {\n \t\t\tpw.release();\n \t\t}\n \n \t\tif (sideband)\n \t\t\tpckOut.end();\n \n \t\tif (statistics != null)\n \t\t\tlogger.onPackStatistics(statistics);\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"eb17495ca4ce95c63bacf81af16ab19ff042b65c": {
			"type": "Ybodychange",
			"commitMessage": "Disable CRC32 computation when no PackIndex will be created\n\nIf a server is streaming 3GiB worth of pack data to a client there\nis no reason to compute the CRC32 checksum on the objects. The\nCRC32 code computed by PackWriter is used only in the new index\ncreated by writeIndex(), which is never invoked for the native Git\nnetwork protocols.\n\nObject reuse may still compute its own CRC32 to verify the data\nbeing copied from an existing pack has not been corrupted. This\ncheck is done by the ObjectReader that implements ObjectReuseAsIs\nand has no relationship to the CRC32 being skipped during output.\n\nChange-Id: I05626f2e0d6ce19119b57d8a27193922636d60a7\n",
			"commitDate": "2013-04-10, 1:58 PM",
			"commitName": "eb17495ca4ce95c63bacf81af16ab19ff042b65c",
			"commitAuthor": "Shawn Pearce",
			"commitDateOld": "2013-03-22, 2:21 PM",
			"commitNameOld": "dd6f41e4010680115c00dd8dc250b1674eb42f42",
			"commitAuthorOld": "Matthias Sohn",
			"daysBetweenCommits": 18.98,
			"commitsBetweenForRepo": 30,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,123 +1,124 @@\n \tprivate void sendPack(final boolean sideband) throws IOException {\n \t\tProgressMonitor pm = NullProgressMonitor.INSTANCE;\n \t\tOutputStream packOut = rawOut;\n \t\tSideBandOutputStream msgOut = null;\n \n \t\tif (sideband) {\n \t\t\tint bufsz = SideBandOutputStream.SMALL_BUF;\n \t\t\tif (options.contains(OPTION_SIDE_BAND_64K))\n \t\t\t\tbufsz = SideBandOutputStream.MAX_BUF;\n \n \t\t\tpackOut = new SideBandOutputStream(SideBandOutputStream.CH_DATA,\n \t\t\t\t\tbufsz, rawOut);\n \t\t\tif (!options.contains(OPTION_NO_PROGRESS)) {\n \t\t\t\tmsgOut = new SideBandOutputStream(\n \t\t\t\t\t\tSideBandOutputStream.CH_PROGRESS, bufsz, rawOut);\n \t\t\t\tpm = new SideBandProgressMonitor(msgOut);\n \t\t\t}\n \t\t}\n \n \t\ttry {\n \t\t\tif (wantAll.isEmpty()) {\n \t\t\t\tpreUploadHook.onSendPack(this, wantIds, commonBase);\n \t\t\t} else {\n \t\t\t\tpreUploadHook.onSendPack(this, wantAll, commonBase);\n \t\t\t}\n \t\t} catch (ServiceMayNotContinueException noPack) {\n \t\t\tif (sideband && noPack.getMessage() != null) {\n \t\t\t\tnoPack.setOutput();\n \t\t\t\t@SuppressWarnings(\"resource\" /* java 7 */)\n \t\t\t\tSideBandOutputStream err = new SideBandOutputStream(\n \t\t\t\t\t\tSideBandOutputStream.CH_ERROR,\n \t\t\t\t\t\tSideBandOutputStream.SMALL_BUF, rawOut);\n \t\t\t\terr.write(Constants.encode(noPack.getMessage()));\n \t\t\t\terr.flush();\n \t\t\t}\n \t\t\tthrow noPack;\n \t\t}\n \n \t\tPackConfig cfg = packConfig;\n \t\tif (cfg == null)\n \t\t\tcfg = new PackConfig(db);\n \t\tfinal PackWriter pw = new PackWriter(cfg, walk.getObjectReader());\n \t\ttry {\n+\t\t\tpw.setIndexDisabled(true);\n \t\t\tpw.setUseCachedPacks(true);\n \t\t\tpw.setUseBitmaps(true);\n \t\t\tpw.setReuseDeltaCommits(true);\n \t\t\tpw.setDeltaBaseAsOffset(options.contains(OPTION_OFS_DELTA));\n \t\t\tpw.setThin(options.contains(OPTION_THIN_PACK));\n \t\t\tpw.setReuseValidatingObjects(false);\n \n \t\t\tif (commonBase.isEmpty() && refs != null) {\n \t\t\t\tSet<ObjectId> tagTargets = new HashSet<ObjectId>();\n \t\t\t\tfor (Ref ref : refs.values()) {\n \t\t\t\t\tif (ref.getPeeledObjectId() != null)\n \t\t\t\t\t\ttagTargets.add(ref.getPeeledObjectId());\n \t\t\t\t\telse if (ref.getObjectId() == null)\n \t\t\t\t\t\tcontinue;\n \t\t\t\t\telse if (ref.getName().startsWith(Constants.R_HEADS))\n \t\t\t\t\t\ttagTargets.add(ref.getObjectId());\n \t\t\t\t}\n \t\t\t\tpw.setTagTargets(tagTargets);\n \t\t\t}\n \n \t\t\tif (depth > 0)\n \t\t\t\tpw.setShallowPack(depth, unshallowCommits);\n \n \t\t\tRevWalk rw = walk;\n \t\t\tif (wantAll.isEmpty()) {\n \t\t\t\tpw.preparePack(pm, wantIds, commonBase);\n \t\t\t} else {\n \t\t\t\twalk.reset();\n \n \t\t\t\tObjectWalk ow = walk.toObjectWalkWithSameObjects();\n \t\t\t\tpw.preparePack(pm, ow, wantAll, commonBase);\n \t\t\t\trw = ow;\n \t\t\t}\n \n \t\t\tif (options.contains(OPTION_INCLUDE_TAG) && refs != null) {\n \t\t\t\tfor (Ref ref : refs.values()) {\n \t\t\t\t\tObjectId objectId = ref.getObjectId();\n \n \t\t\t\t\t// If the object was already requested, skip it.\n \t\t\t\t\tif (wantAll.isEmpty()) {\n \t\t\t\t\t\tif (wantIds.contains(objectId))\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t} else {\n \t\t\t\t\t\tRevObject obj = rw.lookupOrNull(objectId);\n \t\t\t\t\t\tif (obj != null && obj.has(WANT))\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t}\n \n \t\t\t\t\tif (!ref.isPeeled())\n \t\t\t\t\t\tref = db.peel(ref);\n \n \t\t\t\t\tObjectId peeledId = ref.getPeeledObjectId();\n \t\t\t\t\tif (peeledId == null)\n \t\t\t\t\t\tcontinue;\n \n \t\t\t\t\tobjectId = ref.getObjectId();\n \t\t\t\t\tif (pw.willInclude(peeledId) && !pw.willInclude(objectId))\n \t\t\t\t\t\tpw.addObject(rw.parseAny(objectId));\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tpw.writePack(pm, NullProgressMonitor.INSTANCE, packOut);\n \t\t\tstatistics = pw.getStatistics();\n \n \t\t\tif (msgOut != null) {\n \t\t\t\tString msg = pw.getStatistics().getMessage() + '\\n';\n \t\t\t\tmsgOut.write(Constants.encode(msg));\n \t\t\t\tmsgOut.flush();\n \t\t\t}\n \n \t\t} finally {\n \t\t\tpw.release();\n \t\t}\n \n \t\tif (sideband)\n \t\t\tpckOut.end();\n \n \t\tif (statistics != null)\n \t\t\tlogger.onPackStatistics(statistics);\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"43ea887c8b43de26a6b7a9ea547033d3c04022e7": {
			"type": "Ybodychange",
			"commitMessage": "Enable serving upload requests using bitmaps.\n\nIf the pack index has bitmaps, allow the PackWriter to use the bitmaps\nfor upload requests.\n\nChange-Id: Iefa995fe927a11e4fd78afb34530995614221fc0\n",
			"commitDate": "2013-03-05, 12:14 PM",
			"commitName": "43ea887c8b43de26a6b7a9ea547033d3c04022e7",
			"commitAuthor": "Colby Ranger",
			"commitDateOld": "2012-12-27, 8:57 AM",
			"commitNameOld": "c310fa0c802f40a774edb58641de3ac5bfad0e2c",
			"commitAuthorOld": "Robin Rosenberg",
			"daysBetweenCommits": 68.14,
			"commitsBetweenForRepo": 93,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,122 +1,123 @@\n \tprivate void sendPack(final boolean sideband) throws IOException {\n \t\tProgressMonitor pm = NullProgressMonitor.INSTANCE;\n \t\tOutputStream packOut = rawOut;\n \t\tSideBandOutputStream msgOut = null;\n \n \t\tif (sideband) {\n \t\t\tint bufsz = SideBandOutputStream.SMALL_BUF;\n \t\t\tif (options.contains(OPTION_SIDE_BAND_64K))\n \t\t\t\tbufsz = SideBandOutputStream.MAX_BUF;\n \n \t\t\tpackOut = new SideBandOutputStream(SideBandOutputStream.CH_DATA,\n \t\t\t\t\tbufsz, rawOut);\n \t\t\tif (!options.contains(OPTION_NO_PROGRESS)) {\n \t\t\t\tmsgOut = new SideBandOutputStream(\n \t\t\t\t\t\tSideBandOutputStream.CH_PROGRESS, bufsz, rawOut);\n \t\t\t\tpm = new SideBandProgressMonitor(msgOut);\n \t\t\t}\n \t\t}\n \n \t\ttry {\n \t\t\tif (wantAll.isEmpty()) {\n \t\t\t\tpreUploadHook.onSendPack(this, wantIds, commonBase);\n \t\t\t} else {\n \t\t\t\tpreUploadHook.onSendPack(this, wantAll, commonBase);\n \t\t\t}\n \t\t} catch (ServiceMayNotContinueException noPack) {\n \t\t\tif (sideband && noPack.getMessage() != null) {\n \t\t\t\tnoPack.setOutput();\n \t\t\t\t@SuppressWarnings(\"resource\" /* java 7 */)\n \t\t\t\tSideBandOutputStream err = new SideBandOutputStream(\n \t\t\t\t\t\tSideBandOutputStream.CH_ERROR,\n \t\t\t\t\t\tSideBandOutputStream.SMALL_BUF, rawOut);\n \t\t\t\terr.write(Constants.encode(noPack.getMessage()));\n \t\t\t\terr.flush();\n \t\t\t}\n \t\t\tthrow noPack;\n \t\t}\n \n \t\tPackConfig cfg = packConfig;\n \t\tif (cfg == null)\n \t\t\tcfg = new PackConfig(db);\n \t\tfinal PackWriter pw = new PackWriter(cfg, walk.getObjectReader());\n \t\ttry {\n \t\t\tpw.setUseCachedPacks(true);\n+\t\t\tpw.setUseBitmaps(true);\n \t\t\tpw.setReuseDeltaCommits(true);\n \t\t\tpw.setDeltaBaseAsOffset(options.contains(OPTION_OFS_DELTA));\n \t\t\tpw.setThin(options.contains(OPTION_THIN_PACK));\n \t\t\tpw.setReuseValidatingObjects(false);\n \n \t\t\tif (commonBase.isEmpty() && refs != null) {\n \t\t\t\tSet<ObjectId> tagTargets = new HashSet<ObjectId>();\n \t\t\t\tfor (Ref ref : refs.values()) {\n \t\t\t\t\tif (ref.getPeeledObjectId() != null)\n \t\t\t\t\t\ttagTargets.add(ref.getPeeledObjectId());\n \t\t\t\t\telse if (ref.getObjectId() == null)\n \t\t\t\t\t\tcontinue;\n \t\t\t\t\telse if (ref.getName().startsWith(Constants.R_HEADS))\n \t\t\t\t\t\ttagTargets.add(ref.getObjectId());\n \t\t\t\t}\n \t\t\t\tpw.setTagTargets(tagTargets);\n \t\t\t}\n \n \t\t\tif (depth > 0)\n \t\t\t\tpw.setShallowPack(depth, unshallowCommits);\n \n \t\t\tRevWalk rw = walk;\n \t\t\tif (wantAll.isEmpty()) {\n \t\t\t\tpw.preparePack(pm, wantIds, commonBase);\n \t\t\t} else {\n \t\t\t\twalk.reset();\n \n \t\t\t\tObjectWalk ow = walk.toObjectWalkWithSameObjects();\n \t\t\t\tpw.preparePack(pm, ow, wantAll, commonBase);\n \t\t\t\trw = ow;\n \t\t\t}\n \n \t\t\tif (options.contains(OPTION_INCLUDE_TAG) && refs != null) {\n \t\t\t\tfor (Ref ref : refs.values()) {\n \t\t\t\t\tObjectId objectId = ref.getObjectId();\n \n \t\t\t\t\t// If the object was already requested, skip it.\n \t\t\t\t\tif (wantAll.isEmpty()) {\n \t\t\t\t\t\tif (wantIds.contains(objectId))\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t} else {\n \t\t\t\t\t\tRevObject obj = rw.lookupOrNull(objectId);\n \t\t\t\t\t\tif (obj != null && obj.has(WANT))\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t}\n \n \t\t\t\t\tif (!ref.isPeeled())\n \t\t\t\t\t\tref = db.peel(ref);\n \n \t\t\t\t\tObjectId peeledId = ref.getPeeledObjectId();\n \t\t\t\t\tif (peeledId == null)\n \t\t\t\t\t\tcontinue;\n \n \t\t\t\t\tobjectId = ref.getObjectId();\n \t\t\t\t\tif (pw.willInclude(peeledId) && !pw.willInclude(objectId))\n \t\t\t\t\t\tpw.addObject(rw.parseAny(objectId));\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tpw.writePack(pm, NullProgressMonitor.INSTANCE, packOut);\n \t\t\tstatistics = pw.getStatistics();\n \n \t\t\tif (msgOut != null) {\n \t\t\t\tString msg = pw.getStatistics().getMessage() + '\\n';\n \t\t\t\tmsgOut.write(Constants.encode(msg));\n \t\t\t\tmsgOut.flush();\n \t\t\t}\n \n \t\t} finally {\n \t\t\tpw.release();\n \t\t}\n \n \t\tif (sideband)\n \t\t\tpckOut.end();\n \n \t\tif (statistics != null)\n \t\t\tlogger.onPackStatistics(statistics);\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"9b86cf574b230a9b3a71d7cb53a4f6712bfa33eb": {
			"type": "Ybodychange",
			"commitMessage": "Suppress two resource warnings\n\nChange-Id: I829bb135b2347f79aa6d8979a0934042e40d212f\n",
			"commitDate": "2012-08-17, 7:49 AM",
			"commitName": "9b86cf574b230a9b3a71d7cb53a4f6712bfa33eb",
			"commitAuthor": "Robin Rosenberg",
			"commitDateOld": "2012-03-12, 8:20 AM",
			"commitNameOld": "95d311f8886f42f31a4475f84aa23c6345ab7059",
			"commitAuthorOld": "Robin Rosenberg",
			"daysBetweenCommits": 157.98,
			"commitsBetweenForRepo": 158,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,121 +1,122 @@\n \tprivate void sendPack(final boolean sideband) throws IOException {\n \t\tProgressMonitor pm = NullProgressMonitor.INSTANCE;\n \t\tOutputStream packOut = rawOut;\n \t\tSideBandOutputStream msgOut = null;\n \n \t\tif (sideband) {\n \t\t\tint bufsz = SideBandOutputStream.SMALL_BUF;\n \t\t\tif (options.contains(OPTION_SIDE_BAND_64K))\n \t\t\t\tbufsz = SideBandOutputStream.MAX_BUF;\n \n \t\t\tpackOut = new SideBandOutputStream(SideBandOutputStream.CH_DATA,\n \t\t\t\t\tbufsz, rawOut);\n \t\t\tif (!options.contains(OPTION_NO_PROGRESS)) {\n \t\t\t\tmsgOut = new SideBandOutputStream(\n \t\t\t\t\t\tSideBandOutputStream.CH_PROGRESS, bufsz, rawOut);\n \t\t\t\tpm = new SideBandProgressMonitor(msgOut);\n \t\t\t}\n \t\t}\n \n \t\ttry {\n \t\t\tif (wantAll.isEmpty()) {\n \t\t\t\tpreUploadHook.onSendPack(this, wantIds, commonBase);\n \t\t\t} else {\n \t\t\t\tpreUploadHook.onSendPack(this, wantAll, commonBase);\n \t\t\t}\n \t\t} catch (ServiceMayNotContinueException noPack) {\n \t\t\tif (sideband && noPack.getMessage() != null) {\n \t\t\t\tnoPack.setOutput();\n+\t\t\t\t@SuppressWarnings(\"resource\")\n \t\t\t\tSideBandOutputStream err = new SideBandOutputStream(\n \t\t\t\t\t\tSideBandOutputStream.CH_ERROR,\n \t\t\t\t\t\tSideBandOutputStream.SMALL_BUF, rawOut);\n \t\t\t\terr.write(Constants.encode(noPack.getMessage()));\n \t\t\t\terr.flush();\n \t\t\t}\n \t\t\tthrow noPack;\n \t\t}\n \n \t\tPackConfig cfg = packConfig;\n \t\tif (cfg == null)\n \t\t\tcfg = new PackConfig(db);\n \t\tfinal PackWriter pw = new PackWriter(cfg, walk.getObjectReader());\n \t\ttry {\n \t\t\tpw.setUseCachedPacks(true);\n \t\t\tpw.setReuseDeltaCommits(true);\n \t\t\tpw.setDeltaBaseAsOffset(options.contains(OPTION_OFS_DELTA));\n \t\t\tpw.setThin(options.contains(OPTION_THIN_PACK));\n \t\t\tpw.setReuseValidatingObjects(false);\n \n \t\t\tif (commonBase.isEmpty() && refs != null) {\n \t\t\t\tSet<ObjectId> tagTargets = new HashSet<ObjectId>();\n \t\t\t\tfor (Ref ref : refs.values()) {\n \t\t\t\t\tif (ref.getPeeledObjectId() != null)\n \t\t\t\t\t\ttagTargets.add(ref.getPeeledObjectId());\n \t\t\t\t\telse if (ref.getObjectId() == null)\n \t\t\t\t\t\tcontinue;\n \t\t\t\t\telse if (ref.getName().startsWith(Constants.R_HEADS))\n \t\t\t\t\t\ttagTargets.add(ref.getObjectId());\n \t\t\t\t}\n \t\t\t\tpw.setTagTargets(tagTargets);\n \t\t\t}\n \n \t\t\tif (depth > 0)\n \t\t\t\tpw.setShallowPack(depth, unshallowCommits);\n \n \t\t\tRevWalk rw = walk;\n \t\t\tif (wantAll.isEmpty()) {\n \t\t\t\tpw.preparePack(pm, wantIds, commonBase);\n \t\t\t} else {\n \t\t\t\twalk.reset();\n \n \t\t\t\tObjectWalk ow = walk.toObjectWalkWithSameObjects();\n \t\t\t\tpw.preparePack(pm, ow, wantAll, commonBase);\n \t\t\t\trw = ow;\n \t\t\t}\n \n \t\t\tif (options.contains(OPTION_INCLUDE_TAG) && refs != null) {\n \t\t\t\tfor (Ref ref : refs.values()) {\n \t\t\t\t\tObjectId objectId = ref.getObjectId();\n \n \t\t\t\t\t// If the object was already requested, skip it.\n \t\t\t\t\tif (wantAll.isEmpty()) {\n \t\t\t\t\t\tif (wantIds.contains(objectId))\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t} else {\n \t\t\t\t\t\tRevObject obj = rw.lookupOrNull(objectId);\n \t\t\t\t\t\tif (obj != null && obj.has(WANT))\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t}\n \n \t\t\t\t\tif (!ref.isPeeled())\n \t\t\t\t\t\tref = db.peel(ref);\n \n \t\t\t\t\tObjectId peeledId = ref.getPeeledObjectId();\n \t\t\t\t\tif (peeledId == null)\n \t\t\t\t\t\tcontinue;\n \n \t\t\t\t\tobjectId = ref.getObjectId();\n \t\t\t\t\tif (pw.willInclude(peeledId) && !pw.willInclude(objectId))\n \t\t\t\t\t\tpw.addObject(rw.parseAny(objectId));\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tpw.writePack(pm, NullProgressMonitor.INSTANCE, packOut);\n \t\t\tstatistics = pw.getStatistics();\n \n \t\t\tif (msgOut != null) {\n \t\t\t\tString msg = pw.getStatistics().getMessage() + '\\n';\n \t\t\t\tmsgOut.write(Constants.encode(msg));\n \t\t\t\tmsgOut.flush();\n \t\t\t}\n \n \t\t} finally {\n \t\t\tpw.release();\n \t\t}\n \n \t\tif (sideband)\n \t\t\tpckOut.end();\n \n \t\tif (statistics != null)\n \t\t\tlogger.onPackStatistics(statistics);\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"1f2022e3a7e9482caa4823e031504b6bbe8246af": {
			"type": "Ybodychange",
			"commitMessage": "Modify refs in UploadPack/ReceivePack using a hook interface\n\nThis is intended to replace the RefFilter interface (but does not yet,\nfor backwards compatibility). That interface required lots of extra\nscanning and copying in filter cases such as only advertising a subtree\nof the refs directory. Instead, provide a hook that can be executed\nright before ref advertisement, using the public methods on\nUploadPack/ReceivePack to explicitly set the map of advertised refs.\n\nChange-Id: I0067019a191c8148af2cfb71a675f2258c5af0ca\n",
			"commitDate": "2012-02-29, 8:09 PM",
			"commitName": "1f2022e3a7e9482caa4823e031504b6bbe8246af",
			"commitAuthor": "Dave Borowitz",
			"commitDateOld": "2011-12-08, 9:26 AM",
			"commitNameOld": "d6172dc0de2cbaeb0bd38a9d30278dd5f9b140b3",
			"commitAuthorOld": "Dave Borowitz",
			"daysBetweenCommits": 83.45,
			"commitsBetweenForRepo": 81,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,121 +1,121 @@\n \tprivate void sendPack(final boolean sideband) throws IOException {\n \t\tProgressMonitor pm = NullProgressMonitor.INSTANCE;\n \t\tOutputStream packOut = rawOut;\n \t\tSideBandOutputStream msgOut = null;\n \n \t\tif (sideband) {\n \t\t\tint bufsz = SideBandOutputStream.SMALL_BUF;\n \t\t\tif (options.contains(OPTION_SIDE_BAND_64K))\n \t\t\t\tbufsz = SideBandOutputStream.MAX_BUF;\n \n \t\t\tpackOut = new SideBandOutputStream(SideBandOutputStream.CH_DATA,\n \t\t\t\t\tbufsz, rawOut);\n \t\t\tif (!options.contains(OPTION_NO_PROGRESS)) {\n \t\t\t\tmsgOut = new SideBandOutputStream(\n \t\t\t\t\t\tSideBandOutputStream.CH_PROGRESS, bufsz, rawOut);\n \t\t\t\tpm = new SideBandProgressMonitor(msgOut);\n \t\t\t}\n \t\t}\n \n \t\ttry {\n \t\t\tif (wantAll.isEmpty()) {\n \t\t\t\tpreUploadHook.onSendPack(this, wantIds, commonBase);\n \t\t\t} else {\n \t\t\t\tpreUploadHook.onSendPack(this, wantAll, commonBase);\n \t\t\t}\n-\t\t} catch (UploadPackMayNotContinueException noPack) {\n+\t\t} catch (ServiceMayNotContinueException noPack) {\n \t\t\tif (sideband && noPack.getMessage() != null) {\n \t\t\t\tnoPack.setOutput();\n \t\t\t\tSideBandOutputStream err = new SideBandOutputStream(\n \t\t\t\t\t\tSideBandOutputStream.CH_ERROR,\n \t\t\t\t\t\tSideBandOutputStream.SMALL_BUF, rawOut);\n \t\t\t\terr.write(Constants.encode(noPack.getMessage()));\n \t\t\t\terr.flush();\n \t\t\t}\n \t\t\tthrow noPack;\n \t\t}\n \n \t\tPackConfig cfg = packConfig;\n \t\tif (cfg == null)\n \t\t\tcfg = new PackConfig(db);\n \t\tfinal PackWriter pw = new PackWriter(cfg, walk.getObjectReader());\n \t\ttry {\n \t\t\tpw.setUseCachedPacks(true);\n \t\t\tpw.setReuseDeltaCommits(true);\n \t\t\tpw.setDeltaBaseAsOffset(options.contains(OPTION_OFS_DELTA));\n \t\t\tpw.setThin(options.contains(OPTION_THIN_PACK));\n \t\t\tpw.setReuseValidatingObjects(false);\n \n \t\t\tif (commonBase.isEmpty() && refs != null) {\n \t\t\t\tSet<ObjectId> tagTargets = new HashSet<ObjectId>();\n \t\t\t\tfor (Ref ref : refs.values()) {\n \t\t\t\t\tif (ref.getPeeledObjectId() != null)\n \t\t\t\t\t\ttagTargets.add(ref.getPeeledObjectId());\n \t\t\t\t\telse if (ref.getObjectId() == null)\n \t\t\t\t\t\tcontinue;\n \t\t\t\t\telse if (ref.getName().startsWith(Constants.R_HEADS))\n \t\t\t\t\t\ttagTargets.add(ref.getObjectId());\n \t\t\t\t}\n \t\t\t\tpw.setTagTargets(tagTargets);\n \t\t\t}\n \n \t\t\tif (depth > 0)\n \t\t\t\tpw.setShallowPack(depth, unshallowCommits);\n \n \t\t\tRevWalk rw = walk;\n \t\t\tif (wantAll.isEmpty()) {\n \t\t\t\tpw.preparePack(pm, wantIds, commonBase);\n \t\t\t} else {\n \t\t\t\twalk.reset();\n \n \t\t\t\tObjectWalk ow = walk.toObjectWalkWithSameObjects();\n \t\t\t\tpw.preparePack(pm, ow, wantAll, commonBase);\n \t\t\t\trw = ow;\n \t\t\t}\n \n \t\t\tif (options.contains(OPTION_INCLUDE_TAG) && refs != null) {\n \t\t\t\tfor (Ref ref : refs.values()) {\n \t\t\t\t\tObjectId objectId = ref.getObjectId();\n \n \t\t\t\t\t// If the object was already requested, skip it.\n \t\t\t\t\tif (wantAll.isEmpty()) {\n \t\t\t\t\t\tif (wantIds.contains(objectId))\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t} else {\n \t\t\t\t\t\tRevObject obj = rw.lookupOrNull(objectId);\n \t\t\t\t\t\tif (obj != null && obj.has(WANT))\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t}\n \n \t\t\t\t\tif (!ref.isPeeled())\n \t\t\t\t\t\tref = db.peel(ref);\n \n \t\t\t\t\tObjectId peeledId = ref.getPeeledObjectId();\n \t\t\t\t\tif (peeledId == null)\n \t\t\t\t\t\tcontinue;\n \n \t\t\t\t\tobjectId = ref.getObjectId();\n \t\t\t\t\tif (pw.willInclude(peeledId) && !pw.willInclude(objectId))\n \t\t\t\t\t\tpw.addObject(rw.parseAny(objectId));\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tpw.writePack(pm, NullProgressMonitor.INSTANCE, packOut);\n \t\t\tstatistics = pw.getStatistics();\n \n \t\t\tif (msgOut != null) {\n \t\t\t\tString msg = pw.getStatistics().getMessage() + '\\n';\n \t\t\t\tmsgOut.write(Constants.encode(msg));\n \t\t\t\tmsgOut.flush();\n \t\t\t}\n \n \t\t} finally {\n \t\t\tpw.release();\n \t\t}\n \n \t\tif (sideband)\n \t\t\tpckOut.end();\n \n \t\tif (statistics != null)\n \t\t\tlogger.onPackStatistics(statistics);\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"d6172dc0de2cbaeb0bd38a9d30278dd5f9b140b3": {
			"type": "Ybodychange",
			"commitMessage": "Add a no-op UploadPackLogger and use it by default\n\nThis matches the behavior of the hooks in UploadPack.\n\nChange-Id: I21277e52ee9452237d87084f06bb140dfa6bf608\n",
			"commitDate": "2011-12-08, 9:26 AM",
			"commitName": "d6172dc0de2cbaeb0bd38a9d30278dd5f9b140b3",
			"commitAuthor": "Dave Borowitz",
			"commitDateOld": "2011-09-14, 4:34 PM",
			"commitNameOld": "01888db892aa9590862d886c01f3b293140db153",
			"commitAuthorOld": "Shawn O. Pearce",
			"daysBetweenCommits": 84.74,
			"commitsBetweenForRepo": 94,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,121 +1,121 @@\n \tprivate void sendPack(final boolean sideband) throws IOException {\n \t\tProgressMonitor pm = NullProgressMonitor.INSTANCE;\n \t\tOutputStream packOut = rawOut;\n \t\tSideBandOutputStream msgOut = null;\n \n \t\tif (sideband) {\n \t\t\tint bufsz = SideBandOutputStream.SMALL_BUF;\n \t\t\tif (options.contains(OPTION_SIDE_BAND_64K))\n \t\t\t\tbufsz = SideBandOutputStream.MAX_BUF;\n \n \t\t\tpackOut = new SideBandOutputStream(SideBandOutputStream.CH_DATA,\n \t\t\t\t\tbufsz, rawOut);\n \t\t\tif (!options.contains(OPTION_NO_PROGRESS)) {\n \t\t\t\tmsgOut = new SideBandOutputStream(\n \t\t\t\t\t\tSideBandOutputStream.CH_PROGRESS, bufsz, rawOut);\n \t\t\t\tpm = new SideBandProgressMonitor(msgOut);\n \t\t\t}\n \t\t}\n \n \t\ttry {\n \t\t\tif (wantAll.isEmpty()) {\n \t\t\t\tpreUploadHook.onSendPack(this, wantIds, commonBase);\n \t\t\t} else {\n \t\t\t\tpreUploadHook.onSendPack(this, wantAll, commonBase);\n \t\t\t}\n \t\t} catch (UploadPackMayNotContinueException noPack) {\n \t\t\tif (sideband && noPack.getMessage() != null) {\n \t\t\t\tnoPack.setOutput();\n \t\t\t\tSideBandOutputStream err = new SideBandOutputStream(\n \t\t\t\t\t\tSideBandOutputStream.CH_ERROR,\n \t\t\t\t\t\tSideBandOutputStream.SMALL_BUF, rawOut);\n \t\t\t\terr.write(Constants.encode(noPack.getMessage()));\n \t\t\t\terr.flush();\n \t\t\t}\n \t\t\tthrow noPack;\n \t\t}\n \n \t\tPackConfig cfg = packConfig;\n \t\tif (cfg == null)\n \t\t\tcfg = new PackConfig(db);\n \t\tfinal PackWriter pw = new PackWriter(cfg, walk.getObjectReader());\n \t\ttry {\n \t\t\tpw.setUseCachedPacks(true);\n \t\t\tpw.setReuseDeltaCommits(true);\n \t\t\tpw.setDeltaBaseAsOffset(options.contains(OPTION_OFS_DELTA));\n \t\t\tpw.setThin(options.contains(OPTION_THIN_PACK));\n \t\t\tpw.setReuseValidatingObjects(false);\n \n \t\t\tif (commonBase.isEmpty() && refs != null) {\n \t\t\t\tSet<ObjectId> tagTargets = new HashSet<ObjectId>();\n \t\t\t\tfor (Ref ref : refs.values()) {\n \t\t\t\t\tif (ref.getPeeledObjectId() != null)\n \t\t\t\t\t\ttagTargets.add(ref.getPeeledObjectId());\n \t\t\t\t\telse if (ref.getObjectId() == null)\n \t\t\t\t\t\tcontinue;\n \t\t\t\t\telse if (ref.getName().startsWith(Constants.R_HEADS))\n \t\t\t\t\t\ttagTargets.add(ref.getObjectId());\n \t\t\t\t}\n \t\t\t\tpw.setTagTargets(tagTargets);\n \t\t\t}\n \n \t\t\tif (depth > 0)\n \t\t\t\tpw.setShallowPack(depth, unshallowCommits);\n \n \t\t\tRevWalk rw = walk;\n \t\t\tif (wantAll.isEmpty()) {\n \t\t\t\tpw.preparePack(pm, wantIds, commonBase);\n \t\t\t} else {\n \t\t\t\twalk.reset();\n \n \t\t\t\tObjectWalk ow = walk.toObjectWalkWithSameObjects();\n \t\t\t\tpw.preparePack(pm, ow, wantAll, commonBase);\n \t\t\t\trw = ow;\n \t\t\t}\n \n \t\t\tif (options.contains(OPTION_INCLUDE_TAG) && refs != null) {\n \t\t\t\tfor (Ref ref : refs.values()) {\n \t\t\t\t\tObjectId objectId = ref.getObjectId();\n \n \t\t\t\t\t// If the object was already requested, skip it.\n \t\t\t\t\tif (wantAll.isEmpty()) {\n \t\t\t\t\t\tif (wantIds.contains(objectId))\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t} else {\n \t\t\t\t\t\tRevObject obj = rw.lookupOrNull(objectId);\n \t\t\t\t\t\tif (obj != null && obj.has(WANT))\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t}\n \n \t\t\t\t\tif (!ref.isPeeled())\n \t\t\t\t\t\tref = db.peel(ref);\n \n \t\t\t\t\tObjectId peeledId = ref.getPeeledObjectId();\n \t\t\t\t\tif (peeledId == null)\n \t\t\t\t\t\tcontinue;\n \n \t\t\t\t\tobjectId = ref.getObjectId();\n \t\t\t\t\tif (pw.willInclude(peeledId) && !pw.willInclude(objectId))\n \t\t\t\t\t\tpw.addObject(rw.parseAny(objectId));\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tpw.writePack(pm, NullProgressMonitor.INSTANCE, packOut);\n \t\t\tstatistics = pw.getStatistics();\n \n \t\t\tif (msgOut != null) {\n \t\t\t\tString msg = pw.getStatistics().getMessage() + '\\n';\n \t\t\t\tmsgOut.write(Constants.encode(msg));\n \t\t\t\tmsgOut.flush();\n \t\t\t}\n \n \t\t} finally {\n \t\t\tpw.release();\n \t\t}\n \n \t\tif (sideband)\n \t\t\tpckOut.end();\n \n-\t\tif (logger != null && statistics != null)\n+\t\tif (statistics != null)\n \t\t\tlogger.onPackStatistics(statistics);\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"01888db892aa9590862d886c01f3b293140db153": {
			"type": "Ybodychange",
			"commitMessage": "UploadPack: Fix races in smart HTTP negotiation\n\nClients cache the set of advertised references at the start of a\nnegotiation, and keep replaying the same \"want SHA1\" list to the\nserver on each negotiation step.  If another client pushes into\na branch and moves it by fast-forward, any request to obtain that\nbranch's prior SHA-1 is still valid, the commit is reachable from\nthe new position of the reference.  Unfortunately the fast-forward\ncauses smart HTTP negotations to fail, as the server no longer is\nadvertising that prior SHA-1.\n\nInstead of causing clients to fail out with a \"want invalid\" error\nand forcing the end-user retry, possibly getting into a never ending\ntry-fail-retry race while other clients are pushing into the same\nbusy repository, allow the slightly stale want request so long as\nit is still reachable.\n\nC Git implemented this same change recently to fix races on the\nsmart HTTP protocol when the C Git git-http-backend is used.\n\nThe new RequestPolicy feature also allows server authors to make\nan even more lenient configuration that exports any SHA-1 to the\nclient. This might be useful in certain settings where a server\nhas authenticated the client as the \"repository owner\" and wants\nto allow them to grab any content from the server as a complete\nunbroken history chain.\n\nThe new setAdvertisedRefs() method allows server authors to manually\nfix the references that are advertised, possibly bypassing the\ngetAllRefs() call on the Repository object.\n\nChange-Id: I7cdb563bf9c55c83653f217f6e53c3add55a0541\nSigned-off-by: Shawn O. Pearce <spearce@spearce.org>\n",
			"commitDate": "2011-09-14, 4:34 PM",
			"commitName": "01888db892aa9590862d886c01f3b293140db153",
			"commitAuthor": "Shawn O. Pearce",
			"commitDateOld": "2011-08-21, 3:04 PM",
			"commitNameOld": "9952223e0645fd7a8cddc6093a7f449c6390238d",
			"commitAuthorOld": "Matt Fischer",
			"daysBetweenCommits": 24.06,
			"commitsBetweenForRepo": 26,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,121 +1,121 @@\n \tprivate void sendPack(final boolean sideband) throws IOException {\n \t\tProgressMonitor pm = NullProgressMonitor.INSTANCE;\n \t\tOutputStream packOut = rawOut;\n \t\tSideBandOutputStream msgOut = null;\n \n \t\tif (sideband) {\n \t\t\tint bufsz = SideBandOutputStream.SMALL_BUF;\n \t\t\tif (options.contains(OPTION_SIDE_BAND_64K))\n \t\t\t\tbufsz = SideBandOutputStream.MAX_BUF;\n \n \t\t\tpackOut = new SideBandOutputStream(SideBandOutputStream.CH_DATA,\n \t\t\t\t\tbufsz, rawOut);\n \t\t\tif (!options.contains(OPTION_NO_PROGRESS)) {\n \t\t\t\tmsgOut = new SideBandOutputStream(\n \t\t\t\t\t\tSideBandOutputStream.CH_PROGRESS, bufsz, rawOut);\n \t\t\t\tpm = new SideBandProgressMonitor(msgOut);\n \t\t\t}\n \t\t}\n \n \t\ttry {\n \t\t\tif (wantAll.isEmpty()) {\n \t\t\t\tpreUploadHook.onSendPack(this, wantIds, commonBase);\n \t\t\t} else {\n \t\t\t\tpreUploadHook.onSendPack(this, wantAll, commonBase);\n \t\t\t}\n \t\t} catch (UploadPackMayNotContinueException noPack) {\n \t\t\tif (sideband && noPack.getMessage() != null) {\n \t\t\t\tnoPack.setOutput();\n \t\t\t\tSideBandOutputStream err = new SideBandOutputStream(\n \t\t\t\t\t\tSideBandOutputStream.CH_ERROR,\n \t\t\t\t\t\tSideBandOutputStream.SMALL_BUF, rawOut);\n \t\t\t\terr.write(Constants.encode(noPack.getMessage()));\n \t\t\t\terr.flush();\n \t\t\t}\n \t\t\tthrow noPack;\n \t\t}\n \n \t\tPackConfig cfg = packConfig;\n \t\tif (cfg == null)\n \t\t\tcfg = new PackConfig(db);\n \t\tfinal PackWriter pw = new PackWriter(cfg, walk.getObjectReader());\n \t\ttry {\n \t\t\tpw.setUseCachedPacks(true);\n \t\t\tpw.setReuseDeltaCommits(true);\n \t\t\tpw.setDeltaBaseAsOffset(options.contains(OPTION_OFS_DELTA));\n \t\t\tpw.setThin(options.contains(OPTION_THIN_PACK));\n \t\t\tpw.setReuseValidatingObjects(false);\n \n-\t\t\tif (commonBase.isEmpty()) {\n+\t\t\tif (commonBase.isEmpty() && refs != null) {\n \t\t\t\tSet<ObjectId> tagTargets = new HashSet<ObjectId>();\n \t\t\t\tfor (Ref ref : refs.values()) {\n \t\t\t\t\tif (ref.getPeeledObjectId() != null)\n \t\t\t\t\t\ttagTargets.add(ref.getPeeledObjectId());\n \t\t\t\t\telse if (ref.getObjectId() == null)\n \t\t\t\t\t\tcontinue;\n \t\t\t\t\telse if (ref.getName().startsWith(Constants.R_HEADS))\n \t\t\t\t\t\ttagTargets.add(ref.getObjectId());\n \t\t\t\t}\n \t\t\t\tpw.setTagTargets(tagTargets);\n \t\t\t}\n \n \t\t\tif (depth > 0)\n \t\t\t\tpw.setShallowPack(depth, unshallowCommits);\n \n \t\t\tRevWalk rw = walk;\n \t\t\tif (wantAll.isEmpty()) {\n \t\t\t\tpw.preparePack(pm, wantIds, commonBase);\n \t\t\t} else {\n \t\t\t\twalk.reset();\n \n \t\t\t\tObjectWalk ow = walk.toObjectWalkWithSameObjects();\n \t\t\t\tpw.preparePack(pm, ow, wantAll, commonBase);\n \t\t\t\trw = ow;\n \t\t\t}\n \n-\t\t\tif (options.contains(OPTION_INCLUDE_TAG)) {\n+\t\t\tif (options.contains(OPTION_INCLUDE_TAG) && refs != null) {\n \t\t\t\tfor (Ref ref : refs.values()) {\n \t\t\t\t\tObjectId objectId = ref.getObjectId();\n \n \t\t\t\t\t// If the object was already requested, skip it.\n \t\t\t\t\tif (wantAll.isEmpty()) {\n \t\t\t\t\t\tif (wantIds.contains(objectId))\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t} else {\n \t\t\t\t\t\tRevObject obj = rw.lookupOrNull(objectId);\n \t\t\t\t\t\tif (obj != null && obj.has(WANT))\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t}\n \n \t\t\t\t\tif (!ref.isPeeled())\n \t\t\t\t\t\tref = db.peel(ref);\n \n \t\t\t\t\tObjectId peeledId = ref.getPeeledObjectId();\n \t\t\t\t\tif (peeledId == null)\n \t\t\t\t\t\tcontinue;\n \n \t\t\t\t\tobjectId = ref.getObjectId();\n \t\t\t\t\tif (pw.willInclude(peeledId) && !pw.willInclude(objectId))\n \t\t\t\t\t\tpw.addObject(rw.parseAny(objectId));\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tpw.writePack(pm, NullProgressMonitor.INSTANCE, packOut);\n \t\t\tstatistics = pw.getStatistics();\n \n \t\t\tif (msgOut != null) {\n \t\t\t\tString msg = pw.getStatistics().getMessage() + '\\n';\n \t\t\t\tmsgOut.write(Constants.encode(msg));\n \t\t\t\tmsgOut.flush();\n \t\t\t}\n \n \t\t} finally {\n \t\t\tpw.release();\n \t\t}\n \n \t\tif (sideband)\n \t\t\tpckOut.end();\n \n \t\tif (logger != null && statistics != null)\n \t\t\tlogger.onPackStatistics(statistics);\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"9952223e0645fd7a8cddc6093a7f449c6390238d": {
			"type": "Ybodychange",
			"commitMessage": "Implement server support for shallow clones\n\nThis implements the server side of shallow clones only (i.e.\ngit-upload-pack), not the client side.\n\nCQ: 5517\nBug: 301627\nChange-Id: Ied5f501f9c8d1fe90ab2ba44fac5fa67ed0035a4\nSigned-off-by: Chris Aniszczyk <caniszczyk@gmail.com>\n",
			"commitDate": "2011-08-21, 3:04 PM",
			"commitName": "9952223e0645fd7a8cddc6093a7f449c6390238d",
			"commitAuthor": "Matt Fischer",
			"commitDateOld": "2011-08-16, 1:18 PM",
			"commitNameOld": "74333e63b60440be5ff9f591f2203b635e26e3a0",
			"commitAuthorOld": "Shawn O. Pearce",
			"daysBetweenCommits": 5.07,
			"commitsBetweenForRepo": 8,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,118 +1,121 @@\n \tprivate void sendPack(final boolean sideband) throws IOException {\n \t\tProgressMonitor pm = NullProgressMonitor.INSTANCE;\n \t\tOutputStream packOut = rawOut;\n \t\tSideBandOutputStream msgOut = null;\n \n \t\tif (sideband) {\n \t\t\tint bufsz = SideBandOutputStream.SMALL_BUF;\n \t\t\tif (options.contains(OPTION_SIDE_BAND_64K))\n \t\t\t\tbufsz = SideBandOutputStream.MAX_BUF;\n \n \t\t\tpackOut = new SideBandOutputStream(SideBandOutputStream.CH_DATA,\n \t\t\t\t\tbufsz, rawOut);\n \t\t\tif (!options.contains(OPTION_NO_PROGRESS)) {\n \t\t\t\tmsgOut = new SideBandOutputStream(\n \t\t\t\t\t\tSideBandOutputStream.CH_PROGRESS, bufsz, rawOut);\n \t\t\t\tpm = new SideBandProgressMonitor(msgOut);\n \t\t\t}\n \t\t}\n \n \t\ttry {\n \t\t\tif (wantAll.isEmpty()) {\n \t\t\t\tpreUploadHook.onSendPack(this, wantIds, commonBase);\n \t\t\t} else {\n \t\t\t\tpreUploadHook.onSendPack(this, wantAll, commonBase);\n \t\t\t}\n \t\t} catch (UploadPackMayNotContinueException noPack) {\n \t\t\tif (sideband && noPack.getMessage() != null) {\n \t\t\t\tnoPack.setOutput();\n \t\t\t\tSideBandOutputStream err = new SideBandOutputStream(\n \t\t\t\t\t\tSideBandOutputStream.CH_ERROR,\n \t\t\t\t\t\tSideBandOutputStream.SMALL_BUF, rawOut);\n \t\t\t\terr.write(Constants.encode(noPack.getMessage()));\n \t\t\t\terr.flush();\n \t\t\t}\n \t\t\tthrow noPack;\n \t\t}\n \n \t\tPackConfig cfg = packConfig;\n \t\tif (cfg == null)\n \t\t\tcfg = new PackConfig(db);\n \t\tfinal PackWriter pw = new PackWriter(cfg, walk.getObjectReader());\n \t\ttry {\n \t\t\tpw.setUseCachedPacks(true);\n \t\t\tpw.setReuseDeltaCommits(true);\n \t\t\tpw.setDeltaBaseAsOffset(options.contains(OPTION_OFS_DELTA));\n \t\t\tpw.setThin(options.contains(OPTION_THIN_PACK));\n \t\t\tpw.setReuseValidatingObjects(false);\n \n \t\t\tif (commonBase.isEmpty()) {\n \t\t\t\tSet<ObjectId> tagTargets = new HashSet<ObjectId>();\n \t\t\t\tfor (Ref ref : refs.values()) {\n \t\t\t\t\tif (ref.getPeeledObjectId() != null)\n \t\t\t\t\t\ttagTargets.add(ref.getPeeledObjectId());\n \t\t\t\t\telse if (ref.getObjectId() == null)\n \t\t\t\t\t\tcontinue;\n \t\t\t\t\telse if (ref.getName().startsWith(Constants.R_HEADS))\n \t\t\t\t\t\ttagTargets.add(ref.getObjectId());\n \t\t\t\t}\n \t\t\t\tpw.setTagTargets(tagTargets);\n \t\t\t}\n \n+\t\t\tif (depth > 0)\n+\t\t\t\tpw.setShallowPack(depth, unshallowCommits);\n+\n \t\t\tRevWalk rw = walk;\n \t\t\tif (wantAll.isEmpty()) {\n \t\t\t\tpw.preparePack(pm, wantIds, commonBase);\n \t\t\t} else {\n \t\t\t\twalk.reset();\n \n \t\t\t\tObjectWalk ow = walk.toObjectWalkWithSameObjects();\n \t\t\t\tpw.preparePack(pm, ow, wantAll, commonBase);\n \t\t\t\trw = ow;\n \t\t\t}\n \n \t\t\tif (options.contains(OPTION_INCLUDE_TAG)) {\n \t\t\t\tfor (Ref ref : refs.values()) {\n \t\t\t\t\tObjectId objectId = ref.getObjectId();\n \n \t\t\t\t\t// If the object was already requested, skip it.\n \t\t\t\t\tif (wantAll.isEmpty()) {\n \t\t\t\t\t\tif (wantIds.contains(objectId))\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t} else {\n \t\t\t\t\t\tRevObject obj = rw.lookupOrNull(objectId);\n \t\t\t\t\t\tif (obj != null && obj.has(WANT))\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t}\n \n \t\t\t\t\tif (!ref.isPeeled())\n \t\t\t\t\t\tref = db.peel(ref);\n \n \t\t\t\t\tObjectId peeledId = ref.getPeeledObjectId();\n \t\t\t\t\tif (peeledId == null)\n \t\t\t\t\t\tcontinue;\n \n \t\t\t\t\tobjectId = ref.getObjectId();\n \t\t\t\t\tif (pw.willInclude(peeledId) && !pw.willInclude(objectId))\n \t\t\t\t\t\tpw.addObject(rw.parseAny(objectId));\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tpw.writePack(pm, NullProgressMonitor.INSTANCE, packOut);\n \t\t\tstatistics = pw.getStatistics();\n \n \t\t\tif (msgOut != null) {\n \t\t\t\tString msg = pw.getStatistics().getMessage() + '\\n';\n \t\t\t\tmsgOut.write(Constants.encode(msg));\n \t\t\t\tmsgOut.flush();\n \t\t\t}\n \n \t\t} finally {\n \t\t\tpw.release();\n \t\t}\n \n \t\tif (sideband)\n \t\t\tpckOut.end();\n \n \t\tif (logger != null && statistics != null)\n \t\t\tlogger.onPackStatistics(statistics);\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"7ff6eb584cf8b83f83a3b5edf897feb53dbf42c0": {
			"type": "Yintroduced",
			"commitMessage": "Push errors back over sideband when possible\n\nIf an internal exception occurs while packing and the request\nneeds to abort, the HTTP response might already be committed due\nto progress message having already been delivered to the client.\nThis prevents UploadPackServlet from resetting the response and\nsending back an HTTP 500 response.\n\nTry to catch all exceptions and report internal errors over the\nsideband stream or as an ERR command during the initial ACK/NAK\nnegotiation phase. This allows JGit to transmit an error message\nthat the user will receive on their console without needing to\nworry about resetting the (already gone) HTTP response.\n\nChange-Id: Ie393fb8bb55d2b79ab1276adf71c781c1807f9fe\nSigned-off-by: Shawn O. Pearce <spearce@spearce.org>\n",
			"commitDate": "2011-06-09, 6:29 PM",
			"commitName": "7ff6eb584cf8b83f83a3b5edf897feb53dbf42c0",
			"commitAuthor": "Shawn O. Pearce"
		}
	},
	"sha": "bd1a82502680b5de5bf86f6c4470185fd1602386"
}