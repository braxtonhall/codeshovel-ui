{
	"repo": "https://github.com/spring-projects/spring-framework.git",
	"file": "spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassBeanDefinitionReader.java",
	"method": {
		"longName": "private void loadBeanDefinitionsForBeanMethod(BeanMethod beanMethod);",
		"startLine": 174,
		"methodName": "loadBeanDefinitionsForBeanMethod",
		"isStatic": false,
		"isAbstract": false,
		"visibility": "private"
	},
	"history": {
		"c037e75f26ac5ef69e4d5fc3045e101ca674dcaf": {
			"type": "Ybodychange",
			"commitMessage": "Improve debug logging at BeanDefinitionReader and BeanFactory level\n\nIssue: SPR-17090\n",
			"commitDate": "2018-07-27, 8:46 AM",
			"commitName": "c037e75f26ac5ef69e4d5fc3045e101ca674dcaf",
			"commitAuthor": "Juergen Hoeller",
			"commitDateOld": "2018-07-20, 6:05 AM",
			"commitNameOld": "9a43d2ec208d2e8cd0866431acf26af3529f8677",
			"commitAuthorOld": "Juergen Hoeller",
			"daysBetweenCommits": 7.11,
			"commitsBetweenForRepo": 72,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,102 +1,101 @@\n \tprivate void loadBeanDefinitionsForBeanMethod(BeanMethod beanMethod) {\n \t\tConfigurationClass configClass = beanMethod.getConfigurationClass();\n \t\tMethodMetadata metadata = beanMethod.getMetadata();\n \t\tString methodName = metadata.getMethodName();\n \n \t\t// Do we need to mark the bean as skipped by its condition?\n \t\tif (this.conditionEvaluator.shouldSkip(metadata, ConfigurationPhase.REGISTER_BEAN)) {\n \t\t\tconfigClass.skippedBeanMethods.add(methodName);\n \t\t\treturn;\n \t\t}\n \t\tif (configClass.skippedBeanMethods.contains(methodName)) {\n \t\t\treturn;\n \t\t}\n \n \t\tAnnotationAttributes bean = AnnotationConfigUtils.attributesFor(metadata, Bean.class);\n \t\tAssert.state(bean != null, \"No @Bean annotation attributes\");\n \n \t\t// Consider name and any aliases\n \t\tList<String> names = new ArrayList<>(Arrays.asList(bean.getStringArray(\"name\")));\n \t\tString beanName = (!names.isEmpty() ? names.remove(0) : methodName);\n \n \t\t// Register aliases even when overridden\n \t\tfor (String alias : names) {\n \t\t\tthis.registry.registerAlias(beanName, alias);\n \t\t}\n \n \t\t// Has this effectively been overridden before (e.g. via XML)?\n \t\tif (isOverriddenByExistingDefinition(beanMethod, beanName)) {\n \t\t\tif (beanName.equals(beanMethod.getConfigurationClass().getBeanName())) {\n \t\t\t\tthrow new BeanDefinitionStoreException(beanMethod.getConfigurationClass().getResource().getDescription(),\n \t\t\t\t\t\tbeanName, \"Bean name derived from @Bean method '\" + beanMethod.getMetadata().getMethodName() +\n \t\t\t\t\t\t\"' clashes with bean name for containing configuration class; please make those names unique!\");\n \t\t\t}\n \t\t\treturn;\n \t\t}\n \n \t\tConfigurationClassBeanDefinition beanDef = new ConfigurationClassBeanDefinition(configClass, metadata);\n \t\tbeanDef.setResource(configClass.getResource());\n \t\tbeanDef.setSource(this.sourceExtractor.extractSource(metadata, configClass.getResource()));\n \n \t\tif (metadata.isStatic()) {\n \t\t\t// static @Bean method\n \t\t\tbeanDef.setBeanClassName(configClass.getMetadata().getClassName());\n \t\t\tbeanDef.setFactoryMethodName(methodName);\n \t\t}\n \t\telse {\n \t\t\t// instance @Bean method\n \t\t\tbeanDef.setFactoryBeanName(configClass.getBeanName());\n \t\t\tbeanDef.setUniqueFactoryMethodName(methodName);\n \t\t}\n \t\tbeanDef.setAutowireMode(RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n \t\tbeanDef.setAttribute(org.springframework.beans.factory.annotation.RequiredAnnotationBeanPostProcessor.\n \t\t\t\tSKIP_REQUIRED_CHECK_ATTRIBUTE, Boolean.TRUE);\n \n \t\tAnnotationConfigUtils.processCommonDefinitionAnnotations(beanDef, metadata);\n \n \t\tAutowire autowire = bean.getEnum(\"autowire\");\n \t\tif (autowire.isAutowire()) {\n \t\t\tbeanDef.setAutowireMode(autowire.value());\n \t\t}\n \n \t\tboolean autowireCandidate = bean.getBoolean(\"autowireCandidate\");\n \t\tif (!autowireCandidate) {\n \t\t\tbeanDef.setAutowireCandidate(false);\n \t\t}\n \n \t\tString initMethodName = bean.getString(\"initMethod\");\n \t\tif (StringUtils.hasText(initMethodName)) {\n \t\t\tbeanDef.setInitMethodName(initMethodName);\n \t\t}\n \n \t\tString destroyMethodName = bean.getString(\"destroyMethod\");\n \t\tbeanDef.setDestroyMethodName(destroyMethodName);\n \n \t\t// Consider scoping\n \t\tScopedProxyMode proxyMode = ScopedProxyMode.NO;\n \t\tAnnotationAttributes attributes = AnnotationConfigUtils.attributesFor(metadata, Scope.class);\n \t\tif (attributes != null) {\n \t\t\tbeanDef.setScope(attributes.getString(\"value\"));\n \t\t\tproxyMode = attributes.getEnum(\"proxyMode\");\n \t\t\tif (proxyMode == ScopedProxyMode.DEFAULT) {\n \t\t\t\tproxyMode = ScopedProxyMode.NO;\n \t\t\t}\n \t\t}\n \n \t\t// Replace the original bean definition with the target one, if necessary\n \t\tBeanDefinition beanDefToRegister = beanDef;\n \t\tif (proxyMode != ScopedProxyMode.NO) {\n \t\t\tBeanDefinitionHolder proxyDef = ScopedProxyCreator.createScopedProxy(\n \t\t\t\t\tnew BeanDefinitionHolder(beanDef, beanName), this.registry,\n \t\t\t\t\tproxyMode == ScopedProxyMode.TARGET_CLASS);\n \t\t\tbeanDefToRegister = new ConfigurationClassBeanDefinition(\n \t\t\t\t\t(RootBeanDefinition) proxyDef.getBeanDefinition(), configClass, metadata);\n \t\t}\n \n-\t\tif (logger.isDebugEnabled()) {\n-\t\t\tlogger.debug(String.format(\"Registering bean definition for @Bean method %s.%s()\",\n+\t\tif (logger.isTraceEnabled()) {\n+\t\t\tlogger.trace(String.format(\"Registering bean definition for @Bean method %s.%s()\",\n \t\t\t\t\tconfigClass.getMetadata().getClassName(), beanName));\n \t\t}\n-\n \t\tthis.registry.registerBeanDefinition(beanName, beanDefToRegister);\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"fc699b2b3784413bb7348b8c2a92eb2ab871479f": {
			"type": "Ybodychange",
			"commitMessage": "@Bean provides autowireCandidate flag (analogous to XML definitions)\n\nIssue: SPR-16204\n",
			"commitDate": "2018-07-04, 1:41 PM",
			"commitName": "fc699b2b3784413bb7348b8c2a92eb2ab871479f",
			"commitAuthor": "Juergen Hoeller",
			"commitDateOld": "2018-06-28, 5:15 AM",
			"commitNameOld": "81cb740e0ae23b6bd167f5c42ceae8294a27a14a",
			"commitAuthorOld": "Juergen Hoeller",
			"daysBetweenCommits": 6.35,
			"commitsBetweenForRepo": 53,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,97 +1,102 @@\n \tprivate void loadBeanDefinitionsForBeanMethod(BeanMethod beanMethod) {\n \t\tConfigurationClass configClass = beanMethod.getConfigurationClass();\n \t\tMethodMetadata metadata = beanMethod.getMetadata();\n \t\tString methodName = metadata.getMethodName();\n \n \t\t// Do we need to mark the bean as skipped by its condition?\n \t\tif (this.conditionEvaluator.shouldSkip(metadata, ConfigurationPhase.REGISTER_BEAN)) {\n \t\t\tconfigClass.skippedBeanMethods.add(methodName);\n \t\t\treturn;\n \t\t}\n \t\tif (configClass.skippedBeanMethods.contains(methodName)) {\n \t\t\treturn;\n \t\t}\n \n \t\tAnnotationAttributes bean = AnnotationConfigUtils.attributesFor(metadata, Bean.class);\n \t\tAssert.state(bean != null, \"No @Bean annotation attributes\");\n \n \t\t// Consider name and any aliases\n \t\tList<String> names = new ArrayList<>(Arrays.asList(bean.getStringArray(\"name\")));\n \t\tString beanName = (!names.isEmpty() ? names.remove(0) : methodName);\n \n \t\t// Register aliases even when overridden\n \t\tfor (String alias : names) {\n \t\t\tthis.registry.registerAlias(beanName, alias);\n \t\t}\n \n \t\t// Has this effectively been overridden before (e.g. via XML)?\n \t\tif (isOverriddenByExistingDefinition(beanMethod, beanName)) {\n \t\t\tif (beanName.equals(beanMethod.getConfigurationClass().getBeanName())) {\n \t\t\t\tthrow new BeanDefinitionStoreException(beanMethod.getConfigurationClass().getResource().getDescription(),\n \t\t\t\t\t\tbeanName, \"Bean name derived from @Bean method '\" + beanMethod.getMetadata().getMethodName() +\n \t\t\t\t\t\t\"' clashes with bean name for containing configuration class; please make those names unique!\");\n \t\t\t}\n \t\t\treturn;\n \t\t}\n \n \t\tConfigurationClassBeanDefinition beanDef = new ConfigurationClassBeanDefinition(configClass, metadata);\n \t\tbeanDef.setResource(configClass.getResource());\n \t\tbeanDef.setSource(this.sourceExtractor.extractSource(metadata, configClass.getResource()));\n \n \t\tif (metadata.isStatic()) {\n \t\t\t// static @Bean method\n \t\t\tbeanDef.setBeanClassName(configClass.getMetadata().getClassName());\n \t\t\tbeanDef.setFactoryMethodName(methodName);\n \t\t}\n \t\telse {\n \t\t\t// instance @Bean method\n \t\t\tbeanDef.setFactoryBeanName(configClass.getBeanName());\n \t\t\tbeanDef.setUniqueFactoryMethodName(methodName);\n \t\t}\n \t\tbeanDef.setAutowireMode(RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n \t\tbeanDef.setAttribute(org.springframework.beans.factory.annotation.RequiredAnnotationBeanPostProcessor.\n \t\t\t\tSKIP_REQUIRED_CHECK_ATTRIBUTE, Boolean.TRUE);\n \n \t\tAnnotationConfigUtils.processCommonDefinitionAnnotations(beanDef, metadata);\n \n \t\tAutowire autowire = bean.getEnum(\"autowire\");\n \t\tif (autowire.isAutowire()) {\n \t\t\tbeanDef.setAutowireMode(autowire.value());\n \t\t}\n \n+\t\tboolean autowireCandidate = bean.getBoolean(\"autowireCandidate\");\n+\t\tif (!autowireCandidate) {\n+\t\t\tbeanDef.setAutowireCandidate(false);\n+\t\t}\n+\n \t\tString initMethodName = bean.getString(\"initMethod\");\n \t\tif (StringUtils.hasText(initMethodName)) {\n \t\t\tbeanDef.setInitMethodName(initMethodName);\n \t\t}\n \n \t\tString destroyMethodName = bean.getString(\"destroyMethod\");\n \t\tbeanDef.setDestroyMethodName(destroyMethodName);\n \n \t\t// Consider scoping\n \t\tScopedProxyMode proxyMode = ScopedProxyMode.NO;\n \t\tAnnotationAttributes attributes = AnnotationConfigUtils.attributesFor(metadata, Scope.class);\n \t\tif (attributes != null) {\n \t\t\tbeanDef.setScope(attributes.getString(\"value\"));\n \t\t\tproxyMode = attributes.getEnum(\"proxyMode\");\n \t\t\tif (proxyMode == ScopedProxyMode.DEFAULT) {\n \t\t\t\tproxyMode = ScopedProxyMode.NO;\n \t\t\t}\n \t\t}\n \n \t\t// Replace the original bean definition with the target one, if necessary\n \t\tBeanDefinition beanDefToRegister = beanDef;\n \t\tif (proxyMode != ScopedProxyMode.NO) {\n \t\t\tBeanDefinitionHolder proxyDef = ScopedProxyCreator.createScopedProxy(\n \t\t\t\t\tnew BeanDefinitionHolder(beanDef, beanName), this.registry,\n \t\t\t\t\tproxyMode == ScopedProxyMode.TARGET_CLASS);\n \t\t\tbeanDefToRegister = new ConfigurationClassBeanDefinition(\n \t\t\t\t\t(RootBeanDefinition) proxyDef.getBeanDefinition(), configClass, metadata);\n \t\t}\n \n \t\tif (logger.isDebugEnabled()) {\n \t\t\tlogger.debug(String.format(\"Registering bean definition for @Bean method %s.%s()\",\n \t\t\t\t\tconfigClass.getMetadata().getClassName(), beanName));\n \t\t}\n \n \t\tthis.registry.registerBeanDefinition(beanName, beanDefToRegister);\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"81cb740e0ae23b6bd167f5c42ceae8294a27a14a": {
			"type": "Ybodychange",
			"commitMessage": "New postProcessProperties variant on InstantiationAwareBeanPostProcessor\n\nAllows for skipping the now-deprecated postProcessPropertyValues callback with its expensive PropertyDescriptor retrieval requirement. RequiredAnnotationBeanPostProcessor (which is dependent on postProcessPropertyValues) and the @Required annotation itself are also deprecated now: in favor of constructor injection (or afterPropertiesSet).\n\nIssue: SPR-16918\n",
			"commitDate": "2018-06-28, 5:15 AM",
			"commitName": "81cb740e0ae23b6bd167f5c42ceae8294a27a14a",
			"commitAuthor": "Juergen Hoeller",
			"commitDateOld": "2018-05-02, 6:20 AM",
			"commitNameOld": "c8b6233bd03d43c8a91ec197e9cf1ea15bba478c",
			"commitAuthorOld": "Juergen Hoeller",
			"daysBetweenCommits": 56.95,
			"commitsBetweenForRepo": 241,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,96 +1,97 @@\n \tprivate void loadBeanDefinitionsForBeanMethod(BeanMethod beanMethod) {\n \t\tConfigurationClass configClass = beanMethod.getConfigurationClass();\n \t\tMethodMetadata metadata = beanMethod.getMetadata();\n \t\tString methodName = metadata.getMethodName();\n \n \t\t// Do we need to mark the bean as skipped by its condition?\n \t\tif (this.conditionEvaluator.shouldSkip(metadata, ConfigurationPhase.REGISTER_BEAN)) {\n \t\t\tconfigClass.skippedBeanMethods.add(methodName);\n \t\t\treturn;\n \t\t}\n \t\tif (configClass.skippedBeanMethods.contains(methodName)) {\n \t\t\treturn;\n \t\t}\n \n \t\tAnnotationAttributes bean = AnnotationConfigUtils.attributesFor(metadata, Bean.class);\n \t\tAssert.state(bean != null, \"No @Bean annotation attributes\");\n \n \t\t// Consider name and any aliases\n \t\tList<String> names = new ArrayList<>(Arrays.asList(bean.getStringArray(\"name\")));\n \t\tString beanName = (!names.isEmpty() ? names.remove(0) : methodName);\n \n \t\t// Register aliases even when overridden\n \t\tfor (String alias : names) {\n \t\t\tthis.registry.registerAlias(beanName, alias);\n \t\t}\n \n \t\t// Has this effectively been overridden before (e.g. via XML)?\n \t\tif (isOverriddenByExistingDefinition(beanMethod, beanName)) {\n \t\t\tif (beanName.equals(beanMethod.getConfigurationClass().getBeanName())) {\n \t\t\t\tthrow new BeanDefinitionStoreException(beanMethod.getConfigurationClass().getResource().getDescription(),\n \t\t\t\t\t\tbeanName, \"Bean name derived from @Bean method '\" + beanMethod.getMetadata().getMethodName() +\n \t\t\t\t\t\t\"' clashes with bean name for containing configuration class; please make those names unique!\");\n \t\t\t}\n \t\t\treturn;\n \t\t}\n \n \t\tConfigurationClassBeanDefinition beanDef = new ConfigurationClassBeanDefinition(configClass, metadata);\n \t\tbeanDef.setResource(configClass.getResource());\n \t\tbeanDef.setSource(this.sourceExtractor.extractSource(metadata, configClass.getResource()));\n \n \t\tif (metadata.isStatic()) {\n \t\t\t// static @Bean method\n \t\t\tbeanDef.setBeanClassName(configClass.getMetadata().getClassName());\n \t\t\tbeanDef.setFactoryMethodName(methodName);\n \t\t}\n \t\telse {\n \t\t\t// instance @Bean method\n \t\t\tbeanDef.setFactoryBeanName(configClass.getBeanName());\n \t\t\tbeanDef.setUniqueFactoryMethodName(methodName);\n \t\t}\n \t\tbeanDef.setAutowireMode(RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n-\t\tbeanDef.setAttribute(RequiredAnnotationBeanPostProcessor.SKIP_REQUIRED_CHECK_ATTRIBUTE, Boolean.TRUE);\n+\t\tbeanDef.setAttribute(org.springframework.beans.factory.annotation.RequiredAnnotationBeanPostProcessor.\n+\t\t\t\tSKIP_REQUIRED_CHECK_ATTRIBUTE, Boolean.TRUE);\n \n \t\tAnnotationConfigUtils.processCommonDefinitionAnnotations(beanDef, metadata);\n \n \t\tAutowire autowire = bean.getEnum(\"autowire\");\n \t\tif (autowire.isAutowire()) {\n \t\t\tbeanDef.setAutowireMode(autowire.value());\n \t\t}\n \n \t\tString initMethodName = bean.getString(\"initMethod\");\n \t\tif (StringUtils.hasText(initMethodName)) {\n \t\t\tbeanDef.setInitMethodName(initMethodName);\n \t\t}\n \n \t\tString destroyMethodName = bean.getString(\"destroyMethod\");\n \t\tbeanDef.setDestroyMethodName(destroyMethodName);\n \n \t\t// Consider scoping\n \t\tScopedProxyMode proxyMode = ScopedProxyMode.NO;\n \t\tAnnotationAttributes attributes = AnnotationConfigUtils.attributesFor(metadata, Scope.class);\n \t\tif (attributes != null) {\n \t\t\tbeanDef.setScope(attributes.getString(\"value\"));\n \t\t\tproxyMode = attributes.getEnum(\"proxyMode\");\n \t\t\tif (proxyMode == ScopedProxyMode.DEFAULT) {\n \t\t\t\tproxyMode = ScopedProxyMode.NO;\n \t\t\t}\n \t\t}\n \n \t\t// Replace the original bean definition with the target one, if necessary\n \t\tBeanDefinition beanDefToRegister = beanDef;\n \t\tif (proxyMode != ScopedProxyMode.NO) {\n \t\t\tBeanDefinitionHolder proxyDef = ScopedProxyCreator.createScopedProxy(\n \t\t\t\t\tnew BeanDefinitionHolder(beanDef, beanName), this.registry,\n \t\t\t\t\tproxyMode == ScopedProxyMode.TARGET_CLASS);\n \t\t\tbeanDefToRegister = new ConfigurationClassBeanDefinition(\n \t\t\t\t\t(RootBeanDefinition) proxyDef.getBeanDefinition(), configClass, metadata);\n \t\t}\n \n \t\tif (logger.isDebugEnabled()) {\n \t\t\tlogger.debug(String.format(\"Registering bean definition for @Bean method %s.%s()\",\n \t\t\t\t\tconfigClass.getMetadata().getClassName(), beanName));\n \t\t}\n \n \t\tthis.registry.registerBeanDefinition(beanName, beanDefToRegister);\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"bca5a362168e2dad27f273966857fb2f6b9fcd88": {
			"type": "Ybodychange",
			"commitMessage": "Explicit error message for bean name clash with containing configuration class\n\nIssue: SPR-15775\n",
			"commitDate": "2017-07-17, 3:54 PM",
			"commitName": "bca5a362168e2dad27f273966857fb2f6b9fcd88",
			"commitAuthor": "Juergen Hoeller",
			"commitDateOld": "2017-06-11, 11:53 PM",
			"commitNameOld": "27aabb15f9c54f0d495989c917ef65a7b1235845",
			"commitAuthorOld": "Stephane Nicoll",
			"daysBetweenCommits": 35.67,
			"commitsBetweenForRepo": 221,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,91 +1,96 @@\n \tprivate void loadBeanDefinitionsForBeanMethod(BeanMethod beanMethod) {\n \t\tConfigurationClass configClass = beanMethod.getConfigurationClass();\n \t\tMethodMetadata metadata = beanMethod.getMetadata();\n \t\tString methodName = metadata.getMethodName();\n \n \t\t// Do we need to mark the bean as skipped by its condition?\n \t\tif (this.conditionEvaluator.shouldSkip(metadata, ConfigurationPhase.REGISTER_BEAN)) {\n \t\t\tconfigClass.skippedBeanMethods.add(methodName);\n \t\t\treturn;\n \t\t}\n \t\tif (configClass.skippedBeanMethods.contains(methodName)) {\n \t\t\treturn;\n \t\t}\n \n \t\tAnnotationAttributes bean = AnnotationConfigUtils.attributesFor(metadata, Bean.class);\n \t\tAssert.state(bean != null, \"No @Bean annotation attributes\");\n \n \t\t// Consider name and any aliases\n \t\tList<String> names = new ArrayList<>(Arrays.asList(bean.getStringArray(\"name\")));\n \t\tString beanName = (!names.isEmpty() ? names.remove(0) : methodName);\n \n \t\t// Register aliases even when overridden\n \t\tfor (String alias : names) {\n \t\t\tthis.registry.registerAlias(beanName, alias);\n \t\t}\n \n \t\t// Has this effectively been overridden before (e.g. via XML)?\n \t\tif (isOverriddenByExistingDefinition(beanMethod, beanName)) {\n+\t\t\tif (beanName.equals(beanMethod.getConfigurationClass().getBeanName())) {\n+\t\t\t\tthrow new BeanDefinitionStoreException(beanMethod.getConfigurationClass().getResource().getDescription(),\n+\t\t\t\t\t\tbeanName, \"Bean name derived from @Bean method '\" + beanMethod.getMetadata().getMethodName() +\n+\t\t\t\t\t\t\"' clashes with bean name for containing configuration class; please make those names unique!\");\n+\t\t\t}\n \t\t\treturn;\n \t\t}\n \n \t\tConfigurationClassBeanDefinition beanDef = new ConfigurationClassBeanDefinition(configClass, metadata);\n \t\tbeanDef.setResource(configClass.getResource());\n \t\tbeanDef.setSource(this.sourceExtractor.extractSource(metadata, configClass.getResource()));\n \n \t\tif (metadata.isStatic()) {\n \t\t\t// static @Bean method\n \t\t\tbeanDef.setBeanClassName(configClass.getMetadata().getClassName());\n \t\t\tbeanDef.setFactoryMethodName(methodName);\n \t\t}\n \t\telse {\n \t\t\t// instance @Bean method\n \t\t\tbeanDef.setFactoryBeanName(configClass.getBeanName());\n \t\t\tbeanDef.setUniqueFactoryMethodName(methodName);\n \t\t}\n \t\tbeanDef.setAutowireMode(RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n \t\tbeanDef.setAttribute(RequiredAnnotationBeanPostProcessor.SKIP_REQUIRED_CHECK_ATTRIBUTE, Boolean.TRUE);\n \n \t\tAnnotationConfigUtils.processCommonDefinitionAnnotations(beanDef, metadata);\n \n \t\tAutowire autowire = bean.getEnum(\"autowire\");\n \t\tif (autowire.isAutowire()) {\n \t\t\tbeanDef.setAutowireMode(autowire.value());\n \t\t}\n \n \t\tString initMethodName = bean.getString(\"initMethod\");\n \t\tif (StringUtils.hasText(initMethodName)) {\n \t\t\tbeanDef.setInitMethodName(initMethodName);\n \t\t}\n \n \t\tString destroyMethodName = bean.getString(\"destroyMethod\");\n \t\tbeanDef.setDestroyMethodName(destroyMethodName);\n \n \t\t// Consider scoping\n \t\tScopedProxyMode proxyMode = ScopedProxyMode.NO;\n \t\tAnnotationAttributes attributes = AnnotationConfigUtils.attributesFor(metadata, Scope.class);\n \t\tif (attributes != null) {\n \t\t\tbeanDef.setScope(attributes.getString(\"value\"));\n \t\t\tproxyMode = attributes.getEnum(\"proxyMode\");\n \t\t\tif (proxyMode == ScopedProxyMode.DEFAULT) {\n \t\t\t\tproxyMode = ScopedProxyMode.NO;\n \t\t\t}\n \t\t}\n \n \t\t// Replace the original bean definition with the target one, if necessary\n \t\tBeanDefinition beanDefToRegister = beanDef;\n \t\tif (proxyMode != ScopedProxyMode.NO) {\n \t\t\tBeanDefinitionHolder proxyDef = ScopedProxyCreator.createScopedProxy(\n \t\t\t\t\tnew BeanDefinitionHolder(beanDef, beanName), this.registry,\n \t\t\t\t\tproxyMode == ScopedProxyMode.TARGET_CLASS);\n \t\t\tbeanDefToRegister = new ConfigurationClassBeanDefinition(\n \t\t\t\t\t(RootBeanDefinition) proxyDef.getBeanDefinition(), configClass, metadata);\n \t\t}\n \n \t\tif (logger.isDebugEnabled()) {\n \t\t\tlogger.debug(String.format(\"Registering bean definition for @Bean method %s.%s()\",\n \t\t\t\t\tconfigClass.getMetadata().getClassName(), beanName));\n \t\t}\n \n \t\tthis.registry.registerBeanDefinition(beanName, beanDefToRegister);\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"f813712f5b413b354560cd7cc006352e9defa9a3": {
			"type": "Ybodychange",
			"commitMessage": "Consistent use of @Nullable across the codebase (even for internals)\n\nBeyond just formally declaring the current behavior, this revision actually enforces non-null behavior in selected signatures now, not tolerating null values anymore when not explicitly documented. It also changes some utility methods with historic null-in/null-out tolerance towards enforced non-null return values, making them a proper citizen in non-null assignments.\n\nSome issues are left as to-do: in particular a thorough revision of spring-test, and a few tests with unclear failures (ignored as \"TODO: NULLABLE\") to be sorted out in a follow-up commit.\n\nIssue: SPR-15540\n",
			"commitDate": "2017-06-07, 5:19 AM",
			"commitName": "f813712f5b413b354560cd7cc006352e9defa9a3",
			"commitAuthor": "Juergen Hoeller",
			"commitDateOld": "2017-05-31, 1:51 PM",
			"commitNameOld": "b494c53b40a76a3ce01a54b1bd384b6809f1a147",
			"commitAuthorOld": "Sebastien Deleuze",
			"daysBetweenCommits": 6.64,
			"commitsBetweenForRepo": 25,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,91 +1,91 @@\n \tprivate void loadBeanDefinitionsForBeanMethod(BeanMethod beanMethod) {\n \t\tConfigurationClass configClass = beanMethod.getConfigurationClass();\n \t\tMethodMetadata metadata = beanMethod.getMetadata();\n \t\tString methodName = metadata.getMethodName();\n \n \t\t// Do we need to mark the bean as skipped by its condition?\n \t\tif (this.conditionEvaluator.shouldSkip(metadata, ConfigurationPhase.REGISTER_BEAN)) {\n \t\t\tconfigClass.skippedBeanMethods.add(methodName);\n \t\t\treturn;\n \t\t}\n \t\tif (configClass.skippedBeanMethods.contains(methodName)) {\n \t\t\treturn;\n \t\t}\n \n-\t\t// Consider name and any aliases\n \t\tAnnotationAttributes bean = AnnotationConfigUtils.attributesFor(metadata, Bean.class);\n+\t\tAssert.state(bean != null, \"No @Bean annotation attributes\");\n+\n+\t\t// Consider name and any aliases\n \t\tList<String> names = new ArrayList<>(Arrays.asList(bean.getStringArray(\"name\")));\n \t\tString beanName = (!names.isEmpty() ? names.remove(0) : methodName);\n \n \t\t// Register aliases even when overridden\n \t\tfor (String alias : names) {\n \t\t\tthis.registry.registerAlias(beanName, alias);\n \t\t}\n \n \t\t// Has this effectively been overridden before (e.g. via XML)?\n \t\tif (isOverriddenByExistingDefinition(beanMethod, beanName)) {\n \t\t\treturn;\n \t\t}\n \n \t\tConfigurationClassBeanDefinition beanDef = new ConfigurationClassBeanDefinition(configClass, metadata);\n \t\tbeanDef.setResource(configClass.getResource());\n \t\tbeanDef.setSource(this.sourceExtractor.extractSource(metadata, configClass.getResource()));\n \n \t\tif (metadata.isStatic()) {\n \t\t\t// static @Bean method\n \t\t\tbeanDef.setBeanClassName(configClass.getMetadata().getClassName());\n \t\t\tbeanDef.setFactoryMethodName(methodName);\n \t\t}\n \t\telse {\n \t\t\t// instance @Bean method\n \t\t\tbeanDef.setFactoryBeanName(configClass.getBeanName());\n \t\t\tbeanDef.setUniqueFactoryMethodName(methodName);\n \t\t}\n \t\tbeanDef.setAutowireMode(RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n \t\tbeanDef.setAttribute(RequiredAnnotationBeanPostProcessor.SKIP_REQUIRED_CHECK_ATTRIBUTE, Boolean.TRUE);\n \n \t\tAnnotationConfigUtils.processCommonDefinitionAnnotations(beanDef, metadata);\n \n \t\tAutowire autowire = bean.getEnum(\"autowire\");\n \t\tif (autowire.isAutowire()) {\n \t\t\tbeanDef.setAutowireMode(autowire.value());\n \t\t}\n \n \t\tString initMethodName = bean.getString(\"initMethod\");\n \t\tif (StringUtils.hasText(initMethodName)) {\n \t\t\tbeanDef.setInitMethodName(initMethodName);\n \t\t}\n \n \t\tString destroyMethodName = bean.getString(\"destroyMethod\");\n-\t\tif (destroyMethodName != null) {\n-\t\t\tbeanDef.setDestroyMethodName(destroyMethodName);\n-\t\t}\n+\t\tbeanDef.setDestroyMethodName(destroyMethodName);\n \n \t\t// Consider scoping\n \t\tScopedProxyMode proxyMode = ScopedProxyMode.NO;\n \t\tAnnotationAttributes attributes = AnnotationConfigUtils.attributesFor(metadata, Scope.class);\n \t\tif (attributes != null) {\n \t\t\tbeanDef.setScope(attributes.getString(\"value\"));\n \t\t\tproxyMode = attributes.getEnum(\"proxyMode\");\n \t\t\tif (proxyMode == ScopedProxyMode.DEFAULT) {\n \t\t\t\tproxyMode = ScopedProxyMode.NO;\n \t\t\t}\n \t\t}\n \n \t\t// Replace the original bean definition with the target one, if necessary\n \t\tBeanDefinition beanDefToRegister = beanDef;\n \t\tif (proxyMode != ScopedProxyMode.NO) {\n \t\t\tBeanDefinitionHolder proxyDef = ScopedProxyCreator.createScopedProxy(\n \t\t\t\t\tnew BeanDefinitionHolder(beanDef, beanName), this.registry,\n \t\t\t\t\tproxyMode == ScopedProxyMode.TARGET_CLASS);\n \t\t\tbeanDefToRegister = new ConfigurationClassBeanDefinition(\n \t\t\t\t\t(RootBeanDefinition) proxyDef.getBeanDefinition(), configClass, metadata);\n \t\t}\n \n \t\tif (logger.isDebugEnabled()) {\n \t\t\tlogger.debug(String.format(\"Registering bean definition for @Bean method %s.%s()\",\n \t\t\t\t\tconfigClass.getMetadata().getClassName(), beanName));\n \t\t}\n \n \t\tthis.registry.registerBeanDefinition(beanName, beanDefToRegister);\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"e892e02f41031ae18f09aef34bf82d31ddbb12c7": {
			"type": "Ybodychange",
			"commitMessage": "Polishing\n",
			"commitDate": "2017-03-21, 9:44 AM",
			"commitName": "e892e02f41031ae18f09aef34bf82d31ddbb12c7",
			"commitAuthor": "Juergen Hoeller",
			"commitDateOld": "2016-12-09, 6:01 AM",
			"commitNameOld": "a7ec6dc0afb5ad83371ed073a26a31cb9e1dd4f1",
			"commitAuthorOld": "Juergen Hoeller",
			"daysBetweenCommits": 102.11,
			"commitsBetweenForRepo": 642,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,90 +1,90 @@\n \tprivate void loadBeanDefinitionsForBeanMethod(BeanMethod beanMethod) {\n \t\tConfigurationClass configClass = beanMethod.getConfigurationClass();\n \t\tMethodMetadata metadata = beanMethod.getMetadata();\n \t\tString methodName = metadata.getMethodName();\n \n \t\t// Do we need to mark the bean as skipped by its condition?\n \t\tif (this.conditionEvaluator.shouldSkip(metadata, ConfigurationPhase.REGISTER_BEAN)) {\n \t\t\tconfigClass.skippedBeanMethods.add(methodName);\n \t\t\treturn;\n \t\t}\n \t\tif (configClass.skippedBeanMethods.contains(methodName)) {\n \t\t\treturn;\n \t\t}\n \n \t\t// Consider name and any aliases\n \t\tAnnotationAttributes bean = AnnotationConfigUtils.attributesFor(metadata, Bean.class);\n \t\tList<String> names = new ArrayList<>(Arrays.asList(bean.getStringArray(\"name\")));\n-\t\tString beanName = (names.size() > 0 ? names.remove(0) : methodName);\n+\t\tString beanName = (!names.isEmpty() ? names.remove(0) : methodName);\n \n \t\t// Register aliases even when overridden\n \t\tfor (String alias : names) {\n \t\t\tthis.registry.registerAlias(beanName, alias);\n \t\t}\n \n \t\t// Has this effectively been overridden before (e.g. via XML)?\n \t\tif (isOverriddenByExistingDefinition(beanMethod, beanName)) {\n \t\t\treturn;\n \t\t}\n \n \t\tConfigurationClassBeanDefinition beanDef = new ConfigurationClassBeanDefinition(configClass, metadata);\n \t\tbeanDef.setResource(configClass.getResource());\n \t\tbeanDef.setSource(this.sourceExtractor.extractSource(metadata, configClass.getResource()));\n \n \t\tif (metadata.isStatic()) {\n \t\t\t// static @Bean method\n \t\t\tbeanDef.setBeanClassName(configClass.getMetadata().getClassName());\n \t\t\tbeanDef.setFactoryMethodName(methodName);\n \t\t}\n \t\telse {\n \t\t\t// instance @Bean method\n \t\t\tbeanDef.setFactoryBeanName(configClass.getBeanName());\n \t\t\tbeanDef.setUniqueFactoryMethodName(methodName);\n \t\t}\n \t\tbeanDef.setAutowireMode(RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n \t\tbeanDef.setAttribute(RequiredAnnotationBeanPostProcessor.SKIP_REQUIRED_CHECK_ATTRIBUTE, Boolean.TRUE);\n \n \t\tAnnotationConfigUtils.processCommonDefinitionAnnotations(beanDef, metadata);\n \n \t\tAutowire autowire = bean.getEnum(\"autowire\");\n \t\tif (autowire.isAutowire()) {\n \t\t\tbeanDef.setAutowireMode(autowire.value());\n \t\t}\n \n \t\tString initMethodName = bean.getString(\"initMethod\");\n \t\tif (StringUtils.hasText(initMethodName)) {\n \t\t\tbeanDef.setInitMethodName(initMethodName);\n \t\t}\n \n \t\tString destroyMethodName = bean.getString(\"destroyMethod\");\n \t\tif (destroyMethodName != null) {\n \t\t\tbeanDef.setDestroyMethodName(destroyMethodName);\n \t\t}\n \n \t\t// Consider scoping\n \t\tScopedProxyMode proxyMode = ScopedProxyMode.NO;\n \t\tAnnotationAttributes attributes = AnnotationConfigUtils.attributesFor(metadata, Scope.class);\n \t\tif (attributes != null) {\n \t\t\tbeanDef.setScope(attributes.getString(\"value\"));\n \t\t\tproxyMode = attributes.getEnum(\"proxyMode\");\n \t\t\tif (proxyMode == ScopedProxyMode.DEFAULT) {\n \t\t\t\tproxyMode = ScopedProxyMode.NO;\n \t\t\t}\n \t\t}\n \n \t\t// Replace the original bean definition with the target one, if necessary\n \t\tBeanDefinition beanDefToRegister = beanDef;\n \t\tif (proxyMode != ScopedProxyMode.NO) {\n \t\t\tBeanDefinitionHolder proxyDef = ScopedProxyCreator.createScopedProxy(\n \t\t\t\t\tnew BeanDefinitionHolder(beanDef, beanName), this.registry, proxyMode == ScopedProxyMode.TARGET_CLASS);\n \t\t\tbeanDefToRegister = new ConfigurationClassBeanDefinition(\n \t\t\t\t\t(RootBeanDefinition) proxyDef.getBeanDefinition(), configClass, metadata);\n \t\t}\n \n \t\tif (logger.isDebugEnabled()) {\n \t\t\tlogger.debug(String.format(\"Registering bean definition for @Bean method %s.%s()\",\n \t\t\t\t\tconfigClass.getMetadata().getClassName(), beanName));\n \t\t}\n \n \t\tthis.registry.registerBeanDefinition(beanName, beanDefToRegister);\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"3d3407c78992bbb504ae96a8f3eb17dbca07bcc7": {
			"type": "Ybodychange",
			"commitMessage": "Consistent alias processing behind AnnotatedTypeMetadata abstraction (also for ASM)\n\nIssue: SPR-14427\n",
			"commitDate": "2016-07-15, 4:59 AM",
			"commitName": "3d3407c78992bbb504ae96a8f3eb17dbca07bcc7",
			"commitAuthor": "Juergen Hoeller",
			"commitDateOld": "2016-07-05, 8:00 AM",
			"commitNameOld": "00d2606b000f9bdafbd7f4a16b6599fb51b53fa4",
			"commitAuthorOld": "Stephane Nicoll",
			"daysBetweenCommits": 9.87,
			"commitsBetweenForRepo": 122,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,90 +1,90 @@\n \tprivate void loadBeanDefinitionsForBeanMethod(BeanMethod beanMethod) {\n \t\tConfigurationClass configClass = beanMethod.getConfigurationClass();\n \t\tMethodMetadata metadata = beanMethod.getMetadata();\n \t\tString methodName = metadata.getMethodName();\n \n \t\t// Do we need to mark the bean as skipped by its condition?\n \t\tif (this.conditionEvaluator.shouldSkip(metadata, ConfigurationPhase.REGISTER_BEAN)) {\n \t\t\tconfigClass.skippedBeanMethods.add(methodName);\n \t\t\treturn;\n \t\t}\n \t\tif (configClass.skippedBeanMethods.contains(methodName)) {\n \t\t\treturn;\n \t\t}\n \n \t\t// Consider name and any aliases\n \t\tAnnotationAttributes bean = AnnotationConfigUtils.attributesFor(metadata, Bean.class);\n \t\tList<String> names = new ArrayList<>(Arrays.asList(bean.getStringArray(\"name\")));\n \t\tString beanName = (names.size() > 0 ? names.remove(0) : methodName);\n \n \t\t// Register aliases even when overridden\n \t\tfor (String alias : names) {\n \t\t\tthis.registry.registerAlias(beanName, alias);\n \t\t}\n \n \t\t// Has this effectively been overridden before (e.g. via XML)?\n \t\tif (isOverriddenByExistingDefinition(beanMethod, beanName)) {\n \t\t\treturn;\n \t\t}\n \n \t\tConfigurationClassBeanDefinition beanDef = new ConfigurationClassBeanDefinition(configClass, metadata);\n \t\tbeanDef.setResource(configClass.getResource());\n \t\tbeanDef.setSource(this.sourceExtractor.extractSource(metadata, configClass.getResource()));\n \n \t\tif (metadata.isStatic()) {\n \t\t\t// static @Bean method\n \t\t\tbeanDef.setBeanClassName(configClass.getMetadata().getClassName());\n \t\t\tbeanDef.setFactoryMethodName(methodName);\n \t\t}\n \t\telse {\n \t\t\t// instance @Bean method\n \t\t\tbeanDef.setFactoryBeanName(configClass.getBeanName());\n \t\t\tbeanDef.setUniqueFactoryMethodName(methodName);\n \t\t}\n \t\tbeanDef.setAutowireMode(RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n \t\tbeanDef.setAttribute(RequiredAnnotationBeanPostProcessor.SKIP_REQUIRED_CHECK_ATTRIBUTE, Boolean.TRUE);\n \n \t\tAnnotationConfigUtils.processCommonDefinitionAnnotations(beanDef, metadata);\n \n \t\tAutowire autowire = bean.getEnum(\"autowire\");\n \t\tif (autowire.isAutowire()) {\n \t\t\tbeanDef.setAutowireMode(autowire.value());\n \t\t}\n \n \t\tString initMethodName = bean.getString(\"initMethod\");\n \t\tif (StringUtils.hasText(initMethodName)) {\n \t\t\tbeanDef.setInitMethodName(initMethodName);\n \t\t}\n \n \t\tString destroyMethodName = bean.getString(\"destroyMethod\");\n \t\tif (destroyMethodName != null) {\n \t\t\tbeanDef.setDestroyMethodName(destroyMethodName);\n \t\t}\n \n \t\t// Consider scoping\n \t\tScopedProxyMode proxyMode = ScopedProxyMode.NO;\n \t\tAnnotationAttributes attributes = AnnotationConfigUtils.attributesFor(metadata, Scope.class);\n \t\tif (attributes != null) {\n-\t\t\tbeanDef.setScope(attributes.getAliasedString(\"value\", Scope.class, configClass.getResource()));\n+\t\t\tbeanDef.setScope(attributes.getString(\"value\"));\n \t\t\tproxyMode = attributes.getEnum(\"proxyMode\");\n \t\t\tif (proxyMode == ScopedProxyMode.DEFAULT) {\n \t\t\t\tproxyMode = ScopedProxyMode.NO;\n \t\t\t}\n \t\t}\n \n \t\t// Replace the original bean definition with the target one, if necessary\n \t\tBeanDefinition beanDefToRegister = beanDef;\n \t\tif (proxyMode != ScopedProxyMode.NO) {\n \t\t\tBeanDefinitionHolder proxyDef = ScopedProxyCreator.createScopedProxy(\n \t\t\t\t\tnew BeanDefinitionHolder(beanDef, beanName), this.registry, proxyMode == ScopedProxyMode.TARGET_CLASS);\n \t\t\tbeanDefToRegister = new ConfigurationClassBeanDefinition(\n \t\t\t\t\t(RootBeanDefinition) proxyDef.getBeanDefinition(), configClass, metadata);\n \t\t}\n \n \t\tif (logger.isDebugEnabled()) {\n \t\t\tlogger.debug(String.format(\"Registering bean definition for @Bean method %s.%s()\",\n \t\t\t\t\tconfigClass.getMetadata().getClassName(), beanName));\n \t\t}\n \n \t\tthis.registry.registerBeanDefinition(beanName, beanDefToRegister);\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"00d2606b000f9bdafbd7f4a16b6599fb51b53fa4": {
			"type": "Ybodychange",
			"commitMessage": "Explicit type can be replaced by <>\n\nIssue: SPR-13188\n",
			"commitDate": "2016-07-05, 8:00 AM",
			"commitName": "00d2606b000f9bdafbd7f4a16b6599fb51b53fa4",
			"commitAuthor": "Stephane Nicoll",
			"commitDateOld": "2015-07-28, 3:08 AM",
			"commitNameOld": "f0ac2784a4e9602a06bc91c3368f7cf423fc52dc",
			"commitAuthorOld": "Juergen Hoeller",
			"daysBetweenCommits": 343.2,
			"commitsBetweenForRepo": 1426,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,90 +1,90 @@\n \tprivate void loadBeanDefinitionsForBeanMethod(BeanMethod beanMethod) {\n \t\tConfigurationClass configClass = beanMethod.getConfigurationClass();\n \t\tMethodMetadata metadata = beanMethod.getMetadata();\n \t\tString methodName = metadata.getMethodName();\n \n \t\t// Do we need to mark the bean as skipped by its condition?\n \t\tif (this.conditionEvaluator.shouldSkip(metadata, ConfigurationPhase.REGISTER_BEAN)) {\n \t\t\tconfigClass.skippedBeanMethods.add(methodName);\n \t\t\treturn;\n \t\t}\n \t\tif (configClass.skippedBeanMethods.contains(methodName)) {\n \t\t\treturn;\n \t\t}\n \n \t\t// Consider name and any aliases\n \t\tAnnotationAttributes bean = AnnotationConfigUtils.attributesFor(metadata, Bean.class);\n-\t\tList<String> names = new ArrayList<String>(Arrays.asList(bean.getStringArray(\"name\")));\n+\t\tList<String> names = new ArrayList<>(Arrays.asList(bean.getStringArray(\"name\")));\n \t\tString beanName = (names.size() > 0 ? names.remove(0) : methodName);\n \n \t\t// Register aliases even when overridden\n \t\tfor (String alias : names) {\n \t\t\tthis.registry.registerAlias(beanName, alias);\n \t\t}\n \n \t\t// Has this effectively been overridden before (e.g. via XML)?\n \t\tif (isOverriddenByExistingDefinition(beanMethod, beanName)) {\n \t\t\treturn;\n \t\t}\n \n \t\tConfigurationClassBeanDefinition beanDef = new ConfigurationClassBeanDefinition(configClass, metadata);\n \t\tbeanDef.setResource(configClass.getResource());\n \t\tbeanDef.setSource(this.sourceExtractor.extractSource(metadata, configClass.getResource()));\n \n \t\tif (metadata.isStatic()) {\n \t\t\t// static @Bean method\n \t\t\tbeanDef.setBeanClassName(configClass.getMetadata().getClassName());\n \t\t\tbeanDef.setFactoryMethodName(methodName);\n \t\t}\n \t\telse {\n \t\t\t// instance @Bean method\n \t\t\tbeanDef.setFactoryBeanName(configClass.getBeanName());\n \t\t\tbeanDef.setUniqueFactoryMethodName(methodName);\n \t\t}\n \t\tbeanDef.setAutowireMode(RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n \t\tbeanDef.setAttribute(RequiredAnnotationBeanPostProcessor.SKIP_REQUIRED_CHECK_ATTRIBUTE, Boolean.TRUE);\n \n \t\tAnnotationConfigUtils.processCommonDefinitionAnnotations(beanDef, metadata);\n \n \t\tAutowire autowire = bean.getEnum(\"autowire\");\n \t\tif (autowire.isAutowire()) {\n \t\t\tbeanDef.setAutowireMode(autowire.value());\n \t\t}\n \n \t\tString initMethodName = bean.getString(\"initMethod\");\n \t\tif (StringUtils.hasText(initMethodName)) {\n \t\t\tbeanDef.setInitMethodName(initMethodName);\n \t\t}\n \n \t\tString destroyMethodName = bean.getString(\"destroyMethod\");\n \t\tif (destroyMethodName != null) {\n \t\t\tbeanDef.setDestroyMethodName(destroyMethodName);\n \t\t}\n \n \t\t// Consider scoping\n \t\tScopedProxyMode proxyMode = ScopedProxyMode.NO;\n \t\tAnnotationAttributes attributes = AnnotationConfigUtils.attributesFor(metadata, Scope.class);\n \t\tif (attributes != null) {\n \t\t\tbeanDef.setScope(attributes.getAliasedString(\"value\", Scope.class, configClass.getResource()));\n \t\t\tproxyMode = attributes.getEnum(\"proxyMode\");\n \t\t\tif (proxyMode == ScopedProxyMode.DEFAULT) {\n \t\t\t\tproxyMode = ScopedProxyMode.NO;\n \t\t\t}\n \t\t}\n \n \t\t// Replace the original bean definition with the target one, if necessary\n \t\tBeanDefinition beanDefToRegister = beanDef;\n \t\tif (proxyMode != ScopedProxyMode.NO) {\n \t\t\tBeanDefinitionHolder proxyDef = ScopedProxyCreator.createScopedProxy(\n \t\t\t\t\tnew BeanDefinitionHolder(beanDef, beanName), this.registry, proxyMode == ScopedProxyMode.TARGET_CLASS);\n \t\t\tbeanDefToRegister = new ConfigurationClassBeanDefinition(\n \t\t\t\t\t(RootBeanDefinition) proxyDef.getBeanDefinition(), configClass, metadata);\n \t\t}\n \n \t\tif (logger.isDebugEnabled()) {\n \t\t\tlogger.debug(String.format(\"Registering bean definition for @Bean method %s.%s()\",\n \t\t\t\t\tconfigClass.getMetadata().getClassName(), beanName));\n \t\t}\n \n \t\tthis.registry.registerBeanDefinition(beanName, beanDefToRegister);\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"f0ac2784a4e9602a06bc91c3368f7cf423fc52dc": {
			"type": "Ybodychange",
			"commitMessage": "Removed unused fields from ConfigurationClassBeanDefinitionReader\n\nIssue: SPR-11740\nIssue: SPR-13280\n",
			"commitDate": "2015-07-28, 3:08 AM",
			"commitName": "f0ac2784a4e9602a06bc91c3368f7cf423fc52dc",
			"commitAuthor": "Juergen Hoeller",
			"commitDateOld": "2015-07-25, 12:53 PM",
			"commitNameOld": "aae0bd2fb43092bd3e1bc5c3296265e760b4fc43",
			"commitAuthorOld": "Sam Brannen",
			"daysBetweenCommits": 2.59,
			"commitsBetweenForRepo": 26,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,92 +1,90 @@\n \tprivate void loadBeanDefinitionsForBeanMethod(BeanMethod beanMethod) {\n \t\tConfigurationClass configClass = beanMethod.getConfigurationClass();\n \t\tMethodMetadata metadata = beanMethod.getMetadata();\n \t\tString methodName = metadata.getMethodName();\n \n \t\t// Do we need to mark the bean as skipped by its condition?\n \t\tif (this.conditionEvaluator.shouldSkip(metadata, ConfigurationPhase.REGISTER_BEAN)) {\n \t\t\tconfigClass.skippedBeanMethods.add(methodName);\n \t\t\treturn;\n \t\t}\n \t\tif (configClass.skippedBeanMethods.contains(methodName)) {\n \t\t\treturn;\n \t\t}\n \n \t\t// Consider name and any aliases\n \t\tAnnotationAttributes bean = AnnotationConfigUtils.attributesFor(metadata, Bean.class);\n \t\tList<String> names = new ArrayList<String>(Arrays.asList(bean.getStringArray(\"name\")));\n \t\tString beanName = (names.size() > 0 ? names.remove(0) : methodName);\n \n \t\t// Register aliases even when overridden\n \t\tfor (String alias : names) {\n \t\t\tthis.registry.registerAlias(beanName, alias);\n \t\t}\n \n \t\t// Has this effectively been overridden before (e.g. via XML)?\n \t\tif (isOverriddenByExistingDefinition(beanMethod, beanName)) {\n \t\t\treturn;\n \t\t}\n \n \t\tConfigurationClassBeanDefinition beanDef = new ConfigurationClassBeanDefinition(configClass, metadata);\n \t\tbeanDef.setResource(configClass.getResource());\n \t\tbeanDef.setSource(this.sourceExtractor.extractSource(metadata, configClass.getResource()));\n \n \t\tif (metadata.isStatic()) {\n \t\t\t// static @Bean method\n \t\t\tbeanDef.setBeanClassName(configClass.getMetadata().getClassName());\n \t\t\tbeanDef.setFactoryMethodName(methodName);\n \t\t}\n \t\telse {\n \t\t\t// instance @Bean method\n \t\t\tbeanDef.setFactoryBeanName(configClass.getBeanName());\n \t\t\tbeanDef.setUniqueFactoryMethodName(methodName);\n \t\t}\n \t\tbeanDef.setAutowireMode(RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n \t\tbeanDef.setAttribute(RequiredAnnotationBeanPostProcessor.SKIP_REQUIRED_CHECK_ATTRIBUTE, Boolean.TRUE);\n \n \t\tAnnotationConfigUtils.processCommonDefinitionAnnotations(beanDef, metadata);\n \n \t\tAutowire autowire = bean.getEnum(\"autowire\");\n \t\tif (autowire.isAutowire()) {\n \t\t\tbeanDef.setAutowireMode(autowire.value());\n \t\t}\n \n \t\tString initMethodName = bean.getString(\"initMethod\");\n \t\tif (StringUtils.hasText(initMethodName)) {\n \t\t\tbeanDef.setInitMethodName(initMethodName);\n \t\t}\n \n \t\tString destroyMethodName = bean.getString(\"destroyMethod\");\n \t\tif (destroyMethodName != null) {\n \t\t\tbeanDef.setDestroyMethodName(destroyMethodName);\n \t\t}\n \n \t\t// Consider scoping\n \t\tScopedProxyMode proxyMode = ScopedProxyMode.NO;\n-\t\t// TODO [SPR-13280] Determine why type is hard coded to org.springframework.context.annotation.Scope,\n-\t\t// since AnnotationScopeMetadataResolver supports a custom scope annotation type.\n \t\tAnnotationAttributes attributes = AnnotationConfigUtils.attributesFor(metadata, Scope.class);\n \t\tif (attributes != null) {\n \t\t\tbeanDef.setScope(attributes.getAliasedString(\"value\", Scope.class, configClass.getResource()));\n \t\t\tproxyMode = attributes.getEnum(\"proxyMode\");\n \t\t\tif (proxyMode == ScopedProxyMode.DEFAULT) {\n \t\t\t\tproxyMode = ScopedProxyMode.NO;\n \t\t\t}\n \t\t}\n \n \t\t// Replace the original bean definition with the target one, if necessary\n \t\tBeanDefinition beanDefToRegister = beanDef;\n \t\tif (proxyMode != ScopedProxyMode.NO) {\n \t\t\tBeanDefinitionHolder proxyDef = ScopedProxyCreator.createScopedProxy(\n \t\t\t\t\tnew BeanDefinitionHolder(beanDef, beanName), this.registry, proxyMode == ScopedProxyMode.TARGET_CLASS);\n \t\t\tbeanDefToRegister = new ConfigurationClassBeanDefinition(\n \t\t\t\t\t(RootBeanDefinition) proxyDef.getBeanDefinition(), configClass, metadata);\n \t\t}\n \n \t\tif (logger.isDebugEnabled()) {\n \t\t\tlogger.debug(String.format(\"Registering bean definition for @Bean method %s.%s()\",\n \t\t\t\t\tconfigClass.getMetadata().getClassName(), beanName));\n \t\t}\n \n \t\tthis.registry.registerBeanDefinition(beanName, beanDefToRegister);\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"aae0bd2fb43092bd3e1bc5c3296265e760b4fc43": {
			"type": "Ybodychange",
			"commitMessage": "Update TODO for SPR-13280\n",
			"commitDate": "2015-07-25, 12:53 PM",
			"commitName": "aae0bd2fb43092bd3e1bc5c3296265e760b4fc43",
			"commitAuthor": "Sam Brannen",
			"commitDateOld": "2015-06-13, 7:07 AM",
			"commitNameOld": "2d23f42609c2e6a2ee6b0507f4b800870a63ca26",
			"commitAuthorOld": "Sam Brannen",
			"daysBetweenCommits": 42.24,
			"commitsBetweenForRepo": 280,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,92 +1,92 @@\n \tprivate void loadBeanDefinitionsForBeanMethod(BeanMethod beanMethod) {\n \t\tConfigurationClass configClass = beanMethod.getConfigurationClass();\n \t\tMethodMetadata metadata = beanMethod.getMetadata();\n \t\tString methodName = metadata.getMethodName();\n \n \t\t// Do we need to mark the bean as skipped by its condition?\n \t\tif (this.conditionEvaluator.shouldSkip(metadata, ConfigurationPhase.REGISTER_BEAN)) {\n \t\t\tconfigClass.skippedBeanMethods.add(methodName);\n \t\t\treturn;\n \t\t}\n \t\tif (configClass.skippedBeanMethods.contains(methodName)) {\n \t\t\treturn;\n \t\t}\n \n \t\t// Consider name and any aliases\n \t\tAnnotationAttributes bean = AnnotationConfigUtils.attributesFor(metadata, Bean.class);\n \t\tList<String> names = new ArrayList<String>(Arrays.asList(bean.getStringArray(\"name\")));\n \t\tString beanName = (names.size() > 0 ? names.remove(0) : methodName);\n \n \t\t// Register aliases even when overridden\n \t\tfor (String alias : names) {\n \t\t\tthis.registry.registerAlias(beanName, alias);\n \t\t}\n \n \t\t// Has this effectively been overridden before (e.g. via XML)?\n \t\tif (isOverriddenByExistingDefinition(beanMethod, beanName)) {\n \t\t\treturn;\n \t\t}\n \n \t\tConfigurationClassBeanDefinition beanDef = new ConfigurationClassBeanDefinition(configClass, metadata);\n \t\tbeanDef.setResource(configClass.getResource());\n \t\tbeanDef.setSource(this.sourceExtractor.extractSource(metadata, configClass.getResource()));\n \n \t\tif (metadata.isStatic()) {\n \t\t\t// static @Bean method\n \t\t\tbeanDef.setBeanClassName(configClass.getMetadata().getClassName());\n \t\t\tbeanDef.setFactoryMethodName(methodName);\n \t\t}\n \t\telse {\n \t\t\t// instance @Bean method\n \t\t\tbeanDef.setFactoryBeanName(configClass.getBeanName());\n \t\t\tbeanDef.setUniqueFactoryMethodName(methodName);\n \t\t}\n \t\tbeanDef.setAutowireMode(RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n \t\tbeanDef.setAttribute(RequiredAnnotationBeanPostProcessor.SKIP_REQUIRED_CHECK_ATTRIBUTE, Boolean.TRUE);\n \n \t\tAnnotationConfigUtils.processCommonDefinitionAnnotations(beanDef, metadata);\n \n \t\tAutowire autowire = bean.getEnum(\"autowire\");\n \t\tif (autowire.isAutowire()) {\n \t\t\tbeanDef.setAutowireMode(autowire.value());\n \t\t}\n \n \t\tString initMethodName = bean.getString(\"initMethod\");\n \t\tif (StringUtils.hasText(initMethodName)) {\n \t\t\tbeanDef.setInitMethodName(initMethodName);\n \t\t}\n \n \t\tString destroyMethodName = bean.getString(\"destroyMethod\");\n \t\tif (destroyMethodName != null) {\n \t\t\tbeanDef.setDestroyMethodName(destroyMethodName);\n \t\t}\n \n \t\t// Consider scoping\n \t\tScopedProxyMode proxyMode = ScopedProxyMode.NO;\n-\t\t// TODO Determine why type is hard coded to org.springframework.context.annotation.Scope,\n+\t\t// TODO [SPR-13280] Determine why type is hard coded to org.springframework.context.annotation.Scope,\n \t\t// since AnnotationScopeMetadataResolver supports a custom scope annotation type.\n \t\tAnnotationAttributes attributes = AnnotationConfigUtils.attributesFor(metadata, Scope.class);\n \t\tif (attributes != null) {\n \t\t\tbeanDef.setScope(attributes.getAliasedString(\"value\", Scope.class, configClass.getResource()));\n \t\t\tproxyMode = attributes.getEnum(\"proxyMode\");\n \t\t\tif (proxyMode == ScopedProxyMode.DEFAULT) {\n \t\t\t\tproxyMode = ScopedProxyMode.NO;\n \t\t\t}\n \t\t}\n \n \t\t// Replace the original bean definition with the target one, if necessary\n \t\tBeanDefinition beanDefToRegister = beanDef;\n \t\tif (proxyMode != ScopedProxyMode.NO) {\n \t\t\tBeanDefinitionHolder proxyDef = ScopedProxyCreator.createScopedProxy(\n \t\t\t\t\tnew BeanDefinitionHolder(beanDef, beanName), this.registry, proxyMode == ScopedProxyMode.TARGET_CLASS);\n \t\t\tbeanDefToRegister = new ConfigurationClassBeanDefinition(\n \t\t\t\t\t(RootBeanDefinition) proxyDef.getBeanDefinition(), configClass, metadata);\n \t\t}\n \n \t\tif (logger.isDebugEnabled()) {\n \t\t\tlogger.debug(String.format(\"Registering bean definition for @Bean method %s.%s()\",\n \t\t\t\t\tconfigClass.getMetadata().getClassName(), beanName));\n \t\t}\n \n \t\tthis.registry.registerBeanDefinition(beanName, beanDefToRegister);\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"2d23f42609c2e6a2ee6b0507f4b800870a63ca26": {
			"type": "Ybodychange",
			"commitMessage": "Introduce alias for 'value' attribute in @Scope\n\nIssue: SPR-11393\n",
			"commitDate": "2015-06-13, 7:07 AM",
			"commitName": "2d23f42609c2e6a2ee6b0507f4b800870a63ca26",
			"commitAuthor": "Sam Brannen",
			"commitDateOld": "2015-05-20, 8:19 AM",
			"commitNameOld": "0ed9ca097bb499b46c67d34d59e08a1337758097",
			"commitAuthorOld": "Stephane Nicoll",
			"daysBetweenCommits": 23.95,
			"commitsBetweenForRepo": 142,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,90 +1,92 @@\n \tprivate void loadBeanDefinitionsForBeanMethod(BeanMethod beanMethod) {\n \t\tConfigurationClass configClass = beanMethod.getConfigurationClass();\n \t\tMethodMetadata metadata = beanMethod.getMetadata();\n \t\tString methodName = metadata.getMethodName();\n \n \t\t// Do we need to mark the bean as skipped by its condition?\n \t\tif (this.conditionEvaluator.shouldSkip(metadata, ConfigurationPhase.REGISTER_BEAN)) {\n \t\t\tconfigClass.skippedBeanMethods.add(methodName);\n \t\t\treturn;\n \t\t}\n \t\tif (configClass.skippedBeanMethods.contains(methodName)) {\n \t\t\treturn;\n \t\t}\n \n \t\t// Consider name and any aliases\n \t\tAnnotationAttributes bean = AnnotationConfigUtils.attributesFor(metadata, Bean.class);\n \t\tList<String> names = new ArrayList<String>(Arrays.asList(bean.getStringArray(\"name\")));\n \t\tString beanName = (names.size() > 0 ? names.remove(0) : methodName);\n \n \t\t// Register aliases even when overridden\n \t\tfor (String alias : names) {\n \t\t\tthis.registry.registerAlias(beanName, alias);\n \t\t}\n \n \t\t// Has this effectively been overridden before (e.g. via XML)?\n \t\tif (isOverriddenByExistingDefinition(beanMethod, beanName)) {\n \t\t\treturn;\n \t\t}\n \n \t\tConfigurationClassBeanDefinition beanDef = new ConfigurationClassBeanDefinition(configClass, metadata);\n \t\tbeanDef.setResource(configClass.getResource());\n \t\tbeanDef.setSource(this.sourceExtractor.extractSource(metadata, configClass.getResource()));\n \n \t\tif (metadata.isStatic()) {\n \t\t\t// static @Bean method\n \t\t\tbeanDef.setBeanClassName(configClass.getMetadata().getClassName());\n \t\t\tbeanDef.setFactoryMethodName(methodName);\n \t\t}\n \t\telse {\n \t\t\t// instance @Bean method\n \t\t\tbeanDef.setFactoryBeanName(configClass.getBeanName());\n \t\t\tbeanDef.setUniqueFactoryMethodName(methodName);\n \t\t}\n \t\tbeanDef.setAutowireMode(RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n \t\tbeanDef.setAttribute(RequiredAnnotationBeanPostProcessor.SKIP_REQUIRED_CHECK_ATTRIBUTE, Boolean.TRUE);\n \n \t\tAnnotationConfigUtils.processCommonDefinitionAnnotations(beanDef, metadata);\n \n \t\tAutowire autowire = bean.getEnum(\"autowire\");\n \t\tif (autowire.isAutowire()) {\n \t\t\tbeanDef.setAutowireMode(autowire.value());\n \t\t}\n \n \t\tString initMethodName = bean.getString(\"initMethod\");\n \t\tif (StringUtils.hasText(initMethodName)) {\n \t\t\tbeanDef.setInitMethodName(initMethodName);\n \t\t}\n \n \t\tString destroyMethodName = bean.getString(\"destroyMethod\");\n \t\tif (destroyMethodName != null) {\n \t\t\tbeanDef.setDestroyMethodName(destroyMethodName);\n \t\t}\n \n \t\t// Consider scoping\n \t\tScopedProxyMode proxyMode = ScopedProxyMode.NO;\n-\t\tAnnotationAttributes scope = AnnotationConfigUtils.attributesFor(metadata, Scope.class);\n-\t\tif (scope != null) {\n-\t\t\tbeanDef.setScope(scope.getString(\"value\"));\n-\t\t\tproxyMode = scope.getEnum(\"proxyMode\");\n+\t\t// TODO Determine why type is hard coded to org.springframework.context.annotation.Scope,\n+\t\t// since AnnotationScopeMetadataResolver supports a custom scope annotation type.\n+\t\tAnnotationAttributes attributes = AnnotationConfigUtils.attributesFor(metadata, Scope.class);\n+\t\tif (attributes != null) {\n+\t\t\tbeanDef.setScope(attributes.getAliasedString(\"value\", Scope.class, configClass.getResource()));\n+\t\t\tproxyMode = attributes.getEnum(\"proxyMode\");\n \t\t\tif (proxyMode == ScopedProxyMode.DEFAULT) {\n \t\t\t\tproxyMode = ScopedProxyMode.NO;\n \t\t\t}\n \t\t}\n \n \t\t// Replace the original bean definition with the target one, if necessary\n \t\tBeanDefinition beanDefToRegister = beanDef;\n \t\tif (proxyMode != ScopedProxyMode.NO) {\n \t\t\tBeanDefinitionHolder proxyDef = ScopedProxyCreator.createScopedProxy(\n \t\t\t\t\tnew BeanDefinitionHolder(beanDef, beanName), this.registry, proxyMode == ScopedProxyMode.TARGET_CLASS);\n \t\t\tbeanDefToRegister = new ConfigurationClassBeanDefinition(\n \t\t\t\t\t(RootBeanDefinition) proxyDef.getBeanDefinition(), configClass, metadata);\n \t\t}\n \n \t\tif (logger.isDebugEnabled()) {\n \t\t\tlogger.debug(String.format(\"Registering bean definition for @Bean method %s.%s()\",\n \t\t\t\t\tconfigClass.getMetadata().getClassName(), beanName));\n \t\t}\n \n \t\tthis.registry.registerBeanDefinition(beanName, beanDefToRegister);\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"0ed9ca097bb499b46c67d34d59e08a1337758097": {
			"type": "Ybodychange",
			"commitMessage": "Customize destruction callback for AutoCloseable beans\n\nPreviously, a Bean implementing `AutoCloseable` (or `Closeable`) was\nalways destroyed regardless of its bean definition. In particular, the\ndocumented way of disabling the destruction callback via an empty String\ndid not work.\n\nAutoCloseable beans are now treated pretty much as any other bean: we\nstill use the presence of the interface to optimize the check of a\ndestroy method and we only auto-discover the method name to invoke if\nthe inferred mode is enabled.\n\nIssue: SPR-13022\n",
			"commitDate": "2015-05-20, 8:19 AM",
			"commitName": "0ed9ca097bb499b46c67d34d59e08a1337758097",
			"commitAuthor": "Stephane Nicoll",
			"commitDateOld": "2015-05-20, 5:34 AM",
			"commitNameOld": "b4095c3e1d61fc7279e6b2ca105ec60c3cd7128c",
			"commitAuthorOld": "Juergen Hoeller",
			"daysBetweenCommits": 0.11,
			"commitsBetweenForRepo": 3,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,90 +1,90 @@\n \tprivate void loadBeanDefinitionsForBeanMethod(BeanMethod beanMethod) {\n \t\tConfigurationClass configClass = beanMethod.getConfigurationClass();\n \t\tMethodMetadata metadata = beanMethod.getMetadata();\n \t\tString methodName = metadata.getMethodName();\n \n \t\t// Do we need to mark the bean as skipped by its condition?\n \t\tif (this.conditionEvaluator.shouldSkip(metadata, ConfigurationPhase.REGISTER_BEAN)) {\n \t\t\tconfigClass.skippedBeanMethods.add(methodName);\n \t\t\treturn;\n \t\t}\n \t\tif (configClass.skippedBeanMethods.contains(methodName)) {\n \t\t\treturn;\n \t\t}\n \n \t\t// Consider name and any aliases\n \t\tAnnotationAttributes bean = AnnotationConfigUtils.attributesFor(metadata, Bean.class);\n \t\tList<String> names = new ArrayList<String>(Arrays.asList(bean.getStringArray(\"name\")));\n \t\tString beanName = (names.size() > 0 ? names.remove(0) : methodName);\n \n \t\t// Register aliases even when overridden\n \t\tfor (String alias : names) {\n \t\t\tthis.registry.registerAlias(beanName, alias);\n \t\t}\n \n \t\t// Has this effectively been overridden before (e.g. via XML)?\n \t\tif (isOverriddenByExistingDefinition(beanMethod, beanName)) {\n \t\t\treturn;\n \t\t}\n \n \t\tConfigurationClassBeanDefinition beanDef = new ConfigurationClassBeanDefinition(configClass, metadata);\n \t\tbeanDef.setResource(configClass.getResource());\n \t\tbeanDef.setSource(this.sourceExtractor.extractSource(metadata, configClass.getResource()));\n \n \t\tif (metadata.isStatic()) {\n \t\t\t// static @Bean method\n \t\t\tbeanDef.setBeanClassName(configClass.getMetadata().getClassName());\n \t\t\tbeanDef.setFactoryMethodName(methodName);\n \t\t}\n \t\telse {\n \t\t\t// instance @Bean method\n \t\t\tbeanDef.setFactoryBeanName(configClass.getBeanName());\n \t\t\tbeanDef.setUniqueFactoryMethodName(methodName);\n \t\t}\n \t\tbeanDef.setAutowireMode(RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n \t\tbeanDef.setAttribute(RequiredAnnotationBeanPostProcessor.SKIP_REQUIRED_CHECK_ATTRIBUTE, Boolean.TRUE);\n \n \t\tAnnotationConfigUtils.processCommonDefinitionAnnotations(beanDef, metadata);\n \n \t\tAutowire autowire = bean.getEnum(\"autowire\");\n \t\tif (autowire.isAutowire()) {\n \t\t\tbeanDef.setAutowireMode(autowire.value());\n \t\t}\n \n \t\tString initMethodName = bean.getString(\"initMethod\");\n \t\tif (StringUtils.hasText(initMethodName)) {\n \t\t\tbeanDef.setInitMethodName(initMethodName);\n \t\t}\n \n \t\tString destroyMethodName = bean.getString(\"destroyMethod\");\n-\t\tif (StringUtils.hasText(destroyMethodName)) {\n+\t\tif (destroyMethodName != null) {\n \t\t\tbeanDef.setDestroyMethodName(destroyMethodName);\n \t\t}\n \n \t\t// Consider scoping\n \t\tScopedProxyMode proxyMode = ScopedProxyMode.NO;\n \t\tAnnotationAttributes scope = AnnotationConfigUtils.attributesFor(metadata, Scope.class);\n \t\tif (scope != null) {\n \t\t\tbeanDef.setScope(scope.getString(\"value\"));\n \t\t\tproxyMode = scope.getEnum(\"proxyMode\");\n \t\t\tif (proxyMode == ScopedProxyMode.DEFAULT) {\n \t\t\t\tproxyMode = ScopedProxyMode.NO;\n \t\t\t}\n \t\t}\n \n \t\t// Replace the original bean definition with the target one, if necessary\n \t\tBeanDefinition beanDefToRegister = beanDef;\n \t\tif (proxyMode != ScopedProxyMode.NO) {\n \t\t\tBeanDefinitionHolder proxyDef = ScopedProxyCreator.createScopedProxy(\n \t\t\t\t\tnew BeanDefinitionHolder(beanDef, beanName), this.registry, proxyMode == ScopedProxyMode.TARGET_CLASS);\n \t\t\tbeanDefToRegister = new ConfigurationClassBeanDefinition(\n \t\t\t\t\t(RootBeanDefinition) proxyDef.getBeanDefinition(), configClass, metadata);\n \t\t}\n \n \t\tif (logger.isDebugEnabled()) {\n \t\t\tlogger.debug(String.format(\"Registering bean definition for @Bean method %s.%s()\",\n \t\t\t\t\tconfigClass.getMetadata().getClassName(), beanName));\n \t\t}\n \n \t\tthis.registry.registerBeanDefinition(beanName, beanDefToRegister);\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"bb5b5d52edf60350f09cf11c41e6fba534bebb54": {
			"type": "Ybodychange",
			"commitMessage": "Revised condition override check based on method names instead of bean names\n\nIssue: SPR-12744\n",
			"commitDate": "2015-02-25, 9:45 AM",
			"commitName": "bb5b5d52edf60350f09cf11c41e6fba534bebb54",
			"commitAuthor": "Juergen Hoeller",
			"commitDateOld": "2015-02-10, 10:26 AM",
			"commitNameOld": "981aefc2c0d2a6fbf9c08d4d54d17923a75a2e01",
			"commitAuthorOld": "Juergen Hoeller",
			"daysBetweenCommits": 14.97,
			"commitsBetweenForRepo": 63,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,89 +1,90 @@\n \tprivate void loadBeanDefinitionsForBeanMethod(BeanMethod beanMethod) {\n \t\tConfigurationClass configClass = beanMethod.getConfigurationClass();\n \t\tMethodMetadata metadata = beanMethod.getMetadata();\n+\t\tString methodName = metadata.getMethodName();\n+\n+\t\t// Do we need to mark the bean as skipped by its condition?\n+\t\tif (this.conditionEvaluator.shouldSkip(metadata, ConfigurationPhase.REGISTER_BEAN)) {\n+\t\t\tconfigClass.skippedBeanMethods.add(methodName);\n+\t\t\treturn;\n+\t\t}\n+\t\tif (configClass.skippedBeanMethods.contains(methodName)) {\n+\t\t\treturn;\n+\t\t}\n \n \t\t// Consider name and any aliases\n \t\tAnnotationAttributes bean = AnnotationConfigUtils.attributesFor(metadata, Bean.class);\n \t\tList<String> names = new ArrayList<String>(Arrays.asList(bean.getStringArray(\"name\")));\n-\t\tString beanName = (names.size() > 0 ? names.remove(0) : beanMethod.getMetadata().getMethodName());\n-\n-\t\t// Do we need to mark the bean as skipped by its condition?\n-\t\tif (this.conditionEvaluator.shouldSkip(metadata, ConfigurationPhase.REGISTER_BEAN)) {\n-\t\t\tconfigClass.skippedBeans.add(beanName);\n-\t\t\treturn;\n-\t\t}\n-\t\tif (configClass.skippedBeans.contains(beanName)) {\n-\t\t\treturn;\n-\t\t}\n+\t\tString beanName = (names.size() > 0 ? names.remove(0) : methodName);\n \n \t\t// Register aliases even when overridden\n \t\tfor (String alias : names) {\n \t\t\tthis.registry.registerAlias(beanName, alias);\n \t\t}\n \n \t\t// Has this effectively been overridden before (e.g. via XML)?\n \t\tif (isOverriddenByExistingDefinition(beanMethod, beanName)) {\n \t\t\treturn;\n \t\t}\n \n \t\tConfigurationClassBeanDefinition beanDef = new ConfigurationClassBeanDefinition(configClass, metadata);\n \t\tbeanDef.setResource(configClass.getResource());\n \t\tbeanDef.setSource(this.sourceExtractor.extractSource(metadata, configClass.getResource()));\n \n \t\tif (metadata.isStatic()) {\n \t\t\t// static @Bean method\n \t\t\tbeanDef.setBeanClassName(configClass.getMetadata().getClassName());\n-\t\t\tbeanDef.setFactoryMethodName(metadata.getMethodName());\n+\t\t\tbeanDef.setFactoryMethodName(methodName);\n \t\t}\n \t\telse {\n \t\t\t// instance @Bean method\n \t\t\tbeanDef.setFactoryBeanName(configClass.getBeanName());\n-\t\t\tbeanDef.setUniqueFactoryMethodName(metadata.getMethodName());\n+\t\t\tbeanDef.setUniqueFactoryMethodName(methodName);\n \t\t}\n \t\tbeanDef.setAutowireMode(RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n \t\tbeanDef.setAttribute(RequiredAnnotationBeanPostProcessor.SKIP_REQUIRED_CHECK_ATTRIBUTE, Boolean.TRUE);\n \n \t\tAnnotationConfigUtils.processCommonDefinitionAnnotations(beanDef, metadata);\n \n \t\tAutowire autowire = bean.getEnum(\"autowire\");\n \t\tif (autowire.isAutowire()) {\n \t\t\tbeanDef.setAutowireMode(autowire.value());\n \t\t}\n \n \t\tString initMethodName = bean.getString(\"initMethod\");\n \t\tif (StringUtils.hasText(initMethodName)) {\n \t\t\tbeanDef.setInitMethodName(initMethodName);\n \t\t}\n \n \t\tString destroyMethodName = bean.getString(\"destroyMethod\");\n \t\tif (StringUtils.hasText(destroyMethodName)) {\n \t\t\tbeanDef.setDestroyMethodName(destroyMethodName);\n \t\t}\n \n \t\t// Consider scoping\n \t\tScopedProxyMode proxyMode = ScopedProxyMode.NO;\n \t\tAnnotationAttributes scope = AnnotationConfigUtils.attributesFor(metadata, Scope.class);\n \t\tif (scope != null) {\n \t\t\tbeanDef.setScope(scope.getString(\"value\"));\n \t\t\tproxyMode = scope.getEnum(\"proxyMode\");\n \t\t\tif (proxyMode == ScopedProxyMode.DEFAULT) {\n \t\t\t\tproxyMode = ScopedProxyMode.NO;\n \t\t\t}\n \t\t}\n \n \t\t// Replace the original bean definition with the target one, if necessary\n \t\tBeanDefinition beanDefToRegister = beanDef;\n \t\tif (proxyMode != ScopedProxyMode.NO) {\n \t\t\tBeanDefinitionHolder proxyDef = ScopedProxyCreator.createScopedProxy(\n \t\t\t\t\tnew BeanDefinitionHolder(beanDef, beanName), this.registry, proxyMode == ScopedProxyMode.TARGET_CLASS);\n \t\t\tbeanDefToRegister = new ConfigurationClassBeanDefinition(\n \t\t\t\t\t(RootBeanDefinition) proxyDef.getBeanDefinition(), configClass, metadata);\n \t\t}\n \n \t\tif (logger.isDebugEnabled()) {\n \t\t\tlogger.debug(String.format(\"Registering bean definition for @Bean method %s.%s()\",\n \t\t\t\t\tconfigClass.getMetadata().getClassName(), beanName));\n \t\t}\n \n \t\tthis.registry.registerBeanDefinition(beanName, beanDefToRegister);\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"981aefc2c0d2a6fbf9c08d4d54d17923a75a2e01": {
			"type": "Ybodychange",
			"commitMessage": "Properly honor conditions on overriding bean methods\n\nIssue: SPR-12694\n",
			"commitDate": "2015-02-10, 10:26 AM",
			"commitName": "981aefc2c0d2a6fbf9c08d4d54d17923a75a2e01",
			"commitAuthor": "Juergen Hoeller",
			"commitDateOld": "2014-12-01, 9:54 AM",
			"commitNameOld": "c5c5473d44f101271e47921fb7d2a125199be517",
			"commitAuthorOld": "Juergen Hoeller",
			"daysBetweenCommits": 71.02,
			"commitsBetweenForRepo": 192,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,81 +1,89 @@\n \tprivate void loadBeanDefinitionsForBeanMethod(BeanMethod beanMethod) {\n-\t\tif (this.conditionEvaluator.shouldSkip(beanMethod.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {\n+\t\tConfigurationClass configClass = beanMethod.getConfigurationClass();\n+\t\tMethodMetadata metadata = beanMethod.getMetadata();\n+\n+\t\t// Consider name and any aliases\n+\t\tAnnotationAttributes bean = AnnotationConfigUtils.attributesFor(metadata, Bean.class);\n+\t\tList<String> names = new ArrayList<String>(Arrays.asList(bean.getStringArray(\"name\")));\n+\t\tString beanName = (names.size() > 0 ? names.remove(0) : beanMethod.getMetadata().getMethodName());\n+\n+\t\t// Do we need to mark the bean as skipped by its condition?\n+\t\tif (this.conditionEvaluator.shouldSkip(metadata, ConfigurationPhase.REGISTER_BEAN)) {\n+\t\t\tconfigClass.skippedBeans.add(beanName);\n+\t\t\treturn;\n+\t\t}\n+\t\tif (configClass.skippedBeans.contains(beanName)) {\n \t\t\treturn;\n \t\t}\n \n-\t\tConfigurationClass configClass = beanMethod.getConfigurationClass();\n-\t\tMethodMetadata metadata = beanMethod.getMetadata();\n+\t\t// Register aliases even when overridden\n+\t\tfor (String alias : names) {\n+\t\t\tthis.registry.registerAlias(beanName, alias);\n+\t\t}\n+\n+\t\t// Has this effectively been overridden before (e.g. via XML)?\n+\t\tif (isOverriddenByExistingDefinition(beanMethod, beanName)) {\n+\t\t\treturn;\n+\t\t}\n \n \t\tConfigurationClassBeanDefinition beanDef = new ConfigurationClassBeanDefinition(configClass, metadata);\n \t\tbeanDef.setResource(configClass.getResource());\n \t\tbeanDef.setSource(this.sourceExtractor.extractSource(metadata, configClass.getResource()));\n+\n \t\tif (metadata.isStatic()) {\n \t\t\t// static @Bean method\n \t\t\tbeanDef.setBeanClassName(configClass.getMetadata().getClassName());\n \t\t\tbeanDef.setFactoryMethodName(metadata.getMethodName());\n \t\t}\n \t\telse {\n \t\t\t// instance @Bean method\n \t\t\tbeanDef.setFactoryBeanName(configClass.getBeanName());\n \t\t\tbeanDef.setUniqueFactoryMethodName(metadata.getMethodName());\n \t\t}\n \t\tbeanDef.setAutowireMode(RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n \t\tbeanDef.setAttribute(RequiredAnnotationBeanPostProcessor.SKIP_REQUIRED_CHECK_ATTRIBUTE, Boolean.TRUE);\n \n-\t\t// Consider name and any aliases\n-\t\tAnnotationAttributes bean = AnnotationConfigUtils.attributesFor(metadata, Bean.class);\n-\t\tList<String> names = new ArrayList<String>(Arrays.asList(bean.getStringArray(\"name\")));\n-\t\tString beanName = (names.size() > 0 ? names.remove(0) : beanMethod.getMetadata().getMethodName());\n-\t\tfor (String alias : names) {\n-\t\t\tthis.registry.registerAlias(beanName, alias);\n-\t\t}\n-\n-\t\t// Has this effectively been overridden before (e.g. via XML)?\n-\t\tif (isOverriddenByExistingDefinition(beanMethod, beanName)) {\n-\t\t\treturn;\n-\t\t}\n-\n \t\tAnnotationConfigUtils.processCommonDefinitionAnnotations(beanDef, metadata);\n \n \t\tAutowire autowire = bean.getEnum(\"autowire\");\n \t\tif (autowire.isAutowire()) {\n \t\t\tbeanDef.setAutowireMode(autowire.value());\n \t\t}\n \n \t\tString initMethodName = bean.getString(\"initMethod\");\n \t\tif (StringUtils.hasText(initMethodName)) {\n \t\t\tbeanDef.setInitMethodName(initMethodName);\n \t\t}\n \n \t\tString destroyMethodName = bean.getString(\"destroyMethod\");\n \t\tif (StringUtils.hasText(destroyMethodName)) {\n \t\t\tbeanDef.setDestroyMethodName(destroyMethodName);\n \t\t}\n \n \t\t// Consider scoping\n \t\tScopedProxyMode proxyMode = ScopedProxyMode.NO;\n \t\tAnnotationAttributes scope = AnnotationConfigUtils.attributesFor(metadata, Scope.class);\n \t\tif (scope != null) {\n \t\t\tbeanDef.setScope(scope.getString(\"value\"));\n \t\t\tproxyMode = scope.getEnum(\"proxyMode\");\n \t\t\tif (proxyMode == ScopedProxyMode.DEFAULT) {\n \t\t\t\tproxyMode = ScopedProxyMode.NO;\n \t\t\t}\n \t\t}\n \n \t\t// Replace the original bean definition with the target one, if necessary\n \t\tBeanDefinition beanDefToRegister = beanDef;\n \t\tif (proxyMode != ScopedProxyMode.NO) {\n \t\t\tBeanDefinitionHolder proxyDef = ScopedProxyCreator.createScopedProxy(\n \t\t\t\t\tnew BeanDefinitionHolder(beanDef, beanName), this.registry, proxyMode == ScopedProxyMode.TARGET_CLASS);\n \t\t\tbeanDefToRegister = new ConfigurationClassBeanDefinition(\n \t\t\t\t\t(RootBeanDefinition) proxyDef.getBeanDefinition(), configClass, metadata);\n \t\t}\n \n \t\tif (logger.isDebugEnabled()) {\n \t\t\tlogger.debug(String.format(\"Registering bean definition for @Bean method %s.%s()\",\n \t\t\t\t\tconfigClass.getMetadata().getClassName(), beanName));\n \t\t}\n \n \t\tthis.registry.registerBeanDefinition(beanName, beanDefToRegister);\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"f46c706e443860e9ada7768a16cfa01526c10645": {
			"type": "Ybodychange",
			"commitMessage": "Bean method metadata exposed through AnnotatedBeanDefinition\n\nIssue: SPR-12232\n",
			"commitDate": "2014-09-26, 5:46 AM",
			"commitName": "f46c706e443860e9ada7768a16cfa01526c10645",
			"commitAuthor": "Juergen Hoeller",
			"commitDateOld": "2014-09-03, 3:59 AM",
			"commitNameOld": "6563405be5308954394b67608f09af35e7d35b59",
			"commitAuthorOld": "Juergen Hoeller",
			"daysBetweenCommits": 23.07,
			"commitsBetweenForRepo": 115,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,81 +1,81 @@\n \tprivate void loadBeanDefinitionsForBeanMethod(BeanMethod beanMethod) {\n \t\tif (this.conditionEvaluator.shouldSkip(beanMethod.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {\n \t\t\treturn;\n \t\t}\n \n \t\tConfigurationClass configClass = beanMethod.getConfigurationClass();\n \t\tMethodMetadata metadata = beanMethod.getMetadata();\n \n-\t\tConfigurationClassBeanDefinition beanDef = new ConfigurationClassBeanDefinition(configClass);\n+\t\tConfigurationClassBeanDefinition beanDef = new ConfigurationClassBeanDefinition(configClass, metadata);\n \t\tbeanDef.setResource(configClass.getResource());\n \t\tbeanDef.setSource(this.sourceExtractor.extractSource(metadata, configClass.getResource()));\n \t\tif (metadata.isStatic()) {\n \t\t\t// static @Bean method\n \t\t\tbeanDef.setBeanClassName(configClass.getMetadata().getClassName());\n \t\t\tbeanDef.setFactoryMethodName(metadata.getMethodName());\n \t\t}\n \t\telse {\n \t\t\t// instance @Bean method\n \t\t\tbeanDef.setFactoryBeanName(configClass.getBeanName());\n \t\t\tbeanDef.setUniqueFactoryMethodName(metadata.getMethodName());\n \t\t}\n \t\tbeanDef.setAutowireMode(RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n \t\tbeanDef.setAttribute(RequiredAnnotationBeanPostProcessor.SKIP_REQUIRED_CHECK_ATTRIBUTE, Boolean.TRUE);\n \n \t\t// Consider name and any aliases\n \t\tAnnotationAttributes bean = AnnotationConfigUtils.attributesFor(metadata, Bean.class);\n \t\tList<String> names = new ArrayList<String>(Arrays.asList(bean.getStringArray(\"name\")));\n \t\tString beanName = (names.size() > 0 ? names.remove(0) : beanMethod.getMetadata().getMethodName());\n \t\tfor (String alias : names) {\n \t\t\tthis.registry.registerAlias(beanName, alias);\n \t\t}\n \n \t\t// Has this effectively been overridden before (e.g. via XML)?\n \t\tif (isOverriddenByExistingDefinition(beanMethod, beanName)) {\n \t\t\treturn;\n \t\t}\n \n \t\tAnnotationConfigUtils.processCommonDefinitionAnnotations(beanDef, metadata);\n \n \t\tAutowire autowire = bean.getEnum(\"autowire\");\n \t\tif (autowire.isAutowire()) {\n \t\t\tbeanDef.setAutowireMode(autowire.value());\n \t\t}\n \n \t\tString initMethodName = bean.getString(\"initMethod\");\n \t\tif (StringUtils.hasText(initMethodName)) {\n \t\t\tbeanDef.setInitMethodName(initMethodName);\n \t\t}\n \n \t\tString destroyMethodName = bean.getString(\"destroyMethod\");\n \t\tif (StringUtils.hasText(destroyMethodName)) {\n \t\t\tbeanDef.setDestroyMethodName(destroyMethodName);\n \t\t}\n \n \t\t// Consider scoping\n \t\tScopedProxyMode proxyMode = ScopedProxyMode.NO;\n \t\tAnnotationAttributes scope = AnnotationConfigUtils.attributesFor(metadata, Scope.class);\n \t\tif (scope != null) {\n \t\t\tbeanDef.setScope(scope.getString(\"value\"));\n \t\t\tproxyMode = scope.getEnum(\"proxyMode\");\n \t\t\tif (proxyMode == ScopedProxyMode.DEFAULT) {\n \t\t\t\tproxyMode = ScopedProxyMode.NO;\n \t\t\t}\n \t\t}\n \n \t\t// Replace the original bean definition with the target one, if necessary\n \t\tBeanDefinition beanDefToRegister = beanDef;\n \t\tif (proxyMode != ScopedProxyMode.NO) {\n \t\t\tBeanDefinitionHolder proxyDef = ScopedProxyCreator.createScopedProxy(\n \t\t\t\t\tnew BeanDefinitionHolder(beanDef, beanName), this.registry, proxyMode == ScopedProxyMode.TARGET_CLASS);\n-\t\t\tbeanDefToRegister =\n-\t\t\t\t\tnew ConfigurationClassBeanDefinition((RootBeanDefinition) proxyDef.getBeanDefinition(), configClass);\n+\t\t\tbeanDefToRegister = new ConfigurationClassBeanDefinition(\n+\t\t\t\t\t(RootBeanDefinition) proxyDef.getBeanDefinition(), configClass, metadata);\n \t\t}\n \n \t\tif (logger.isDebugEnabled()) {\n \t\t\tlogger.debug(String.format(\"Registering bean definition for @Bean method %s.%s()\",\n \t\t\t\t\tconfigClass.getMetadata().getClassName(), beanName));\n \t\t}\n \n \t\tthis.registry.registerBeanDefinition(beanName, beanDefToRegister);\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"6d80da2e3129044df2294e5c3e7fb137b9286e6a": {
			"type": "Ybodychange",
			"commitMessage": "Polishing\n",
			"commitDate": "2013-10-25, 5:21 PM",
			"commitName": "6d80da2e3129044df2294e5c3e7fb137b9286e6a",
			"commitAuthor": "Juergen Hoeller",
			"commitDateOld": "2013-08-28, 1:14 PM",
			"commitNameOld": "fe8dec912d53db4819064b50d667c34300bb59b1",
			"commitAuthorOld": "Juergen Hoeller",
			"daysBetweenCommits": 58.17,
			"commitsBetweenForRepo": 208,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,80 +1,80 @@\n \tprivate void loadBeanDefinitionsForBeanMethod(BeanMethod beanMethod) {\n \t\tif (this.conditionEvaluator.shouldSkip(beanMethod.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {\n \t\t\treturn;\n \t\t}\n \t\tConfigurationClass configClass = beanMethod.getConfigurationClass();\n \t\tMethodMetadata metadata = beanMethod.getMetadata();\n \n \t\tConfigurationClassBeanDefinition beanDef = new ConfigurationClassBeanDefinition(configClass);\n \t\tbeanDef.setResource(configClass.getResource());\n \t\tbeanDef.setSource(this.sourceExtractor.extractSource(metadata, configClass.getResource()));\n \t\tif (metadata.isStatic()) {\n \t\t\t// static @Bean method\n \t\t\tbeanDef.setBeanClassName(configClass.getMetadata().getClassName());\n \t\t\tbeanDef.setFactoryMethodName(metadata.getMethodName());\n \t\t}\n \t\telse {\n \t\t\t// instance @Bean method\n \t\t\tbeanDef.setFactoryBeanName(configClass.getBeanName());\n \t\t\tbeanDef.setUniqueFactoryMethodName(metadata.getMethodName());\n \t\t}\n \t\tbeanDef.setAutowireMode(RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n \t\tbeanDef.setAttribute(RequiredAnnotationBeanPostProcessor.SKIP_REQUIRED_CHECK_ATTRIBUTE, Boolean.TRUE);\n \n \t\t// Consider name and any aliases\n \t\tAnnotationAttributes bean = AnnotationConfigUtils.attributesFor(metadata, Bean.class);\n \t\tList<String> names = new ArrayList<String>(Arrays.asList(bean.getStringArray(\"name\")));\n \t\tString beanName = (names.size() > 0 ? names.remove(0) : beanMethod.getMetadata().getMethodName());\n \t\tfor (String alias : names) {\n \t\t\tthis.registry.registerAlias(beanName, alias);\n \t\t}\n \n-\t\t// Has this  effectively been overridden before (e.g. via XML)?\n+\t\t// Has this effectively been overridden before (e.g. via XML)?\n \t\tif (isOverriddenByExistingDefinition(beanMethod, beanName)) {\n \t\t\treturn;\n \t\t}\n \n \t\tAnnotationConfigUtils.processCommonDefinitionAnnotations(beanDef, metadata);\n \n \t\tAutowire autowire = bean.getEnum(\"autowire\");\n \t\tif (autowire.isAutowire()) {\n \t\t\tbeanDef.setAutowireMode(autowire.value());\n \t\t}\n \n \t\tString initMethodName = bean.getString(\"initMethod\");\n \t\tif (StringUtils.hasText(initMethodName)) {\n \t\t\tbeanDef.setInitMethodName(initMethodName);\n \t\t}\n \n \t\tString destroyMethodName = bean.getString(\"destroyMethod\");\n \t\tif (StringUtils.hasText(destroyMethodName)) {\n \t\t\tbeanDef.setDestroyMethodName(destroyMethodName);\n \t\t}\n \n \t\t// Consider scoping\n \t\tScopedProxyMode proxyMode = ScopedProxyMode.NO;\n \t\tAnnotationAttributes scope = AnnotationConfigUtils.attributesFor(metadata, Scope.class);\n \t\tif (scope != null) {\n \t\t\tbeanDef.setScope(scope.getString(\"value\"));\n \t\t\tproxyMode = scope.getEnum(\"proxyMode\");\n \t\t\tif (proxyMode == ScopedProxyMode.DEFAULT) {\n \t\t\t\tproxyMode = ScopedProxyMode.NO;\n \t\t\t}\n \t\t}\n \n \t\t// Replace the original bean definition with the target one, if necessary\n \t\tBeanDefinition beanDefToRegister = beanDef;\n \t\tif (proxyMode != ScopedProxyMode.NO) {\n \t\t\tBeanDefinitionHolder proxyDef = ScopedProxyCreator.createScopedProxy(\n \t\t\t\t\tnew BeanDefinitionHolder(beanDef, beanName), this.registry, proxyMode == ScopedProxyMode.TARGET_CLASS);\n \t\t\tbeanDefToRegister =\n \t\t\t\t\tnew ConfigurationClassBeanDefinition((RootBeanDefinition) proxyDef.getBeanDefinition(), configClass);\n \t\t}\n \n \t\tif (logger.isDebugEnabled()) {\n \t\t\tlogger.debug(String.format(\"Registering bean definition for @Bean method %s.%s()\",\n \t\t\t\t\tconfigClass.getMetadata().getClassName(), beanName));\n \t\t}\n \n \t\tthis.registry.registerBeanDefinition(beanName, beanDefToRegister);\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"fe8dec912d53db4819064b50d667c34300bb59b1": {
			"type": "Ybodychange",
			"commitMessage": "@Bean methods are allowed to override existing bean definitions with a role other than ROLE_APPLICATION now (e.g. framework-generated default beans)\n\nAlso, DefaultListableBeanFactory logs a warning when overriding an application definition with a framework-generated definition now, which is expected to be an accident.\n\nIssue: SPR-10607\n",
			"commitDate": "2013-08-28, 1:14 PM",
			"commitName": "fe8dec912d53db4819064b50d667c34300bb59b1",
			"commitAuthor": "Juergen Hoeller",
			"commitDateOld": "2013-08-27, 3:00 PM",
			"commitNameOld": "5efe894ee4969a7c3780a2fd4d2ceab695777c50",
			"commitAuthorOld": "Juergen Hoeller",
			"daysBetweenCommits": 0.93,
			"commitsBetweenForRepo": 13,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,89 +1,80 @@\n \tprivate void loadBeanDefinitionsForBeanMethod(BeanMethod beanMethod) {\n \t\tif (this.conditionEvaluator.shouldSkip(beanMethod.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {\n \t\t\treturn;\n \t\t}\n \t\tConfigurationClass configClass = beanMethod.getConfigurationClass();\n \t\tMethodMetadata metadata = beanMethod.getMetadata();\n \n \t\tConfigurationClassBeanDefinition beanDef = new ConfigurationClassBeanDefinition(configClass);\n \t\tbeanDef.setResource(configClass.getResource());\n \t\tbeanDef.setSource(this.sourceExtractor.extractSource(metadata, configClass.getResource()));\n \t\tif (metadata.isStatic()) {\n \t\t\t// static @Bean method\n \t\t\tbeanDef.setBeanClassName(configClass.getMetadata().getClassName());\n \t\t\tbeanDef.setFactoryMethodName(metadata.getMethodName());\n \t\t}\n \t\telse {\n \t\t\t// instance @Bean method\n \t\t\tbeanDef.setFactoryBeanName(configClass.getBeanName());\n \t\t\tbeanDef.setUniqueFactoryMethodName(metadata.getMethodName());\n \t\t}\n \t\tbeanDef.setAutowireMode(RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n \t\tbeanDef.setAttribute(RequiredAnnotationBeanPostProcessor.SKIP_REQUIRED_CHECK_ATTRIBUTE, Boolean.TRUE);\n \n-\t\t// consider name and any aliases\n+\t\t// Consider name and any aliases\n \t\tAnnotationAttributes bean = AnnotationConfigUtils.attributesFor(metadata, Bean.class);\n \t\tList<String> names = new ArrayList<String>(Arrays.asList(bean.getStringArray(\"name\")));\n \t\tString beanName = (names.size() > 0 ? names.remove(0) : beanMethod.getMetadata().getMethodName());\n \t\tfor (String alias : names) {\n \t\t\tthis.registry.registerAlias(beanName, alias);\n \t\t}\n \n-\t\t// has this already been overridden (e.g. via XML)?\n-\t\tif (this.registry.containsBeanDefinition(beanName)) {\n-\t\t\tBeanDefinition existingBeanDef = registry.getBeanDefinition(beanName);\n-\t\t\t// is the existing bean definition one that was created from a configuration class?\n-\t\t\tif (!(existingBeanDef instanceof ConfigurationClassBeanDefinition)) {\n-\t\t\t\t// no -> then it's an external override, probably XML\n-\t\t\t\t// overriding is legal, return immediately\n-\t\t\t\tif (logger.isDebugEnabled()) {\n-\t\t\t\t\tlogger.debug(String.format(\"Skipping loading bean definition for %s: a definition for bean \" +\n-\t\t\t\t\t\t\t\"'%s' already exists. This is likely due to an override in XML.\", beanMethod, beanName));\n-\t\t\t\t}\n-\t\t\t\treturn;\n-\t\t\t}\n+\t\t// Has this  effectively been overridden before (e.g. via XML)?\n+\t\tif (isOverriddenByExistingDefinition(beanMethod, beanName)) {\n+\t\t\treturn;\n \t\t}\n \n \t\tAnnotationConfigUtils.processCommonDefinitionAnnotations(beanDef, metadata);\n \n \t\tAutowire autowire = bean.getEnum(\"autowire\");\n \t\tif (autowire.isAutowire()) {\n \t\t\tbeanDef.setAutowireMode(autowire.value());\n \t\t}\n \n \t\tString initMethodName = bean.getString(\"initMethod\");\n \t\tif (StringUtils.hasText(initMethodName)) {\n \t\t\tbeanDef.setInitMethodName(initMethodName);\n \t\t}\n \n \t\tString destroyMethodName = bean.getString(\"destroyMethod\");\n \t\tif (StringUtils.hasText(destroyMethodName)) {\n \t\t\tbeanDef.setDestroyMethodName(destroyMethodName);\n \t\t}\n \n-\t\t// consider scoping\n+\t\t// Consider scoping\n \t\tScopedProxyMode proxyMode = ScopedProxyMode.NO;\n \t\tAnnotationAttributes scope = AnnotationConfigUtils.attributesFor(metadata, Scope.class);\n \t\tif (scope != null) {\n \t\t\tbeanDef.setScope(scope.getString(\"value\"));\n \t\t\tproxyMode = scope.getEnum(\"proxyMode\");\n \t\t\tif (proxyMode == ScopedProxyMode.DEFAULT) {\n \t\t\t\tproxyMode = ScopedProxyMode.NO;\n \t\t\t}\n \t\t}\n \n-\t\t// replace the original bean definition with the target one, if necessary\n+\t\t// Replace the original bean definition with the target one, if necessary\n \t\tBeanDefinition beanDefToRegister = beanDef;\n \t\tif (proxyMode != ScopedProxyMode.NO) {\n \t\t\tBeanDefinitionHolder proxyDef = ScopedProxyCreator.createScopedProxy(\n \t\t\t\t\tnew BeanDefinitionHolder(beanDef, beanName), this.registry, proxyMode == ScopedProxyMode.TARGET_CLASS);\n \t\t\tbeanDefToRegister =\n \t\t\t\t\tnew ConfigurationClassBeanDefinition((RootBeanDefinition) proxyDef.getBeanDefinition(), configClass);\n \t\t}\n \n \t\tif (logger.isDebugEnabled()) {\n-\t\t\tlogger.debug(String.format(\"Registering bean definition for @Bean method %s.%s()\", configClass.getMetadata().getClassName(), beanName));\n+\t\t\tlogger.debug(String.format(\"Registering bean definition for @Bean method %s.%s()\",\n+\t\t\t\t\tconfigClass.getMetadata().getClassName(), beanName));\n \t\t}\n \n-\t\tregistry.registerBeanDefinition(beanName, beanDefToRegister);\n+\t\tthis.registry.registerBeanDefinition(beanName, beanDefToRegister);\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"c9771012e98afe1679cd1c3ebf5ab6c1a018fd65": {
			"type": "Ybodychange",
			"commitMessage": "Introduced @Description annotation for populating BeanDefinition.getDescription()\n\nIssue: SPR-10583\n",
			"commitDate": "2013-08-23, 7:49 AM",
			"commitName": "c9771012e98afe1679cd1c3ebf5ab6c1a018fd65",
			"commitAuthor": "Juergen Hoeller",
			"commitDateOld": "2013-06-12, 11:45 AM",
			"commitNameOld": "2e2e9b8dd0ecb113c86ec3a5d0cf87d4f6f72fd6",
			"commitAuthorOld": "Phillip Webb",
			"daysBetweenCommits": 71.84,
			"commitsBetweenForRepo": 263,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,116 +1,89 @@\n \tprivate void loadBeanDefinitionsForBeanMethod(BeanMethod beanMethod) {\n-\t\tif (conditionEvaluator.shouldSkip(beanMethod.getMetadata(),\n-\t\t\t\tConfigurationPhase.REGISTER_BEAN)) {\n+\t\tif (this.conditionEvaluator.shouldSkip(beanMethod.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {\n \t\t\treturn;\n \t\t}\n \t\tConfigurationClass configClass = beanMethod.getConfigurationClass();\n \t\tMethodMetadata metadata = beanMethod.getMetadata();\n \n-\t\tRootBeanDefinition beanDef = new ConfigurationClassBeanDefinition(configClass);\n+\t\tConfigurationClassBeanDefinition beanDef = new ConfigurationClassBeanDefinition(configClass);\n \t\tbeanDef.setResource(configClass.getResource());\n \t\tbeanDef.setSource(this.sourceExtractor.extractSource(metadata, configClass.getResource()));\n \t\tif (metadata.isStatic()) {\n \t\t\t// static @Bean method\n \t\t\tbeanDef.setBeanClassName(configClass.getMetadata().getClassName());\n \t\t\tbeanDef.setFactoryMethodName(metadata.getMethodName());\n \t\t}\n \t\telse {\n \t\t\t// instance @Bean method\n \t\t\tbeanDef.setFactoryBeanName(configClass.getBeanName());\n \t\t\tbeanDef.setUniqueFactoryMethodName(metadata.getMethodName());\n \t\t}\n \t\tbeanDef.setAutowireMode(RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n \t\tbeanDef.setAttribute(RequiredAnnotationBeanPostProcessor.SKIP_REQUIRED_CHECK_ATTRIBUTE, Boolean.TRUE);\n \n-\t\t// consider role\n-\t\tAnnotationAttributes role = attributesFor(metadata, Role.class);\n-\t\tif (role != null) {\n-\t\t\tbeanDef.setRole(role.<Integer>getNumber(\"value\"));\n-\t\t}\n-\n \t\t// consider name and any aliases\n-\t\tAnnotationAttributes bean = attributesFor(metadata, Bean.class);\n+\t\tAnnotationAttributes bean = AnnotationConfigUtils.attributesFor(metadata, Bean.class);\n \t\tList<String> names = new ArrayList<String>(Arrays.asList(bean.getStringArray(\"name\")));\n \t\tString beanName = (names.size() > 0 ? names.remove(0) : beanMethod.getMetadata().getMethodName());\n \t\tfor (String alias : names) {\n \t\t\tthis.registry.registerAlias(beanName, alias);\n \t\t}\n \n \t\t// has this already been overridden (e.g. via XML)?\n \t\tif (this.registry.containsBeanDefinition(beanName)) {\n \t\t\tBeanDefinition existingBeanDef = registry.getBeanDefinition(beanName);\n \t\t\t// is the existing bean definition one that was created from a configuration class?\n \t\t\tif (!(existingBeanDef instanceof ConfigurationClassBeanDefinition)) {\n \t\t\t\t// no -> then it's an external override, probably XML\n \t\t\t\t// overriding is legal, return immediately\n \t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\tlogger.debug(String.format(\"Skipping loading bean definition for %s: a definition for bean \" +\n \t\t\t\t\t\t\t\"'%s' already exists. This is likely due to an override in XML.\", beanMethod, beanName));\n \t\t\t\t}\n \t\t\t\treturn;\n \t\t\t}\n \t\t}\n \n-\t\tif (metadata.isAnnotated(Primary.class.getName())) {\n-\t\t\tbeanDef.setPrimary(true);\n-\t\t}\n-\n-\t\t// is this bean to be instantiated lazily?\n-\t\tif (metadata.isAnnotated(Lazy.class.getName())) {\n-\t\t\tAnnotationAttributes lazy = attributesFor(metadata, Lazy.class);\n-\t\t\tbeanDef.setLazyInit(lazy.getBoolean(\"value\"));\n-\t\t}\n-\t\telse if (configClass.getMetadata().isAnnotated(Lazy.class.getName())){\n-\t\t\tAnnotationAttributes lazy = attributesFor(configClass.getMetadata(), Lazy.class);\n-\t\t\tbeanDef.setLazyInit(lazy.getBoolean(\"value\"));\n-\t\t}\n-\n-\t\tif (metadata.isAnnotated(DependsOn.class.getName())) {\n-\t\t\tAnnotationAttributes dependsOn = attributesFor(metadata, DependsOn.class);\n-\t\t\tString[] otherBeans = dependsOn.getStringArray(\"value\");\n-\t\t\tif (otherBeans.length > 0) {\n-\t\t\t\tbeanDef.setDependsOn(otherBeans);\n-\t\t\t}\n-\t\t}\n+\t\tAnnotationConfigUtils.processCommonDefinitionAnnotations(beanDef, metadata);\n \n \t\tAutowire autowire = bean.getEnum(\"autowire\");\n \t\tif (autowire.isAutowire()) {\n \t\t\tbeanDef.setAutowireMode(autowire.value());\n \t\t}\n \n \t\tString initMethodName = bean.getString(\"initMethod\");\n \t\tif (StringUtils.hasText(initMethodName)) {\n \t\t\tbeanDef.setInitMethodName(initMethodName);\n \t\t}\n \n \t\tString destroyMethodName = bean.getString(\"destroyMethod\");\n \t\tif (StringUtils.hasText(destroyMethodName)) {\n \t\t\tbeanDef.setDestroyMethodName(destroyMethodName);\n \t\t}\n \n \t\t// consider scoping\n \t\tScopedProxyMode proxyMode = ScopedProxyMode.NO;\n-\t\tAnnotationAttributes scope = attributesFor(metadata, Scope.class);\n+\t\tAnnotationAttributes scope = AnnotationConfigUtils.attributesFor(metadata, Scope.class);\n \t\tif (scope != null) {\n \t\t\tbeanDef.setScope(scope.getString(\"value\"));\n \t\t\tproxyMode = scope.getEnum(\"proxyMode\");\n \t\t\tif (proxyMode == ScopedProxyMode.DEFAULT) {\n \t\t\t\tproxyMode = ScopedProxyMode.NO;\n \t\t\t}\n \t\t}\n \n \t\t// replace the original bean definition with the target one, if necessary\n \t\tBeanDefinition beanDefToRegister = beanDef;\n \t\tif (proxyMode != ScopedProxyMode.NO) {\n \t\t\tBeanDefinitionHolder proxyDef = ScopedProxyCreator.createScopedProxy(\n \t\t\t\t\tnew BeanDefinitionHolder(beanDef, beanName), this.registry, proxyMode == ScopedProxyMode.TARGET_CLASS);\n \t\t\tbeanDefToRegister =\n \t\t\t\t\tnew ConfigurationClassBeanDefinition((RootBeanDefinition) proxyDef.getBeanDefinition(), configClass);\n \t\t}\n \n \t\tif (logger.isDebugEnabled()) {\n \t\t\tlogger.debug(String.format(\"Registering bean definition for @Bean method %s.%s()\", configClass.getMetadata().getClassName(), beanName));\n \t\t}\n \n \t\tregistry.registerBeanDefinition(beanName, beanDefToRegister);\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"2e2e9b8dd0ecb113c86ec3a5d0cf87d4f6f72fd6": {
			"type": "Ybodychange",
			"commitMessage": "Improve support for @Conditional on @Configuration\n\nIntroduce new ConfigurationCondition interface allowing more\nfine-grained control for @Conditional when used with @Configuration\nbeans.\n\nPrimarily added so that the evaluation of conditions that inspect bean\ndefinitions can be deferred until all @Configuration classes have been\nparsed.\n\nIssue: SPR-10534\n",
			"commitDate": "2013-06-12, 11:45 AM",
			"commitName": "2e2e9b8dd0ecb113c86ec3a5d0cf87d4f6f72fd6",
			"commitAuthor": "Phillip Webb",
			"commitDateOld": "2013-06-04, 10:27 AM",
			"commitNameOld": "239ce1466ce118294f5c7b8e842a80815fd813de",
			"commitAuthorOld": "Phillip Webb",
			"daysBetweenCommits": 8.05,
			"commitsBetweenForRepo": 12,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,116 +1,116 @@\n \tprivate void loadBeanDefinitionsForBeanMethod(BeanMethod beanMethod) {\n-\t\tif (ConditionEvaluator.get(beanMethod.getMetadata(), false).shouldSkip(\n-\t\t\t\tthis.registry, this.environment)) {\n+\t\tif (conditionEvaluator.shouldSkip(beanMethod.getMetadata(),\n+\t\t\t\tConfigurationPhase.REGISTER_BEAN)) {\n \t\t\treturn;\n \t\t}\n \t\tConfigurationClass configClass = beanMethod.getConfigurationClass();\n \t\tMethodMetadata metadata = beanMethod.getMetadata();\n \n \t\tRootBeanDefinition beanDef = new ConfigurationClassBeanDefinition(configClass);\n \t\tbeanDef.setResource(configClass.getResource());\n \t\tbeanDef.setSource(this.sourceExtractor.extractSource(metadata, configClass.getResource()));\n \t\tif (metadata.isStatic()) {\n \t\t\t// static @Bean method\n \t\t\tbeanDef.setBeanClassName(configClass.getMetadata().getClassName());\n \t\t\tbeanDef.setFactoryMethodName(metadata.getMethodName());\n \t\t}\n \t\telse {\n \t\t\t// instance @Bean method\n \t\t\tbeanDef.setFactoryBeanName(configClass.getBeanName());\n \t\t\tbeanDef.setUniqueFactoryMethodName(metadata.getMethodName());\n \t\t}\n \t\tbeanDef.setAutowireMode(RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n \t\tbeanDef.setAttribute(RequiredAnnotationBeanPostProcessor.SKIP_REQUIRED_CHECK_ATTRIBUTE, Boolean.TRUE);\n \n \t\t// consider role\n \t\tAnnotationAttributes role = attributesFor(metadata, Role.class);\n \t\tif (role != null) {\n \t\t\tbeanDef.setRole(role.<Integer>getNumber(\"value\"));\n \t\t}\n \n \t\t// consider name and any aliases\n \t\tAnnotationAttributes bean = attributesFor(metadata, Bean.class);\n \t\tList<String> names = new ArrayList<String>(Arrays.asList(bean.getStringArray(\"name\")));\n \t\tString beanName = (names.size() > 0 ? names.remove(0) : beanMethod.getMetadata().getMethodName());\n \t\tfor (String alias : names) {\n \t\t\tthis.registry.registerAlias(beanName, alias);\n \t\t}\n \n \t\t// has this already been overridden (e.g. via XML)?\n \t\tif (this.registry.containsBeanDefinition(beanName)) {\n \t\t\tBeanDefinition existingBeanDef = registry.getBeanDefinition(beanName);\n \t\t\t// is the existing bean definition one that was created from a configuration class?\n \t\t\tif (!(existingBeanDef instanceof ConfigurationClassBeanDefinition)) {\n \t\t\t\t// no -> then it's an external override, probably XML\n \t\t\t\t// overriding is legal, return immediately\n \t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\tlogger.debug(String.format(\"Skipping loading bean definition for %s: a definition for bean \" +\n \t\t\t\t\t\t\t\"'%s' already exists. This is likely due to an override in XML.\", beanMethod, beanName));\n \t\t\t\t}\n \t\t\t\treturn;\n \t\t\t}\n \t\t}\n \n \t\tif (metadata.isAnnotated(Primary.class.getName())) {\n \t\t\tbeanDef.setPrimary(true);\n \t\t}\n \n \t\t// is this bean to be instantiated lazily?\n \t\tif (metadata.isAnnotated(Lazy.class.getName())) {\n \t\t\tAnnotationAttributes lazy = attributesFor(metadata, Lazy.class);\n \t\t\tbeanDef.setLazyInit(lazy.getBoolean(\"value\"));\n \t\t}\n \t\telse if (configClass.getMetadata().isAnnotated(Lazy.class.getName())){\n \t\t\tAnnotationAttributes lazy = attributesFor(configClass.getMetadata(), Lazy.class);\n \t\t\tbeanDef.setLazyInit(lazy.getBoolean(\"value\"));\n \t\t}\n \n \t\tif (metadata.isAnnotated(DependsOn.class.getName())) {\n \t\t\tAnnotationAttributes dependsOn = attributesFor(metadata, DependsOn.class);\n \t\t\tString[] otherBeans = dependsOn.getStringArray(\"value\");\n \t\t\tif (otherBeans.length > 0) {\n \t\t\t\tbeanDef.setDependsOn(otherBeans);\n \t\t\t}\n \t\t}\n \n \t\tAutowire autowire = bean.getEnum(\"autowire\");\n \t\tif (autowire.isAutowire()) {\n \t\t\tbeanDef.setAutowireMode(autowire.value());\n \t\t}\n \n \t\tString initMethodName = bean.getString(\"initMethod\");\n \t\tif (StringUtils.hasText(initMethodName)) {\n \t\t\tbeanDef.setInitMethodName(initMethodName);\n \t\t}\n \n \t\tString destroyMethodName = bean.getString(\"destroyMethod\");\n \t\tif (StringUtils.hasText(destroyMethodName)) {\n \t\t\tbeanDef.setDestroyMethodName(destroyMethodName);\n \t\t}\n \n \t\t// consider scoping\n \t\tScopedProxyMode proxyMode = ScopedProxyMode.NO;\n \t\tAnnotationAttributes scope = attributesFor(metadata, Scope.class);\n \t\tif (scope != null) {\n \t\t\tbeanDef.setScope(scope.getString(\"value\"));\n \t\t\tproxyMode = scope.getEnum(\"proxyMode\");\n \t\t\tif (proxyMode == ScopedProxyMode.DEFAULT) {\n \t\t\t\tproxyMode = ScopedProxyMode.NO;\n \t\t\t}\n \t\t}\n \n \t\t// replace the original bean definition with the target one, if necessary\n \t\tBeanDefinition beanDefToRegister = beanDef;\n \t\tif (proxyMode != ScopedProxyMode.NO) {\n \t\t\tBeanDefinitionHolder proxyDef = ScopedProxyCreator.createScopedProxy(\n \t\t\t\t\tnew BeanDefinitionHolder(beanDef, beanName), this.registry, proxyMode == ScopedProxyMode.TARGET_CLASS);\n \t\t\tbeanDefToRegister =\n \t\t\t\t\tnew ConfigurationClassBeanDefinition((RootBeanDefinition) proxyDef.getBeanDefinition(), configClass);\n \t\t}\n \n \t\tif (logger.isDebugEnabled()) {\n \t\t\tlogger.debug(String.format(\"Registering bean definition for @Bean method %s.%s()\", configClass.getMetadata().getClassName(), beanName));\n \t\t}\n \n \t\tregistry.registerBeanDefinition(beanName, beanDefToRegister);\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"239ce1466ce118294f5c7b8e842a80815fd813de": {
			"type": "Ybodychange",
			"commitMessage": "Update @Conditional processing logic\n\nDefer @Conditional processing on @Configuration classes until the bean\ndefinitions are loaded, rather than when the @Configuration class is\nparsed. This provides better support for @Conditional implementations\nthat inspect bean definitions.\n\nThis commit also fixes some minor problems with original implementation\nand replaces the ConditionalAnnotationHelper class with\nConditionEvaluator.\n\nIssue: SPR-10534\n",
			"commitDate": "2013-06-04, 10:27 AM",
			"commitName": "239ce1466ce118294f5c7b8e842a80815fd813de",
			"commitAuthor": "Phillip Webb",
			"commitDateOld": "2013-05-13, 3:04 PM",
			"commitNameOld": "94685481162a93666fc2f39b66223833a6bcb418",
			"commitAuthorOld": "Rob Winch",
			"daysBetweenCommits": 21.81,
			"commitsBetweenForRepo": 52,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,116 +1,116 @@\n \tprivate void loadBeanDefinitionsForBeanMethod(BeanMethod beanMethod) {\n-\t\tif (ConditionalAnnotationHelper.shouldSkip(beanMethod, this.registry,\n-\t\t\t\tthis.environment, this.importBeanNameGenerator)) {\n+\t\tif (ConditionEvaluator.get(beanMethod.getMetadata(), false).shouldSkip(\n+\t\t\t\tthis.registry, this.environment)) {\n \t\t\treturn;\n \t\t}\n \t\tConfigurationClass configClass = beanMethod.getConfigurationClass();\n \t\tMethodMetadata metadata = beanMethod.getMetadata();\n \n \t\tRootBeanDefinition beanDef = new ConfigurationClassBeanDefinition(configClass);\n \t\tbeanDef.setResource(configClass.getResource());\n \t\tbeanDef.setSource(this.sourceExtractor.extractSource(metadata, configClass.getResource()));\n \t\tif (metadata.isStatic()) {\n \t\t\t// static @Bean method\n \t\t\tbeanDef.setBeanClassName(configClass.getMetadata().getClassName());\n \t\t\tbeanDef.setFactoryMethodName(metadata.getMethodName());\n \t\t}\n \t\telse {\n \t\t\t// instance @Bean method\n \t\t\tbeanDef.setFactoryBeanName(configClass.getBeanName());\n \t\t\tbeanDef.setUniqueFactoryMethodName(metadata.getMethodName());\n \t\t}\n \t\tbeanDef.setAutowireMode(RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n \t\tbeanDef.setAttribute(RequiredAnnotationBeanPostProcessor.SKIP_REQUIRED_CHECK_ATTRIBUTE, Boolean.TRUE);\n \n \t\t// consider role\n \t\tAnnotationAttributes role = attributesFor(metadata, Role.class);\n \t\tif (role != null) {\n \t\t\tbeanDef.setRole(role.<Integer>getNumber(\"value\"));\n \t\t}\n \n \t\t// consider name and any aliases\n \t\tAnnotationAttributes bean = attributesFor(metadata, Bean.class);\n \t\tList<String> names = new ArrayList<String>(Arrays.asList(bean.getStringArray(\"name\")));\n \t\tString beanName = (names.size() > 0 ? names.remove(0) : beanMethod.getMetadata().getMethodName());\n \t\tfor (String alias : names) {\n \t\t\tthis.registry.registerAlias(beanName, alias);\n \t\t}\n \n \t\t// has this already been overridden (e.g. via XML)?\n \t\tif (this.registry.containsBeanDefinition(beanName)) {\n \t\t\tBeanDefinition existingBeanDef = registry.getBeanDefinition(beanName);\n \t\t\t// is the existing bean definition one that was created from a configuration class?\n \t\t\tif (!(existingBeanDef instanceof ConfigurationClassBeanDefinition)) {\n \t\t\t\t// no -> then it's an external override, probably XML\n \t\t\t\t// overriding is legal, return immediately\n \t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\tlogger.debug(String.format(\"Skipping loading bean definition for %s: a definition for bean \" +\n \t\t\t\t\t\t\t\"'%s' already exists. This is likely due to an override in XML.\", beanMethod, beanName));\n \t\t\t\t}\n \t\t\t\treturn;\n \t\t\t}\n \t\t}\n \n \t\tif (metadata.isAnnotated(Primary.class.getName())) {\n \t\t\tbeanDef.setPrimary(true);\n \t\t}\n \n \t\t// is this bean to be instantiated lazily?\n \t\tif (metadata.isAnnotated(Lazy.class.getName())) {\n \t\t\tAnnotationAttributes lazy = attributesFor(metadata, Lazy.class);\n \t\t\tbeanDef.setLazyInit(lazy.getBoolean(\"value\"));\n \t\t}\n \t\telse if (configClass.getMetadata().isAnnotated(Lazy.class.getName())){\n \t\t\tAnnotationAttributes lazy = attributesFor(configClass.getMetadata(), Lazy.class);\n \t\t\tbeanDef.setLazyInit(lazy.getBoolean(\"value\"));\n \t\t}\n \n \t\tif (metadata.isAnnotated(DependsOn.class.getName())) {\n \t\t\tAnnotationAttributes dependsOn = attributesFor(metadata, DependsOn.class);\n \t\t\tString[] otherBeans = dependsOn.getStringArray(\"value\");\n \t\t\tif (otherBeans.length > 0) {\n \t\t\t\tbeanDef.setDependsOn(otherBeans);\n \t\t\t}\n \t\t}\n \n \t\tAutowire autowire = bean.getEnum(\"autowire\");\n \t\tif (autowire.isAutowire()) {\n \t\t\tbeanDef.setAutowireMode(autowire.value());\n \t\t}\n \n \t\tString initMethodName = bean.getString(\"initMethod\");\n \t\tif (StringUtils.hasText(initMethodName)) {\n \t\t\tbeanDef.setInitMethodName(initMethodName);\n \t\t}\n \n \t\tString destroyMethodName = bean.getString(\"destroyMethod\");\n \t\tif (StringUtils.hasText(destroyMethodName)) {\n \t\t\tbeanDef.setDestroyMethodName(destroyMethodName);\n \t\t}\n \n \t\t// consider scoping\n \t\tScopedProxyMode proxyMode = ScopedProxyMode.NO;\n \t\tAnnotationAttributes scope = attributesFor(metadata, Scope.class);\n \t\tif (scope != null) {\n \t\t\tbeanDef.setScope(scope.getString(\"value\"));\n \t\t\tproxyMode = scope.getEnum(\"proxyMode\");\n \t\t\tif (proxyMode == ScopedProxyMode.DEFAULT) {\n \t\t\t\tproxyMode = ScopedProxyMode.NO;\n \t\t\t}\n \t\t}\n \n \t\t// replace the original bean definition with the target one, if necessary\n \t\tBeanDefinition beanDefToRegister = beanDef;\n \t\tif (proxyMode != ScopedProxyMode.NO) {\n \t\t\tBeanDefinitionHolder proxyDef = ScopedProxyCreator.createScopedProxy(\n \t\t\t\t\tnew BeanDefinitionHolder(beanDef, beanName), this.registry, proxyMode == ScopedProxyMode.TARGET_CLASS);\n \t\t\tbeanDefToRegister =\n \t\t\t\t\tnew ConfigurationClassBeanDefinition((RootBeanDefinition) proxyDef.getBeanDefinition(), configClass);\n \t\t}\n \n \t\tif (logger.isDebugEnabled()) {\n \t\t\tlogger.debug(String.format(\"Registering bean definition for @Bean method %s.%s()\", configClass.getMetadata().getClassName(), beanName));\n \t\t}\n \n \t\tregistry.registerBeanDefinition(beanName, beanDefToRegister);\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"b257253a2b6890ef532f27a662c441fc4fd21f3b": {
			"type": "Ybodychange",
			"commitMessage": "Support for @Conditional configuration\n\nIntroduce new @Conditional annotation that can be used to filter\nwhich @Configuration classes or methods are loaded. @Conditional\ncan be used directly or as a meta-annotation. Condition implementations\nare provided via the 'Condition' interface and are free to filter based\non any criteria available at the time that they run. The\nConditionalContext provides access to the BeanDefinitionRegistry,\nEnvironment and ConfigurableListableBeanFactory along with a\nResourceLoader and ClassLoader.\n\nThe existing @Profile annotation has been refactored as a @Conditional\nwith the added benefit that it can now be used as a method level\nannotation.\n",
			"commitDate": "2013-05-08, 7:41 PM",
			"commitName": "b257253a2b6890ef532f27a662c441fc4fd21f3b",
			"commitAuthor": "Phillip Webb",
			"commitDateOld": "2013-04-23, 4:49 AM",
			"commitNameOld": "d3a406876834b91a4cf3b1e840855caeb0446d28",
			"commitAuthorOld": "Juergen Hoeller",
			"daysBetweenCommits": 15.62,
			"commitsBetweenForRepo": 93,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,112 +1,116 @@\n \tprivate void loadBeanDefinitionsForBeanMethod(BeanMethod beanMethod) {\n+\t\tif (ConditionalAnnotationHelper.shouldSkip(beanMethod, this.registry,\n+\t\t\t\tthis.environment, this.importBeanNameGenerator)) {\n+\t\t\treturn;\n+\t\t}\n \t\tConfigurationClass configClass = beanMethod.getConfigurationClass();\n \t\tMethodMetadata metadata = beanMethod.getMetadata();\n \n \t\tRootBeanDefinition beanDef = new ConfigurationClassBeanDefinition(configClass);\n \t\tbeanDef.setResource(configClass.getResource());\n \t\tbeanDef.setSource(this.sourceExtractor.extractSource(metadata, configClass.getResource()));\n \t\tif (metadata.isStatic()) {\n \t\t\t// static @Bean method\n \t\t\tbeanDef.setBeanClassName(configClass.getMetadata().getClassName());\n \t\t\tbeanDef.setFactoryMethodName(metadata.getMethodName());\n \t\t}\n \t\telse {\n \t\t\t// instance @Bean method\n \t\t\tbeanDef.setFactoryBeanName(configClass.getBeanName());\n \t\t\tbeanDef.setUniqueFactoryMethodName(metadata.getMethodName());\n \t\t}\n \t\tbeanDef.setAutowireMode(RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n \t\tbeanDef.setAttribute(RequiredAnnotationBeanPostProcessor.SKIP_REQUIRED_CHECK_ATTRIBUTE, Boolean.TRUE);\n \n \t\t// consider role\n \t\tAnnotationAttributes role = attributesFor(metadata, Role.class);\n \t\tif (role != null) {\n \t\t\tbeanDef.setRole(role.<Integer>getNumber(\"value\"));\n \t\t}\n \n \t\t// consider name and any aliases\n \t\tAnnotationAttributes bean = attributesFor(metadata, Bean.class);\n \t\tList<String> names = new ArrayList<String>(Arrays.asList(bean.getStringArray(\"name\")));\n \t\tString beanName = (names.size() > 0 ? names.remove(0) : beanMethod.getMetadata().getMethodName());\n \t\tfor (String alias : names) {\n \t\t\tthis.registry.registerAlias(beanName, alias);\n \t\t}\n \n \t\t// has this already been overridden (e.g. via XML)?\n \t\tif (this.registry.containsBeanDefinition(beanName)) {\n \t\t\tBeanDefinition existingBeanDef = registry.getBeanDefinition(beanName);\n \t\t\t// is the existing bean definition one that was created from a configuration class?\n \t\t\tif (!(existingBeanDef instanceof ConfigurationClassBeanDefinition)) {\n \t\t\t\t// no -> then it's an external override, probably XML\n \t\t\t\t// overriding is legal, return immediately\n \t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\tlogger.debug(String.format(\"Skipping loading bean definition for %s: a definition for bean \" +\n \t\t\t\t\t\t\t\"'%s' already exists. This is likely due to an override in XML.\", beanMethod, beanName));\n \t\t\t\t}\n \t\t\t\treturn;\n \t\t\t}\n \t\t}\n \n \t\tif (metadata.isAnnotated(Primary.class.getName())) {\n \t\t\tbeanDef.setPrimary(true);\n \t\t}\n \n \t\t// is this bean to be instantiated lazily?\n \t\tif (metadata.isAnnotated(Lazy.class.getName())) {\n \t\t\tAnnotationAttributes lazy = attributesFor(metadata, Lazy.class);\n \t\t\tbeanDef.setLazyInit(lazy.getBoolean(\"value\"));\n \t\t}\n \t\telse if (configClass.getMetadata().isAnnotated(Lazy.class.getName())){\n \t\t\tAnnotationAttributes lazy = attributesFor(configClass.getMetadata(), Lazy.class);\n \t\t\tbeanDef.setLazyInit(lazy.getBoolean(\"value\"));\n \t\t}\n \n \t\tif (metadata.isAnnotated(DependsOn.class.getName())) {\n \t\t\tAnnotationAttributes dependsOn = attributesFor(metadata, DependsOn.class);\n \t\t\tString[] otherBeans = dependsOn.getStringArray(\"value\");\n \t\t\tif (otherBeans.length > 0) {\n \t\t\t\tbeanDef.setDependsOn(otherBeans);\n \t\t\t}\n \t\t}\n \n \t\tAutowire autowire = bean.getEnum(\"autowire\");\n \t\tif (autowire.isAutowire()) {\n \t\t\tbeanDef.setAutowireMode(autowire.value());\n \t\t}\n \n \t\tString initMethodName = bean.getString(\"initMethod\");\n \t\tif (StringUtils.hasText(initMethodName)) {\n \t\t\tbeanDef.setInitMethodName(initMethodName);\n \t\t}\n \n \t\tString destroyMethodName = bean.getString(\"destroyMethod\");\n \t\tif (StringUtils.hasText(destroyMethodName)) {\n \t\t\tbeanDef.setDestroyMethodName(destroyMethodName);\n \t\t}\n \n \t\t// consider scoping\n \t\tScopedProxyMode proxyMode = ScopedProxyMode.NO;\n \t\tAnnotationAttributes scope = attributesFor(metadata, Scope.class);\n \t\tif (scope != null) {\n \t\t\tbeanDef.setScope(scope.getString(\"value\"));\n \t\t\tproxyMode = scope.getEnum(\"proxyMode\");\n \t\t\tif (proxyMode == ScopedProxyMode.DEFAULT) {\n \t\t\t\tproxyMode = ScopedProxyMode.NO;\n \t\t\t}\n \t\t}\n \n \t\t// replace the original bean definition with the target one, if necessary\n \t\tBeanDefinition beanDefToRegister = beanDef;\n \t\tif (proxyMode != ScopedProxyMode.NO) {\n \t\t\tBeanDefinitionHolder proxyDef = ScopedProxyCreator.createScopedProxy(\n \t\t\t\t\tnew BeanDefinitionHolder(beanDef, beanName), this.registry, proxyMode == ScopedProxyMode.TARGET_CLASS);\n \t\t\tbeanDefToRegister =\n \t\t\t\t\tnew ConfigurationClassBeanDefinition((RootBeanDefinition) proxyDef.getBeanDefinition(), configClass);\n \t\t}\n \n \t\tif (logger.isDebugEnabled()) {\n \t\t\tlogger.debug(String.format(\"Registering bean definition for @Bean method %s.%s()\", configClass.getMetadata().getClassName(), beanName));\n \t\t}\n \n \t\tregistry.registerBeanDefinition(beanName, beanDefToRegister);\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"6b82d293d5ed2ec6f4e02432594a73e354d17928": {
			"type": "Ybodychange",
			"commitMessage": "ConfigurationClassPostProcessor allows for overriding of scoped-proxy bean definitions\n\nIssue: SPR-10265\n",
			"commitDate": "2013-02-06, 12:01 PM",
			"commitName": "6b82d293d5ed2ec6f4e02432594a73e354d17928",
			"commitAuthor": "Juergen Hoeller",
			"commitDateOld": "2012-12-28, 11:49 AM",
			"commitNameOld": "1762157ad1a89ff8778387a2c72a8e36ff341a40",
			"commitAuthorOld": "Phillip Webb",
			"daysBetweenCommits": 40.01,
			"commitsBetweenForRepo": 224,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,111 +1,112 @@\n \tprivate void loadBeanDefinitionsForBeanMethod(BeanMethod beanMethod) {\n \t\tConfigurationClass configClass = beanMethod.getConfigurationClass();\n \t\tMethodMetadata metadata = beanMethod.getMetadata();\n \n \t\tRootBeanDefinition beanDef = new ConfigurationClassBeanDefinition(configClass);\n \t\tbeanDef.setResource(configClass.getResource());\n \t\tbeanDef.setSource(this.sourceExtractor.extractSource(metadata, configClass.getResource()));\n \t\tif (metadata.isStatic()) {\n \t\t\t// static @Bean method\n \t\t\tbeanDef.setBeanClassName(configClass.getMetadata().getClassName());\n \t\t\tbeanDef.setFactoryMethodName(metadata.getMethodName());\n \t\t}\n \t\telse {\n \t\t\t// instance @Bean method\n \t\t\tbeanDef.setFactoryBeanName(configClass.getBeanName());\n \t\t\tbeanDef.setUniqueFactoryMethodName(metadata.getMethodName());\n \t\t}\n \t\tbeanDef.setAutowireMode(RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n \t\tbeanDef.setAttribute(RequiredAnnotationBeanPostProcessor.SKIP_REQUIRED_CHECK_ATTRIBUTE, Boolean.TRUE);\n \n \t\t// consider role\n \t\tAnnotationAttributes role = attributesFor(metadata, Role.class);\n \t\tif (role != null) {\n \t\t\tbeanDef.setRole(role.<Integer>getNumber(\"value\"));\n \t\t}\n \n \t\t// consider name and any aliases\n \t\tAnnotationAttributes bean = attributesFor(metadata, Bean.class);\n \t\tList<String> names = new ArrayList<String>(Arrays.asList(bean.getStringArray(\"name\")));\n \t\tString beanName = (names.size() > 0 ? names.remove(0) : beanMethod.getMetadata().getMethodName());\n \t\tfor (String alias : names) {\n \t\t\tthis.registry.registerAlias(beanName, alias);\n \t\t}\n \n \t\t// has this already been overridden (e.g. via XML)?\n \t\tif (this.registry.containsBeanDefinition(beanName)) {\n \t\t\tBeanDefinition existingBeanDef = registry.getBeanDefinition(beanName);\n \t\t\t// is the existing bean definition one that was created from a configuration class?\n \t\t\tif (!(existingBeanDef instanceof ConfigurationClassBeanDefinition)) {\n \t\t\t\t// no -> then it's an external override, probably XML\n \t\t\t\t// overriding is legal, return immediately\n \t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\tlogger.debug(String.format(\"Skipping loading bean definition for %s: a definition for bean \" +\n \t\t\t\t\t\t\t\"'%s' already exists. This is likely due to an override in XML.\", beanMethod, beanName));\n \t\t\t\t}\n \t\t\t\treturn;\n \t\t\t}\n \t\t}\n \n \t\tif (metadata.isAnnotated(Primary.class.getName())) {\n \t\t\tbeanDef.setPrimary(true);\n \t\t}\n \n \t\t// is this bean to be instantiated lazily?\n \t\tif (metadata.isAnnotated(Lazy.class.getName())) {\n \t\t\tAnnotationAttributes lazy = attributesFor(metadata, Lazy.class);\n \t\t\tbeanDef.setLazyInit(lazy.getBoolean(\"value\"));\n \t\t}\n \t\telse if (configClass.getMetadata().isAnnotated(Lazy.class.getName())){\n \t\t\tAnnotationAttributes lazy = attributesFor(configClass.getMetadata(), Lazy.class);\n \t\t\tbeanDef.setLazyInit(lazy.getBoolean(\"value\"));\n \t\t}\n \n \t\tif (metadata.isAnnotated(DependsOn.class.getName())) {\n \t\t\tAnnotationAttributes dependsOn = attributesFor(metadata, DependsOn.class);\n \t\t\tString[] otherBeans = dependsOn.getStringArray(\"value\");\n \t\t\tif (otherBeans.length > 0) {\n \t\t\t\tbeanDef.setDependsOn(otherBeans);\n \t\t\t}\n \t\t}\n \n \t\tAutowire autowire = bean.getEnum(\"autowire\");\n \t\tif (autowire.isAutowire()) {\n \t\t\tbeanDef.setAutowireMode(autowire.value());\n \t\t}\n \n \t\tString initMethodName = bean.getString(\"initMethod\");\n \t\tif (StringUtils.hasText(initMethodName)) {\n \t\t\tbeanDef.setInitMethodName(initMethodName);\n \t\t}\n \n \t\tString destroyMethodName = bean.getString(\"destroyMethod\");\n \t\tif (StringUtils.hasText(destroyMethodName)) {\n \t\t\tbeanDef.setDestroyMethodName(destroyMethodName);\n \t\t}\n \n \t\t// consider scoping\n \t\tScopedProxyMode proxyMode = ScopedProxyMode.NO;\n \t\tAnnotationAttributes scope = attributesFor(metadata, Scope.class);\n \t\tif (scope != null) {\n \t\t\tbeanDef.setScope(scope.getString(\"value\"));\n \t\t\tproxyMode = scope.getEnum(\"proxyMode\");\n \t\t\tif (proxyMode == ScopedProxyMode.DEFAULT) {\n \t\t\t\tproxyMode = ScopedProxyMode.NO;\n \t\t\t}\n \t\t}\n \n \t\t// replace the original bean definition with the target one, if necessary\n \t\tBeanDefinition beanDefToRegister = beanDef;\n \t\tif (proxyMode != ScopedProxyMode.NO) {\n \t\t\tBeanDefinitionHolder proxyDef = ScopedProxyCreator.createScopedProxy(\n \t\t\t\t\tnew BeanDefinitionHolder(beanDef, beanName), this.registry, proxyMode == ScopedProxyMode.TARGET_CLASS);\n-\t\t\tbeanDefToRegister = proxyDef.getBeanDefinition();\n+\t\t\tbeanDefToRegister =\n+\t\t\t\t\tnew ConfigurationClassBeanDefinition((RootBeanDefinition) proxyDef.getBeanDefinition(), configClass);\n \t\t}\n \n \t\tif (logger.isDebugEnabled()) {\n \t\t\tlogger.debug(String.format(\"Registering bean definition for @Bean method %s.%s()\", configClass.getMetadata().getClassName(), beanName));\n \t\t}\n \n \t\tregistry.registerBeanDefinition(beanName, beanDefToRegister);\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"02a4473c62d8240837bec297f0a1f3cb67ef8a7b": {
			"type": "Yfilerename",
			"commitMessage": "Rename modules {org.springframework.*=>spring-*}\n\nThis renaming more intuitively expresses the relationship between\nsubprojects and the JAR artifacts they produce.\n\nTracking history across these renames is possible, but it requires\nuse of the --follow flag to `git log`, for example\n\n    $ git log spring-aop/src/main/java/org/springframework/aop/Advisor.java\n\nwill show history up until the renaming event, where\n\n    $ git log --follow spring-aop/src/main/java/org/springframework/aop/Advisor.java\n\nwill show history for all changes to the file, before and after the\nrenaming.\n\nSee http://chrisbeams.com/git-diff-across-renamed-directories\n",
			"commitDate": "2012-01-31, 5:37 AM",
			"commitName": "02a4473c62d8240837bec297f0a1f3cb67ef8a7b",
			"commitAuthor": "Chris Beams",
			"commitDateOld": "2012-01-31, 5:37 AM",
			"commitNameOld": "b6cb514d383dcef52ba6c609a863f19e1a4c1faf",
			"commitAuthorOld": "Chris Beams",
			"daysBetweenCommits": 0,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "",
			"extendedDetails": {
				"oldPath": "org.springframework.context/src/main/java/org/springframework/context/annotation/ConfigurationClassBeanDefinitionReader.java",
				"newPath": "spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassBeanDefinitionReader.java"
			}
		},
		"52bef0b7b024e794186437dee78945fbb5bd209a": {
			"type": "Ybodychange",
			"commitMessage": "Allow static modifier on @Bean methods\n\nDeclaring @Bean methods as 'static' is now permitted, whereas previously\nit raised an exception at @Configuration class validation time.\n\nA static @Bean method can be called by the container without requiring\nthe instantiation of its declaring @Configuration class. This is\nparticularly useful when dealing with BeanFactoryPostProcessor beans,\nas they can interfere with the standard post-processing lifecycle\nnecessary to handle @Autowired, @Inject, @Value, @PostConstruct and\nother annotations.\n\nstatic @Bean methods cannot recieve CGLIB enhancement for scoping and\nAOP concerns. This is acceptable in BFPP cases as they rarely if ever\nneed it, and should not in typical cases ever be called by another\n@Bean method.  Once invoked by the container, the resulting bean will\nbe cached as usual, but multiple invocations of the static @Bean method\nwill result in creation of multiple instances of the bean.\n\nstatic @Bean methods may not, for obvious reasons, refer to normal\ninstance @Bean methods, but again this is not likely a concern for BFPP\ntypes. In the rare case that they do need a bean reference, parameter\ninjection into the static @Bean method is technically an option, but\nshould be avoided as it will potentially cause premature instantiation\nof more beans that the user may have intended.\n\nNote particularly that a WARN-level log message is now issued for any\nnon-static @Bean method with a return type assignable to BFPP.  This\nserves as a strong recommendation to users that they always mark BFPP\n@Bean methods as static.\n\nSee @Bean Javadoc for complete details.\n\nIssue: SPR-8257, SPR-8269\n",
			"commitDate": "2011-05-10, 4:55 AM",
			"commitName": "52bef0b7b024e794186437dee78945fbb5bd209a",
			"commitAuthor": "Chris Beams",
			"commitDateOld": "2011-05-08, 6:49 AM",
			"commitNameOld": "d0c31ad84cffd7af718a45d679483a1c51f9e552",
			"commitAuthorOld": "Chris Beams",
			"daysBetweenCommits": 1.92,
			"commitsBetweenForRepo": 6,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,101 +1,109 @@\n \tprivate void loadBeanDefinitionsForBeanMethod(BeanMethod beanMethod) {\n \t\tConfigurationClass configClass = beanMethod.getConfigurationClass();\n \t\tMethodMetadata metadata = beanMethod.getMetadata();\n \n \t\tRootBeanDefinition beanDef = new ConfigurationClassBeanDefinition(configClass);\n \t\tbeanDef.setResource(configClass.getResource());\n \t\tbeanDef.setSource(this.sourceExtractor.extractSource(metadata, configClass.getResource()));\n-\t\tbeanDef.setFactoryBeanName(configClass.getBeanName());\n-\t\tbeanDef.setUniqueFactoryMethodName(metadata.getMethodName());\n+\t\tif (metadata.isStatic()) {\n+\t\t\t// static @Bean method\n+\t\t\tbeanDef.setBeanClassName(configClass.getMetadata().getClassName());\n+\t\t\tbeanDef.setFactoryMethodName(metadata.getMethodName());\n+\t\t}\n+\t\telse {\n+\t\t\t// instance @Bean method\n+\t\t\tbeanDef.setFactoryBeanName(configClass.getBeanName());\n+\t\t\tbeanDef.setUniqueFactoryMethodName(metadata.getMethodName());\n+\t\t}\n \t\tbeanDef.setAutowireMode(RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n \t\tbeanDef.setAttribute(RequiredAnnotationBeanPostProcessor.SKIP_REQUIRED_CHECK_ATTRIBUTE, Boolean.TRUE);\n \n \t\t// consider role\n \t\tMap<String, Object> roleAttributes = metadata.getAnnotationAttributes(Role.class.getName());\n \t\tif (roleAttributes != null) {\n \t\t\tint role = (Integer) roleAttributes.get(\"value\");\n \t\t\tbeanDef.setRole(role);\n \t\t}\n \n \t\t// consider name and any aliases\n \t\tMap<String, Object> beanAttributes = metadata.getAnnotationAttributes(Bean.class.getName());\n \t\tList<String> names = new ArrayList<String>(Arrays.asList((String[]) beanAttributes.get(\"name\")));\n \t\tString beanName = (names.size() > 0 ? names.remove(0) : beanMethod.getMetadata().getMethodName());\n \t\tfor (String alias : names) {\n \t\t\tthis.registry.registerAlias(beanName, alias);\n \t\t}\n \n \t\t// has this already been overridden (e.g. via XML)?\n \t\tif (this.registry.containsBeanDefinition(beanName)) {\n \t\t\tBeanDefinition existingBeanDef = registry.getBeanDefinition(beanName);\n \t\t\t// is the existing bean definition one that was created from a configuration class?\n \t\t\tif (!(existingBeanDef instanceof ConfigurationClassBeanDefinition)) {\n \t\t\t\t// no -> then it's an external override, probably XML\n \t\t\t\t// overriding is legal, return immediately\n \t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\tlogger.debug(String.format(\"Skipping loading bean definition for %s: a definition for bean \" +\n \t\t\t\t\t\t\t\"'%s' already exists. This is likely due to an override in XML.\", beanMethod, beanName));\n \t\t\t\t}\n \t\t\t\treturn;\n \t\t\t}\n \t\t}\n \n \t\tif (metadata.isAnnotated(Primary.class.getName())) {\n \t\t\tbeanDef.setPrimary(true);\n \t\t}\n \n \t\t// is this bean to be instantiated lazily?\n \t\tif (metadata.isAnnotated(Lazy.class.getName())) {\n \t\t\tbeanDef.setLazyInit((Boolean) metadata.getAnnotationAttributes(Lazy.class.getName()).get(\"value\"));\n \t\t}\n \t\telse if (configClass.getMetadata().isAnnotated(Lazy.class.getName())){\n \t\t\tbeanDef.setLazyInit((Boolean) configClass.getMetadata().getAnnotationAttributes(Lazy.class.getName()).get(\"value\"));\n \t\t}\n \n \t\tif (metadata.isAnnotated(DependsOn.class.getName())) {\n \t\t\tString[] dependsOn = (String[]) metadata.getAnnotationAttributes(DependsOn.class.getName()).get(\"value\");\n \t\t\tif (dependsOn.length > 0) {\n \t\t\t\tbeanDef.setDependsOn(dependsOn);\n \t\t\t}\n \t\t}\n \n \t\tAutowire autowire = (Autowire) beanAttributes.get(\"autowire\");\n \t\tif (autowire.isAutowire()) {\n \t\t\tbeanDef.setAutowireMode(autowire.value());\n \t\t}\n \n \t\tString initMethodName = (String) beanAttributes.get(\"initMethod\");\n \t\tif (StringUtils.hasText(initMethodName)) {\n \t\t\tbeanDef.setInitMethodName(initMethodName);\n \t\t}\n \n \t\tString destroyMethodName = (String) beanAttributes.get(\"destroyMethod\");\n \t\tif (StringUtils.hasText(destroyMethodName)) {\n \t\t\tbeanDef.setDestroyMethodName(destroyMethodName);\n \t\t}\n \n \t\t// consider scoping\n \t\tScopedProxyMode proxyMode = ScopedProxyMode.NO;\n \t\tMap<String, Object> scopeAttributes = metadata.getAnnotationAttributes(Scope.class.getName());\n \t\tif (scopeAttributes != null) {\n \t\t\tbeanDef.setScope((String) scopeAttributes.get(\"value\"));\n \t\t\tproxyMode = (ScopedProxyMode) scopeAttributes.get(\"proxyMode\");\n \t\t\tif (proxyMode == ScopedProxyMode.DEFAULT) {\n \t\t\t\tproxyMode = ScopedProxyMode.NO;\n \t\t\t}\n \t\t}\n \n \t\t// replace the original bean definition with the target one, if necessary\n \t\tBeanDefinition beanDefToRegister = beanDef;\n \t\tif (proxyMode != ScopedProxyMode.NO) {\n \t\t\tBeanDefinitionHolder proxyDef = ScopedProxyCreator.createScopedProxy(\n \t\t\t\t\tnew BeanDefinitionHolder(beanDef, beanName), this.registry, proxyMode == ScopedProxyMode.TARGET_CLASS);\n \t\t\tbeanDefToRegister = proxyDef.getBeanDefinition();\n \t\t}\n \n \t\tif (logger.isDebugEnabled()) {\n \t\t\tlogger.debug(String.format(\"Registering bean definition for @Bean method %s.%s()\", configClass.getMetadata().getClassName(), beanName));\n \t\t}\n \n \t\tregistry.registerBeanDefinition(beanName, beanDefToRegister);\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"cf0fc278bbc5ef4a3b08cc0a98d581ee8f930eae": {
			"type": "Ybodychange",
			"commitMessage": "Introduce @Role\n\nAs a mechanism for setting the 'role' hint on BeanDefinitions created\nvia component-scanning or @Bean methods.\n",
			"commitDate": "2011-05-06, 12:08 PM",
			"commitName": "cf0fc278bbc5ef4a3b08cc0a98d581ee8f930eae",
			"commitAuthor": "Chris Beams",
			"commitDateOld": "2011-05-06, 12:04 PM",
			"commitNameOld": "856da7edb984cd8ad5643a376e536f40e06d8faa",
			"commitAuthorOld": "Chris Beams",
			"daysBetweenCommits": 0,
			"commitsBetweenForRepo": 7,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,94 +1,101 @@\n \tprivate void loadBeanDefinitionsForBeanMethod(BeanMethod beanMethod) {\n \t\tConfigurationClass configClass = beanMethod.getConfigurationClass();\n \t\tMethodMetadata metadata = beanMethod.getMetadata();\n \n \t\tRootBeanDefinition beanDef = new ConfigurationClassBeanDefinition(configClass);\n \t\tbeanDef.setResource(configClass.getResource());\n \t\tbeanDef.setSource(this.sourceExtractor.extractSource(metadata, configClass.getResource()));\n \t\tbeanDef.setFactoryBeanName(configClass.getBeanName());\n \t\tbeanDef.setUniqueFactoryMethodName(metadata.getMethodName());\n \t\tbeanDef.setAutowireMode(RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n \t\tbeanDef.setAttribute(RequiredAnnotationBeanPostProcessor.SKIP_REQUIRED_CHECK_ATTRIBUTE, Boolean.TRUE);\n \n+\t\t// consider role\n+\t\tMap<String, Object> roleAttributes = metadata.getAnnotationAttributes(Role.class.getName());\n+\t\tif (roleAttributes != null) {\n+\t\t\tint role = (Integer) roleAttributes.get(\"value\");\n+\t\t\tbeanDef.setRole(role);\n+\t\t}\n+\n \t\t// consider name and any aliases\n \t\tMap<String, Object> beanAttributes = metadata.getAnnotationAttributes(Bean.class.getName());\n \t\tList<String> names = new ArrayList<String>(Arrays.asList((String[]) beanAttributes.get(\"name\")));\n \t\tString beanName = (names.size() > 0 ? names.remove(0) : beanMethod.getMetadata().getMethodName());\n \t\tfor (String alias : names) {\n \t\t\tthis.registry.registerAlias(beanName, alias);\n \t\t}\n \n \t\t// has this already been overridden (e.g. via XML)?\n \t\tif (this.registry.containsBeanDefinition(beanName)) {\n \t\t\tBeanDefinition existingBeanDef = registry.getBeanDefinition(beanName);\n \t\t\t// is the existing bean definition one that was created from a configuration class?\n \t\t\tif (!(existingBeanDef instanceof ConfigurationClassBeanDefinition)) {\n \t\t\t\t// no -> then it's an external override, probably XML\n \t\t\t\t// overriding is legal, return immediately\n \t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\tlogger.debug(String.format(\"Skipping loading bean definition for %s: a definition for bean \" +\n \t\t\t\t\t\t\t\"'%s' already exists. This is likely due to an override in XML.\", beanMethod, beanName));\n \t\t\t\t}\n \t\t\t\treturn;\n \t\t\t}\n \t\t}\n \n \t\tif (metadata.isAnnotated(Primary.class.getName())) {\n \t\t\tbeanDef.setPrimary(true);\n \t\t}\n \n \t\t// is this bean to be instantiated lazily?\n \t\tif (metadata.isAnnotated(Lazy.class.getName())) {\n \t\t\tbeanDef.setLazyInit((Boolean) metadata.getAnnotationAttributes(Lazy.class.getName()).get(\"value\"));\n \t\t}\n \t\telse if (configClass.getMetadata().isAnnotated(Lazy.class.getName())){\n \t\t\tbeanDef.setLazyInit((Boolean) configClass.getMetadata().getAnnotationAttributes(Lazy.class.getName()).get(\"value\"));\n \t\t}\n \n \t\tif (metadata.isAnnotated(DependsOn.class.getName())) {\n \t\t\tString[] dependsOn = (String[]) metadata.getAnnotationAttributes(DependsOn.class.getName()).get(\"value\");\n \t\t\tif (dependsOn.length > 0) {\n \t\t\t\tbeanDef.setDependsOn(dependsOn);\n \t\t\t}\n \t\t}\n \n \t\tAutowire autowire = (Autowire) beanAttributes.get(\"autowire\");\n \t\tif (autowire.isAutowire()) {\n \t\t\tbeanDef.setAutowireMode(autowire.value());\n \t\t}\n \n \t\tString initMethodName = (String) beanAttributes.get(\"initMethod\");\n \t\tif (StringUtils.hasText(initMethodName)) {\n \t\t\tbeanDef.setInitMethodName(initMethodName);\n \t\t}\n \n \t\tString destroyMethodName = (String) beanAttributes.get(\"destroyMethod\");\n \t\tif (StringUtils.hasText(destroyMethodName)) {\n \t\t\tbeanDef.setDestroyMethodName(destroyMethodName);\n \t\t}\n \n \t\t// consider scoping\n \t\tScopedProxyMode proxyMode = ScopedProxyMode.NO;\n \t\tMap<String, Object> scopeAttributes = metadata.getAnnotationAttributes(Scope.class.getName());\n \t\tif (scopeAttributes != null) {\n \t\t\tbeanDef.setScope((String) scopeAttributes.get(\"value\"));\n \t\t\tproxyMode = (ScopedProxyMode) scopeAttributes.get(\"proxyMode\");\n \t\t\tif (proxyMode == ScopedProxyMode.DEFAULT) {\n \t\t\t\tproxyMode = ScopedProxyMode.NO;\n \t\t\t}\n \t\t}\n \n \t\t// replace the original bean definition with the target one, if necessary\n \t\tBeanDefinition beanDefToRegister = beanDef;\n \t\tif (proxyMode != ScopedProxyMode.NO) {\n \t\t\tBeanDefinitionHolder proxyDef = ScopedProxyCreator.createScopedProxy(\n \t\t\t\t\tnew BeanDefinitionHolder(beanDef, beanName), this.registry, proxyMode == ScopedProxyMode.TARGET_CLASS);\n \t\t\tbeanDefToRegister = proxyDef.getBeanDefinition();\n \t\t}\n \n \t\tif (logger.isDebugEnabled()) {\n \t\t\tlogger.debug(String.format(\"Registering bean definition for @Bean method %s.%s()\", configClass.getMetadata().getClassName(), beanName));\n \t\t}\n \n \t\tregistry.registerBeanDefinition(beanName, beanDefToRegister);\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"0a790c143feeabf571e98f8ee0700a4586cbb67c": {
			"type": "Yparameterchange",
			"commitMessage": "Rename ConfigurationClassMethod => BeanMethod\n",
			"commitDate": "2011-05-06, 12:01 PM",
			"commitName": "0a790c143feeabf571e98f8ee0700a4586cbb67c",
			"commitAuthor": "Chris Beams",
			"commitDateOld": "2011-05-06, 12:01 PM",
			"commitNameOld": "f683f781c584b12790752ddfb0ee334e61a0b9e9",
			"commitAuthorOld": "Chris Beams",
			"daysBetweenCommits": 0,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,94 +1,94 @@\n-\tprivate void loadBeanDefinitionsForBeanMethod(ConfigurationClassMethod beanMethod) {\n+\tprivate void loadBeanDefinitionsForBeanMethod(BeanMethod beanMethod) {\n \t\tConfigurationClass configClass = beanMethod.getConfigurationClass();\n \t\tMethodMetadata metadata = beanMethod.getMetadata();\n \n \t\tRootBeanDefinition beanDef = new ConfigurationClassBeanDefinition(configClass);\n \t\tbeanDef.setResource(configClass.getResource());\n \t\tbeanDef.setSource(this.sourceExtractor.extractSource(metadata, configClass.getResource()));\n \t\tbeanDef.setFactoryBeanName(configClass.getBeanName());\n \t\tbeanDef.setUniqueFactoryMethodName(metadata.getMethodName());\n \t\tbeanDef.setAutowireMode(RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n \t\tbeanDef.setAttribute(RequiredAnnotationBeanPostProcessor.SKIP_REQUIRED_CHECK_ATTRIBUTE, Boolean.TRUE);\n \n \t\t// consider name and any aliases\n \t\tMap<String, Object> beanAttributes = metadata.getAnnotationAttributes(Bean.class.getName());\n \t\tList<String> names = new ArrayList<String>(Arrays.asList((String[]) beanAttributes.get(\"name\")));\n \t\tString beanName = (names.size() > 0 ? names.remove(0) : beanMethod.getMetadata().getMethodName());\n \t\tfor (String alias : names) {\n \t\t\tthis.registry.registerAlias(beanName, alias);\n \t\t}\n \n \t\t// has this already been overridden (e.g. via XML)?\n \t\tif (this.registry.containsBeanDefinition(beanName)) {\n \t\t\tBeanDefinition existingBeanDef = registry.getBeanDefinition(beanName);\n \t\t\t// is the existing bean definition one that was created from a configuration class?\n \t\t\tif (!(existingBeanDef instanceof ConfigurationClassBeanDefinition)) {\n \t\t\t\t// no -> then it's an external override, probably XML\n \t\t\t\t// overriding is legal, return immediately\n \t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\tlogger.debug(String.format(\"Skipping loading bean definition for %s: a definition for bean \" +\n \t\t\t\t\t\t\t\"'%s' already exists. This is likely due to an override in XML.\", beanMethod, beanName));\n \t\t\t\t}\n \t\t\t\treturn;\n \t\t\t}\n \t\t}\n \n \t\tif (metadata.isAnnotated(Primary.class.getName())) {\n \t\t\tbeanDef.setPrimary(true);\n \t\t}\n \n \t\t// is this bean to be instantiated lazily?\n \t\tif (metadata.isAnnotated(Lazy.class.getName())) {\n \t\t\tbeanDef.setLazyInit((Boolean) metadata.getAnnotationAttributes(Lazy.class.getName()).get(\"value\"));\n \t\t}\n \t\telse if (configClass.getMetadata().isAnnotated(Lazy.class.getName())){\n \t\t\tbeanDef.setLazyInit((Boolean) configClass.getMetadata().getAnnotationAttributes(Lazy.class.getName()).get(\"value\"));\n \t\t}\n \n \t\tif (metadata.isAnnotated(DependsOn.class.getName())) {\n \t\t\tString[] dependsOn = (String[]) metadata.getAnnotationAttributes(DependsOn.class.getName()).get(\"value\");\n \t\t\tif (dependsOn.length > 0) {\n \t\t\t\tbeanDef.setDependsOn(dependsOn);\n \t\t\t}\n \t\t}\n \n \t\tAutowire autowire = (Autowire) beanAttributes.get(\"autowire\");\n \t\tif (autowire.isAutowire()) {\n \t\t\tbeanDef.setAutowireMode(autowire.value());\n \t\t}\n \n \t\tString initMethodName = (String) beanAttributes.get(\"initMethod\");\n \t\tif (StringUtils.hasText(initMethodName)) {\n \t\t\tbeanDef.setInitMethodName(initMethodName);\n \t\t}\n \n \t\tString destroyMethodName = (String) beanAttributes.get(\"destroyMethod\");\n \t\tif (StringUtils.hasText(destroyMethodName)) {\n \t\t\tbeanDef.setDestroyMethodName(destroyMethodName);\n \t\t}\n \n \t\t// consider scoping\n \t\tScopedProxyMode proxyMode = ScopedProxyMode.NO;\n \t\tMap<String, Object> scopeAttributes = metadata.getAnnotationAttributes(Scope.class.getName());\n \t\tif (scopeAttributes != null) {\n \t\t\tbeanDef.setScope((String) scopeAttributes.get(\"value\"));\n \t\t\tproxyMode = (ScopedProxyMode) scopeAttributes.get(\"proxyMode\");\n \t\t\tif (proxyMode == ScopedProxyMode.DEFAULT) {\n \t\t\t\tproxyMode = ScopedProxyMode.NO;\n \t\t\t}\n \t\t}\n \n \t\t// replace the original bean definition with the target one, if necessary\n \t\tBeanDefinition beanDefToRegister = beanDef;\n \t\tif (proxyMode != ScopedProxyMode.NO) {\n \t\t\tBeanDefinitionHolder proxyDef = ScopedProxyCreator.createScopedProxy(\n \t\t\t\t\tnew BeanDefinitionHolder(beanDef, beanName), this.registry, proxyMode == ScopedProxyMode.TARGET_CLASS);\n \t\t\tbeanDefToRegister = proxyDef.getBeanDefinition();\n \t\t}\n \n \t\tif (logger.isDebugEnabled()) {\n \t\t\tlogger.debug(String.format(\"Registering bean definition for @Bean method %s.%s()\", configClass.getMetadata().getClassName(), beanName));\n \t\t}\n \n \t\tregistry.registerBeanDefinition(beanName, beanDefToRegister);\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {
				"oldValue": "[beanMethod-ConfigurationClassMethod]",
				"newValue": "[beanMethod-BeanMethod]"
			}
		},
		"b4fea47d5cff9f3c85e62c233c2fe86b1d616592": {
			"type": "Ymultichange(Yrename,Yparameterchange,Ybodychange)",
			"commitMessage": "Introduce FeatureSpecification support\n\nIntroduce FeatureSpecification interface and implementations\n\n    FeatureSpecification objects decouple the configuration of\n    spring container features from the concern of parsing XML\n    namespaces, allowing for reuse in code-based configuration\n    (see @Feature* annotations below).\n\n    * ComponentScanSpec\n    * TxAnnotationDriven\n    * MvcAnnotationDriven\n    * MvcDefaultServletHandler\n    * MvcResources\n    * MvcViewControllers\n\nRefactor associated BeanDefinitionParsers to delegate to new impls above\n\n    The following BeanDefinitionParser implementations now deal only\n    with the concern of XML parsing.  Validation is handled by their\n    corresponding FeatureSpecification object.  Bean definition creation\n    and registration is handled by their corresponding\n    FeatureSpecificationExecutor type.\n\n    * ComponentScanBeanDefinitionParser\n    * AnnotationDrivenBeanDefinitionParser (tx)\n    * AnnotationDrivenBeanDefinitionParser (mvc)\n    * DefaultServletHandlerBeanDefinitionParser\n    * ResourcesBeanDefinitionParser\n    * ViewControllerBeanDefinitionParser\n\nUpdate AopNamespaceUtils to decouple from XML (DOM API)\n\n    Methods necessary for executing TxAnnotationDriven specification\n    (and eventually, the AspectJAutoProxy specification) have been\n    added that accept boolean arguments for whether to proxy\n    target classes and whether to expose the proxy via threadlocal.\n\n    Methods that accepted and introspected DOM Element objects still\n    exist but have been deprecated.\n\nIntroduce @FeatureConfiguration classes and @Feature methods\n\n    Allow for creation and configuration of FeatureSpecification objects\n    at the user level.  A companion for @Configuration classes allowing\n    for completely code-driven configuration of the Spring container.\n\n    See changes in ConfigurationClassPostProcessor for implementation\n    details.\n\n    See Feature*Tests for usage examples.\n\n    FeatureTestSuite in .integration-tests is a JUnit test suite designed\n    to aggregate all BDP and Feature* related tests for a convenient way\n    to confirm that Feature-related changes don't break anything.\n    Uncomment this test and execute from Eclipse / IDEA. Due to classpath\n    issues, this cannot be compiled by Ant/Ivy at the command line.\n\nIntroduce @FeatureAnnotation meta-annotation and @ComponentScan impl\n\n    @FeatureAnnotation provides an alternate mechanism for creating\n    and executing FeatureSpecification objects.  See @ComponentScan\n    and its corresponding ComponentScanAnnotationParser implementation\n    for details.  See ComponentScanAnnotationIntegrationTests for usage\n    examples\n\nIntroduce Default[Formatting]ConversionService implementations\n\n    Allows for convenient instantiation of ConversionService objects\n    containing defaults appropriate for most environments.  Replaces\n    similar support originally in ConversionServiceFactory (which is now\n    deprecated). This change was justified by the need to avoid use\n    of FactoryBeans in @Configuration classes (such as\n    FormattingConversionServiceFactoryBean). It is strongly preferred\n    that users simply instantiate and configure the objects that underlie\n    our FactoryBeans. In the case of the ConversionService types, the\n    easiest way to do this is to create Default* subtypes. This also\n    follows convention with the rest of the framework.\n\nMinor updates to util classes\n\n    All in service of changes above. See diffs for self-explanatory\n    details.\n\n    * BeanUtils\n    * ObjectUtils\n    * ReflectionUtils\n",
			"commitDate": "2011-02-08, 6:42 AM",
			"commitName": "b4fea47d5cff9f3c85e62c233c2fe86b1d616592",
			"commitAuthor": "Chris Beams",
			"subchanges": [
				{
					"type": "Yrename",
					"commitMessage": "Introduce FeatureSpecification support\n\nIntroduce FeatureSpecification interface and implementations\n\n    FeatureSpecification objects decouple the configuration of\n    spring container features from the concern of parsing XML\n    namespaces, allowing for reuse in code-based configuration\n    (see @Feature* annotations below).\n\n    * ComponentScanSpec\n    * TxAnnotationDriven\n    * MvcAnnotationDriven\n    * MvcDefaultServletHandler\n    * MvcResources\n    * MvcViewControllers\n\nRefactor associated BeanDefinitionParsers to delegate to new impls above\n\n    The following BeanDefinitionParser implementations now deal only\n    with the concern of XML parsing.  Validation is handled by their\n    corresponding FeatureSpecification object.  Bean definition creation\n    and registration is handled by their corresponding\n    FeatureSpecificationExecutor type.\n\n    * ComponentScanBeanDefinitionParser\n    * AnnotationDrivenBeanDefinitionParser (tx)\n    * AnnotationDrivenBeanDefinitionParser (mvc)\n    * DefaultServletHandlerBeanDefinitionParser\n    * ResourcesBeanDefinitionParser\n    * ViewControllerBeanDefinitionParser\n\nUpdate AopNamespaceUtils to decouple from XML (DOM API)\n\n    Methods necessary for executing TxAnnotationDriven specification\n    (and eventually, the AspectJAutoProxy specification) have been\n    added that accept boolean arguments for whether to proxy\n    target classes and whether to expose the proxy via threadlocal.\n\n    Methods that accepted and introspected DOM Element objects still\n    exist but have been deprecated.\n\nIntroduce @FeatureConfiguration classes and @Feature methods\n\n    Allow for creation and configuration of FeatureSpecification objects\n    at the user level.  A companion for @Configuration classes allowing\n    for completely code-driven configuration of the Spring container.\n\n    See changes in ConfigurationClassPostProcessor for implementation\n    details.\n\n    See Feature*Tests for usage examples.\n\n    FeatureTestSuite in .integration-tests is a JUnit test suite designed\n    to aggregate all BDP and Feature* related tests for a convenient way\n    to confirm that Feature-related changes don't break anything.\n    Uncomment this test and execute from Eclipse / IDEA. Due to classpath\n    issues, this cannot be compiled by Ant/Ivy at the command line.\n\nIntroduce @FeatureAnnotation meta-annotation and @ComponentScan impl\n\n    @FeatureAnnotation provides an alternate mechanism for creating\n    and executing FeatureSpecification objects.  See @ComponentScan\n    and its corresponding ComponentScanAnnotationParser implementation\n    for details.  See ComponentScanAnnotationIntegrationTests for usage\n    examples\n\nIntroduce Default[Formatting]ConversionService implementations\n\n    Allows for convenient instantiation of ConversionService objects\n    containing defaults appropriate for most environments.  Replaces\n    similar support originally in ConversionServiceFactory (which is now\n    deprecated). This change was justified by the need to avoid use\n    of FactoryBeans in @Configuration classes (such as\n    FormattingConversionServiceFactoryBean). It is strongly preferred\n    that users simply instantiate and configure the objects that underlie\n    our FactoryBeans. In the case of the ConversionService types, the\n    easiest way to do this is to create Default* subtypes. This also\n    follows convention with the rest of the framework.\n\nMinor updates to util classes\n\n    All in service of changes above. See diffs for self-explanatory\n    details.\n\n    * BeanUtils\n    * ObjectUtils\n    * ReflectionUtils\n",
					"commitDate": "2011-02-08, 6:42 AM",
					"commitName": "b4fea47d5cff9f3c85e62c233c2fe86b1d616592",
					"commitAuthor": "Chris Beams",
					"commitDateOld": "2010-12-07, 11:58 PM",
					"commitNameOld": "e693d9fa587db6f3392fb545cffbd3e50893c4a1",
					"commitAuthorOld": "Chris Beams",
					"daysBetweenCommits": 62.28,
					"commitsBetweenForRepo": 124,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,94 +1,94 @@\n-\tprivate void loadBeanDefinitionsForModelMethod(ConfigurationClassMethod method) {\n-\t\tConfigurationClass configClass = method.getConfigurationClass();\n-\t\tMethodMetadata metadata = method.getMetadata();\n+\tprivate void loadBeanDefinitionsForBeanMethod(ConfigurationClassMethod beanMethod) {\n+\t\tConfigurationClass configClass = beanMethod.getConfigurationClass();\n+\t\tMethodMetadata metadata = beanMethod.getMetadata();\n \n \t\tRootBeanDefinition beanDef = new ConfigurationClassBeanDefinition(configClass);\n \t\tbeanDef.setResource(configClass.getResource());\n \t\tbeanDef.setSource(this.sourceExtractor.extractSource(metadata, configClass.getResource()));\n \t\tbeanDef.setFactoryBeanName(configClass.getBeanName());\n \t\tbeanDef.setUniqueFactoryMethodName(metadata.getMethodName());\n \t\tbeanDef.setAutowireMode(RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n \t\tbeanDef.setAttribute(RequiredAnnotationBeanPostProcessor.SKIP_REQUIRED_CHECK_ATTRIBUTE, Boolean.TRUE);\n \n \t\t// consider name and any aliases\n \t\tMap<String, Object> beanAttributes = metadata.getAnnotationAttributes(Bean.class.getName());\n \t\tList<String> names = new ArrayList<String>(Arrays.asList((String[]) beanAttributes.get(\"name\")));\n-\t\tString beanName = (names.size() > 0 ? names.remove(0) : method.getMetadata().getMethodName());\n+\t\tString beanName = (names.size() > 0 ? names.remove(0) : beanMethod.getMetadata().getMethodName());\n \t\tfor (String alias : names) {\n \t\t\tthis.registry.registerAlias(beanName, alias);\n \t\t}\n \n \t\t// has this already been overridden (e.g. via XML)?\n \t\tif (this.registry.containsBeanDefinition(beanName)) {\n \t\t\tBeanDefinition existingBeanDef = registry.getBeanDefinition(beanName);\n \t\t\t// is the existing bean definition one that was created from a configuration class?\n \t\t\tif (!(existingBeanDef instanceof ConfigurationClassBeanDefinition)) {\n \t\t\t\t// no -> then it's an external override, probably XML\n \t\t\t\t// overriding is legal, return immediately\n \t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\tlogger.debug(String.format(\"Skipping loading bean definition for %s: a definition for bean \" +\n-\t\t\t\t\t\t\t\"'%s' already exists. This is likely due to an override in XML.\", method, beanName));\n+\t\t\t\t\t\t\t\"'%s' already exists. This is likely due to an override in XML.\", beanMethod, beanName));\n \t\t\t\t}\n \t\t\t\treturn;\n \t\t\t}\n \t\t}\n \n \t\tif (metadata.isAnnotated(Primary.class.getName())) {\n \t\t\tbeanDef.setPrimary(true);\n \t\t}\n \n \t\t// is this bean to be instantiated lazily?\n \t\tif (metadata.isAnnotated(Lazy.class.getName())) {\n \t\t\tbeanDef.setLazyInit((Boolean) metadata.getAnnotationAttributes(Lazy.class.getName()).get(\"value\"));\n \t\t}\n \t\telse if (configClass.getMetadata().isAnnotated(Lazy.class.getName())){\n \t\t\tbeanDef.setLazyInit((Boolean) configClass.getMetadata().getAnnotationAttributes(Lazy.class.getName()).get(\"value\"));\n \t\t}\n \n \t\tif (metadata.isAnnotated(DependsOn.class.getName())) {\n \t\t\tString[] dependsOn = (String[]) metadata.getAnnotationAttributes(DependsOn.class.getName()).get(\"value\");\n \t\t\tif (dependsOn.length > 0) {\n \t\t\t\tbeanDef.setDependsOn(dependsOn);\n \t\t\t}\n \t\t}\n \n \t\tAutowire autowire = (Autowire) beanAttributes.get(\"autowire\");\n \t\tif (autowire.isAutowire()) {\n \t\t\tbeanDef.setAutowireMode(autowire.value());\n \t\t}\n \n \t\tString initMethodName = (String) beanAttributes.get(\"initMethod\");\n \t\tif (StringUtils.hasText(initMethodName)) {\n \t\t\tbeanDef.setInitMethodName(initMethodName);\n \t\t}\n \n \t\tString destroyMethodName = (String) beanAttributes.get(\"destroyMethod\");\n \t\tif (StringUtils.hasText(destroyMethodName)) {\n \t\t\tbeanDef.setDestroyMethodName(destroyMethodName);\n \t\t}\n \n \t\t// consider scoping\n \t\tScopedProxyMode proxyMode = ScopedProxyMode.NO;\n \t\tMap<String, Object> scopeAttributes = metadata.getAnnotationAttributes(Scope.class.getName());\n \t\tif (scopeAttributes != null) {\n \t\t\tbeanDef.setScope((String) scopeAttributes.get(\"value\"));\n \t\t\tproxyMode = (ScopedProxyMode) scopeAttributes.get(\"proxyMode\");\n \t\t\tif (proxyMode == ScopedProxyMode.DEFAULT) {\n \t\t\t\tproxyMode = ScopedProxyMode.NO;\n \t\t\t}\n \t\t}\n \n \t\t// replace the original bean definition with the target one, if necessary\n \t\tBeanDefinition beanDefToRegister = beanDef;\n \t\tif (proxyMode != ScopedProxyMode.NO) {\n \t\t\tBeanDefinitionHolder proxyDef = ScopedProxyCreator.createScopedProxy(\n \t\t\t\t\tnew BeanDefinitionHolder(beanDef, beanName), this.registry, proxyMode == ScopedProxyMode.TARGET_CLASS);\n \t\t\tbeanDefToRegister = proxyDef.getBeanDefinition();\n \t\t}\n \n \t\tif (logger.isDebugEnabled()) {\n \t\t\tlogger.debug(String.format(\"Registering bean definition for @Bean method %s.%s()\", configClass.getMetadata().getClassName(), beanName));\n \t\t}\n \n \t\tregistry.registerBeanDefinition(beanName, beanDefToRegister);\n \t}\n\\ No newline at end of file\n",
					"extendedDetails": {
						"oldValue": "loadBeanDefinitionsForModelMethod",
						"newValue": "loadBeanDefinitionsForBeanMethod"
					}
				},
				{
					"type": "Yparameterchange",
					"commitMessage": "Introduce FeatureSpecification support\n\nIntroduce FeatureSpecification interface and implementations\n\n    FeatureSpecification objects decouple the configuration of\n    spring container features from the concern of parsing XML\n    namespaces, allowing for reuse in code-based configuration\n    (see @Feature* annotations below).\n\n    * ComponentScanSpec\n    * TxAnnotationDriven\n    * MvcAnnotationDriven\n    * MvcDefaultServletHandler\n    * MvcResources\n    * MvcViewControllers\n\nRefactor associated BeanDefinitionParsers to delegate to new impls above\n\n    The following BeanDefinitionParser implementations now deal only\n    with the concern of XML parsing.  Validation is handled by their\n    corresponding FeatureSpecification object.  Bean definition creation\n    and registration is handled by their corresponding\n    FeatureSpecificationExecutor type.\n\n    * ComponentScanBeanDefinitionParser\n    * AnnotationDrivenBeanDefinitionParser (tx)\n    * AnnotationDrivenBeanDefinitionParser (mvc)\n    * DefaultServletHandlerBeanDefinitionParser\n    * ResourcesBeanDefinitionParser\n    * ViewControllerBeanDefinitionParser\n\nUpdate AopNamespaceUtils to decouple from XML (DOM API)\n\n    Methods necessary for executing TxAnnotationDriven specification\n    (and eventually, the AspectJAutoProxy specification) have been\n    added that accept boolean arguments for whether to proxy\n    target classes and whether to expose the proxy via threadlocal.\n\n    Methods that accepted and introspected DOM Element objects still\n    exist but have been deprecated.\n\nIntroduce @FeatureConfiguration classes and @Feature methods\n\n    Allow for creation and configuration of FeatureSpecification objects\n    at the user level.  A companion for @Configuration classes allowing\n    for completely code-driven configuration of the Spring container.\n\n    See changes in ConfigurationClassPostProcessor for implementation\n    details.\n\n    See Feature*Tests for usage examples.\n\n    FeatureTestSuite in .integration-tests is a JUnit test suite designed\n    to aggregate all BDP and Feature* related tests for a convenient way\n    to confirm that Feature-related changes don't break anything.\n    Uncomment this test and execute from Eclipse / IDEA. Due to classpath\n    issues, this cannot be compiled by Ant/Ivy at the command line.\n\nIntroduce @FeatureAnnotation meta-annotation and @ComponentScan impl\n\n    @FeatureAnnotation provides an alternate mechanism for creating\n    and executing FeatureSpecification objects.  See @ComponentScan\n    and its corresponding ComponentScanAnnotationParser implementation\n    for details.  See ComponentScanAnnotationIntegrationTests for usage\n    examples\n\nIntroduce Default[Formatting]ConversionService implementations\n\n    Allows for convenient instantiation of ConversionService objects\n    containing defaults appropriate for most environments.  Replaces\n    similar support originally in ConversionServiceFactory (which is now\n    deprecated). This change was justified by the need to avoid use\n    of FactoryBeans in @Configuration classes (such as\n    FormattingConversionServiceFactoryBean). It is strongly preferred\n    that users simply instantiate and configure the objects that underlie\n    our FactoryBeans. In the case of the ConversionService types, the\n    easiest way to do this is to create Default* subtypes. This also\n    follows convention with the rest of the framework.\n\nMinor updates to util classes\n\n    All in service of changes above. See diffs for self-explanatory\n    details.\n\n    * BeanUtils\n    * ObjectUtils\n    * ReflectionUtils\n",
					"commitDate": "2011-02-08, 6:42 AM",
					"commitName": "b4fea47d5cff9f3c85e62c233c2fe86b1d616592",
					"commitAuthor": "Chris Beams",
					"commitDateOld": "2010-12-07, 11:58 PM",
					"commitNameOld": "e693d9fa587db6f3392fb545cffbd3e50893c4a1",
					"commitAuthorOld": "Chris Beams",
					"daysBetweenCommits": 62.28,
					"commitsBetweenForRepo": 124,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,94 +1,94 @@\n-\tprivate void loadBeanDefinitionsForModelMethod(ConfigurationClassMethod method) {\n-\t\tConfigurationClass configClass = method.getConfigurationClass();\n-\t\tMethodMetadata metadata = method.getMetadata();\n+\tprivate void loadBeanDefinitionsForBeanMethod(ConfigurationClassMethod beanMethod) {\n+\t\tConfigurationClass configClass = beanMethod.getConfigurationClass();\n+\t\tMethodMetadata metadata = beanMethod.getMetadata();\n \n \t\tRootBeanDefinition beanDef = new ConfigurationClassBeanDefinition(configClass);\n \t\tbeanDef.setResource(configClass.getResource());\n \t\tbeanDef.setSource(this.sourceExtractor.extractSource(metadata, configClass.getResource()));\n \t\tbeanDef.setFactoryBeanName(configClass.getBeanName());\n \t\tbeanDef.setUniqueFactoryMethodName(metadata.getMethodName());\n \t\tbeanDef.setAutowireMode(RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n \t\tbeanDef.setAttribute(RequiredAnnotationBeanPostProcessor.SKIP_REQUIRED_CHECK_ATTRIBUTE, Boolean.TRUE);\n \n \t\t// consider name and any aliases\n \t\tMap<String, Object> beanAttributes = metadata.getAnnotationAttributes(Bean.class.getName());\n \t\tList<String> names = new ArrayList<String>(Arrays.asList((String[]) beanAttributes.get(\"name\")));\n-\t\tString beanName = (names.size() > 0 ? names.remove(0) : method.getMetadata().getMethodName());\n+\t\tString beanName = (names.size() > 0 ? names.remove(0) : beanMethod.getMetadata().getMethodName());\n \t\tfor (String alias : names) {\n \t\t\tthis.registry.registerAlias(beanName, alias);\n \t\t}\n \n \t\t// has this already been overridden (e.g. via XML)?\n \t\tif (this.registry.containsBeanDefinition(beanName)) {\n \t\t\tBeanDefinition existingBeanDef = registry.getBeanDefinition(beanName);\n \t\t\t// is the existing bean definition one that was created from a configuration class?\n \t\t\tif (!(existingBeanDef instanceof ConfigurationClassBeanDefinition)) {\n \t\t\t\t// no -> then it's an external override, probably XML\n \t\t\t\t// overriding is legal, return immediately\n \t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\tlogger.debug(String.format(\"Skipping loading bean definition for %s: a definition for bean \" +\n-\t\t\t\t\t\t\t\"'%s' already exists. This is likely due to an override in XML.\", method, beanName));\n+\t\t\t\t\t\t\t\"'%s' already exists. This is likely due to an override in XML.\", beanMethod, beanName));\n \t\t\t\t}\n \t\t\t\treturn;\n \t\t\t}\n \t\t}\n \n \t\tif (metadata.isAnnotated(Primary.class.getName())) {\n \t\t\tbeanDef.setPrimary(true);\n \t\t}\n \n \t\t// is this bean to be instantiated lazily?\n \t\tif (metadata.isAnnotated(Lazy.class.getName())) {\n \t\t\tbeanDef.setLazyInit((Boolean) metadata.getAnnotationAttributes(Lazy.class.getName()).get(\"value\"));\n \t\t}\n \t\telse if (configClass.getMetadata().isAnnotated(Lazy.class.getName())){\n \t\t\tbeanDef.setLazyInit((Boolean) configClass.getMetadata().getAnnotationAttributes(Lazy.class.getName()).get(\"value\"));\n \t\t}\n \n \t\tif (metadata.isAnnotated(DependsOn.class.getName())) {\n \t\t\tString[] dependsOn = (String[]) metadata.getAnnotationAttributes(DependsOn.class.getName()).get(\"value\");\n \t\t\tif (dependsOn.length > 0) {\n \t\t\t\tbeanDef.setDependsOn(dependsOn);\n \t\t\t}\n \t\t}\n \n \t\tAutowire autowire = (Autowire) beanAttributes.get(\"autowire\");\n \t\tif (autowire.isAutowire()) {\n \t\t\tbeanDef.setAutowireMode(autowire.value());\n \t\t}\n \n \t\tString initMethodName = (String) beanAttributes.get(\"initMethod\");\n \t\tif (StringUtils.hasText(initMethodName)) {\n \t\t\tbeanDef.setInitMethodName(initMethodName);\n \t\t}\n \n \t\tString destroyMethodName = (String) beanAttributes.get(\"destroyMethod\");\n \t\tif (StringUtils.hasText(destroyMethodName)) {\n \t\t\tbeanDef.setDestroyMethodName(destroyMethodName);\n \t\t}\n \n \t\t// consider scoping\n \t\tScopedProxyMode proxyMode = ScopedProxyMode.NO;\n \t\tMap<String, Object> scopeAttributes = metadata.getAnnotationAttributes(Scope.class.getName());\n \t\tif (scopeAttributes != null) {\n \t\t\tbeanDef.setScope((String) scopeAttributes.get(\"value\"));\n \t\t\tproxyMode = (ScopedProxyMode) scopeAttributes.get(\"proxyMode\");\n \t\t\tif (proxyMode == ScopedProxyMode.DEFAULT) {\n \t\t\t\tproxyMode = ScopedProxyMode.NO;\n \t\t\t}\n \t\t}\n \n \t\t// replace the original bean definition with the target one, if necessary\n \t\tBeanDefinition beanDefToRegister = beanDef;\n \t\tif (proxyMode != ScopedProxyMode.NO) {\n \t\t\tBeanDefinitionHolder proxyDef = ScopedProxyCreator.createScopedProxy(\n \t\t\t\t\tnew BeanDefinitionHolder(beanDef, beanName), this.registry, proxyMode == ScopedProxyMode.TARGET_CLASS);\n \t\t\tbeanDefToRegister = proxyDef.getBeanDefinition();\n \t\t}\n \n \t\tif (logger.isDebugEnabled()) {\n \t\t\tlogger.debug(String.format(\"Registering bean definition for @Bean method %s.%s()\", configClass.getMetadata().getClassName(), beanName));\n \t\t}\n \n \t\tregistry.registerBeanDefinition(beanName, beanDefToRegister);\n \t}\n\\ No newline at end of file\n",
					"extendedDetails": {
						"oldValue": "[method-ConfigurationClassMethod]",
						"newValue": "[beanMethod-ConfigurationClassMethod]"
					}
				},
				{
					"type": "Ybodychange",
					"commitMessage": "Introduce FeatureSpecification support\n\nIntroduce FeatureSpecification interface and implementations\n\n    FeatureSpecification objects decouple the configuration of\n    spring container features from the concern of parsing XML\n    namespaces, allowing for reuse in code-based configuration\n    (see @Feature* annotations below).\n\n    * ComponentScanSpec\n    * TxAnnotationDriven\n    * MvcAnnotationDriven\n    * MvcDefaultServletHandler\n    * MvcResources\n    * MvcViewControllers\n\nRefactor associated BeanDefinitionParsers to delegate to new impls above\n\n    The following BeanDefinitionParser implementations now deal only\n    with the concern of XML parsing.  Validation is handled by their\n    corresponding FeatureSpecification object.  Bean definition creation\n    and registration is handled by their corresponding\n    FeatureSpecificationExecutor type.\n\n    * ComponentScanBeanDefinitionParser\n    * AnnotationDrivenBeanDefinitionParser (tx)\n    * AnnotationDrivenBeanDefinitionParser (mvc)\n    * DefaultServletHandlerBeanDefinitionParser\n    * ResourcesBeanDefinitionParser\n    * ViewControllerBeanDefinitionParser\n\nUpdate AopNamespaceUtils to decouple from XML (DOM API)\n\n    Methods necessary for executing TxAnnotationDriven specification\n    (and eventually, the AspectJAutoProxy specification) have been\n    added that accept boolean arguments for whether to proxy\n    target classes and whether to expose the proxy via threadlocal.\n\n    Methods that accepted and introspected DOM Element objects still\n    exist but have been deprecated.\n\nIntroduce @FeatureConfiguration classes and @Feature methods\n\n    Allow for creation and configuration of FeatureSpecification objects\n    at the user level.  A companion for @Configuration classes allowing\n    for completely code-driven configuration of the Spring container.\n\n    See changes in ConfigurationClassPostProcessor for implementation\n    details.\n\n    See Feature*Tests for usage examples.\n\n    FeatureTestSuite in .integration-tests is a JUnit test suite designed\n    to aggregate all BDP and Feature* related tests for a convenient way\n    to confirm that Feature-related changes don't break anything.\n    Uncomment this test and execute from Eclipse / IDEA. Due to classpath\n    issues, this cannot be compiled by Ant/Ivy at the command line.\n\nIntroduce @FeatureAnnotation meta-annotation and @ComponentScan impl\n\n    @FeatureAnnotation provides an alternate mechanism for creating\n    and executing FeatureSpecification objects.  See @ComponentScan\n    and its corresponding ComponentScanAnnotationParser implementation\n    for details.  See ComponentScanAnnotationIntegrationTests for usage\n    examples\n\nIntroduce Default[Formatting]ConversionService implementations\n\n    Allows for convenient instantiation of ConversionService objects\n    containing defaults appropriate for most environments.  Replaces\n    similar support originally in ConversionServiceFactory (which is now\n    deprecated). This change was justified by the need to avoid use\n    of FactoryBeans in @Configuration classes (such as\n    FormattingConversionServiceFactoryBean). It is strongly preferred\n    that users simply instantiate and configure the objects that underlie\n    our FactoryBeans. In the case of the ConversionService types, the\n    easiest way to do this is to create Default* subtypes. This also\n    follows convention with the rest of the framework.\n\nMinor updates to util classes\n\n    All in service of changes above. See diffs for self-explanatory\n    details.\n\n    * BeanUtils\n    * ObjectUtils\n    * ReflectionUtils\n",
					"commitDate": "2011-02-08, 6:42 AM",
					"commitName": "b4fea47d5cff9f3c85e62c233c2fe86b1d616592",
					"commitAuthor": "Chris Beams",
					"commitDateOld": "2010-12-07, 11:58 PM",
					"commitNameOld": "e693d9fa587db6f3392fb545cffbd3e50893c4a1",
					"commitAuthorOld": "Chris Beams",
					"daysBetweenCommits": 62.28,
					"commitsBetweenForRepo": 124,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,94 +1,94 @@\n-\tprivate void loadBeanDefinitionsForModelMethod(ConfigurationClassMethod method) {\n-\t\tConfigurationClass configClass = method.getConfigurationClass();\n-\t\tMethodMetadata metadata = method.getMetadata();\n+\tprivate void loadBeanDefinitionsForBeanMethod(ConfigurationClassMethod beanMethod) {\n+\t\tConfigurationClass configClass = beanMethod.getConfigurationClass();\n+\t\tMethodMetadata metadata = beanMethod.getMetadata();\n \n \t\tRootBeanDefinition beanDef = new ConfigurationClassBeanDefinition(configClass);\n \t\tbeanDef.setResource(configClass.getResource());\n \t\tbeanDef.setSource(this.sourceExtractor.extractSource(metadata, configClass.getResource()));\n \t\tbeanDef.setFactoryBeanName(configClass.getBeanName());\n \t\tbeanDef.setUniqueFactoryMethodName(metadata.getMethodName());\n \t\tbeanDef.setAutowireMode(RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n \t\tbeanDef.setAttribute(RequiredAnnotationBeanPostProcessor.SKIP_REQUIRED_CHECK_ATTRIBUTE, Boolean.TRUE);\n \n \t\t// consider name and any aliases\n \t\tMap<String, Object> beanAttributes = metadata.getAnnotationAttributes(Bean.class.getName());\n \t\tList<String> names = new ArrayList<String>(Arrays.asList((String[]) beanAttributes.get(\"name\")));\n-\t\tString beanName = (names.size() > 0 ? names.remove(0) : method.getMetadata().getMethodName());\n+\t\tString beanName = (names.size() > 0 ? names.remove(0) : beanMethod.getMetadata().getMethodName());\n \t\tfor (String alias : names) {\n \t\t\tthis.registry.registerAlias(beanName, alias);\n \t\t}\n \n \t\t// has this already been overridden (e.g. via XML)?\n \t\tif (this.registry.containsBeanDefinition(beanName)) {\n \t\t\tBeanDefinition existingBeanDef = registry.getBeanDefinition(beanName);\n \t\t\t// is the existing bean definition one that was created from a configuration class?\n \t\t\tif (!(existingBeanDef instanceof ConfigurationClassBeanDefinition)) {\n \t\t\t\t// no -> then it's an external override, probably XML\n \t\t\t\t// overriding is legal, return immediately\n \t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\tlogger.debug(String.format(\"Skipping loading bean definition for %s: a definition for bean \" +\n-\t\t\t\t\t\t\t\"'%s' already exists. This is likely due to an override in XML.\", method, beanName));\n+\t\t\t\t\t\t\t\"'%s' already exists. This is likely due to an override in XML.\", beanMethod, beanName));\n \t\t\t\t}\n \t\t\t\treturn;\n \t\t\t}\n \t\t}\n \n \t\tif (metadata.isAnnotated(Primary.class.getName())) {\n \t\t\tbeanDef.setPrimary(true);\n \t\t}\n \n \t\t// is this bean to be instantiated lazily?\n \t\tif (metadata.isAnnotated(Lazy.class.getName())) {\n \t\t\tbeanDef.setLazyInit((Boolean) metadata.getAnnotationAttributes(Lazy.class.getName()).get(\"value\"));\n \t\t}\n \t\telse if (configClass.getMetadata().isAnnotated(Lazy.class.getName())){\n \t\t\tbeanDef.setLazyInit((Boolean) configClass.getMetadata().getAnnotationAttributes(Lazy.class.getName()).get(\"value\"));\n \t\t}\n \n \t\tif (metadata.isAnnotated(DependsOn.class.getName())) {\n \t\t\tString[] dependsOn = (String[]) metadata.getAnnotationAttributes(DependsOn.class.getName()).get(\"value\");\n \t\t\tif (dependsOn.length > 0) {\n \t\t\t\tbeanDef.setDependsOn(dependsOn);\n \t\t\t}\n \t\t}\n \n \t\tAutowire autowire = (Autowire) beanAttributes.get(\"autowire\");\n \t\tif (autowire.isAutowire()) {\n \t\t\tbeanDef.setAutowireMode(autowire.value());\n \t\t}\n \n \t\tString initMethodName = (String) beanAttributes.get(\"initMethod\");\n \t\tif (StringUtils.hasText(initMethodName)) {\n \t\t\tbeanDef.setInitMethodName(initMethodName);\n \t\t}\n \n \t\tString destroyMethodName = (String) beanAttributes.get(\"destroyMethod\");\n \t\tif (StringUtils.hasText(destroyMethodName)) {\n \t\t\tbeanDef.setDestroyMethodName(destroyMethodName);\n \t\t}\n \n \t\t// consider scoping\n \t\tScopedProxyMode proxyMode = ScopedProxyMode.NO;\n \t\tMap<String, Object> scopeAttributes = metadata.getAnnotationAttributes(Scope.class.getName());\n \t\tif (scopeAttributes != null) {\n \t\t\tbeanDef.setScope((String) scopeAttributes.get(\"value\"));\n \t\t\tproxyMode = (ScopedProxyMode) scopeAttributes.get(\"proxyMode\");\n \t\t\tif (proxyMode == ScopedProxyMode.DEFAULT) {\n \t\t\t\tproxyMode = ScopedProxyMode.NO;\n \t\t\t}\n \t\t}\n \n \t\t// replace the original bean definition with the target one, if necessary\n \t\tBeanDefinition beanDefToRegister = beanDef;\n \t\tif (proxyMode != ScopedProxyMode.NO) {\n \t\t\tBeanDefinitionHolder proxyDef = ScopedProxyCreator.createScopedProxy(\n \t\t\t\t\tnew BeanDefinitionHolder(beanDef, beanName), this.registry, proxyMode == ScopedProxyMode.TARGET_CLASS);\n \t\t\tbeanDefToRegister = proxyDef.getBeanDefinition();\n \t\t}\n \n \t\tif (logger.isDebugEnabled()) {\n \t\t\tlogger.debug(String.format(\"Registering bean definition for @Bean method %s.%s()\", configClass.getMetadata().getClassName(), beanName));\n \t\t}\n \n \t\tregistry.registerBeanDefinition(beanName, beanDefToRegister);\n \t}\n\\ No newline at end of file\n",
					"extendedDetails": {}
				}
			]
		},
		"6b2b5c4c233bba63fa5da2b11146ffaf66f9de80": {
			"type": "Ybodychange",
			"commitMessage": "introduced BeanDefinitionRegistryPostProcessor extension to BeanFactoryPostProcessor; @Configuration classes support definition of BeanFactoryPostProcessor beans as well (SPR-6455, SPR-6611)\n\n",
			"commitDate": "2010-01-31, 6:05 AM",
			"commitName": "6b2b5c4c233bba63fa5da2b11146ffaf66f9de80",
			"commitAuthor": "Juergen Hoeller",
			"commitDateOld": "2010-01-29, 3:31 PM",
			"commitNameOld": "fbd797e50b2f1c5b0dfef944ee218d826f1a0694",
			"commitAuthorOld": "Chris Beams",
			"daysBetweenCommits": 1.61,
			"commitsBetweenForRepo": 2,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,94 +1,94 @@\n \tprivate void loadBeanDefinitionsForModelMethod(ConfigurationClassMethod method) {\n \t\tConfigurationClass configClass = method.getConfigurationClass();\n \t\tMethodMetadata metadata = method.getMetadata();\n \n \t\tRootBeanDefinition beanDef = new ConfigurationClassBeanDefinition(configClass);\n \t\tbeanDef.setResource(configClass.getResource());\n \t\tbeanDef.setSource(this.sourceExtractor.extractSource(metadata, configClass.getResource()));\n \t\tbeanDef.setFactoryBeanName(configClass.getBeanName());\n \t\tbeanDef.setUniqueFactoryMethodName(metadata.getMethodName());\n \t\tbeanDef.setAutowireMode(RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n \t\tbeanDef.setAttribute(RequiredAnnotationBeanPostProcessor.SKIP_REQUIRED_CHECK_ATTRIBUTE, Boolean.TRUE);\n \n \t\t// consider name and any aliases\n \t\tMap<String, Object> beanAttributes = metadata.getAnnotationAttributes(Bean.class.getName());\n \t\tList<String> names = new ArrayList<String>(Arrays.asList((String[]) beanAttributes.get(\"name\")));\n \t\tString beanName = (names.size() > 0 ? names.remove(0) : method.getMetadata().getMethodName());\n \t\tfor (String alias : names) {\n \t\t\tthis.registry.registerAlias(beanName, alias);\n \t\t}\n \n-\t\t// has this already been overriden (i.e.: via XML)?\n+\t\t// has this already been overridden (e.g. via XML)?\n \t\tif (this.registry.containsBeanDefinition(beanName)) {\n \t\t\tBeanDefinition existingBeanDef = registry.getBeanDefinition(beanName);\n \t\t\t// is the existing bean definition one that was created from a configuration class?\n \t\t\tif (!(existingBeanDef instanceof ConfigurationClassBeanDefinition)) {\n \t\t\t\t// no -> then it's an external override, probably XML\n \t\t\t\t// overriding is legal, return immediately\n \t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\tlogger.debug(String.format(\"Skipping loading bean definition for %s: a definition for bean \" +\n \t\t\t\t\t\t\t\"'%s' already exists. This is likely due to an override in XML.\", method, beanName));\n \t\t\t\t}\n \t\t\t\treturn;\n \t\t\t}\n \t\t}\n \n \t\tif (metadata.isAnnotated(Primary.class.getName())) {\n \t\t\tbeanDef.setPrimary(true);\n \t\t}\n \n \t\t// is this bean to be instantiated lazily?\n \t\tif (metadata.isAnnotated(Lazy.class.getName())) {\n \t\t\tbeanDef.setLazyInit((Boolean) metadata.getAnnotationAttributes(Lazy.class.getName()).get(\"value\"));\n \t\t}\n \t\telse if (configClass.getMetadata().isAnnotated(Lazy.class.getName())){\n \t\t\tbeanDef.setLazyInit((Boolean) configClass.getMetadata().getAnnotationAttributes(Lazy.class.getName()).get(\"value\"));\n \t\t}\n \n \t\tif (metadata.isAnnotated(DependsOn.class.getName())) {\n \t\t\tString[] dependsOn = (String[]) metadata.getAnnotationAttributes(DependsOn.class.getName()).get(\"value\");\n \t\t\tif (dependsOn.length > 0) {\n \t\t\t\tbeanDef.setDependsOn(dependsOn);\n \t\t\t}\n \t\t}\n \n \t\tAutowire autowire = (Autowire) beanAttributes.get(\"autowire\");\n \t\tif (autowire.isAutowire()) {\n \t\t\tbeanDef.setAutowireMode(autowire.value());\n \t\t}\n \n \t\tString initMethodName = (String) beanAttributes.get(\"initMethod\");\n \t\tif (StringUtils.hasText(initMethodName)) {\n \t\t\tbeanDef.setInitMethodName(initMethodName);\n \t\t}\n \n \t\tString destroyMethodName = (String) beanAttributes.get(\"destroyMethod\");\n \t\tif (StringUtils.hasText(destroyMethodName)) {\n \t\t\tbeanDef.setDestroyMethodName(destroyMethodName);\n \t\t}\n \n \t\t// consider scoping\n \t\tScopedProxyMode proxyMode = ScopedProxyMode.NO;\n \t\tMap<String, Object> scopeAttributes = metadata.getAnnotationAttributes(Scope.class.getName());\n \t\tif (scopeAttributes != null) {\n \t\t\tbeanDef.setScope((String) scopeAttributes.get(\"value\"));\n \t\t\tproxyMode = (ScopedProxyMode) scopeAttributes.get(\"proxyMode\");\n \t\t\tif (proxyMode == ScopedProxyMode.DEFAULT) {\n \t\t\t\tproxyMode = ScopedProxyMode.NO;\n \t\t\t}\n \t\t}\n \n \t\t// replace the original bean definition with the target one, if necessary\n \t\tBeanDefinition beanDefToRegister = beanDef;\n \t\tif (proxyMode != ScopedProxyMode.NO) {\n \t\t\tBeanDefinitionHolder proxyDef = ScopedProxyCreator.createScopedProxy(\n \t\t\t\t\tnew BeanDefinitionHolder(beanDef, beanName), this.registry, proxyMode == ScopedProxyMode.TARGET_CLASS);\n \t\t\tbeanDefToRegister = proxyDef.getBeanDefinition();\n \t\t}\n \n \t\tif (logger.isDebugEnabled()) {\n \t\t\tlogger.debug(String.format(\"Registering bean definition for @Bean method %s.%s()\", configClass.getMetadata().getClassName(), beanName));\n \t\t}\n \n \t\tregistry.registerBeanDefinition(beanName, beanDefToRegister);\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"d1b3f57320d5567ff8f6420c9bcf07521ea5e2b9": {
			"type": "Ybodychange",
			"commitMessage": "Resolved SPR-6618. Restrictions were too tight on overloaded bean methods and were preventing it altogether.  Overloading is now allowed, as long as there is no ambiguity at runtime which bean method should be invoked.\n",
			"commitDate": "2009-12-30, 11:42 AM",
			"commitName": "d1b3f57320d5567ff8f6420c9bcf07521ea5e2b9",
			"commitAuthor": "Chris Beams",
			"commitDateOld": "2009-11-11, 11:29 PM",
			"commitNameOld": "9f07b151853f21bc363340fd3056ec14118a1e89",
			"commitAuthorOld": "Chris Beams",
			"daysBetweenCommits": 48.51,
			"commitsBetweenForRepo": 306,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,94 +1,94 @@\n \tprivate void loadBeanDefinitionsForModelMethod(ConfigurationClassMethod method) {\n-\t\tConfigurationClass configClass = method.getDeclaringClass();\n+\t\tConfigurationClass configClass = method.getConfigurationClass();\n \t\tMethodMetadata metadata = method.getMetadata();\n \n \t\tRootBeanDefinition beanDef = new ConfigurationClassBeanDefinition(configClass);\n \t\tbeanDef.setResource(configClass.getResource());\n \t\tbeanDef.setSource(this.sourceExtractor.extractSource(metadata, configClass.getResource()));\n \t\tbeanDef.setFactoryBeanName(configClass.getBeanName());\n \t\tbeanDef.setUniqueFactoryMethodName(metadata.getMethodName());\n \t\tbeanDef.setAutowireMode(RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n \t\tbeanDef.setAttribute(RequiredAnnotationBeanPostProcessor.SKIP_REQUIRED_CHECK_ATTRIBUTE, Boolean.TRUE);\n \n \t\t// consider name and any aliases\n \t\tMap<String, Object> beanAttributes = metadata.getAnnotationAttributes(Bean.class.getName());\n \t\tList<String> names = new ArrayList<String>(Arrays.asList((String[]) beanAttributes.get(\"name\")));\n \t\tString beanName = (names.size() > 0 ? names.remove(0) : method.getMetadata().getMethodName());\n \t\tfor (String alias : names) {\n \t\t\tthis.registry.registerAlias(beanName, alias);\n \t\t}\n \n \t\t// has this already been overriden (i.e.: via XML)?\n \t\tif (this.registry.containsBeanDefinition(beanName)) {\n \t\t\tBeanDefinition existingBeanDef = registry.getBeanDefinition(beanName);\n \t\t\t// is the existing bean definition one that was created from a configuration class?\n \t\t\tif (!(existingBeanDef instanceof ConfigurationClassBeanDefinition)) {\n \t\t\t\t// no -> then it's an external override, probably XML\n \t\t\t\t// overriding is legal, return immediately\n \t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\tlogger.debug(String.format(\"Skipping loading bean definition for %s: a definition for bean \" +\n \t\t\t\t\t\t\t\"'%s' already exists. This is likely due to an override in XML.\", method, beanName));\n \t\t\t\t}\n \t\t\t\treturn;\n \t\t\t}\n \t\t}\n \n \t\tif (metadata.isAnnotated(Primary.class.getName())) {\n \t\t\tbeanDef.setPrimary(true);\n \t\t}\n \n \t\t// is this bean to be instantiated lazily?\n \t\tif (metadata.isAnnotated(Lazy.class.getName())) {\n \t\t\tbeanDef.setLazyInit((Boolean) metadata.getAnnotationAttributes(Lazy.class.getName()).get(\"value\"));\n \t\t}\n \t\telse if (configClass.getMetadata().isAnnotated(Lazy.class.getName())){\n \t\t\tbeanDef.setLazyInit((Boolean) configClass.getMetadata().getAnnotationAttributes(Lazy.class.getName()).get(\"value\"));\n \t\t}\n \n \t\tif (metadata.isAnnotated(DependsOn.class.getName())) {\n \t\t\tString[] dependsOn = (String[]) metadata.getAnnotationAttributes(DependsOn.class.getName()).get(\"value\");\n \t\t\tif (dependsOn.length > 0) {\n \t\t\t\tbeanDef.setDependsOn(dependsOn);\n \t\t\t}\n \t\t}\n \n \t\tAutowire autowire = (Autowire) beanAttributes.get(\"autowire\");\n \t\tif (autowire.isAutowire()) {\n \t\t\tbeanDef.setAutowireMode(autowire.value());\n \t\t}\n \n \t\tString initMethodName = (String) beanAttributes.get(\"initMethod\");\n \t\tif (StringUtils.hasText(initMethodName)) {\n \t\t\tbeanDef.setInitMethodName(initMethodName);\n \t\t}\n \n \t\tString destroyMethodName = (String) beanAttributes.get(\"destroyMethod\");\n \t\tif (StringUtils.hasText(destroyMethodName)) {\n \t\t\tbeanDef.setDestroyMethodName(destroyMethodName);\n \t\t}\n \n \t\t// consider scoping\n \t\tScopedProxyMode proxyMode = ScopedProxyMode.NO;\n \t\tMap<String, Object> scopeAttributes = metadata.getAnnotationAttributes(Scope.class.getName());\n \t\tif (scopeAttributes != null) {\n \t\t\tbeanDef.setScope((String) scopeAttributes.get(\"value\"));\n \t\t\tproxyMode = (ScopedProxyMode) scopeAttributes.get(\"proxyMode\");\n \t\t\tif (proxyMode == ScopedProxyMode.DEFAULT) {\n \t\t\t\tproxyMode = ScopedProxyMode.NO;\n \t\t\t}\n \t\t}\n \n \t\t// replace the original bean definition with the target one, if necessary\n \t\tBeanDefinition beanDefToRegister = beanDef;\n \t\tif (proxyMode != ScopedProxyMode.NO) {\n \t\t\tBeanDefinitionHolder proxyDef = ScopedProxyCreator.createScopedProxy(\n \t\t\t\t\tnew BeanDefinitionHolder(beanDef, beanName), this.registry, proxyMode == ScopedProxyMode.TARGET_CLASS);\n \t\t\tbeanDefToRegister = proxyDef.getBeanDefinition();\n \t\t}\n \n \t\tif (logger.isDebugEnabled()) {\n \t\t\tlogger.debug(String.format(\"Registering bean definition for @Bean method %s.%s()\", configClass.getMetadata().getClassName(), beanName));\n \t\t}\n \n \t\tregistry.registerBeanDefinition(beanName, beanDefToRegister);\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"c7b019cd5c5285d81f0aea967be8af021eac8b07": {
			"type": "Ybodychange",
			"commitMessage": "@Required does not get processed on beans returned by @Bean factory methods (SPR-5744)\n",
			"commitDate": "2009-07-24, 6:29 AM",
			"commitName": "c7b019cd5c5285d81f0aea967be8af021eac8b07",
			"commitAuthor": "Juergen Hoeller",
			"commitDateOld": "2009-07-22, 8:23 AM",
			"commitNameOld": "f519406c37b23eef816704baeb3a496f7430bb89",
			"commitAuthorOld": "Juergen Hoeller",
			"daysBetweenCommits": 1.92,
			"commitsBetweenForRepo": 11,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,93 +1,94 @@\n \tprivate void loadBeanDefinitionsForModelMethod(ConfigurationClassMethod method) {\n \t\tConfigurationClass configClass = method.getDeclaringClass();\n \t\tMethodMetadata metadata = method.getMetadata();\n \n \t\tRootBeanDefinition beanDef = new ConfigurationClassBeanDefinition(configClass);\n \t\tbeanDef.setResource(configClass.getResource());\n \t\tbeanDef.setSource(this.sourceExtractor.extractSource(metadata, configClass.getResource()));\n \t\tbeanDef.setFactoryBeanName(configClass.getBeanName());\n \t\tbeanDef.setUniqueFactoryMethodName(metadata.getMethodName());\n \t\tbeanDef.setAutowireMode(RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n+\t\tbeanDef.setAttribute(RequiredAnnotationBeanPostProcessor.SKIP_REQUIRED_CHECK_ATTRIBUTE, Boolean.TRUE);\n \n \t\t// consider name and any aliases\n \t\tMap<String, Object> beanAttributes = metadata.getAnnotationAttributes(Bean.class.getName());\n \t\tList<String> names = new ArrayList<String>(Arrays.asList((String[]) beanAttributes.get(\"name\")));\n \t\tString beanName = (names.size() > 0 ? names.remove(0) : method.getMetadata().getMethodName());\n \t\tfor (String alias : names) {\n \t\t\tthis.registry.registerAlias(beanName, alias);\n \t\t}\n \n \t\t// has this already been overriden (i.e.: via XML)?\n \t\tif (this.registry.containsBeanDefinition(beanName)) {\n \t\t\tBeanDefinition existingBeanDef = registry.getBeanDefinition(beanName);\n \t\t\t// is the existing bean definition one that was created from a configuration class?\n \t\t\tif (!(existingBeanDef instanceof ConfigurationClassBeanDefinition)) {\n \t\t\t\t// no -> then it's an external override, probably XML\n \t\t\t\t// overriding is legal, return immediately\n \t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\tlogger.debug(String.format(\"Skipping loading bean definition for %s: a definition for bean \" +\n \t\t\t\t\t\t\t\"'%s' already exists. This is likely due to an override in XML.\", method, beanName));\n \t\t\t\t}\n \t\t\t\treturn;\n \t\t\t}\n \t\t}\n \n \t\tif (metadata.isAnnotated(Primary.class.getName())) {\n \t\t\tbeanDef.setPrimary(true);\n \t\t}\n \n \t\t// is this bean to be instantiated lazily?\n \t\tif (metadata.isAnnotated(Lazy.class.getName())) {\n \t\t\tbeanDef.setLazyInit((Boolean) metadata.getAnnotationAttributes(Lazy.class.getName()).get(\"value\"));\n \t\t}\n \t\telse if (configClass.getMetadata().isAnnotated(Lazy.class.getName())){\n \t\t\tbeanDef.setLazyInit((Boolean) configClass.getMetadata().getAnnotationAttributes(Lazy.class.getName()).get(\"value\"));\n \t\t}\n \n \t\tif (metadata.isAnnotated(DependsOn.class.getName())) {\n \t\t\tString[] dependsOn = (String[]) metadata.getAnnotationAttributes(DependsOn.class.getName()).get(\"value\");\n \t\t\tif (dependsOn.length > 0) {\n \t\t\t\tbeanDef.setDependsOn(dependsOn);\n \t\t\t}\n \t\t}\n \n \t\tAutowire autowire = (Autowire) beanAttributes.get(\"autowire\");\n \t\tif (autowire.isAutowire()) {\n \t\t\tbeanDef.setAutowireMode(autowire.value());\n \t\t}\n \n \t\tString initMethodName = (String) beanAttributes.get(\"initMethod\");\n \t\tif (StringUtils.hasText(initMethodName)) {\n \t\t\tbeanDef.setInitMethodName(initMethodName);\n \t\t}\n \n \t\tString destroyMethodName = (String) beanAttributes.get(\"destroyMethod\");\n \t\tif (StringUtils.hasText(destroyMethodName)) {\n \t\t\tbeanDef.setDestroyMethodName(destroyMethodName);\n \t\t}\n \n \t\t// consider scoping\n \t\tScopedProxyMode proxyMode = ScopedProxyMode.NO;\n \t\tMap<String, Object> scopeAttributes = metadata.getAnnotationAttributes(Scope.class.getName());\n \t\tif (scopeAttributes != null) {\n \t\t\tbeanDef.setScope((String) scopeAttributes.get(\"value\"));\n \t\t\tproxyMode = (ScopedProxyMode) scopeAttributes.get(\"proxyMode\");\n \t\t\tif (proxyMode == ScopedProxyMode.DEFAULT) {\n \t\t\t\tproxyMode = ScopedProxyMode.NO;\n \t\t\t}\n \t\t}\n \n \t\t// replace the original bean definition with the target one, if necessary\n \t\tBeanDefinition beanDefToRegister = beanDef;\n \t\tif (proxyMode != ScopedProxyMode.NO) {\n \t\t\tBeanDefinitionHolder proxyDef = ScopedProxyCreator.createScopedProxy(\n \t\t\t\t\tnew BeanDefinitionHolder(beanDef, beanName), this.registry, proxyMode == ScopedProxyMode.TARGET_CLASS);\n \t\t\tbeanDefToRegister = proxyDef.getBeanDefinition();\n \t\t}\n \n \t\tif (logger.isDebugEnabled()) {\n \t\t\tlogger.debug(String.format(\"Registering bean definition for @Bean method %s.%s()\", configClass.getMetadata().getClassName(), beanName));\n \t\t}\n \n \t\tregistry.registerBeanDefinition(beanName, beanDefToRegister);\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"f519406c37b23eef816704baeb3a496f7430bb89": {
			"type": "Ybodychange",
			"commitMessage": "@Primary/@Lazy/@DependsOn supported as meta-annotations; @Bean supported as meta-annotation on factory methods as well\n",
			"commitDate": "2009-07-22, 8:23 AM",
			"commitName": "f519406c37b23eef816704baeb3a496f7430bb89",
			"commitAuthor": "Juergen Hoeller",
			"commitDateOld": "2009-07-21, 7:23 AM",
			"commitNameOld": "ec1f0e6211172f43e842aabef8d4c66d946d99f2",
			"commitAuthorOld": "Juergen Hoeller",
			"daysBetweenCommits": 1.04,
			"commitsBetweenForRepo": 10,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,93 +1,93 @@\n \tprivate void loadBeanDefinitionsForModelMethod(ConfigurationClassMethod method) {\n \t\tConfigurationClass configClass = method.getDeclaringClass();\n \t\tMethodMetadata metadata = method.getMetadata();\n \n \t\tRootBeanDefinition beanDef = new ConfigurationClassBeanDefinition(configClass);\n \t\tbeanDef.setResource(configClass.getResource());\n \t\tbeanDef.setSource(this.sourceExtractor.extractSource(metadata, configClass.getResource()));\n \t\tbeanDef.setFactoryBeanName(configClass.getBeanName());\n \t\tbeanDef.setUniqueFactoryMethodName(metadata.getMethodName());\n \t\tbeanDef.setAutowireMode(RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n \n \t\t// consider name and any aliases\n \t\tMap<String, Object> beanAttributes = metadata.getAnnotationAttributes(Bean.class.getName());\n \t\tList<String> names = new ArrayList<String>(Arrays.asList((String[]) beanAttributes.get(\"name\")));\n \t\tString beanName = (names.size() > 0 ? names.remove(0) : method.getMetadata().getMethodName());\n \t\tfor (String alias : names) {\n-\t\t\tregistry.registerAlias(beanName, alias);\n+\t\t\tthis.registry.registerAlias(beanName, alias);\n \t\t}\n \n \t\t// has this already been overriden (i.e.: via XML)?\n-\t\tif (registry.containsBeanDefinition(beanName)) {\n+\t\tif (this.registry.containsBeanDefinition(beanName)) {\n \t\t\tBeanDefinition existingBeanDef = registry.getBeanDefinition(beanName);\n \t\t\t// is the existing bean definition one that was created from a configuration class?\n \t\t\tif (!(existingBeanDef instanceof ConfigurationClassBeanDefinition)) {\n \t\t\t\t// no -> then it's an external override, probably XML\n \t\t\t\t// overriding is legal, return immediately\n \t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\tlogger.debug(String.format(\"Skipping loading bean definition for %s: a definition for bean \" +\n \t\t\t\t\t\t\t\"'%s' already exists. This is likely due to an override in XML.\", method, beanName));\n \t\t\t\t}\n \t\t\t\treturn;\n \t\t\t}\n \t\t}\n \n-\t\tif (metadata.hasAnnotation(Primary.class.getName())) {\n+\t\tif (metadata.isAnnotated(Primary.class.getName())) {\n \t\t\tbeanDef.setPrimary(true);\n \t\t}\n \n \t\t// is this bean to be instantiated lazily?\n-\t\tif (metadata.hasAnnotation(Lazy.class.getName())) {\n+\t\tif (metadata.isAnnotated(Lazy.class.getName())) {\n \t\t\tbeanDef.setLazyInit((Boolean) metadata.getAnnotationAttributes(Lazy.class.getName()).get(\"value\"));\n \t\t}\n-\t\telse if (configClass.getMetadata().hasAnnotation(Lazy.class.getName())){\n+\t\telse if (configClass.getMetadata().isAnnotated(Lazy.class.getName())){\n \t\t\tbeanDef.setLazyInit((Boolean) configClass.getMetadata().getAnnotationAttributes(Lazy.class.getName()).get(\"value\"));\n \t\t}\n \n-\t\tif (metadata.hasAnnotation(DependsOn.class.getName())) {\n+\t\tif (metadata.isAnnotated(DependsOn.class.getName())) {\n \t\t\tString[] dependsOn = (String[]) metadata.getAnnotationAttributes(DependsOn.class.getName()).get(\"value\");\n \t\t\tif (dependsOn.length > 0) {\n \t\t\t\tbeanDef.setDependsOn(dependsOn);\n \t\t\t}\n \t\t}\n \n \t\tAutowire autowire = (Autowire) beanAttributes.get(\"autowire\");\n \t\tif (autowire.isAutowire()) {\n \t\t\tbeanDef.setAutowireMode(autowire.value());\n \t\t}\n \n \t\tString initMethodName = (String) beanAttributes.get(\"initMethod\");\n \t\tif (StringUtils.hasText(initMethodName)) {\n \t\t\tbeanDef.setInitMethodName(initMethodName);\n \t\t}\n \n \t\tString destroyMethodName = (String) beanAttributes.get(\"destroyMethod\");\n \t\tif (StringUtils.hasText(destroyMethodName)) {\n \t\t\tbeanDef.setDestroyMethodName(destroyMethodName);\n \t\t}\n \n \t\t// consider scoping\n \t\tScopedProxyMode proxyMode = ScopedProxyMode.NO;\n \t\tMap<String, Object> scopeAttributes = metadata.getAnnotationAttributes(Scope.class.getName());\n \t\tif (scopeAttributes != null) {\n \t\t\tbeanDef.setScope((String) scopeAttributes.get(\"value\"));\n \t\t\tproxyMode = (ScopedProxyMode) scopeAttributes.get(\"proxyMode\");\n \t\t\tif (proxyMode == ScopedProxyMode.DEFAULT) {\n \t\t\t\tproxyMode = ScopedProxyMode.NO;\n \t\t\t}\n \t\t}\n \n \t\t// replace the original bean definition with the target one, if necessary\n \t\tBeanDefinition beanDefToRegister = beanDef;\n \t\tif (proxyMode != ScopedProxyMode.NO) {\n \t\t\tBeanDefinitionHolder proxyDef = ScopedProxyCreator.createScopedProxy(\n \t\t\t\t\tnew BeanDefinitionHolder(beanDef, beanName), this.registry, proxyMode == ScopedProxyMode.TARGET_CLASS);\n \t\t\tbeanDefToRegister = proxyDef.getBeanDefinition();\n \t\t}\n \n \t\tif (logger.isDebugEnabled()) {\n \t\t\tlogger.debug(String.format(\"Registering bean definition for @Bean method %s.%s()\", configClass.getMetadata().getClassName(), beanName));\n \t\t}\n \n \t\tregistry.registerBeanDefinition(beanName, beanDefToRegister);\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"ec1f0e6211172f43e842aabef8d4c66d946d99f2": {
			"type": "Ybodychange",
			"commitMessage": "support scope meta-annotations on factory methods as well\n",
			"commitDate": "2009-07-21, 7:23 AM",
			"commitName": "ec1f0e6211172f43e842aabef8d4c66d946d99f2",
			"commitAuthor": "Juergen Hoeller",
			"commitDateOld": "2009-05-13, 1:49 PM",
			"commitNameOld": "14732c5dc2700dbd15a4148bb7244938099b9c89",
			"commitAuthorOld": "Juergen Hoeller",
			"daysBetweenCommits": 68.73,
			"commitsBetweenForRepo": 404,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,93 +1,93 @@\n \tprivate void loadBeanDefinitionsForModelMethod(ConfigurationClassMethod method) {\n \t\tConfigurationClass configClass = method.getDeclaringClass();\n \t\tMethodMetadata metadata = method.getMetadata();\n \n \t\tRootBeanDefinition beanDef = new ConfigurationClassBeanDefinition(configClass);\n \t\tbeanDef.setResource(configClass.getResource());\n \t\tbeanDef.setSource(this.sourceExtractor.extractSource(metadata, configClass.getResource()));\n \t\tbeanDef.setFactoryBeanName(configClass.getBeanName());\n \t\tbeanDef.setUniqueFactoryMethodName(metadata.getMethodName());\n \t\tbeanDef.setAutowireMode(RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n \n \t\t// consider name and any aliases\n \t\tMap<String, Object> beanAttributes = metadata.getAnnotationAttributes(Bean.class.getName());\n \t\tList<String> names = new ArrayList<String>(Arrays.asList((String[]) beanAttributes.get(\"name\")));\n \t\tString beanName = (names.size() > 0 ? names.remove(0) : method.getMetadata().getMethodName());\n \t\tfor (String alias : names) {\n \t\t\tregistry.registerAlias(beanName, alias);\n \t\t}\n \n \t\t// has this already been overriden (i.e.: via XML)?\n \t\tif (registry.containsBeanDefinition(beanName)) {\n \t\t\tBeanDefinition existingBeanDef = registry.getBeanDefinition(beanName);\n \t\t\t// is the existing bean definition one that was created from a configuration class?\n \t\t\tif (!(existingBeanDef instanceof ConfigurationClassBeanDefinition)) {\n \t\t\t\t// no -> then it's an external override, probably XML\n \t\t\t\t// overriding is legal, return immediately\n \t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\tlogger.debug(String.format(\"Skipping loading bean definition for %s: a definition for bean \" +\n \t\t\t\t\t\t\t\"'%s' already exists. This is likely due to an override in XML.\", method, beanName));\n \t\t\t\t}\n \t\t\t\treturn;\n \t\t\t}\n \t\t}\n \n \t\tif (metadata.hasAnnotation(Primary.class.getName())) {\n \t\t\tbeanDef.setPrimary(true);\n \t\t}\n \n \t\t// is this bean to be instantiated lazily?\n \t\tif (metadata.hasAnnotation(Lazy.class.getName())) {\n \t\t\tbeanDef.setLazyInit((Boolean) metadata.getAnnotationAttributes(Lazy.class.getName()).get(\"value\"));\n \t\t}\n \t\telse if (configClass.getMetadata().hasAnnotation(Lazy.class.getName())){\n \t\t\tbeanDef.setLazyInit((Boolean) configClass.getMetadata().getAnnotationAttributes(Lazy.class.getName()).get(\"value\"));\n \t\t}\n \n \t\tif (metadata.hasAnnotation(DependsOn.class.getName())) {\n \t\t\tString[] dependsOn = (String[]) metadata.getAnnotationAttributes(DependsOn.class.getName()).get(\"value\");\n \t\t\tif (dependsOn.length > 0) {\n \t\t\t\tbeanDef.setDependsOn(dependsOn);\n \t\t\t}\n \t\t}\n \n \t\tAutowire autowire = (Autowire) beanAttributes.get(\"autowire\");\n \t\tif (autowire.isAutowire()) {\n \t\t\tbeanDef.setAutowireMode(autowire.value());\n \t\t}\n \n \t\tString initMethodName = (String) beanAttributes.get(\"initMethod\");\n \t\tif (StringUtils.hasText(initMethodName)) {\n \t\t\tbeanDef.setInitMethodName(initMethodName);\n \t\t}\n \n \t\tString destroyMethodName = (String) beanAttributes.get(\"destroyMethod\");\n \t\tif (StringUtils.hasText(destroyMethodName)) {\n \t\t\tbeanDef.setDestroyMethodName(destroyMethodName);\n \t\t}\n \n \t\t// consider scoping\n \t\tScopedProxyMode proxyMode = ScopedProxyMode.NO;\n-\t\tif (metadata.hasAnnotation(Scope.class.getName())) {\n-\t\t\tMap<String, Object> scopeAttributes = metadata.getAnnotationAttributes(Scope.class.getName());\n+\t\tMap<String, Object> scopeAttributes = metadata.getAnnotationAttributes(Scope.class.getName());\n+\t\tif (scopeAttributes != null) {\n \t\t\tbeanDef.setScope((String) scopeAttributes.get(\"value\"));\n \t\t\tproxyMode = (ScopedProxyMode) scopeAttributes.get(\"proxyMode\");\n \t\t\tif (proxyMode == ScopedProxyMode.DEFAULT) {\n \t\t\t\tproxyMode = ScopedProxyMode.NO;\n \t\t\t}\n \t\t}\n \n \t\t// replace the original bean definition with the target one, if necessary\n \t\tBeanDefinition beanDefToRegister = beanDef;\n \t\tif (proxyMode != ScopedProxyMode.NO) {\n \t\t\tBeanDefinitionHolder proxyDef = ScopedProxyCreator.createScopedProxy(\n-\t\t\t\t\tnew BeanDefinitionHolder(beanDef, beanName), registry, proxyMode == ScopedProxyMode.TARGET_CLASS);\n+\t\t\t\t\tnew BeanDefinitionHolder(beanDef, beanName), this.registry, proxyMode == ScopedProxyMode.TARGET_CLASS);\n \t\t\tbeanDefToRegister = proxyDef.getBeanDefinition();\n \t\t}\n \n \t\tif (logger.isDebugEnabled()) {\n \t\t\tlogger.debug(String.format(\"Registering bean definition for @Bean method %s.%s()\", configClass.getMetadata().getClassName(), beanName));\n \t\t}\n \n \t\tregistry.registerBeanDefinition(beanName, beanDefToRegister);\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"da71f266aed8c3dbea7c995ab4e2f3dae51cca45": {
			"type": "Ybodychange",
			"commitMessage": "ConfigurationClassBeanDefinition implements AnnotatedBeanDefinition\n",
			"commitDate": "2009-05-12, 4:12 PM",
			"commitName": "da71f266aed8c3dbea7c995ab4e2f3dae51cca45",
			"commitAuthor": "Juergen Hoeller",
			"commitDateOld": "2009-05-12, 3:27 PM",
			"commitNameOld": "cce6e2f4cdfed4233805a32fb82626fa5e901cc0",
			"commitAuthorOld": "Juergen Hoeller",
			"daysBetweenCommits": 0.03,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,92 +1,93 @@\n \tprivate void loadBeanDefinitionsForModelMethod(ConfigurationClassMethod method) {\n+\t\tConfigurationClass configClass = method.getDeclaringClass();\n \t\tMethodMetadata metadata = method.getMetadata();\n \n-\t\tRootBeanDefinition beanDef = new ConfigurationClassBeanDefinition();\n-\t\tConfigurationClass configClass = method.getDeclaringClass();\n+\t\tRootBeanDefinition beanDef = new ConfigurationClassBeanDefinition(configClass);\n+\t\tbeanDef.setResource(configClass.getResource());\n \t\tbeanDef.setSource(this.sourceExtractor.extractSource(metadata, configClass.getResource()));\n \t\tbeanDef.setFactoryBeanName(configClass.getBeanName());\n \t\tbeanDef.setUniqueFactoryMethodName(metadata.getMethodName());\n \t\tbeanDef.setAutowireMode(RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n \n \t\t// consider name and any aliases\n \t\tMap<String, Object> beanAttributes = metadata.getAnnotationAttributes(Bean.class.getName());\n \t\tList<String> names = new ArrayList<String>(Arrays.asList((String[]) beanAttributes.get(\"name\")));\n \t\tString beanName = (names.size() > 0 ? names.remove(0) : method.getMetadata().getMethodName());\n \t\tfor (String alias : names) {\n \t\t\tregistry.registerAlias(beanName, alias);\n \t\t}\n \n \t\t// has this already been overriden (i.e.: via XML)?\n \t\tif (registry.containsBeanDefinition(beanName)) {\n \t\t\tBeanDefinition existingBeanDef = registry.getBeanDefinition(beanName);\n \t\t\t// is the existing bean definition one that was created from a configuration class?\n \t\t\tif (!(existingBeanDef instanceof ConfigurationClassBeanDefinition)) {\n \t\t\t\t// no -> then it's an external override, probably XML\n \t\t\t\t// overriding is legal, return immediately\n \t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\tlogger.debug(String.format(\"Skipping loading bean definition for %s: a definition for bean \" +\n \t\t\t\t\t\t\t\"'%s' already exists. This is likely due to an override in XML.\", method, beanName));\n \t\t\t\t}\n \t\t\t\treturn;\n \t\t\t}\n \t\t}\n \n \t\tif (metadata.hasAnnotation(Primary.class.getName())) {\n \t\t\tbeanDef.setPrimary(true);\n \t\t}\n \n \t\t// is this bean to be instantiated lazily?\n \t\tif (metadata.hasAnnotation(Lazy.class.getName())) {\n \t\t\tbeanDef.setLazyInit((Boolean) metadata.getAnnotationAttributes(Lazy.class.getName()).get(\"value\"));\n \t\t}\n \t\telse if (configClass.getMetadata().hasAnnotation(Lazy.class.getName())){\n \t\t\tbeanDef.setLazyInit((Boolean) configClass.getMetadata().getAnnotationAttributes(Lazy.class.getName()).get(\"value\"));\n \t\t}\n \n \t\tif (metadata.hasAnnotation(DependsOn.class.getName())) {\n \t\t\tString[] dependsOn = (String[]) metadata.getAnnotationAttributes(DependsOn.class.getName()).get(\"value\");\n \t\t\tif (dependsOn.length > 0) {\n \t\t\t\tbeanDef.setDependsOn(dependsOn);\n \t\t\t}\n \t\t}\n \n \t\tAutowire autowire = (Autowire) beanAttributes.get(\"autowire\");\n \t\tif (autowire.isAutowire()) {\n \t\t\tbeanDef.setAutowireMode(autowire.value());\n \t\t}\n \n \t\tString initMethodName = (String) beanAttributes.get(\"initMethod\");\n \t\tif (StringUtils.hasText(initMethodName)) {\n \t\t\tbeanDef.setInitMethodName(initMethodName);\n \t\t}\n \n \t\tString destroyMethodName = (String) beanAttributes.get(\"destroyMethod\");\n \t\tif (StringUtils.hasText(destroyMethodName)) {\n \t\t\tbeanDef.setDestroyMethodName(destroyMethodName);\n \t\t}\n \n \t\t// consider scoping\n \t\tScopedProxyMode proxyMode = ScopedProxyMode.NO;\n \t\tif (metadata.hasAnnotation(Scope.class.getName())) {\n \t\t\tMap<String, Object> scopeAttributes = metadata.getAnnotationAttributes(Scope.class.getName());\n \t\t\tbeanDef.setScope((String) scopeAttributes.get(\"value\"));\n \t\t\tproxyMode = (ScopedProxyMode) scopeAttributes.get(\"proxyMode\");\n \t\t\tif (proxyMode == ScopedProxyMode.DEFAULT) {\n \t\t\t\tproxyMode = ScopedProxyMode.NO;\n \t\t\t}\n \t\t}\n \n \t\t// replace the original bean definition with the target one, if necessary\n \t\tBeanDefinition beanDefToRegister = beanDef;\n \t\tif (proxyMode != ScopedProxyMode.NO) {\n \t\t\tBeanDefinitionHolder proxyDef = ScopedProxyCreator.createScopedProxy(\n \t\t\t\t\tnew BeanDefinitionHolder(beanDef, beanName), registry, proxyMode == ScopedProxyMode.TARGET_CLASS);\n \t\t\tbeanDefToRegister = proxyDef.getBeanDefinition();\n \t\t}\n \n \t\tif (logger.isDebugEnabled()) {\n \t\t\tlogger.debug(String.format(\"Registering bean definition for @Bean method %s.%s()\", configClass.getMetadata().getClassName(), beanName));\n \t\t}\n \n \t\tregistry.registerBeanDefinition(beanName, beanDefToRegister);\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"cce6e2f4cdfed4233805a32fb82626fa5e901cc0": {
			"type": "Ybodychange",
			"commitMessage": "added SourceExtractor support\n",
			"commitDate": "2009-05-12, 3:27 PM",
			"commitName": "cce6e2f4cdfed4233805a32fb82626fa5e901cc0",
			"commitAuthor": "Juergen Hoeller",
			"commitDateOld": "2009-04-26, 4:41 AM",
			"commitNameOld": "cea8f7f69e8939d4d20073862890f0b1c1824499",
			"commitAuthorOld": "Juergen Hoeller",
			"daysBetweenCommits": 16.45,
			"commitsBetweenForRepo": 98,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,91 +1,92 @@\n \tprivate void loadBeanDefinitionsForModelMethod(ConfigurationClassMethod method) {\n \t\tMethodMetadata metadata = method.getMetadata();\n \n \t\tRootBeanDefinition beanDef = new ConfigurationClassBeanDefinition();\n \t\tConfigurationClass configClass = method.getDeclaringClass();\n+\t\tbeanDef.setSource(this.sourceExtractor.extractSource(metadata, configClass.getResource()));\n \t\tbeanDef.setFactoryBeanName(configClass.getBeanName());\n \t\tbeanDef.setUniqueFactoryMethodName(metadata.getMethodName());\n \t\tbeanDef.setAutowireMode(RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n \n \t\t// consider name and any aliases\n \t\tMap<String, Object> beanAttributes = metadata.getAnnotationAttributes(Bean.class.getName());\n \t\tList<String> names = new ArrayList<String>(Arrays.asList((String[]) beanAttributes.get(\"name\")));\n \t\tString beanName = (names.size() > 0 ? names.remove(0) : method.getMetadata().getMethodName());\n \t\tfor (String alias : names) {\n \t\t\tregistry.registerAlias(beanName, alias);\n \t\t}\n \n \t\t// has this already been overriden (i.e.: via XML)?\n \t\tif (registry.containsBeanDefinition(beanName)) {\n \t\t\tBeanDefinition existingBeanDef = registry.getBeanDefinition(beanName);\n \t\t\t// is the existing bean definition one that was created from a configuration class?\n \t\t\tif (!(existingBeanDef instanceof ConfigurationClassBeanDefinition)) {\n \t\t\t\t// no -> then it's an external override, probably XML\n \t\t\t\t// overriding is legal, return immediately\n \t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\tlogger.debug(String.format(\"Skipping loading bean definition for %s: a definition for bean \" +\n \t\t\t\t\t\t\t\"'%s' already exists. This is likely due to an override in XML.\", method, beanName));\n \t\t\t\t}\n \t\t\t\treturn;\n \t\t\t}\n \t\t}\n \n \t\tif (metadata.hasAnnotation(Primary.class.getName())) {\n \t\t\tbeanDef.setPrimary(true);\n \t\t}\n \n \t\t// is this bean to be instantiated lazily?\n \t\tif (metadata.hasAnnotation(Lazy.class.getName())) {\n \t\t\tbeanDef.setLazyInit((Boolean) metadata.getAnnotationAttributes(Lazy.class.getName()).get(\"value\"));\n \t\t}\n \t\telse if (configClass.getMetadata().hasAnnotation(Lazy.class.getName())){\n \t\t\tbeanDef.setLazyInit((Boolean) configClass.getMetadata().getAnnotationAttributes(Lazy.class.getName()).get(\"value\"));\n \t\t}\n \n \t\tif (metadata.hasAnnotation(DependsOn.class.getName())) {\n \t\t\tString[] dependsOn = (String[]) metadata.getAnnotationAttributes(DependsOn.class.getName()).get(\"value\");\n \t\t\tif (dependsOn.length > 0) {\n \t\t\t\tbeanDef.setDependsOn(dependsOn);\n \t\t\t}\n \t\t}\n \n \t\tAutowire autowire = (Autowire) beanAttributes.get(\"autowire\");\n \t\tif (autowire.isAutowire()) {\n \t\t\tbeanDef.setAutowireMode(autowire.value());\n \t\t}\n \n \t\tString initMethodName = (String) beanAttributes.get(\"initMethod\");\n \t\tif (StringUtils.hasText(initMethodName)) {\n \t\t\tbeanDef.setInitMethodName(initMethodName);\n \t\t}\n \n \t\tString destroyMethodName = (String) beanAttributes.get(\"destroyMethod\");\n \t\tif (StringUtils.hasText(destroyMethodName)) {\n \t\t\tbeanDef.setDestroyMethodName(destroyMethodName);\n \t\t}\n \n \t\t// consider scoping\n \t\tScopedProxyMode proxyMode = ScopedProxyMode.NO;\n \t\tif (metadata.hasAnnotation(Scope.class.getName())) {\n \t\t\tMap<String, Object> scopeAttributes = metadata.getAnnotationAttributes(Scope.class.getName());\n \t\t\tbeanDef.setScope((String) scopeAttributes.get(\"value\"));\n \t\t\tproxyMode = (ScopedProxyMode) scopeAttributes.get(\"proxyMode\");\n \t\t\tif (proxyMode == ScopedProxyMode.DEFAULT) {\n \t\t\t\tproxyMode = ScopedProxyMode.NO;\n \t\t\t}\n \t\t}\n \n \t\t// replace the original bean definition with the target one, if necessary\n \t\tBeanDefinition beanDefToRegister = beanDef;\n \t\tif (proxyMode != ScopedProxyMode.NO) {\n \t\t\tBeanDefinitionHolder proxyDef = ScopedProxyCreator.createScopedProxy(\n \t\t\t\t\tnew BeanDefinitionHolder(beanDef, beanName), registry, proxyMode == ScopedProxyMode.TARGET_CLASS);\n \t\t\tbeanDefToRegister = proxyDef.getBeanDefinition();\n \t\t}\n \n \t\tif (logger.isDebugEnabled()) {\n \t\t\tlogger.debug(String.format(\"Registering bean definition for @Bean method %s.%s()\", configClass.getMetadata().getClassName(), beanName));\n \t\t}\n \n \t\tregistry.registerBeanDefinition(beanName, beanDefToRegister);\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"cea8f7f69e8939d4d20073862890f0b1c1824499": {
			"type": "Ybodychange",
			"commitMessage": "custom stereotype annotations can be meta-annotated with @Service, @Controller etc as well; @Scope and @Transactional are now supported as meta-annotations on custom annotations\n",
			"commitDate": "2009-04-26, 4:41 AM",
			"commitName": "cea8f7f69e8939d4d20073862890f0b1c1824499",
			"commitAuthor": "Juergen Hoeller",
			"commitDateOld": "2009-04-24, 4:16 AM",
			"commitNameOld": "b5d21108da24f8344be3bc708c7afdfca9a1d089",
			"commitAuthorOld": "Juergen Hoeller",
			"daysBetweenCommits": 2.02,
			"commitsBetweenForRepo": 4,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,91 +1,91 @@\n \tprivate void loadBeanDefinitionsForModelMethod(ConfigurationClassMethod method) {\n \t\tMethodMetadata metadata = method.getMetadata();\n \n \t\tRootBeanDefinition beanDef = new ConfigurationClassBeanDefinition();\n \t\tConfigurationClass configClass = method.getDeclaringClass();\n \t\tbeanDef.setFactoryBeanName(configClass.getBeanName());\n \t\tbeanDef.setUniqueFactoryMethodName(metadata.getMethodName());\n \t\tbeanDef.setAutowireMode(RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n \n \t\t// consider name and any aliases\n \t\tMap<String, Object> beanAttributes = metadata.getAnnotationAttributes(Bean.class.getName());\n \t\tList<String> names = new ArrayList<String>(Arrays.asList((String[]) beanAttributes.get(\"name\")));\n \t\tString beanName = (names.size() > 0 ? names.remove(0) : method.getMetadata().getMethodName());\n \t\tfor (String alias : names) {\n \t\t\tregistry.registerAlias(beanName, alias);\n \t\t}\n \n \t\t// has this already been overriden (i.e.: via XML)?\n \t\tif (registry.containsBeanDefinition(beanName)) {\n \t\t\tBeanDefinition existingBeanDef = registry.getBeanDefinition(beanName);\n \t\t\t// is the existing bean definition one that was created from a configuration class?\n \t\t\tif (!(existingBeanDef instanceof ConfigurationClassBeanDefinition)) {\n \t\t\t\t// no -> then it's an external override, probably XML\n \t\t\t\t// overriding is legal, return immediately\n \t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\tlogger.debug(String.format(\"Skipping loading bean definition for %s: a definition for bean \" +\n \t\t\t\t\t\t\t\"'%s' already exists. This is likely due to an override in XML.\", method, beanName));\n \t\t\t\t}\n \t\t\t\treturn;\n \t\t\t}\n \t\t}\n \n \t\tif (metadata.hasAnnotation(Primary.class.getName())) {\n \t\t\tbeanDef.setPrimary(true);\n \t\t}\n \n \t\t// is this bean to be instantiated lazily?\n \t\tif (metadata.hasAnnotation(Lazy.class.getName())) {\n \t\t\tbeanDef.setLazyInit((Boolean) metadata.getAnnotationAttributes(Lazy.class.getName()).get(\"value\"));\n \t\t}\n \t\telse if (configClass.getMetadata().hasAnnotation(Lazy.class.getName())){\n \t\t\tbeanDef.setLazyInit((Boolean) configClass.getMetadata().getAnnotationAttributes(Lazy.class.getName()).get(\"value\"));\n \t\t}\n \n \t\tif (metadata.hasAnnotation(DependsOn.class.getName())) {\n \t\t\tString[] dependsOn = (String[]) metadata.getAnnotationAttributes(DependsOn.class.getName()).get(\"value\");\n \t\t\tif (dependsOn.length > 0) {\n \t\t\t\tbeanDef.setDependsOn(dependsOn);\n \t\t\t}\n \t\t}\n \n \t\tAutowire autowire = (Autowire) beanAttributes.get(\"autowire\");\n \t\tif (autowire.isAutowire()) {\n \t\t\tbeanDef.setAutowireMode(autowire.value());\n \t\t}\n \n \t\tString initMethodName = (String) beanAttributes.get(\"initMethod\");\n \t\tif (StringUtils.hasText(initMethodName)) {\n \t\t\tbeanDef.setInitMethodName(initMethodName);\n \t\t}\n \n \t\tString destroyMethodName = (String) beanAttributes.get(\"destroyMethod\");\n \t\tif (StringUtils.hasText(destroyMethodName)) {\n \t\t\tbeanDef.setDestroyMethodName(destroyMethodName);\n \t\t}\n \n \t\t// consider scoping\n \t\tScopedProxyMode proxyMode = ScopedProxyMode.NO;\n \t\tif (metadata.hasAnnotation(Scope.class.getName())) {\n \t\t\tMap<String, Object> scopeAttributes = metadata.getAnnotationAttributes(Scope.class.getName());\n \t\t\tbeanDef.setScope((String) scopeAttributes.get(\"value\"));\n \t\t\tproxyMode = (ScopedProxyMode) scopeAttributes.get(\"proxyMode\");\n \t\t\tif (proxyMode == ScopedProxyMode.DEFAULT) {\n \t\t\t\tproxyMode = ScopedProxyMode.NO;\n \t\t\t}\n \t\t}\n \n \t\t// replace the original bean definition with the target one, if necessary\n \t\tBeanDefinition beanDefToRegister = beanDef;\n \t\tif (proxyMode != ScopedProxyMode.NO) {\n-\t\t\tBeanDefinitionHolder proxyDef = ScopedProxyUtils.createScopedProxy(\n+\t\t\tBeanDefinitionHolder proxyDef = ScopedProxyCreator.createScopedProxy(\n \t\t\t\t\tnew BeanDefinitionHolder(beanDef, beanName), registry, proxyMode == ScopedProxyMode.TARGET_CLASS);\n \t\t\tbeanDefToRegister = proxyDef.getBeanDefinition();\n \t\t}\n \n \t\tif (logger.isDebugEnabled()) {\n \t\t\tlogger.debug(String.format(\"Registering bean definition for @Bean method %s.%s()\", configClass.getMetadata().getClassName(), beanName));\n \t\t}\n \n \t\tregistry.registerBeanDefinition(beanName, beanDefToRegister);\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"b5d21108da24f8344be3bc708c7afdfca9a1d089": {
			"type": "Ybodychange",
			"commitMessage": "@Configuration parsing fully relies on Spring's MetadataReader abstraction now\n",
			"commitDate": "2009-04-24, 4:16 AM",
			"commitName": "b5d21108da24f8344be3bc708c7afdfca9a1d089",
			"commitAuthor": "Juergen Hoeller",
			"commitDateOld": "2009-04-22, 3:46 AM",
			"commitNameOld": "ea9d8925a27e80d31d924826cf54f70b2bbcc638",
			"commitAuthorOld": "Juergen Hoeller",
			"daysBetweenCommits": 2.02,
			"commitsBetweenForRepo": 15,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,91 +1,91 @@\n \tprivate void loadBeanDefinitionsForModelMethod(ConfigurationClassMethod method) {\n+\t\tMethodMetadata metadata = method.getMetadata();\n+\n \t\tRootBeanDefinition beanDef = new ConfigurationClassBeanDefinition();\n \t\tConfigurationClass configClass = method.getDeclaringClass();\n \t\tbeanDef.setFactoryBeanName(configClass.getBeanName());\n-\t\tbeanDef.setUniqueFactoryMethodName(method.getName());\n+\t\tbeanDef.setUniqueFactoryMethodName(metadata.getMethodName());\n \t\tbeanDef.setAutowireMode(RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n \n \t\t// consider name and any aliases\n-\t\tBean bean = method.getRequiredAnnotation(Bean.class);\n-\t\tList<String> names = new ArrayList<String>(Arrays.asList(bean.name()));\n-\t\tString beanName = (names.size() > 0) ? names.remove(0) : method.getName();\n-\t\tfor (String alias : bean.name()) {\n+\t\tMap<String, Object> beanAttributes = metadata.getAnnotationAttributes(Bean.class.getName());\n+\t\tList<String> names = new ArrayList<String>(Arrays.asList((String[]) beanAttributes.get(\"name\")));\n+\t\tString beanName = (names.size() > 0 ? names.remove(0) : method.getMetadata().getMethodName());\n+\t\tfor (String alias : names) {\n \t\t\tregistry.registerAlias(beanName, alias);\n \t\t}\n \n \t\t// has this already been overriden (i.e.: via XML)?\n \t\tif (registry.containsBeanDefinition(beanName)) {\n \t\t\tBeanDefinition existingBeanDef = registry.getBeanDefinition(beanName);\n-\t\t\t// is the existing bean definition one that was created by JavaConfig?\n+\t\t\t// is the existing bean definition one that was created from a configuration class?\n \t\t\tif (!(existingBeanDef instanceof ConfigurationClassBeanDefinition)) {\n \t\t\t\t// no -> then it's an external override, probably XML\n \t\t\t\t// overriding is legal, return immediately\n \t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\tlogger.debug(String.format(\"Skipping loading bean definition for %s: a definition for bean \" +\n \t\t\t\t\t\t\t\"'%s' already exists. This is likely due to an override in XML.\", method, beanName));\n \t\t\t\t}\n \t\t\t\treturn;\n \t\t\t}\n \t\t}\n \n-\t\tif (method.getAnnotation(Primary.class) != null) {\n+\t\tif (metadata.hasAnnotation(Primary.class.getName())) {\n \t\t\tbeanDef.setPrimary(true);\n \t\t}\n \n \t\t// is this bean to be instantiated lazily?\n-\t\tLazy lazy = method.getAnnotation(Lazy.class);\n-\t\tif (lazy != null) {\n-\t\t\tbeanDef.setLazyInit(lazy.value());\n+\t\tif (metadata.hasAnnotation(Lazy.class.getName())) {\n+\t\t\tbeanDef.setLazyInit((Boolean) metadata.getAnnotationAttributes(Lazy.class.getName()).get(\"value\"));\n \t\t}\n-\t\telse {\n-\t\t\tLazy defaultLazy = configClass.getAnnotation(Lazy.class);\n-\t\t\tif (defaultLazy != null) {\n-\t\t\t\tbeanDef.setLazyInit(defaultLazy.value());\n+\t\telse if (configClass.getMetadata().hasAnnotation(Lazy.class.getName())){\n+\t\t\tbeanDef.setLazyInit((Boolean) configClass.getMetadata().getAnnotationAttributes(Lazy.class.getName()).get(\"value\"));\n+\t\t}\n+\n+\t\tif (metadata.hasAnnotation(DependsOn.class.getName())) {\n+\t\t\tString[] dependsOn = (String[]) metadata.getAnnotationAttributes(DependsOn.class.getName()).get(\"value\");\n+\t\t\tif (dependsOn.length > 0) {\n+\t\t\t\tbeanDef.setDependsOn(dependsOn);\n \t\t\t}\n \t\t}\n \n-\t\tDependsOn dependsOn = method.getAnnotation(DependsOn.class);\n-\t\tif (dependsOn != null && dependsOn.value().length > 0) {\n-\t\t\tbeanDef.setDependsOn(dependsOn.value());\n-\t\t}\n-\n-\t\tAutowire autowire = bean.autowire();\n+\t\tAutowire autowire = (Autowire) beanAttributes.get(\"autowire\");\n \t\tif (autowire.isAutowire()) {\n \t\t\tbeanDef.setAutowireMode(autowire.value());\n \t\t}\n \n-\t\tString initMethodName = bean.initMethod();\n+\t\tString initMethodName = (String) beanAttributes.get(\"initMethod\");\n \t\tif (StringUtils.hasText(initMethodName)) {\n \t\t\tbeanDef.setInitMethodName(initMethodName);\n \t\t}\n \n-\t\tString destroyMethodName = bean.destroyMethod();\n+\t\tString destroyMethodName = (String) beanAttributes.get(\"destroyMethod\");\n \t\tif (StringUtils.hasText(destroyMethodName)) {\n \t\t\tbeanDef.setDestroyMethodName(destroyMethodName);\n \t\t}\n \n \t\t// consider scoping\n-\t\tScope scope = method.getAnnotation(Scope.class);\n \t\tScopedProxyMode proxyMode = ScopedProxyMode.NO;\n-\t\tif (scope != null) {\n-\t\t\tbeanDef.setScope(scope.value());\n-\t\t\tproxyMode = scope.proxyMode();\n+\t\tif (metadata.hasAnnotation(Scope.class.getName())) {\n+\t\t\tMap<String, Object> scopeAttributes = metadata.getAnnotationAttributes(Scope.class.getName());\n+\t\t\tbeanDef.setScope((String) scopeAttributes.get(\"value\"));\n+\t\t\tproxyMode = (ScopedProxyMode) scopeAttributes.get(\"proxyMode\");\n \t\t\tif (proxyMode == ScopedProxyMode.DEFAULT) {\n \t\t\t\tproxyMode = ScopedProxyMode.NO;\n \t\t\t}\n \t\t}\n \n \t\t// replace the original bean definition with the target one, if necessary\n \t\tBeanDefinition beanDefToRegister = beanDef;\n \t\tif (proxyMode != ScopedProxyMode.NO) {\n \t\t\tBeanDefinitionHolder proxyDef = ScopedProxyUtils.createScopedProxy(\n \t\t\t\t\tnew BeanDefinitionHolder(beanDef, beanName), registry, proxyMode == ScopedProxyMode.TARGET_CLASS);\n \t\t\tbeanDefToRegister = proxyDef.getBeanDefinition();\n \t\t}\n \n \t\tif (logger.isDebugEnabled()) {\n-\t\t\tlogger.debug(String.format(\"Registering bean definition for @Bean method %s.%s()\", configClass.getName(), beanName));\n+\t\t\tlogger.debug(String.format(\"Registering bean definition for @Bean method %s.%s()\", configClass.getMetadata().getClassName(), beanName));\n \t\t}\n \n \t\tregistry.registerBeanDefinition(beanName, beanDefToRegister);\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"ea9d8925a27e80d31d924826cf54f70b2bbcc638": {
			"type": "Ybodychange",
			"commitMessage": "next cut of JavaConfig metadata reading revision: using cached MetadataReaders\n",
			"commitDate": "2009-04-22, 3:46 AM",
			"commitName": "ea9d8925a27e80d31d924826cf54f70b2bbcc638",
			"commitAuthor": "Juergen Hoeller",
			"commitDateOld": "2009-04-19, 4:45 PM",
			"commitNameOld": "14bd47551900ced88eeacf2a5f63c187ff72028c",
			"commitAuthorOld": "Juergen Hoeller",
			"daysBetweenCommits": 2.46,
			"commitsBetweenForRepo": 13,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,91 +1,91 @@\n \tprivate void loadBeanDefinitionsForModelMethod(ConfigurationClassMethod method) {\n \t\tRootBeanDefinition beanDef = new ConfigurationClassBeanDefinition();\n \t\tConfigurationClass configClass = method.getDeclaringClass();\n \t\tbeanDef.setFactoryBeanName(configClass.getBeanName());\n-\t\tbeanDef.setFactoryMethodName(method.getName());\n+\t\tbeanDef.setUniqueFactoryMethodName(method.getName());\n \t\tbeanDef.setAutowireMode(RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n \n \t\t// consider name and any aliases\n \t\tBean bean = method.getRequiredAnnotation(Bean.class);\n \t\tList<String> names = new ArrayList<String>(Arrays.asList(bean.name()));\n \t\tString beanName = (names.size() > 0) ? names.remove(0) : method.getName();\n \t\tfor (String alias : bean.name()) {\n \t\t\tregistry.registerAlias(beanName, alias);\n \t\t}\n \n \t\t// has this already been overriden (i.e.: via XML)?\n \t\tif (registry.containsBeanDefinition(beanName)) {\n \t\t\tBeanDefinition existingBeanDef = registry.getBeanDefinition(beanName);\n \t\t\t// is the existing bean definition one that was created by JavaConfig?\n \t\t\tif (!(existingBeanDef instanceof ConfigurationClassBeanDefinition)) {\n \t\t\t\t// no -> then it's an external override, probably XML\n \t\t\t\t// overriding is legal, return immediately\n \t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\tlogger.debug(String.format(\"Skipping loading bean definition for %s: a definition for bean \" +\n \t\t\t\t\t\t\t\"'%s' already exists. This is likely due to an override in XML.\", method, beanName));\n \t\t\t\t}\n \t\t\t\treturn;\n \t\t\t}\n \t\t}\n \n \t\tif (method.getAnnotation(Primary.class) != null) {\n \t\t\tbeanDef.setPrimary(true);\n \t\t}\n \n \t\t// is this bean to be instantiated lazily?\n \t\tLazy lazy = method.getAnnotation(Lazy.class);\n \t\tif (lazy != null) {\n \t\t\tbeanDef.setLazyInit(lazy.value());\n \t\t}\n \t\telse {\n \t\t\tLazy defaultLazy = configClass.getAnnotation(Lazy.class);\n \t\t\tif (defaultLazy != null) {\n \t\t\t\tbeanDef.setLazyInit(defaultLazy.value());\n \t\t\t}\n \t\t}\n \n \t\tDependsOn dependsOn = method.getAnnotation(DependsOn.class);\n \t\tif (dependsOn != null && dependsOn.value().length > 0) {\n \t\t\tbeanDef.setDependsOn(dependsOn.value());\n \t\t}\n \n \t\tAutowire autowire = bean.autowire();\n \t\tif (autowire.isAutowire()) {\n \t\t\tbeanDef.setAutowireMode(autowire.value());\n \t\t}\n \n \t\tString initMethodName = bean.initMethod();\n \t\tif (StringUtils.hasText(initMethodName)) {\n \t\t\tbeanDef.setInitMethodName(initMethodName);\n \t\t}\n \n \t\tString destroyMethodName = bean.destroyMethod();\n \t\tif (StringUtils.hasText(destroyMethodName)) {\n \t\t\tbeanDef.setDestroyMethodName(destroyMethodName);\n \t\t}\n \n \t\t// consider scoping\n \t\tScope scope = method.getAnnotation(Scope.class);\n \t\tScopedProxyMode proxyMode = ScopedProxyMode.NO;\n \t\tif (scope != null) {\n \t\t\tbeanDef.setScope(scope.value());\n \t\t\tproxyMode = scope.proxyMode();\n \t\t\tif (proxyMode == ScopedProxyMode.DEFAULT) {\n \t\t\t\tproxyMode = ScopedProxyMode.NO;\n \t\t\t}\n \t\t}\n \n \t\t// replace the original bean definition with the target one, if necessary\n \t\tBeanDefinition beanDefToRegister = beanDef;\n \t\tif (proxyMode != ScopedProxyMode.NO) {\n \t\t\tBeanDefinitionHolder proxyDef = ScopedProxyUtils.createScopedProxy(\n \t\t\t\t\tnew BeanDefinitionHolder(beanDef, beanName), registry, proxyMode == ScopedProxyMode.TARGET_CLASS);\n \t\t\tbeanDefToRegister = proxyDef.getBeanDefinition();\n \t\t}\n \n \t\tif (logger.isDebugEnabled()) {\n \t\t\tlogger.debug(String.format(\"Registering bean definition for @Bean method %s.%s()\", configClass.getName(), beanName));\n \t\t}\n \n \t\tregistry.registerBeanDefinition(beanName, beanDefToRegister);\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"14bd47551900ced88eeacf2a5f63c187ff72028c": {
			"type": "Ymultichange(Ymovefromfile,Ybodychange,Yparameterchange)",
			"commitMessage": "revised support for annotated factory methods (merged @FactoryMethod functionality into JavaConfig facility)\n",
			"commitDate": "2009-04-19, 4:45 PM",
			"commitName": "14bd47551900ced88eeacf2a5f63c187ff72028c",
			"commitAuthor": "Juergen Hoeller",
			"subchanges": [
				{
					"type": "Ymovefromfile",
					"commitMessage": "revised support for annotated factory methods (merged @FactoryMethod functionality into JavaConfig facility)\n",
					"commitDate": "2009-04-19, 4:45 PM",
					"commitName": "14bd47551900ced88eeacf2a5f63c187ff72028c",
					"commitAuthor": "Juergen Hoeller",
					"commitDateOld": "2009-04-19, 3:28 PM",
					"commitNameOld": "736169aa2a46f489cd8e75cf4d61cef997fc456f",
					"commitAuthorOld": "Juergen Hoeller",
					"daysBetweenCommits": 0.05,
					"commitsBetweenForRepo": 1,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,93 +1,91 @@\n-\tprivate void loadBeanDefinitionsForModelMethod(BeanMethod method) {\n+\tprivate void loadBeanDefinitionsForModelMethod(ConfigurationClassMethod method) {\n \t\tRootBeanDefinition beanDef = new ConfigurationClassBeanDefinition();\n-\n \t\tConfigurationClass configClass = method.getDeclaringClass();\n-\n \t\tbeanDef.setFactoryBeanName(configClass.getBeanName());\n \t\tbeanDef.setFactoryMethodName(method.getName());\n-\n-\t\tBean bean = method.getRequiredAnnotation(Bean.class);\n-\n-\t\t// consider scoping\n-\t\tScope scope = method.getAnnotation(Scope.class);\n-\t\tif(scope != null)\n-\t\t\tbeanDef.setScope(scope.value());\n+\t\tbeanDef.setAutowireMode(RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n \n \t\t// consider name and any aliases\n-\t\tArrayList<String> names = new ArrayList<String>(Arrays.asList(bean.name()));\n+\t\tBean bean = method.getRequiredAnnotation(Bean.class);\n+\t\tList<String> names = new ArrayList<String>(Arrays.asList(bean.name()));\n \t\tString beanName = (names.size() > 0) ? names.remove(0) : method.getName();\n-\t\tfor (String alias : bean.name())\n+\t\tfor (String alias : bean.name()) {\n \t\t\tregistry.registerAlias(beanName, alias);\n+\t\t}\n \n \t\t// has this already been overriden (i.e.: via XML)?\n-\t\tif (containsBeanDefinitionIncludingAncestry(beanName, registry)) {\n-\t\t\tBeanDefinition existingBeanDef = getBeanDefinitionIncludingAncestry(beanName, registry);\n-\n+\t\tif (registry.containsBeanDefinition(beanName)) {\n+\t\t\tBeanDefinition existingBeanDef = registry.getBeanDefinition(beanName);\n \t\t\t// is the existing bean definition one that was created by JavaConfig?\n \t\t\tif (!(existingBeanDef instanceof ConfigurationClassBeanDefinition)) {\n \t\t\t\t// no -> then it's an external override, probably XML\n-\n \t\t\t\t// overriding is legal, return immediately\n-\t\t\t\tlog.info(format(\"Skipping loading bean definition for %s: a definition for bean \"\n-\t\t\t\t\t+ \"'%s' already exists. This is likely due to an override in XML.\", method, beanName));\n+\t\t\t\tif (logger.isDebugEnabled()) {\n+\t\t\t\t\tlogger.debug(String.format(\"Skipping loading bean definition for %s: a definition for bean \" +\n+\t\t\t\t\t\t\t\"'%s' already exists. This is likely due to an override in XML.\", method, beanName));\n+\t\t\t\t}\n \t\t\t\treturn;\n \t\t\t}\n \t\t}\n \n-\t\tif (method.getAnnotation(Primary.class) != null)\n+\t\tif (method.getAnnotation(Primary.class) != null) {\n \t\t\tbeanDef.setPrimary(true);\n-\n-\t\t// is this bean to be instantiated lazily?\n-\t\tLazy defaultLazy = configClass.getAnnotation(Lazy.class);\n-\t\tif (defaultLazy != null)\n-\t\t\tbeanDef.setLazyInit(defaultLazy.value());\n-\t\tLazy lazy = method.getAnnotation(Lazy.class);\n-\t\tif (lazy != null)\n-\t\t\tbeanDef.setLazyInit(lazy.value());\n-\n-\t\t// does this bean have a custom init-method specified?\n-\t\tString initMethodName = bean.initMethod();\n-\t\tif (hasText(initMethodName))\n-\t\t\tbeanDef.setInitMethodName(initMethodName);\n-\n-\t\t// does this bean have a custom destroy-method specified?\n-\t\tString destroyMethodName = bean.destroyMethod();\n-\t\tif (hasText(destroyMethodName))\n-\t\t\tbeanDef.setDestroyMethodName(destroyMethodName);\n-\n-\t\t// is this method annotated with @Scope(scopedProxy=...)?\n-\t\tif (scope != null && scope.proxyMode() != ScopedProxyMode.NO) {\n-\t\t\tRootBeanDefinition targetDef = beanDef;\n-\n-\t\t\t// Create a scoped proxy definition for the original bean name,\n-\t\t\t// \"hiding\" the target bean in an internal target definition.\n-\t\t\tString targetBeanName = resolveHiddenScopedProxyBeanName(beanName);\n-\t\t\tRootBeanDefinition scopedProxyDefinition = new RootBeanDefinition(ScopedProxyFactoryBean.class);\n-\t\t\tscopedProxyDefinition.getPropertyValues().addPropertyValue(\"targetBeanName\", targetBeanName);\n-\n-\t\t\tif (scope.proxyMode() == ScopedProxyMode.TARGET_CLASS)\n-\t\t\t\ttargetDef.setAttribute(AutoProxyUtils.PRESERVE_TARGET_CLASS_ATTRIBUTE, Boolean.TRUE);\n-\t\t\t// ScopedFactoryBean's \"proxyTargetClass\" default is TRUE, so we\n-\t\t\t// don't need to set it explicitly here.\n-\t\t\telse\n-\t\t\t\tscopedProxyDefinition.getPropertyValues().addPropertyValue(\"proxyTargetClass\", Boolean.FALSE);\n-\n-\t\t\t// The target bean should be ignored in favor of the scoped proxy.\n-\t\t\ttargetDef.setAutowireCandidate(false);\n-\n-\t\t\t// Register the target bean as separate bean in the factory\n-\t\t\tregistry.registerBeanDefinition(targetBeanName, targetDef);\n-\n-\t\t\t// replace the original bean definition with the target one\n-\t\t\tbeanDef = scopedProxyDefinition;\n \t\t}\n \n-\t\tif (bean.dependsOn().length > 0)\n-\t\t\tbeanDef.setDependsOn(bean.dependsOn());\n+\t\t// is this bean to be instantiated lazily?\n+\t\tLazy lazy = method.getAnnotation(Lazy.class);\n+\t\tif (lazy != null) {\n+\t\t\tbeanDef.setLazyInit(lazy.value());\n+\t\t}\n+\t\telse {\n+\t\t\tLazy defaultLazy = configClass.getAnnotation(Lazy.class);\n+\t\t\tif (defaultLazy != null) {\n+\t\t\t\tbeanDef.setLazyInit(defaultLazy.value());\n+\t\t\t}\n+\t\t}\n \n-\t\tlog.info(format(\"Registering bean definition for @Bean method %s.%s()\",\n-\t\t\tconfigClass.getName(), beanName));\n+\t\tDependsOn dependsOn = method.getAnnotation(DependsOn.class);\n+\t\tif (dependsOn != null && dependsOn.value().length > 0) {\n+\t\t\tbeanDef.setDependsOn(dependsOn.value());\n+\t\t}\n \n-\t\tregistry.registerBeanDefinition(beanName, beanDef);\n+\t\tAutowire autowire = bean.autowire();\n+\t\tif (autowire.isAutowire()) {\n+\t\t\tbeanDef.setAutowireMode(autowire.value());\n+\t\t}\n \n+\t\tString initMethodName = bean.initMethod();\n+\t\tif (StringUtils.hasText(initMethodName)) {\n+\t\t\tbeanDef.setInitMethodName(initMethodName);\n+\t\t}\n+\n+\t\tString destroyMethodName = bean.destroyMethod();\n+\t\tif (StringUtils.hasText(destroyMethodName)) {\n+\t\t\tbeanDef.setDestroyMethodName(destroyMethodName);\n+\t\t}\n+\n+\t\t// consider scoping\n+\t\tScope scope = method.getAnnotation(Scope.class);\n+\t\tScopedProxyMode proxyMode = ScopedProxyMode.NO;\n+\t\tif (scope != null) {\n+\t\t\tbeanDef.setScope(scope.value());\n+\t\t\tproxyMode = scope.proxyMode();\n+\t\t\tif (proxyMode == ScopedProxyMode.DEFAULT) {\n+\t\t\t\tproxyMode = ScopedProxyMode.NO;\n+\t\t\t}\n+\t\t}\n+\n+\t\t// replace the original bean definition with the target one, if necessary\n+\t\tBeanDefinition beanDefToRegister = beanDef;\n+\t\tif (proxyMode != ScopedProxyMode.NO) {\n+\t\t\tBeanDefinitionHolder proxyDef = ScopedProxyUtils.createScopedProxy(\n+\t\t\t\t\tnew BeanDefinitionHolder(beanDef, beanName), registry, proxyMode == ScopedProxyMode.TARGET_CLASS);\n+\t\t\tbeanDefToRegister = proxyDef.getBeanDefinition();\n+\t\t}\n+\n+\t\tif (logger.isDebugEnabled()) {\n+\t\t\tlogger.debug(String.format(\"Registering bean definition for @Bean method %s.%s()\", configClass.getName(), beanName));\n+\t\t}\n+\n+\t\tregistry.registerBeanDefinition(beanName, beanDefToRegister);\n \t}\n\\ No newline at end of file\n",
					"extendedDetails": {
						"oldPath": "org.springframework.context/src/main/java/org/springframework/context/annotation/ConfigurationModelBeanDefinitionReader.java",
						"newPath": "org.springframework.context/src/main/java/org/springframework/context/annotation/ConfigurationClassBeanDefinitionReader.java",
						"oldMethodName": "loadBeanDefinitionsForModelMethod",
						"newMethodName": "loadBeanDefinitionsForModelMethod"
					}
				},
				{
					"type": "Ybodychange",
					"commitMessage": "revised support for annotated factory methods (merged @FactoryMethod functionality into JavaConfig facility)\n",
					"commitDate": "2009-04-19, 4:45 PM",
					"commitName": "14bd47551900ced88eeacf2a5f63c187ff72028c",
					"commitAuthor": "Juergen Hoeller",
					"commitDateOld": "2009-04-19, 3:28 PM",
					"commitNameOld": "736169aa2a46f489cd8e75cf4d61cef997fc456f",
					"commitAuthorOld": "Juergen Hoeller",
					"daysBetweenCommits": 0.05,
					"commitsBetweenForRepo": 1,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,93 +1,91 @@\n-\tprivate void loadBeanDefinitionsForModelMethod(BeanMethod method) {\n+\tprivate void loadBeanDefinitionsForModelMethod(ConfigurationClassMethod method) {\n \t\tRootBeanDefinition beanDef = new ConfigurationClassBeanDefinition();\n-\n \t\tConfigurationClass configClass = method.getDeclaringClass();\n-\n \t\tbeanDef.setFactoryBeanName(configClass.getBeanName());\n \t\tbeanDef.setFactoryMethodName(method.getName());\n-\n-\t\tBean bean = method.getRequiredAnnotation(Bean.class);\n-\n-\t\t// consider scoping\n-\t\tScope scope = method.getAnnotation(Scope.class);\n-\t\tif(scope != null)\n-\t\t\tbeanDef.setScope(scope.value());\n+\t\tbeanDef.setAutowireMode(RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n \n \t\t// consider name and any aliases\n-\t\tArrayList<String> names = new ArrayList<String>(Arrays.asList(bean.name()));\n+\t\tBean bean = method.getRequiredAnnotation(Bean.class);\n+\t\tList<String> names = new ArrayList<String>(Arrays.asList(bean.name()));\n \t\tString beanName = (names.size() > 0) ? names.remove(0) : method.getName();\n-\t\tfor (String alias : bean.name())\n+\t\tfor (String alias : bean.name()) {\n \t\t\tregistry.registerAlias(beanName, alias);\n+\t\t}\n \n \t\t// has this already been overriden (i.e.: via XML)?\n-\t\tif (containsBeanDefinitionIncludingAncestry(beanName, registry)) {\n-\t\t\tBeanDefinition existingBeanDef = getBeanDefinitionIncludingAncestry(beanName, registry);\n-\n+\t\tif (registry.containsBeanDefinition(beanName)) {\n+\t\t\tBeanDefinition existingBeanDef = registry.getBeanDefinition(beanName);\n \t\t\t// is the existing bean definition one that was created by JavaConfig?\n \t\t\tif (!(existingBeanDef instanceof ConfigurationClassBeanDefinition)) {\n \t\t\t\t// no -> then it's an external override, probably XML\n-\n \t\t\t\t// overriding is legal, return immediately\n-\t\t\t\tlog.info(format(\"Skipping loading bean definition for %s: a definition for bean \"\n-\t\t\t\t\t+ \"'%s' already exists. This is likely due to an override in XML.\", method, beanName));\n+\t\t\t\tif (logger.isDebugEnabled()) {\n+\t\t\t\t\tlogger.debug(String.format(\"Skipping loading bean definition for %s: a definition for bean \" +\n+\t\t\t\t\t\t\t\"'%s' already exists. This is likely due to an override in XML.\", method, beanName));\n+\t\t\t\t}\n \t\t\t\treturn;\n \t\t\t}\n \t\t}\n \n-\t\tif (method.getAnnotation(Primary.class) != null)\n+\t\tif (method.getAnnotation(Primary.class) != null) {\n \t\t\tbeanDef.setPrimary(true);\n-\n-\t\t// is this bean to be instantiated lazily?\n-\t\tLazy defaultLazy = configClass.getAnnotation(Lazy.class);\n-\t\tif (defaultLazy != null)\n-\t\t\tbeanDef.setLazyInit(defaultLazy.value());\n-\t\tLazy lazy = method.getAnnotation(Lazy.class);\n-\t\tif (lazy != null)\n-\t\t\tbeanDef.setLazyInit(lazy.value());\n-\n-\t\t// does this bean have a custom init-method specified?\n-\t\tString initMethodName = bean.initMethod();\n-\t\tif (hasText(initMethodName))\n-\t\t\tbeanDef.setInitMethodName(initMethodName);\n-\n-\t\t// does this bean have a custom destroy-method specified?\n-\t\tString destroyMethodName = bean.destroyMethod();\n-\t\tif (hasText(destroyMethodName))\n-\t\t\tbeanDef.setDestroyMethodName(destroyMethodName);\n-\n-\t\t// is this method annotated with @Scope(scopedProxy=...)?\n-\t\tif (scope != null && scope.proxyMode() != ScopedProxyMode.NO) {\n-\t\t\tRootBeanDefinition targetDef = beanDef;\n-\n-\t\t\t// Create a scoped proxy definition for the original bean name,\n-\t\t\t// \"hiding\" the target bean in an internal target definition.\n-\t\t\tString targetBeanName = resolveHiddenScopedProxyBeanName(beanName);\n-\t\t\tRootBeanDefinition scopedProxyDefinition = new RootBeanDefinition(ScopedProxyFactoryBean.class);\n-\t\t\tscopedProxyDefinition.getPropertyValues().addPropertyValue(\"targetBeanName\", targetBeanName);\n-\n-\t\t\tif (scope.proxyMode() == ScopedProxyMode.TARGET_CLASS)\n-\t\t\t\ttargetDef.setAttribute(AutoProxyUtils.PRESERVE_TARGET_CLASS_ATTRIBUTE, Boolean.TRUE);\n-\t\t\t// ScopedFactoryBean's \"proxyTargetClass\" default is TRUE, so we\n-\t\t\t// don't need to set it explicitly here.\n-\t\t\telse\n-\t\t\t\tscopedProxyDefinition.getPropertyValues().addPropertyValue(\"proxyTargetClass\", Boolean.FALSE);\n-\n-\t\t\t// The target bean should be ignored in favor of the scoped proxy.\n-\t\t\ttargetDef.setAutowireCandidate(false);\n-\n-\t\t\t// Register the target bean as separate bean in the factory\n-\t\t\tregistry.registerBeanDefinition(targetBeanName, targetDef);\n-\n-\t\t\t// replace the original bean definition with the target one\n-\t\t\tbeanDef = scopedProxyDefinition;\n \t\t}\n \n-\t\tif (bean.dependsOn().length > 0)\n-\t\t\tbeanDef.setDependsOn(bean.dependsOn());\n+\t\t// is this bean to be instantiated lazily?\n+\t\tLazy lazy = method.getAnnotation(Lazy.class);\n+\t\tif (lazy != null) {\n+\t\t\tbeanDef.setLazyInit(lazy.value());\n+\t\t}\n+\t\telse {\n+\t\t\tLazy defaultLazy = configClass.getAnnotation(Lazy.class);\n+\t\t\tif (defaultLazy != null) {\n+\t\t\t\tbeanDef.setLazyInit(defaultLazy.value());\n+\t\t\t}\n+\t\t}\n \n-\t\tlog.info(format(\"Registering bean definition for @Bean method %s.%s()\",\n-\t\t\tconfigClass.getName(), beanName));\n+\t\tDependsOn dependsOn = method.getAnnotation(DependsOn.class);\n+\t\tif (dependsOn != null && dependsOn.value().length > 0) {\n+\t\t\tbeanDef.setDependsOn(dependsOn.value());\n+\t\t}\n \n-\t\tregistry.registerBeanDefinition(beanName, beanDef);\n+\t\tAutowire autowire = bean.autowire();\n+\t\tif (autowire.isAutowire()) {\n+\t\t\tbeanDef.setAutowireMode(autowire.value());\n+\t\t}\n \n+\t\tString initMethodName = bean.initMethod();\n+\t\tif (StringUtils.hasText(initMethodName)) {\n+\t\t\tbeanDef.setInitMethodName(initMethodName);\n+\t\t}\n+\n+\t\tString destroyMethodName = bean.destroyMethod();\n+\t\tif (StringUtils.hasText(destroyMethodName)) {\n+\t\t\tbeanDef.setDestroyMethodName(destroyMethodName);\n+\t\t}\n+\n+\t\t// consider scoping\n+\t\tScope scope = method.getAnnotation(Scope.class);\n+\t\tScopedProxyMode proxyMode = ScopedProxyMode.NO;\n+\t\tif (scope != null) {\n+\t\t\tbeanDef.setScope(scope.value());\n+\t\t\tproxyMode = scope.proxyMode();\n+\t\t\tif (proxyMode == ScopedProxyMode.DEFAULT) {\n+\t\t\t\tproxyMode = ScopedProxyMode.NO;\n+\t\t\t}\n+\t\t}\n+\n+\t\t// replace the original bean definition with the target one, if necessary\n+\t\tBeanDefinition beanDefToRegister = beanDef;\n+\t\tif (proxyMode != ScopedProxyMode.NO) {\n+\t\t\tBeanDefinitionHolder proxyDef = ScopedProxyUtils.createScopedProxy(\n+\t\t\t\t\tnew BeanDefinitionHolder(beanDef, beanName), registry, proxyMode == ScopedProxyMode.TARGET_CLASS);\n+\t\t\tbeanDefToRegister = proxyDef.getBeanDefinition();\n+\t\t}\n+\n+\t\tif (logger.isDebugEnabled()) {\n+\t\t\tlogger.debug(String.format(\"Registering bean definition for @Bean method %s.%s()\", configClass.getName(), beanName));\n+\t\t}\n+\n+\t\tregistry.registerBeanDefinition(beanName, beanDefToRegister);\n \t}\n\\ No newline at end of file\n",
					"extendedDetails": {}
				},
				{
					"type": "Yparameterchange",
					"commitMessage": "revised support for annotated factory methods (merged @FactoryMethod functionality into JavaConfig facility)\n",
					"commitDate": "2009-04-19, 4:45 PM",
					"commitName": "14bd47551900ced88eeacf2a5f63c187ff72028c",
					"commitAuthor": "Juergen Hoeller",
					"commitDateOld": "2009-04-19, 3:28 PM",
					"commitNameOld": "736169aa2a46f489cd8e75cf4d61cef997fc456f",
					"commitAuthorOld": "Juergen Hoeller",
					"daysBetweenCommits": 0.05,
					"commitsBetweenForRepo": 1,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,93 +1,91 @@\n-\tprivate void loadBeanDefinitionsForModelMethod(BeanMethod method) {\n+\tprivate void loadBeanDefinitionsForModelMethod(ConfigurationClassMethod method) {\n \t\tRootBeanDefinition beanDef = new ConfigurationClassBeanDefinition();\n-\n \t\tConfigurationClass configClass = method.getDeclaringClass();\n-\n \t\tbeanDef.setFactoryBeanName(configClass.getBeanName());\n \t\tbeanDef.setFactoryMethodName(method.getName());\n-\n-\t\tBean bean = method.getRequiredAnnotation(Bean.class);\n-\n-\t\t// consider scoping\n-\t\tScope scope = method.getAnnotation(Scope.class);\n-\t\tif(scope != null)\n-\t\t\tbeanDef.setScope(scope.value());\n+\t\tbeanDef.setAutowireMode(RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n \n \t\t// consider name and any aliases\n-\t\tArrayList<String> names = new ArrayList<String>(Arrays.asList(bean.name()));\n+\t\tBean bean = method.getRequiredAnnotation(Bean.class);\n+\t\tList<String> names = new ArrayList<String>(Arrays.asList(bean.name()));\n \t\tString beanName = (names.size() > 0) ? names.remove(0) : method.getName();\n-\t\tfor (String alias : bean.name())\n+\t\tfor (String alias : bean.name()) {\n \t\t\tregistry.registerAlias(beanName, alias);\n+\t\t}\n \n \t\t// has this already been overriden (i.e.: via XML)?\n-\t\tif (containsBeanDefinitionIncludingAncestry(beanName, registry)) {\n-\t\t\tBeanDefinition existingBeanDef = getBeanDefinitionIncludingAncestry(beanName, registry);\n-\n+\t\tif (registry.containsBeanDefinition(beanName)) {\n+\t\t\tBeanDefinition existingBeanDef = registry.getBeanDefinition(beanName);\n \t\t\t// is the existing bean definition one that was created by JavaConfig?\n \t\t\tif (!(existingBeanDef instanceof ConfigurationClassBeanDefinition)) {\n \t\t\t\t// no -> then it's an external override, probably XML\n-\n \t\t\t\t// overriding is legal, return immediately\n-\t\t\t\tlog.info(format(\"Skipping loading bean definition for %s: a definition for bean \"\n-\t\t\t\t\t+ \"'%s' already exists. This is likely due to an override in XML.\", method, beanName));\n+\t\t\t\tif (logger.isDebugEnabled()) {\n+\t\t\t\t\tlogger.debug(String.format(\"Skipping loading bean definition for %s: a definition for bean \" +\n+\t\t\t\t\t\t\t\"'%s' already exists. This is likely due to an override in XML.\", method, beanName));\n+\t\t\t\t}\n \t\t\t\treturn;\n \t\t\t}\n \t\t}\n \n-\t\tif (method.getAnnotation(Primary.class) != null)\n+\t\tif (method.getAnnotation(Primary.class) != null) {\n \t\t\tbeanDef.setPrimary(true);\n-\n-\t\t// is this bean to be instantiated lazily?\n-\t\tLazy defaultLazy = configClass.getAnnotation(Lazy.class);\n-\t\tif (defaultLazy != null)\n-\t\t\tbeanDef.setLazyInit(defaultLazy.value());\n-\t\tLazy lazy = method.getAnnotation(Lazy.class);\n-\t\tif (lazy != null)\n-\t\t\tbeanDef.setLazyInit(lazy.value());\n-\n-\t\t// does this bean have a custom init-method specified?\n-\t\tString initMethodName = bean.initMethod();\n-\t\tif (hasText(initMethodName))\n-\t\t\tbeanDef.setInitMethodName(initMethodName);\n-\n-\t\t// does this bean have a custom destroy-method specified?\n-\t\tString destroyMethodName = bean.destroyMethod();\n-\t\tif (hasText(destroyMethodName))\n-\t\t\tbeanDef.setDestroyMethodName(destroyMethodName);\n-\n-\t\t// is this method annotated with @Scope(scopedProxy=...)?\n-\t\tif (scope != null && scope.proxyMode() != ScopedProxyMode.NO) {\n-\t\t\tRootBeanDefinition targetDef = beanDef;\n-\n-\t\t\t// Create a scoped proxy definition for the original bean name,\n-\t\t\t// \"hiding\" the target bean in an internal target definition.\n-\t\t\tString targetBeanName = resolveHiddenScopedProxyBeanName(beanName);\n-\t\t\tRootBeanDefinition scopedProxyDefinition = new RootBeanDefinition(ScopedProxyFactoryBean.class);\n-\t\t\tscopedProxyDefinition.getPropertyValues().addPropertyValue(\"targetBeanName\", targetBeanName);\n-\n-\t\t\tif (scope.proxyMode() == ScopedProxyMode.TARGET_CLASS)\n-\t\t\t\ttargetDef.setAttribute(AutoProxyUtils.PRESERVE_TARGET_CLASS_ATTRIBUTE, Boolean.TRUE);\n-\t\t\t// ScopedFactoryBean's \"proxyTargetClass\" default is TRUE, so we\n-\t\t\t// don't need to set it explicitly here.\n-\t\t\telse\n-\t\t\t\tscopedProxyDefinition.getPropertyValues().addPropertyValue(\"proxyTargetClass\", Boolean.FALSE);\n-\n-\t\t\t// The target bean should be ignored in favor of the scoped proxy.\n-\t\t\ttargetDef.setAutowireCandidate(false);\n-\n-\t\t\t// Register the target bean as separate bean in the factory\n-\t\t\tregistry.registerBeanDefinition(targetBeanName, targetDef);\n-\n-\t\t\t// replace the original bean definition with the target one\n-\t\t\tbeanDef = scopedProxyDefinition;\n \t\t}\n \n-\t\tif (bean.dependsOn().length > 0)\n-\t\t\tbeanDef.setDependsOn(bean.dependsOn());\n+\t\t// is this bean to be instantiated lazily?\n+\t\tLazy lazy = method.getAnnotation(Lazy.class);\n+\t\tif (lazy != null) {\n+\t\t\tbeanDef.setLazyInit(lazy.value());\n+\t\t}\n+\t\telse {\n+\t\t\tLazy defaultLazy = configClass.getAnnotation(Lazy.class);\n+\t\t\tif (defaultLazy != null) {\n+\t\t\t\tbeanDef.setLazyInit(defaultLazy.value());\n+\t\t\t}\n+\t\t}\n \n-\t\tlog.info(format(\"Registering bean definition for @Bean method %s.%s()\",\n-\t\t\tconfigClass.getName(), beanName));\n+\t\tDependsOn dependsOn = method.getAnnotation(DependsOn.class);\n+\t\tif (dependsOn != null && dependsOn.value().length > 0) {\n+\t\t\tbeanDef.setDependsOn(dependsOn.value());\n+\t\t}\n \n-\t\tregistry.registerBeanDefinition(beanName, beanDef);\n+\t\tAutowire autowire = bean.autowire();\n+\t\tif (autowire.isAutowire()) {\n+\t\t\tbeanDef.setAutowireMode(autowire.value());\n+\t\t}\n \n+\t\tString initMethodName = bean.initMethod();\n+\t\tif (StringUtils.hasText(initMethodName)) {\n+\t\t\tbeanDef.setInitMethodName(initMethodName);\n+\t\t}\n+\n+\t\tString destroyMethodName = bean.destroyMethod();\n+\t\tif (StringUtils.hasText(destroyMethodName)) {\n+\t\t\tbeanDef.setDestroyMethodName(destroyMethodName);\n+\t\t}\n+\n+\t\t// consider scoping\n+\t\tScope scope = method.getAnnotation(Scope.class);\n+\t\tScopedProxyMode proxyMode = ScopedProxyMode.NO;\n+\t\tif (scope != null) {\n+\t\t\tbeanDef.setScope(scope.value());\n+\t\t\tproxyMode = scope.proxyMode();\n+\t\t\tif (proxyMode == ScopedProxyMode.DEFAULT) {\n+\t\t\t\tproxyMode = ScopedProxyMode.NO;\n+\t\t\t}\n+\t\t}\n+\n+\t\t// replace the original bean definition with the target one, if necessary\n+\t\tBeanDefinition beanDefToRegister = beanDef;\n+\t\tif (proxyMode != ScopedProxyMode.NO) {\n+\t\t\tBeanDefinitionHolder proxyDef = ScopedProxyUtils.createScopedProxy(\n+\t\t\t\t\tnew BeanDefinitionHolder(beanDef, beanName), registry, proxyMode == ScopedProxyMode.TARGET_CLASS);\n+\t\t\tbeanDefToRegister = proxyDef.getBeanDefinition();\n+\t\t}\n+\n+\t\tif (logger.isDebugEnabled()) {\n+\t\t\tlogger.debug(String.format(\"Registering bean definition for @Bean method %s.%s()\", configClass.getName(), beanName));\n+\t\t}\n+\n+\t\tregistry.registerBeanDefinition(beanName, beanDefToRegister);\n \t}\n\\ No newline at end of file\n",
					"extendedDetails": {
						"oldValue": "[method-BeanMethod]",
						"newValue": "[method-ConfigurationClassMethod]"
					}
				}
			]
		},
		"69a762e86ac075035bfcdc899aadf2b36abaf167": {
			"type": "Ybodychange",
			"commitMessage": "resolved:\n+ Provide @Primary annotation (SPR-5590)\n+ Provide @Lazy annotation (SPR-5591)\n+ Test @Bean initMethod/destroyMethod functionality (SPR-5592)\n+ Test @Bean dependsOn functionality (SPR-5593)\n\n",
			"commitDate": "2009-03-28, 3:21 PM",
			"commitName": "69a762e86ac075035bfcdc899aadf2b36abaf167",
			"commitAuthor": "Chris Beams",
			"commitDateOld": "2009-03-26, 9:57 PM",
			"commitNameOld": "1697932c57af5389fe07971e91866980e966403f",
			"commitAuthorOld": "Chris Beams",
			"daysBetweenCommits": 1.73,
			"commitsBetweenForRepo": 24,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,92 +1,93 @@\n \tprivate void loadBeanDefinitionsForModelMethod(BeanMethod method) {\n \t\tRootBeanDefinition beanDef = new ConfigurationClassBeanDefinition();\n \n \t\tConfigurationClass configClass = method.getDeclaringClass();\n \n \t\tbeanDef.setFactoryBeanName(configClass.getBeanName());\n \t\tbeanDef.setFactoryMethodName(method.getName());\n \n \t\tBean bean = method.getRequiredAnnotation(Bean.class);\n \n \t\t// consider scoping\n \t\tScope scope = method.getAnnotation(Scope.class);\n \t\tif(scope != null)\n \t\t\tbeanDef.setScope(scope.value());\n \n \t\t// consider name and any aliases\n \t\tArrayList<String> names = new ArrayList<String>(Arrays.asList(bean.name()));\n \t\tString beanName = (names.size() > 0) ? names.remove(0) : method.getName();\n \t\tfor (String alias : bean.name())\n \t\t\tregistry.registerAlias(beanName, alias);\n \n \t\t// has this already been overriden (i.e.: via XML)?\n \t\tif (containsBeanDefinitionIncludingAncestry(beanName, registry)) {\n \t\t\tBeanDefinition existingBeanDef = getBeanDefinitionIncludingAncestry(beanName, registry);\n \n \t\t\t// is the existing bean definition one that was created by JavaConfig?\n \t\t\tif (!(existingBeanDef instanceof ConfigurationClassBeanDefinition)) {\n \t\t\t\t// no -> then it's an external override, probably XML\n \n \t\t\t\t// overriding is legal, return immediately\n \t\t\t\tlog.info(format(\"Skipping loading bean definition for %s: a definition for bean \"\n \t\t\t\t\t+ \"'%s' already exists. This is likely due to an override in XML.\", method, beanName));\n \t\t\t\treturn;\n \t\t\t}\n \t\t}\n \n-\t\t// TODO: re-enable for Lazy support\n-\t\t// // is this bean marked as primary for disambiguation?\n-\t\t// if (bean.primary() == Primary.TRUE)\n-\t\t// beanDef.setPrimary(true);\n-\t\t//\n-\t\t// // is this bean lazily instantiated?\n-\t\t// if ((bean.lazy() == Lazy.TRUE)\n-\t\t// || ((bean.lazy() == Lazy.UNSPECIFIED) && (defaults.defaultLazy() == Lazy.TRUE)))\n-\t\t// beanDef.setLazyInit(true);\n+\t\tif (method.getAnnotation(Primary.class) != null)\n+\t\t\tbeanDef.setPrimary(true);\n+\n+\t\t// is this bean to be instantiated lazily?\n+\t\tLazy defaultLazy = configClass.getAnnotation(Lazy.class);\n+\t\tif (defaultLazy != null)\n+\t\t\tbeanDef.setLazyInit(defaultLazy.value());\n+\t\tLazy lazy = method.getAnnotation(Lazy.class);\n+\t\tif (lazy != null)\n+\t\t\tbeanDef.setLazyInit(lazy.value());\n \n \t\t// does this bean have a custom init-method specified?\n \t\tString initMethodName = bean.initMethod();\n \t\tif (hasText(initMethodName))\n \t\t\tbeanDef.setInitMethodName(initMethodName);\n \n \t\t// does this bean have a custom destroy-method specified?\n \t\tString destroyMethodName = bean.destroyMethod();\n \t\tif (hasText(destroyMethodName))\n \t\t\tbeanDef.setDestroyMethodName(destroyMethodName);\n \n \t\t// is this method annotated with @Scope(scopedProxy=...)?\n \t\tif (scope != null && scope.proxyMode() != ScopedProxyMode.NO) {\n \t\t\tRootBeanDefinition targetDef = beanDef;\n \n \t\t\t// Create a scoped proxy definition for the original bean name,\n \t\t\t// \"hiding\" the target bean in an internal target definition.\n \t\t\tString targetBeanName = resolveHiddenScopedProxyBeanName(beanName);\n \t\t\tRootBeanDefinition scopedProxyDefinition = new RootBeanDefinition(ScopedProxyFactoryBean.class);\n \t\t\tscopedProxyDefinition.getPropertyValues().addPropertyValue(\"targetBeanName\", targetBeanName);\n \n \t\t\tif (scope.proxyMode() == ScopedProxyMode.TARGET_CLASS)\n \t\t\t\ttargetDef.setAttribute(AutoProxyUtils.PRESERVE_TARGET_CLASS_ATTRIBUTE, Boolean.TRUE);\n \t\t\t// ScopedFactoryBean's \"proxyTargetClass\" default is TRUE, so we\n \t\t\t// don't need to set it explicitly here.\n \t\t\telse\n \t\t\t\tscopedProxyDefinition.getPropertyValues().addPropertyValue(\"proxyTargetClass\", Boolean.FALSE);\n \n \t\t\t// The target bean should be ignored in favor of the scoped proxy.\n \t\t\ttargetDef.setAutowireCandidate(false);\n \n \t\t\t// Register the target bean as separate bean in the factory\n \t\t\tregistry.registerBeanDefinition(targetBeanName, targetDef);\n \n \t\t\t// replace the original bean definition with the target one\n \t\t\tbeanDef = scopedProxyDefinition;\n \t\t}\n \n \t\tif (bean.dependsOn().length > 0)\n \t\t\tbeanDef.setDependsOn(bean.dependsOn());\n \n \t\tlog.info(format(\"Registering bean definition for @Bean method %s.%s()\",\n \t\t\tconfigClass.getName(), beanName));\n \n \t\tregistry.registerBeanDefinition(beanName, beanDef);\n \n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"1697932c57af5389fe07971e91866980e966403f": {
			"type": "Yfilerename",
			"commitMessage": "consolidated context.annotation.support -> context.annotation\n\n",
			"commitDate": "2009-03-26, 9:57 PM",
			"commitName": "1697932c57af5389fe07971e91866980e966403f",
			"commitAuthor": "Chris Beams",
			"commitDateOld": "2009-03-26, 8:10 PM",
			"commitNameOld": "2c0c523d7099ed1ad77864242f25d30e218b2a95",
			"commitAuthorOld": "Chris Beams",
			"daysBetweenCommits": 0.07,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "",
			"extendedDetails": {
				"oldPath": "org.springframework.context/src/main/java/org/springframework/context/annotation/support/ConfigurationModelBeanDefinitionReader.java",
				"newPath": "org.springframework.context/src/main/java/org/springframework/context/annotation/ConfigurationModelBeanDefinitionReader.java"
			}
		},
		"7f96f57375d3b33d08bf3be6d5206066f3142cfe": {
			"type": "Ybodychange",
			"commitMessage": "polishing\n",
			"commitDate": "2009-03-22, 11:23 PM",
			"commitName": "7f96f57375d3b33d08bf3be6d5206066f3142cfe",
			"commitAuthor": "Chris Beams",
			"commitDateOld": "2009-03-22, 9:48 PM",
			"commitNameOld": "cd50e456457ecac48f61e2da991b6fd5dc0c6ee7",
			"commitAuthorOld": "Chris Beams",
			"daysBetweenCommits": 0.07,
			"commitsBetweenForRepo": 3,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,95 +1,92 @@\n \tprivate void loadBeanDefinitionsForModelMethod(BeanMethod method) {\n \t\tRootBeanDefinition beanDef = new ConfigurationClassBeanDefinition();\n \n \t\tConfigurationClass configClass = method.getDeclaringClass();\n \n \t\tbeanDef.setFactoryBeanName(configClass.getBeanName());\n \t\tbeanDef.setFactoryMethodName(method.getName());\n \n \t\tBean bean = method.getRequiredAnnotation(Bean.class);\n \n-\t\t// TODO: prune defaults\n-\t\t//Configuration defaults = configClass.getMetadata();\n-\n \t\t// consider scoping\n \t\tScope scope = method.getAnnotation(Scope.class);\n \t\tif(scope != null)\n \t\t\tbeanDef.setScope(scope.value());\n \n \t\t// consider name and any aliases\n \t\tArrayList<String> names = new ArrayList<String>(Arrays.asList(bean.name()));\n \t\tString beanName = (names.size() > 0) ? names.remove(0) : method.getName();\n \t\tfor (String alias : bean.name())\n \t\t\tregistry.registerAlias(beanName, alias);\n \n \t\t// has this already been overriden (i.e.: via XML)?\n \t\tif (containsBeanDefinitionIncludingAncestry(beanName, registry)) {\n \t\t\tBeanDefinition existingBeanDef = getBeanDefinitionIncludingAncestry(beanName, registry);\n \n \t\t\t// is the existing bean definition one that was created by JavaConfig?\n \t\t\tif (!(existingBeanDef instanceof ConfigurationClassBeanDefinition)) {\n \t\t\t\t// no -> then it's an external override, probably XML\n \n \t\t\t\t// overriding is legal, return immediately\n \t\t\t\tlog.info(format(\"Skipping loading bean definition for %s: a definition for bean \"\n \t\t\t\t\t+ \"'%s' already exists. This is likely due to an override in XML.\", method, beanName));\n \t\t\t\treturn;\n \t\t\t}\n \t\t}\n \n \t\t// TODO: re-enable for Lazy support\n \t\t// // is this bean marked as primary for disambiguation?\n \t\t// if (bean.primary() == Primary.TRUE)\n \t\t// beanDef.setPrimary(true);\n \t\t//\n \t\t// // is this bean lazily instantiated?\n \t\t// if ((bean.lazy() == Lazy.TRUE)\n \t\t// || ((bean.lazy() == Lazy.UNSPECIFIED) && (defaults.defaultLazy() == Lazy.TRUE)))\n \t\t// beanDef.setLazyInit(true);\n \n \t\t// does this bean have a custom init-method specified?\n \t\tString initMethodName = bean.initMethod();\n \t\tif (hasText(initMethodName))\n \t\t\tbeanDef.setInitMethodName(initMethodName);\n \n \t\t// does this bean have a custom destroy-method specified?\n \t\tString destroyMethodName = bean.destroyMethod();\n \t\tif (hasText(destroyMethodName))\n \t\t\tbeanDef.setDestroyMethodName(destroyMethodName);\n \n \t\t// is this method annotated with @Scope(scopedProxy=...)?\n \t\tif (scope != null && scope.proxyMode() != ScopedProxyMode.NO) {\n \t\t\tRootBeanDefinition targetDef = beanDef;\n \n \t\t\t// Create a scoped proxy definition for the original bean name,\n \t\t\t// \"hiding\" the target bean in an internal target definition.\n \t\t\tString targetBeanName = resolveHiddenScopedProxyBeanName(beanName);\n \t\t\tRootBeanDefinition scopedProxyDefinition = new RootBeanDefinition(ScopedProxyFactoryBean.class);\n \t\t\tscopedProxyDefinition.getPropertyValues().addPropertyValue(\"targetBeanName\", targetBeanName);\n \n \t\t\tif (scope.proxyMode() == ScopedProxyMode.TARGET_CLASS)\n \t\t\t\ttargetDef.setAttribute(AutoProxyUtils.PRESERVE_TARGET_CLASS_ATTRIBUTE, Boolean.TRUE);\n \t\t\t// ScopedFactoryBean's \"proxyTargetClass\" default is TRUE, so we\n \t\t\t// don't need to set it explicitly here.\n \t\t\telse\n \t\t\t\tscopedProxyDefinition.getPropertyValues().addPropertyValue(\"proxyTargetClass\", Boolean.FALSE);\n \n \t\t\t// The target bean should be ignored in favor of the scoped proxy.\n \t\t\ttargetDef.setAutowireCandidate(false);\n \n \t\t\t// Register the target bean as separate bean in the factory\n \t\t\tregistry.registerBeanDefinition(targetBeanName, targetDef);\n \n \t\t\t// replace the original bean definition with the target one\n \t\t\tbeanDef = scopedProxyDefinition;\n \t\t}\n \n \t\tif (bean.dependsOn().length > 0)\n \t\t\tbeanDef.setDependsOn(bean.dependsOn());\n \n \t\tlog.info(format(\"Registering bean definition for @Bean method %s.%s()\",\n \t\t\tconfigClass.getName(), beanName));\n \n \t\tregistry.registerBeanDefinition(beanName, beanDef);\n \n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"cd50e456457ecac48f61e2da991b6fd5dc0c6ee7": {
			"type": "Yfilerename",
			"commitMessage": "+ Moving .config.java module -> .context\n\n",
			"commitDate": "2009-03-22, 9:48 PM",
			"commitName": "cd50e456457ecac48f61e2da991b6fd5dc0c6ee7",
			"commitAuthor": "Chris Beams",
			"commitDateOld": "2009-03-22, 9:25 PM",
			"commitNameOld": "63b5c48461f69cc611f4378d52f46197998334db",
			"commitAuthorOld": "Chris Beams",
			"daysBetweenCommits": 0.02,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "",
			"extendedDetails": {
				"oldPath": "org.springframework.config.java/src/main/java/org/springframework/context/annotation/support/ConfigurationModelBeanDefinitionReader.java",
				"newPath": "org.springframework.context/src/main/java/org/springframework/context/annotation/support/ConfigurationModelBeanDefinitionReader.java"
			}
		},
		"ef02c61e581dcd1f3cf110608da72ed133777d62": {
			"type": "Yfilerename",
			"commitMessage": "+ Repackaged src and test from .config.java.* -> .context.annotation.*\n\n",
			"commitDate": "2009-03-22, 9:23 PM",
			"commitName": "ef02c61e581dcd1f3cf110608da72ed133777d62",
			"commitAuthor": "Chris Beams",
			"commitDateOld": "2009-03-22, 9:14 PM",
			"commitNameOld": "3f196517f99b7a7148e68531d1fa1b475ff81939",
			"commitAuthorOld": "Chris Beams",
			"daysBetweenCommits": 0.01,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "",
			"extendedDetails": {
				"oldPath": "org.springframework.config.java/src/main/java/org/springframework/config/java/support/ConfigurationModelBeanDefinitionReader.java",
				"newPath": "org.springframework.config.java/src/main/java/org/springframework/context/annotation/support/ConfigurationModelBeanDefinitionReader.java"
			}
		},
		"8a5c2a6a56e7b88b44af7111edb2bfc8b1781f48": {
			"type": "Ybodychange",
			"commitMessage": "+ Added tests for custom @Bean naming and aliasing\n+ Eliminated BeanDefinitionRegistrar and BeanRegistrar types\n+ Simplified ConfigurationEnhancer logic\n+ Updated JavaDoc for ConfigurationModel and related classes\n+ Updated JavaDoc for all ASM visitors\n\n",
			"commitDate": "2009-03-22, 3:39 PM",
			"commitName": "8a5c2a6a56e7b88b44af7111edb2bfc8b1781f48",
			"commitAuthor": "Chris Beams",
			"commitDateOld": "2009-03-21, 6:43 PM",
			"commitNameOld": "72fae2ea1930c5c0d004220895bf890abcfecde4",
			"commitAuthorOld": "Chris Beams",
			"daysBetweenCommits": 0.87,
			"commitsBetweenForRepo": 2,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,3 +1,95 @@\n \tprivate void loadBeanDefinitionsForModelMethod(BeanMethod method) {\n-\t\tnew BeanRegistrar().register(method, registry);\n+\t\tRootBeanDefinition beanDef = new ConfigurationClassBeanDefinition();\n+\n+\t\tConfigurationClass configClass = method.getDeclaringClass();\n+\n+\t\tbeanDef.setFactoryBeanName(configClass.getBeanName());\n+\t\tbeanDef.setFactoryMethodName(method.getName());\n+\n+\t\tBean bean = method.getRequiredAnnotation(Bean.class);\n+\n+\t\t// TODO: prune defaults\n+\t\t//Configuration defaults = configClass.getMetadata();\n+\n+\t\t// consider scoping\n+\t\tScope scope = method.getAnnotation(Scope.class);\n+\t\tif(scope != null)\n+\t\t\tbeanDef.setScope(scope.value());\n+\n+\t\t// consider name and any aliases\n+\t\tArrayList<String> names = new ArrayList<String>(Arrays.asList(bean.name()));\n+\t\tString beanName = (names.size() > 0) ? names.remove(0) : method.getName();\n+\t\tfor (String alias : bean.name())\n+\t\t\tregistry.registerAlias(beanName, alias);\n+\n+\t\t// has this already been overriden (i.e.: via XML)?\n+\t\tif (containsBeanDefinitionIncludingAncestry(beanName, registry)) {\n+\t\t\tBeanDefinition existingBeanDef = getBeanDefinitionIncludingAncestry(beanName, registry);\n+\n+\t\t\t// is the existing bean definition one that was created by JavaConfig?\n+\t\t\tif (!(existingBeanDef instanceof ConfigurationClassBeanDefinition)) {\n+\t\t\t\t// no -> then it's an external override, probably XML\n+\n+\t\t\t\t// overriding is legal, return immediately\n+\t\t\t\tlog.info(format(\"Skipping loading bean definition for %s: a definition for bean \"\n+\t\t\t\t\t+ \"'%s' already exists. This is likely due to an override in XML.\", method, beanName));\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t}\n+\n+\t\t// TODO: re-enable for Lazy support\n+\t\t// // is this bean marked as primary for disambiguation?\n+\t\t// if (bean.primary() == Primary.TRUE)\n+\t\t// beanDef.setPrimary(true);\n+\t\t//\n+\t\t// // is this bean lazily instantiated?\n+\t\t// if ((bean.lazy() == Lazy.TRUE)\n+\t\t// || ((bean.lazy() == Lazy.UNSPECIFIED) && (defaults.defaultLazy() == Lazy.TRUE)))\n+\t\t// beanDef.setLazyInit(true);\n+\n+\t\t// does this bean have a custom init-method specified?\n+\t\tString initMethodName = bean.initMethod();\n+\t\tif (hasText(initMethodName))\n+\t\t\tbeanDef.setInitMethodName(initMethodName);\n+\n+\t\t// does this bean have a custom destroy-method specified?\n+\t\tString destroyMethodName = bean.destroyMethod();\n+\t\tif (hasText(destroyMethodName))\n+\t\t\tbeanDef.setDestroyMethodName(destroyMethodName);\n+\n+\t\t// is this method annotated with @Scope(scopedProxy=...)?\n+\t\tif (scope != null && scope.proxyMode() != ScopedProxyMode.NO) {\n+\t\t\tRootBeanDefinition targetDef = beanDef;\n+\n+\t\t\t// Create a scoped proxy definition for the original bean name,\n+\t\t\t// \"hiding\" the target bean in an internal target definition.\n+\t\t\tString targetBeanName = resolveHiddenScopedProxyBeanName(beanName);\n+\t\t\tRootBeanDefinition scopedProxyDefinition = new RootBeanDefinition(ScopedProxyFactoryBean.class);\n+\t\t\tscopedProxyDefinition.getPropertyValues().addPropertyValue(\"targetBeanName\", targetBeanName);\n+\n+\t\t\tif (scope.proxyMode() == ScopedProxyMode.TARGET_CLASS)\n+\t\t\t\ttargetDef.setAttribute(AutoProxyUtils.PRESERVE_TARGET_CLASS_ATTRIBUTE, Boolean.TRUE);\n+\t\t\t// ScopedFactoryBean's \"proxyTargetClass\" default is TRUE, so we\n+\t\t\t// don't need to set it explicitly here.\n+\t\t\telse\n+\t\t\t\tscopedProxyDefinition.getPropertyValues().addPropertyValue(\"proxyTargetClass\", Boolean.FALSE);\n+\n+\t\t\t// The target bean should be ignored in favor of the scoped proxy.\n+\t\t\ttargetDef.setAutowireCandidate(false);\n+\n+\t\t\t// Register the target bean as separate bean in the factory\n+\t\t\tregistry.registerBeanDefinition(targetBeanName, targetDef);\n+\n+\t\t\t// replace the original bean definition with the target one\n+\t\t\tbeanDef = scopedProxyDefinition;\n+\t\t}\n+\n+\t\tif (bean.dependsOn().length > 0)\n+\t\t\tbeanDef.setDependsOn(bean.dependsOn());\n+\n+\t\tlog.info(format(\"Registering bean definition for @Bean method %s.%s()\",\n+\t\t\tconfigClass.getName(), beanName));\n+\n+\t\tregistry.registerBeanDefinition(beanName, beanDef);\n+\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"dc191bec2dfceb7ee052ac238c84eb564d27e1ee": {
			"type": "Ybodychange",
			"commitMessage": "Whitespace and license polish\n\n",
			"commitDate": "2009-03-07, 1:41 PM",
			"commitName": "dc191bec2dfceb7ee052ac238c84eb564d27e1ee",
			"commitAuthor": "Chris Beams",
			"commitDateOld": "2009-03-06, 10:14 PM",
			"commitNameOld": "5de6e2c3953ab594fd04c4f2e59a102633a0a64f",
			"commitAuthorOld": "Chris Beams",
			"daysBetweenCommits": 0.64,
			"commitsBetweenForRepo": 6,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,4 +1,3 @@\n \tprivate void loadBeanDefinitionsForModelMethod(BeanMethod method) {\n \t\tnew BeanRegistrar().register(method, registry);\n-\t\t//method.getRegistrar().register(method, registry);\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"b985011b24cb40671ad6d2b8cc34fbea763ed7a4": {
			"type": "Ybodychange",
			"commitMessage": "+ Fleshed out, documented, tested and polished the ConfigurationPostProcessor implementation\n+ Removed @FactoryMethod indirection and extension point in favor of direct processing of @Bean annotations\n\n",
			"commitDate": "2009-03-05, 7:12 PM",
			"commitName": "b985011b24cb40671ad6d2b8cc34fbea763ed7a4",
			"commitAuthor": "Chris Beams",
			"commitDateOld": "2009-03-05, 12:08 PM",
			"commitNameOld": "eaf3a7cec49e3a6e8ed828dbb69b9a9b007b0b39",
			"commitAuthorOld": "Chris Beams",
			"daysBetweenCommits": 0.29,
			"commitsBetweenForRepo": 4,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,3 +1,4 @@\n \tprivate void loadBeanDefinitionsForModelMethod(BeanMethod method) {\n-\t\tmethod.getRegistrar().register(method, registry);\n+\t\tnew BeanRegistrar().register(method, registry);\n+\t\t//method.getRegistrar().register(method, registry);\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"eaf3a7cec49e3a6e8ed828dbb69b9a9b007b0b39": {
			"type": "Ymultichange(Yparameterchange,Ybodychange)",
			"commitMessage": "+ Adding POC tooling integration points, namely AbstractConfigurationPostProcessor and allowing for tooling-specified ClassLoader for use with ASM parsing\n+ Eliminated ModelMethod in favor of BeanMethod throughout\n\n\n",
			"commitDate": "2009-03-05, 12:08 PM",
			"commitName": "eaf3a7cec49e3a6e8ed828dbb69b9a9b007b0b39",
			"commitAuthor": "Chris Beams",
			"subchanges": [
				{
					"type": "Yparameterchange",
					"commitMessage": "+ Adding POC tooling integration points, namely AbstractConfigurationPostProcessor and allowing for tooling-specified ClassLoader for use with ASM parsing\n+ Eliminated ModelMethod in favor of BeanMethod throughout\n\n\n",
					"commitDate": "2009-03-05, 12:08 PM",
					"commitName": "eaf3a7cec49e3a6e8ed828dbb69b9a9b007b0b39",
					"commitAuthor": "Chris Beams",
					"commitDateOld": "2009-02-27, 10:57 PM",
					"commitNameOld": "e3153f705ffd70157deffb2935e3db5b2a2a38a1",
					"commitAuthorOld": "Chris Beams",
					"daysBetweenCommits": 5.55,
					"commitsBetweenForRepo": 12,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,3 +1,3 @@\n-\tprivate void loadBeanDefinitionsForModelMethod(ModelMethod method) {\n-\t\tmethod.getRegistrar().register(method, beanFactory);\n+\tprivate void loadBeanDefinitionsForModelMethod(BeanMethod method) {\n+\t\tmethod.getRegistrar().register(method, registry);\n \t}\n\\ No newline at end of file\n",
					"extendedDetails": {
						"oldValue": "[method-ModelMethod]",
						"newValue": "[method-BeanMethod]"
					}
				},
				{
					"type": "Ybodychange",
					"commitMessage": "+ Adding POC tooling integration points, namely AbstractConfigurationPostProcessor and allowing for tooling-specified ClassLoader for use with ASM parsing\n+ Eliminated ModelMethod in favor of BeanMethod throughout\n\n\n",
					"commitDate": "2009-03-05, 12:08 PM",
					"commitName": "eaf3a7cec49e3a6e8ed828dbb69b9a9b007b0b39",
					"commitAuthor": "Chris Beams",
					"commitDateOld": "2009-02-27, 10:57 PM",
					"commitNameOld": "e3153f705ffd70157deffb2935e3db5b2a2a38a1",
					"commitAuthorOld": "Chris Beams",
					"daysBetweenCommits": 5.55,
					"commitsBetweenForRepo": 12,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,3 +1,3 @@\n-\tprivate void loadBeanDefinitionsForModelMethod(ModelMethod method) {\n-\t\tmethod.getRegistrar().register(method, beanFactory);\n+\tprivate void loadBeanDefinitionsForModelMethod(BeanMethod method) {\n+\t\tmethod.getRegistrar().register(method, registry);\n \t}\n\\ No newline at end of file\n",
					"extendedDetails": {}
				}
			]
		},
		"c593f063970df90d7de7b85c6da5733aadcafde6": {
			"type": "Yfilerename",
			"commitMessage": "Consolidating types and reducing visibility wherever possible. Non-internal public API is now at 18 types (21 including internal packages).\n",
			"commitDate": "2009-02-27, 7:43 PM",
			"commitName": "c593f063970df90d7de7b85c6da5733aadcafde6",
			"commitAuthor": "Chris Beams",
			"commitDateOld": "2009-02-27, 7:08 PM",
			"commitNameOld": "6deb1acab435d18f024e07a564ac77147729e0ec",
			"commitAuthorOld": "Chris Beams",
			"daysBetweenCommits": 0.02,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "",
			"extendedDetails": {
				"oldPath": "org.springframework.config.java/src/main/java/org/springframework/config/java/internal/factory/support/ConfigurationModelBeanDefinitionReader.java",
				"newPath": "org.springframework.config.java/src/main/java/org/springframework/config/java/support/ConfigurationModelBeanDefinitionReader.java"
			}
		},
		"e48fe0d89271113bcac4e7c41e86cb1d8230594e": {
			"type": "Yintroduced",
			"commitMessage": "Initial cut at migrating JavaConfig essentials into Core. test.basic.BasicTests successfully excercises the simplest possible @Configuration class (contains a single @Bean method). 39 classes were pulled in from from JavaConfig to support this use case.\n\n",
			"commitDate": "2009-02-26, 5:35 PM",
			"commitName": "e48fe0d89271113bcac4e7c41e86cb1d8230594e",
			"commitAuthor": "Chris Beams",
			"diff": "@@ -0,0 +1,3 @@\n+    private void loadBeanDefinitionsForModelMethod(ModelMethod method) {\n+        method.getRegistrar().register(method, beanFactory);\n+    }\n\\ No newline at end of file\n"
		}
	},
	"sha": "b325c74216fd9564a36602158fa1269e2e832874"
}