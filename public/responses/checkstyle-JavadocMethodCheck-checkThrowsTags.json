{
	"repo": "https://github.com/checkstyle/checkstyle.git",
	"file": "src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocMethodCheck.java",
	"method": {
		"longName": "private void checkThrowsTags(List<JavadocTag> tags, List<ExceptionInfo> throwsList, boolean reportExpectedTags);",
		"startLine": 875,
		"methodName": "checkThrowsTags",
		"isStatic": false,
		"isAbstract": false,
		"visibility": "private"
	},
	"history": {
		"fbf3f95c2273be23b966cba6e6ef89390a6fb020": {
			"type": "Ybodychange",
			"commitMessage": "Issue #3433: Cut down on Checkstyle's dependencies on Guava (part 2) (#3454)\n\n",
			"commitDate": "2016-09-20, 7:52 PM",
			"commitName": "fbf3f95c2273be23b966cba6e6ef89390a6fb020",
			"commitAuthor": "Andrei Selkin",
			"commitDateOld": "2016-09-14, 1:58 PM",
			"commitNameOld": "25a37e5049b7816b34c552899841a978efc37a63",
			"commitAuthorOld": "Andrei Selkin",
			"daysBetweenCommits": 6.25,
			"commitsBetweenForRepo": 9,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,50 +1,50 @@\n     private void checkThrowsTags(List<JavadocTag> tags,\n             List<ExceptionInfo> throwsList, boolean reportExpectedTags) {\n         // Loop over the tags, checking to see they exist in the throws.\n         // The foundThrows used for performance only\n-        final Set<String> foundThrows = Sets.newHashSet();\n+        final Set<String> foundThrows = new HashSet<>();\n         final ListIterator<JavadocTag> tagIt = tags.listIterator();\n         while (tagIt.hasNext()) {\n             final JavadocTag tag = tagIt.next();\n \n             if (!tag.isThrowsTag()) {\n                 continue;\n             }\n             tagIt.remove();\n \n             // Loop looking for matching throw\n             final String documentedEx = tag.getFirstArg();\n             final Token token = new Token(tag.getFirstArg(), tag.getLineNo(), tag\n                     .getColumnNo());\n             final AbstractClassInfo documentedClassInfo = createClassInfo(token,\n                     getCurrentClassName());\n             final boolean found = foundThrows.contains(documentedEx)\n                     || isInThrows(throwsList, documentedClassInfo, foundThrows);\n \n             // Handle extra JavadocTag.\n             if (!found) {\n                 boolean reqd = true;\n                 if (allowUndeclaredRTE) {\n                     reqd = !isUnchecked(documentedClassInfo.getClazz());\n                 }\n \n                 if (reqd && validateThrows) {\n                     log(tag.getLineNo(), tag.getColumnNo(),\n                         MSG_UNUSED_TAG,\n                         JavadocTagInfo.THROWS.getText(), tag.getFirstArg());\n \n                 }\n             }\n         }\n         // Now dump out all throws without tags :- unless\n         // the user has chosen to suppress these problems\n         if (!allowMissingThrowsTags && reportExpectedTags) {\n             throwsList.stream().filter(exceptionInfo -> !exceptionInfo.isFound())\n                 .forEach(exceptionInfo -> {\n                     final Token token = exceptionInfo.getName();\n                     log(token.getLineNo(), token.getColumnNo(),\n                         MSG_EXPECTED_TAG,\n                         JavadocTagInfo.THROWS.getText(), token.getText());\n                 });\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"de022d2434e58dd633fd50a7f9bb50565a8767b5": {
			"type": "Ybodychange",
			"commitMessage": "Issue #3233: Resolve IntelijIdea inspection violations for java8 migration (#3434)\n\n",
			"commitDate": "2016-09-08, 5:30 AM",
			"commitName": "de022d2434e58dd633fd50a7f9bb50565a8767b5",
			"commitAuthor": "Mariia Mykhailova",
			"commitDateOld": "2016-05-27, 6:42 AM",
			"commitNameOld": "39b343a32a4f1ce18ee98a34618fda0a5404d6a0",
			"commitAuthorOld": "rnveach",
			"daysBetweenCommits": 103.95,
			"commitsBetweenForRepo": 185,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,51 +1,50 @@\n     private void checkThrowsTags(List<JavadocTag> tags,\n             List<ExceptionInfo> throwsList, boolean reportExpectedTags) {\n         // Loop over the tags, checking to see they exist in the throws.\n         // The foundThrows used for performance only\n         final Set<String> foundThrows = Sets.newHashSet();\n         final ListIterator<JavadocTag> tagIt = tags.listIterator();\n         while (tagIt.hasNext()) {\n             final JavadocTag tag = tagIt.next();\n \n             if (!tag.isThrowsTag()) {\n                 continue;\n             }\n             tagIt.remove();\n \n             // Loop looking for matching throw\n             final String documentedEx = tag.getFirstArg();\n             final Token token = new Token(tag.getFirstArg(), tag.getLineNo(), tag\n                     .getColumnNo());\n             final AbstractClassInfo documentedClassInfo = createClassInfo(token,\n                     getCurrentClassName());\n             final boolean found = foundThrows.contains(documentedEx)\n                     || isInThrows(throwsList, documentedClassInfo, foundThrows);\n \n             // Handle extra JavadocTag.\n             if (!found) {\n                 boolean reqd = true;\n                 if (allowUndeclaredRTE) {\n                     reqd = !isUnchecked(documentedClassInfo.getClazz());\n                 }\n \n                 if (reqd && validateThrows) {\n                     log(tag.getLineNo(), tag.getColumnNo(),\n                         MSG_UNUSED_TAG,\n                         JavadocTagInfo.THROWS.getText(), tag.getFirstArg());\n \n                 }\n             }\n         }\n         // Now dump out all throws without tags :- unless\n         // the user has chosen to suppress these problems\n         if (!allowMissingThrowsTags && reportExpectedTags) {\n-            for (ExceptionInfo exceptionInfo : throwsList) {\n-                if (!exceptionInfo.isFound()) {\n+            throwsList.stream().filter(exceptionInfo -> !exceptionInfo.isFound())\n+                .forEach(exceptionInfo -> {\n                     final Token token = exceptionInfo.getName();\n                     log(token.getLineNo(), token.getColumnNo(),\n-                            MSG_EXPECTED_TAG,\n-                            JavadocTagInfo.THROWS.getText(), token.getText());\n-                }\n-            }\n+                        MSG_EXPECTED_TAG,\n+                        JavadocTagInfo.THROWS.getText(), token.getText());\n+                });\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"aab0718232e060bd8f289770ab81780b3a2705a2": {
			"type": "Ybodychange",
			"commitMessage": "Issue #2604: Update regexp pattern for LocalVariableName\n",
			"commitDate": "2015-12-06, 4:02 PM",
			"commitName": "aab0718232e060bd8f289770ab81780b3a2705a2",
			"commitAuthor": "Andrei Selkin",
			"commitDateOld": "2015-11-21, 5:51 PM",
			"commitNameOld": "bf9325be913ce46a1427232c455f4830b574ba44",
			"commitAuthorOld": "Roman Ivanov",
			"daysBetweenCommits": 14.92,
			"commitsBetweenForRepo": 36,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,51 +1,51 @@\n     private void checkThrowsTags(List<JavadocTag> tags,\n             List<ExceptionInfo> throwsList, boolean reportExpectedTags) {\n         // Loop over the tags, checking to see they exist in the throws.\n         // The foundThrows used for performance only\n         final Set<String> foundThrows = Sets.newHashSet();\n         final ListIterator<JavadocTag> tagIt = tags.listIterator();\n         while (tagIt.hasNext()) {\n             final JavadocTag tag = tagIt.next();\n \n             if (!tag.isThrowsTag()) {\n                 continue;\n             }\n             tagIt.remove();\n \n             // Loop looking for matching throw\n             final String documentedEx = tag.getFirstArg();\n             final Token token = new Token(tag.getFirstArg(), tag.getLineNo(), tag\n                     .getColumnNo());\n             final AbstractClassInfo documentedClassInfo = createClassInfo(token,\n                     getCurrentClassName());\n             final boolean found = foundThrows.contains(documentedEx)\n                     || isInThrows(throwsList, documentedClassInfo, foundThrows);\n \n             // Handle extra JavadocTag.\n             if (!found) {\n                 boolean reqd = true;\n                 if (allowUndeclaredRTE) {\n                     reqd = !isUnchecked(documentedClassInfo.getClazz());\n                 }\n \n                 if (reqd && validateThrows) {\n                     log(tag.getLineNo(), tag.getColumnNo(),\n                         MSG_UNUSED_TAG,\n                         JavadocTagInfo.THROWS.getText(), tag.getFirstArg());\n \n                 }\n             }\n         }\n         // Now dump out all throws without tags :- unless\n         // the user has chosen to suppress these problems\n         if (!allowMissingThrowsTags && reportExpectedTags) {\n-            for (ExceptionInfo ei : throwsList) {\n-                if (!ei.isFound()) {\n-                    final Token token = ei.getName();\n+            for (ExceptionInfo exceptionInfo : throwsList) {\n+                if (!exceptionInfo.isFound()) {\n+                    final Token token = exceptionInfo.getName();\n                     log(token.getLineNo(), token.getColumnNo(),\n                             MSG_EXPECTED_TAG,\n                             JavadocTagInfo.THROWS.getText(), token.getText());\n                 }\n             }\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"bf9325be913ce46a1427232c455f4830b574ba44": {
			"type": "Ybodychange",
			"commitMessage": "Issue #2639: adjust AbbreviationAsWordInName in checkstyle_checks.xml to catch unexpected abbreviations\n",
			"commitDate": "2015-11-21, 5:51 PM",
			"commitName": "bf9325be913ce46a1427232c455f4830b574ba44",
			"commitAuthor": "Roman Ivanov",
			"commitDateOld": "2015-10-21, 11:00 PM",
			"commitNameOld": "9e9b817c6558d1141617e52444716c0f802c1417",
			"commitAuthorOld": "John Erik Halse",
			"daysBetweenCommits": 30.83,
			"commitsBetweenForRepo": 188,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,51 +1,51 @@\n     private void checkThrowsTags(List<JavadocTag> tags,\n             List<ExceptionInfo> throwsList, boolean reportExpectedTags) {\n         // Loop over the tags, checking to see they exist in the throws.\n         // The foundThrows used for performance only\n         final Set<String> foundThrows = Sets.newHashSet();\n         final ListIterator<JavadocTag> tagIt = tags.listIterator();\n         while (tagIt.hasNext()) {\n             final JavadocTag tag = tagIt.next();\n \n             if (!tag.isThrowsTag()) {\n                 continue;\n             }\n             tagIt.remove();\n \n             // Loop looking for matching throw\n             final String documentedEx = tag.getFirstArg();\n             final Token token = new Token(tag.getFirstArg(), tag.getLineNo(), tag\n                     .getColumnNo());\n-            final AbstractClassInfo documentedCI = createClassInfo(token,\n+            final AbstractClassInfo documentedClassInfo = createClassInfo(token,\n                     getCurrentClassName());\n             final boolean found = foundThrows.contains(documentedEx)\n-                    || isInThrows(throwsList, documentedCI, foundThrows);\n+                    || isInThrows(throwsList, documentedClassInfo, foundThrows);\n \n             // Handle extra JavadocTag.\n             if (!found) {\n                 boolean reqd = true;\n                 if (allowUndeclaredRTE) {\n-                    reqd = !isUnchecked(documentedCI.getClazz());\n+                    reqd = !isUnchecked(documentedClassInfo.getClazz());\n                 }\n \n                 if (reqd && validateThrows) {\n                     log(tag.getLineNo(), tag.getColumnNo(),\n                         MSG_UNUSED_TAG,\n                         JavadocTagInfo.THROWS.getText(), tag.getFirstArg());\n \n                 }\n             }\n         }\n         // Now dump out all throws without tags :- unless\n         // the user has chosen to suppress these problems\n         if (!allowMissingThrowsTags && reportExpectedTags) {\n             for (ExceptionInfo ei : throwsList) {\n                 if (!ei.isFound()) {\n                     final Token token = ei.getName();\n                     log(token.getLineNo(), token.getColumnNo(),\n                             MSG_EXPECTED_TAG,\n                             JavadocTagInfo.THROWS.getText(), token.getText());\n                 }\n             }\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"5f5142b2325051f9ed31130167c73d154d547211": {
			"type": "Ybodychange",
			"commitMessage": "Issue #985: Fix PMD violations for ShortVariable rule\n",
			"commitDate": "2015-10-06, 7:33 PM",
			"commitName": "5f5142b2325051f9ed31130167c73d154d547211",
			"commitAuthor": "Roman Ivanov",
			"commitDateOld": "2015-10-06, 6:56 AM",
			"commitNameOld": "e2b4e687d7b8f9d6d5e1346d874b90e4567aff81",
			"commitAuthorOld": "Roman Ivanov",
			"daysBetweenCommits": 0.53,
			"commitsBetweenForRepo": 9,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,51 +1,51 @@\n     private void checkThrowsTags(List<JavadocTag> tags,\n             List<ExceptionInfo> throwsList, boolean reportExpectedTags) {\n         // Loop over the tags, checking to see they exist in the throws.\n         // The foundThrows used for performance only\n         final Set<String> foundThrows = Sets.newHashSet();\n         final ListIterator<JavadocTag> tagIt = tags.listIterator();\n         while (tagIt.hasNext()) {\n             final JavadocTag tag = tagIt.next();\n \n             if (!tag.isThrowsTag()) {\n                 continue;\n             }\n             tagIt.remove();\n \n             // Loop looking for matching throw\n             final String documentedEx = tag.getFirstArg();\n             final Token token = new Token(tag.getFirstArg(), tag.getLineNo(), tag\n                     .getColumnNo());\n             final AbstractClassInfo documentedCI = createClassInfo(token,\n                     getCurrentClassName());\n             final boolean found = foundThrows.contains(documentedEx)\n                     || isInThrows(throwsList, documentedCI, foundThrows);\n \n             // Handle extra JavadocTag.\n             if (!found) {\n                 boolean reqd = true;\n                 if (allowUndeclaredRTE) {\n                     reqd = !isUnchecked(documentedCI.getClazz());\n                 }\n \n                 if (reqd && validateThrows) {\n                     log(tag.getLineNo(), tag.getColumnNo(),\n                         MSG_UNUSED_TAG,\n                         JavadocTagInfo.THROWS.getText(), tag.getFirstArg());\n \n                 }\n             }\n         }\n         // Now dump out all throws without tags :- unless\n         // the user has chosen to suppress these problems\n         if (!allowMissingThrowsTags && reportExpectedTags) {\n             for (ExceptionInfo ei : throwsList) {\n                 if (!ei.isFound()) {\n-                    final Token fi = ei.getName();\n-                    log(fi.getLineNo(), fi.getColumnNo(),\n+                    final Token token = ei.getName();\n+                    log(token.getLineNo(), token.getColumnNo(),\n                             MSG_EXPECTED_TAG,\n-                        JavadocTagInfo.THROWS.getText(), fi.getText());\n+                            JavadocTagInfo.THROWS.getText(), token.getText());\n                 }\n             }\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"d220d7c3cc74490c7f2923f2ea85d00133afe98c": {
			"type": "Ybodychange",
			"commitMessage": "Issue #2080: Fix typos in code\n\nFixes some `SpellCheckingInspection` inspection violations.\n\nDescription:\n>Spellchecker inspection helps locate typos and misspelling in your code, comments and literals.\n",
			"commitDate": "2015-09-04, 5:28 PM",
			"commitName": "d220d7c3cc74490c7f2923f2ea85d00133afe98c",
			"commitAuthor": "Michal Kordas",
			"commitDateOld": "2015-08-31, 12:58 PM",
			"commitNameOld": "49a0ee81710e0c43ed06a01f1d64ac7f5598a934",
			"commitAuthorOld": "Baratali Izmailov",
			"daysBetweenCommits": 4.19,
			"commitsBetweenForRepo": 71,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,51 +1,51 @@\n     private void checkThrowsTags(List<JavadocTag> tags,\n             List<ExceptionInfo> throwsList, boolean reportExpectedTags) {\n         // Loop over the tags, checking to see they exist in the throws.\n         // The foundThrows used for performance only\n         final Set<String> foundThrows = Sets.newHashSet();\n         final ListIterator<JavadocTag> tagIt = tags.listIterator();\n         while (tagIt.hasNext()) {\n             final JavadocTag tag = tagIt.next();\n \n             if (!tag.isThrowsTag()) {\n                 continue;\n             }\n             tagIt.remove();\n \n             // Loop looking for matching throw\n             final String documentedEx = tag.getFirstArg();\n             final Token token = new Token(tag.getFirstArg(), tag.getLineNo(), tag\n                     .getColumnNo());\n             final AbstractClassInfo documentedCI = createClassInfo(token,\n                     getCurrentClassName());\n             final boolean found = foundThrows.contains(documentedEx)\n                     || isInThrows(throwsList, documentedCI, foundThrows);\n \n             // Handle extra JavadocTag.\n             if (!found) {\n                 boolean reqd = true;\n                 if (allowUndeclaredRTE) {\n                     reqd = !isUnchecked(documentedCI.getClazz());\n                 }\n \n                 if (reqd && validateThrows) {\n                     log(tag.getLineNo(), tag.getColumnNo(),\n                         MSG_UNUSED_TAG,\n                         JavadocTagInfo.THROWS.getText(), tag.getFirstArg());\n \n                 }\n             }\n         }\n         // Now dump out all throws without tags :- unless\n         // the user has chosen to suppress these problems\n         if (!allowMissingThrowsTags && reportExpectedTags) {\n             for (ExceptionInfo ei : throwsList) {\n                 if (!ei.isFound()) {\n                     final Token fi = ei.getName();\n                     log(fi.getLineNo(), fi.getColumnNo(),\n-                        MSG_EXCPECTED_TAG,\n+                            MSG_EXPECTED_TAG,\n                         JavadocTagInfo.THROWS.getText(), fi.getText());\n                 }\n             }\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"6f1840f011cea3a523d9df1278d4a0af98e1d967": {
			"type": "Ybodychange",
			"commitMessage": "Issue #1566: Refactoring of JavadocMethodCheck to reduce method's length\n",
			"commitDate": "2015-08-27, 6:30 AM",
			"commitName": "6f1840f011cea3a523d9df1278d4a0af98e1d967",
			"commitAuthor": "Baratali Izmailov",
			"commitDateOld": "2015-08-27, 5:17 AM",
			"commitNameOld": "cdf3e56bacd3895262af8a1df9ca5c81f4071970",
			"commitAuthorOld": "Ilja Dubinin",
			"daysBetweenCommits": 0.05,
			"commitsBetweenForRepo": 22,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,80 +1,54 @@\n     private void checkThrowsTags(List<JavadocTag> tags,\n             List<ExceptionInfo> throwsList, boolean reportExpectedTags) {\n         // Loop over the tags, checking to see they exist in the throws.\n         // The foundThrows used for performance only\n         final Set<String> foundThrows = Sets.newHashSet();\n         final ListIterator<JavadocTag> tagIt = tags.listIterator();\n         while (tagIt.hasNext()) {\n             final JavadocTag tag = tagIt.next();\n \n             if (!tag.isThrowsTag()) {\n                 continue;\n             }\n \n             tagIt.remove();\n \n             // Loop looking for matching throw\n             final String documentedEx = tag.getFirstArg();\n             final Token token = new Token(tag.getFirstArg(), tag.getLineNo(), tag\n                     .getColumnNo());\n             final AbstractClassInfo documentedCI = createClassInfo(token,\n                     getCurrentClassName());\n-            boolean found = foundThrows.contains(documentedEx);\n \n-            // First look for matches on the exception name\n-            ListIterator<ExceptionInfo> throwIt = throwsList.listIterator();\n-            while (!found && throwIt.hasNext()) {\n-                final ExceptionInfo ei = throwIt.next();\n-\n-                if (ei.getName().getText().equals(\n-                        documentedCI.getName().getText())) {\n-                    found = true;\n-                    ei.setFound();\n-                    foundThrows.add(documentedEx);\n-                }\n-            }\n-\n-            // Now match on the exception type\n-            throwIt = throwsList.listIterator();\n-            while (!found && throwIt.hasNext()) {\n-                final ExceptionInfo ei = throwIt.next();\n-\n-                if (documentedCI.getClazz() == ei.getClazz()) {\n-                    found = true;\n-                    ei.setFound();\n-                    foundThrows.add(documentedEx);\n-                }\n-                else if (allowThrowsTagsForSubclasses) {\n-                    found = isSubclass(documentedCI.getClazz(), ei.getClazz());\n-                }\n-            }\n+            final boolean found = foundThrows.contains(documentedEx)\n+                    || isInThrows(throwsList, documentedCI, foundThrows);\n \n             // Handle extra JavadocTag.\n             if (!found) {\n                 boolean reqd = true;\n                 if (allowUndeclaredRTE) {\n                     reqd = !isUnchecked(documentedCI.getClazz());\n                 }\n \n                 if (reqd && validateThrows) {\n                     log(tag.getLineNo(), tag.getColumnNo(),\n                         MSG_UNUSED_TAG,\n                         JavadocTagInfo.THROWS.getText(), tag.getFirstArg());\n \n                 }\n             }\n         }\n \n         // Now dump out all throws without tags :- unless\n         // the user has chosen to suppress these problems\n         if (!allowMissingThrowsTags && reportExpectedTags) {\n             for (ExceptionInfo ei : throwsList) {\n                 if (!ei.isFound()) {\n                     final Token fi = ei.getName();\n                     log(fi.getLineNo(), fi.getColumnNo(),\n                         MSG_EXCPECTED_TAG,\n                         JavadocTagInfo.THROWS.getText(), fi.getText());\n                 }\n             }\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"66d73fe6189267fee3423e2e8d7fc2d68599a43f": {
			"type": "Ybodychange",
			"commitMessage": "Issue #1566: MemberName and MethodName violations fixed\n",
			"commitDate": "2015-08-14, 7:00 AM",
			"commitName": "66d73fe6189267fee3423e2e8d7fc2d68599a43f",
			"commitAuthor": "Ruslan Diachenko",
			"commitDateOld": "2015-08-11, 10:19 PM",
			"commitNameOld": "3bd699bd593414d63c7139aa410f13ec8341a027",
			"commitAuthorOld": "Ruslan Diachenko",
			"daysBetweenCommits": 2.36,
			"commitsBetweenForRepo": 18,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,80 +1,80 @@\n     private void checkThrowsTags(List<JavadocTag> tags,\n             List<ExceptionInfo> throwsList, boolean reportExpectedTags) {\n         // Loop over the tags, checking to see they exist in the throws.\n         // The foundThrows used for performance only\n         final Set<String> foundThrows = Sets.newHashSet();\n         final ListIterator<JavadocTag> tagIt = tags.listIterator();\n         while (tagIt.hasNext()) {\n             final JavadocTag tag = tagIt.next();\n \n             if (!tag.isThrowsTag()) {\n                 continue;\n             }\n \n             tagIt.remove();\n \n             // Loop looking for matching throw\n-            final String documentedEx = tag.getArg1();\n-            final Token token = new Token(tag.getArg1(), tag.getLineNo(), tag\n+            final String documentedEx = tag.getFirstArg();\n+            final Token token = new Token(tag.getFirstArg(), tag.getLineNo(), tag\n                     .getColumnNo());\n             final AbstractClassInfo documentedCI = createClassInfo(token,\n                     getCurrentClassName());\n             boolean found = foundThrows.contains(documentedEx);\n \n             // First look for matches on the exception name\n             ListIterator<ExceptionInfo> throwIt = throwsList.listIterator();\n             while (!found && throwIt.hasNext()) {\n                 final ExceptionInfo ei = throwIt.next();\n \n                 if (ei.getName().getText().equals(\n                         documentedCI.getName().getText())) {\n                     found = true;\n                     ei.setFound();\n                     foundThrows.add(documentedEx);\n                 }\n             }\n \n             // Now match on the exception type\n             throwIt = throwsList.listIterator();\n             while (!found && throwIt.hasNext()) {\n                 final ExceptionInfo ei = throwIt.next();\n \n                 if (documentedCI.getClazz() == ei.getClazz()) {\n                     found = true;\n                     ei.setFound();\n                     foundThrows.add(documentedEx);\n                 }\n                 else if (allowThrowsTagsForSubclasses) {\n                     found = isSubclass(documentedCI.getClazz(), ei.getClazz());\n                 }\n             }\n \n             // Handle extra JavadocTag.\n             if (!found) {\n                 boolean reqd = true;\n                 if (allowUndeclaredRTE) {\n                     reqd = !isUnchecked(documentedCI.getClazz());\n                 }\n \n                 if (reqd && validateThrows) {\n                     log(tag.getLineNo(), tag.getColumnNo(),\n                         MSG_UNUSED_TAG,\n-                        JavadocTagInfo.THROWS.getText(), tag.getArg1());\n+                        JavadocTagInfo.THROWS.getText(), tag.getFirstArg());\n \n                 }\n             }\n         }\n \n         // Now dump out all throws without tags :- unless\n         // the user has chosen to suppress these problems\n         if (!allowMissingThrowsTags && reportExpectedTags) {\n             for (ExceptionInfo ei : throwsList) {\n                 if (!ei.isFound()) {\n                     final Token fi = ei.getName();\n                     log(fi.getLineNo(), fi.getColumnNo(),\n                         MSG_EXCPECTED_TAG,\n                         JavadocTagInfo.THROWS.getText(), fi.getText());\n                 }\n             }\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"eb5896a4a1d66552f5100046413f15d62b485b62": {
			"type": "Ybodychange",
			"commitMessage": "Fix PMD violations for AbstractNaming rule #983\n",
			"commitDate": "2015-06-18, 10:52 AM",
			"commitName": "eb5896a4a1d66552f5100046413f15d62b485b62",
			"commitAuthor": "Bhavik Patel",
			"commitDateOld": "2015-05-28, 4:59 AM",
			"commitNameOld": "835a5700d8d70436b198c80aba63f843da0b4dab",
			"commitAuthorOld": "Gustav Carlson",
			"daysBetweenCommits": 21.25,
			"commitsBetweenForRepo": 123,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,80 +1,80 @@\n     private void checkThrowsTags(List<JavadocTag> tags,\n             List<ExceptionInfo> throwsList, boolean reportExpectedTags) {\n         // Loop over the tags, checking to see they exist in the throws.\n         // The foundThrows used for performance only\n         final Set<String> foundThrows = Sets.newHashSet();\n         final ListIterator<JavadocTag> tagIt = tags.listIterator();\n         while (tagIt.hasNext()) {\n             final JavadocTag tag = tagIt.next();\n \n             if (!tag.isThrowsTag()) {\n                 continue;\n             }\n \n             tagIt.remove();\n \n             // Loop looking for matching throw\n             final String documentedEx = tag.getArg1();\n             final Token token = new Token(tag.getArg1(), tag.getLineNo(), tag\n                     .getColumnNo());\n-            final ClassInfo documentedCI = createClassInfo(token,\n+            final AbstractClassInfo documentedCI = createClassInfo(token,\n                     getCurrentClassName());\n             boolean found = foundThrows.contains(documentedEx);\n \n             // First look for matches on the exception name\n             ListIterator<ExceptionInfo> throwIt = throwsList.listIterator();\n             while (!found && throwIt.hasNext()) {\n                 final ExceptionInfo ei = throwIt.next();\n \n                 if (ei.getName().getText().equals(\n                         documentedCI.getName().getText())) {\n                     found = true;\n                     ei.setFound();\n                     foundThrows.add(documentedEx);\n                 }\n             }\n \n             // Now match on the exception type\n             throwIt = throwsList.listIterator();\n             while (!found && throwIt.hasNext()) {\n                 final ExceptionInfo ei = throwIt.next();\n \n                 if (documentedCI.getClazz() == ei.getClazz()) {\n                     found = true;\n                     ei.setFound();\n                     foundThrows.add(documentedEx);\n                 }\n                 else if (allowThrowsTagsForSubclasses) {\n                     found = isSubclass(documentedCI.getClazz(), ei.getClazz());\n                 }\n             }\n \n             // Handle extra JavadocTag.\n             if (!found) {\n                 boolean reqd = true;\n                 if (allowUndeclaredRTE) {\n                     reqd = !isUnchecked(documentedCI.getClazz());\n                 }\n \n                 if (reqd && validateThrows) {\n                     log(tag.getLineNo(), tag.getColumnNo(),\n                         MSG_UNUSED_TAG,\n                         JavadocTagInfo.THROWS.getText(), tag.getArg1());\n \n                 }\n             }\n         }\n \n         // Now dump out all throws without tags :- unless\n         // the user has chosen to suppress these problems\n         if (!allowMissingThrowsTags && reportExpectedTags) {\n             for (ExceptionInfo ei : throwsList) {\n                 if (!ei.isFound()) {\n                     final Token fi = ei.getName();\n                     log(fi.getLineNo(), fi.getColumnNo(),\n                         MSG_EXCPECTED_TAG,\n                         JavadocTagInfo.THROWS.getText(), fi.getText());\n                 }\n             }\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"cee4f351944dc6bad1c0b91eb8aaa118eed59fcc": {
			"type": "Ybodychange",
			"commitMessage": "Refactored UTs, javadoc package, issue #537\n",
			"commitDate": "2015-02-20, 5:02 AM",
			"commitName": "cee4f351944dc6bad1c0b91eb8aaa118eed59fcc",
			"commitAuthor": "alexkravin",
			"commitDateOld": "2015-02-18, 1:14 PM",
			"commitNameOld": "c9a9e6508c15e00cf6820b213d79d5ebf41c6343",
			"commitAuthorOld": "Roman Ivanov",
			"daysBetweenCommits": 1.66,
			"commitsBetweenForRepo": 11,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,82 +1,82 @@\n     private void checkThrowsTags(List<JavadocTag> tags,\n             List<ExceptionInfo> throwsList, boolean reportExpectedTags)\n     {\n         // Loop over the tags, checking to see they exist in the throws.\n         // The foundThrows used for performance only\n         final Set<String> foundThrows = Sets.newHashSet();\n         final ListIterator<JavadocTag> tagIt = tags.listIterator();\n         while (tagIt.hasNext()) {\n             final JavadocTag tag = tagIt.next();\n \n             if (!tag.isThrowsTag()) {\n                 continue;\n             }\n \n             tagIt.remove();\n \n             // Loop looking for matching throw\n             final String documentedEx = tag.getArg1();\n             final Token token = new Token(tag.getArg1(), tag.getLineNo(), tag\n                     .getColumnNo());\n             final ClassInfo documentedCI = createClassInfo(token,\n                     getCurrentClassName());\n             boolean found = foundThrows.contains(documentedEx);\n \n             // First look for matches on the exception name\n             ListIterator<ExceptionInfo> throwIt = throwsList.listIterator();\n             while (!found && throwIt.hasNext()) {\n                 final ExceptionInfo ei = throwIt.next();\n \n                 if (ei.getName().getText().equals(\n                         documentedCI.getName().getText()))\n                 {\n                     found = true;\n                     ei.setFound();\n                     foundThrows.add(documentedEx);\n                 }\n             }\n \n             // Now match on the exception type\n             throwIt = throwsList.listIterator();\n             while (!found && throwIt.hasNext()) {\n                 final ExceptionInfo ei = throwIt.next();\n \n                 if (documentedCI.getClazz() == ei.getClazz()) {\n                     found = true;\n                     ei.setFound();\n                     foundThrows.add(documentedEx);\n                 }\n                 else if (allowThrowsTagsForSubclasses) {\n                     found = isSubclass(documentedCI.getClazz(), ei.getClazz());\n                 }\n             }\n \n             // Handle extra JavadocTag.\n             if (!found) {\n                 boolean reqd = true;\n                 if (allowUndeclaredRTE) {\n                     reqd = !isUnchecked(documentedCI.getClazz());\n                 }\n \n                 if (reqd && validateThrows) {\n                     log(tag.getLineNo(), tag.getColumnNo(),\n-                        \"javadoc.unusedTag\",\n+                        MSG_UNUSED_TAG,\n                         JavadocTagInfo.THROWS.getText(), tag.getArg1());\n \n                 }\n             }\n         }\n \n         // Now dump out all throws without tags :- unless\n         // the user has chosen to suppress these problems\n         if (!allowMissingThrowsTags && reportExpectedTags) {\n             for (ExceptionInfo ei : throwsList) {\n                 if (!ei.isFound()) {\n                     final Token fi = ei.getName();\n                     log(fi.getLineNo(), fi.getColumnNo(),\n-                        \"javadoc.expectedTag\",\n+                        MSG_EXCPECTED_TAG,\n                         JavadocTagInfo.THROWS.getText(), fi.getText());\n                 }\n             }\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"89a51ba032fd9126651fa9efad31baf10c006ddf": {
			"type": "Ymultichange(Yparameterchange,Ybodychange)",
			"commitMessage": "Prefixes, javadoc, #512\n",
			"commitDate": "2015-01-19, 6:21 AM",
			"commitName": "89a51ba032fd9126651fa9efad31baf10c006ddf",
			"commitAuthor": "alexkravin",
			"subchanges": [
				{
					"type": "Yparameterchange",
					"commitMessage": "Prefixes, javadoc, #512\n",
					"commitDate": "2015-01-19, 6:21 AM",
					"commitName": "89a51ba032fd9126651fa9efad31baf10c006ddf",
					"commitAuthor": "alexkravin",
					"commitDateOld": "2014-12-29, 7:49 AM",
					"commitNameOld": "c29a5466d141595ddf773f3bead5b0591203d7d2",
					"commitAuthorOld": "alexkravin",
					"daysBetweenCommits": 20.94,
					"commitsBetweenForRepo": 36,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,82 +1,82 @@\n-    private void checkThrowsTags(List<JavadocTag> aTags,\n-            List<ExceptionInfo> aThrows, boolean aReportExpectedTags)\n+    private void checkThrowsTags(List<JavadocTag> tags,\n+            List<ExceptionInfo> throwsList, boolean reportExpectedTags)\n     {\n         // Loop over the tags, checking to see they exist in the throws.\n         // The foundThrows used for performance only\n         final Set<String> foundThrows = Sets.newHashSet();\n-        final ListIterator<JavadocTag> tagIt = aTags.listIterator();\n+        final ListIterator<JavadocTag> tagIt = tags.listIterator();\n         while (tagIt.hasNext()) {\n             final JavadocTag tag = tagIt.next();\n \n             if (!tag.isThrowsTag()) {\n                 continue;\n             }\n \n             tagIt.remove();\n \n             // Loop looking for matching throw\n             final String documentedEx = tag.getArg1();\n             final Token token = new Token(tag.getArg1(), tag.getLineNo(), tag\n                     .getColumnNo());\n             final ClassInfo documentedCI = createClassInfo(token,\n                     getCurrentClassName());\n             boolean found = foundThrows.contains(documentedEx);\n \n             // First look for matches on the exception name\n-            ListIterator<ExceptionInfo> throwIt = aThrows.listIterator();\n+            ListIterator<ExceptionInfo> throwIt = throwsList.listIterator();\n             while (!found && throwIt.hasNext()) {\n                 final ExceptionInfo ei = throwIt.next();\n \n                 if (ei.getName().getText().equals(\n                         documentedCI.getName().getText()))\n                 {\n                     found = true;\n                     ei.setFound();\n                     foundThrows.add(documentedEx);\n                 }\n             }\n \n             // Now match on the exception type\n-            throwIt = aThrows.listIterator();\n+            throwIt = throwsList.listIterator();\n             while (!found && throwIt.hasNext()) {\n                 final ExceptionInfo ei = throwIt.next();\n \n                 if (documentedCI.getClazz() == ei.getClazz()) {\n                     found = true;\n                     ei.setFound();\n                     foundThrows.add(documentedEx);\n                 }\n-                else if (mAllowThrowsTagsForSubclasses) {\n+                else if (allowThrowsTagsForSubclasses) {\n                     found = isSubclass(documentedCI.getClazz(), ei.getClazz());\n                 }\n             }\n \n             // Handle extra JavadocTag.\n             if (!found) {\n                 boolean reqd = true;\n-                if (mAllowUndeclaredRTE) {\n+                if (allowUndeclaredRTE) {\n                     reqd = !isUnchecked(documentedCI.getClazz());\n                 }\n \n-                if (reqd && mValidateThrows) {\n+                if (reqd && validateThrows) {\n                     log(tag.getLineNo(), tag.getColumnNo(),\n                         \"javadoc.unusedTag\",\n                         JavadocTagInfo.THROWS.getText(), tag.getArg1());\n \n                 }\n             }\n         }\n \n         // Now dump out all throws without tags :- unless\n         // the user has chosen to suppress these problems\n-        if (!mAllowMissingThrowsTags && aReportExpectedTags) {\n-            for (ExceptionInfo ei : aThrows) {\n+        if (!allowMissingThrowsTags && reportExpectedTags) {\n+            for (ExceptionInfo ei : throwsList) {\n                 if (!ei.isFound()) {\n                     final Token fi = ei.getName();\n                     log(fi.getLineNo(), fi.getColumnNo(),\n                         \"javadoc.expectedTag\",\n                         JavadocTagInfo.THROWS.getText(), fi.getText());\n                 }\n             }\n         }\n     }\n\\ No newline at end of file\n",
					"extendedDetails": {
						"oldValue": "[aTags-List<JavadocTag>, aThrows-List<ExceptionInfo>, aReportExpectedTags-boolean]",
						"newValue": "[tags-List<JavadocTag>, throwsList-List<ExceptionInfo>, reportExpectedTags-boolean]"
					}
				},
				{
					"type": "Ybodychange",
					"commitMessage": "Prefixes, javadoc, #512\n",
					"commitDate": "2015-01-19, 6:21 AM",
					"commitName": "89a51ba032fd9126651fa9efad31baf10c006ddf",
					"commitAuthor": "alexkravin",
					"commitDateOld": "2014-12-29, 7:49 AM",
					"commitNameOld": "c29a5466d141595ddf773f3bead5b0591203d7d2",
					"commitAuthorOld": "alexkravin",
					"daysBetweenCommits": 20.94,
					"commitsBetweenForRepo": 36,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,82 +1,82 @@\n-    private void checkThrowsTags(List<JavadocTag> aTags,\n-            List<ExceptionInfo> aThrows, boolean aReportExpectedTags)\n+    private void checkThrowsTags(List<JavadocTag> tags,\n+            List<ExceptionInfo> throwsList, boolean reportExpectedTags)\n     {\n         // Loop over the tags, checking to see they exist in the throws.\n         // The foundThrows used for performance only\n         final Set<String> foundThrows = Sets.newHashSet();\n-        final ListIterator<JavadocTag> tagIt = aTags.listIterator();\n+        final ListIterator<JavadocTag> tagIt = tags.listIterator();\n         while (tagIt.hasNext()) {\n             final JavadocTag tag = tagIt.next();\n \n             if (!tag.isThrowsTag()) {\n                 continue;\n             }\n \n             tagIt.remove();\n \n             // Loop looking for matching throw\n             final String documentedEx = tag.getArg1();\n             final Token token = new Token(tag.getArg1(), tag.getLineNo(), tag\n                     .getColumnNo());\n             final ClassInfo documentedCI = createClassInfo(token,\n                     getCurrentClassName());\n             boolean found = foundThrows.contains(documentedEx);\n \n             // First look for matches on the exception name\n-            ListIterator<ExceptionInfo> throwIt = aThrows.listIterator();\n+            ListIterator<ExceptionInfo> throwIt = throwsList.listIterator();\n             while (!found && throwIt.hasNext()) {\n                 final ExceptionInfo ei = throwIt.next();\n \n                 if (ei.getName().getText().equals(\n                         documentedCI.getName().getText()))\n                 {\n                     found = true;\n                     ei.setFound();\n                     foundThrows.add(documentedEx);\n                 }\n             }\n \n             // Now match on the exception type\n-            throwIt = aThrows.listIterator();\n+            throwIt = throwsList.listIterator();\n             while (!found && throwIt.hasNext()) {\n                 final ExceptionInfo ei = throwIt.next();\n \n                 if (documentedCI.getClazz() == ei.getClazz()) {\n                     found = true;\n                     ei.setFound();\n                     foundThrows.add(documentedEx);\n                 }\n-                else if (mAllowThrowsTagsForSubclasses) {\n+                else if (allowThrowsTagsForSubclasses) {\n                     found = isSubclass(documentedCI.getClazz(), ei.getClazz());\n                 }\n             }\n \n             // Handle extra JavadocTag.\n             if (!found) {\n                 boolean reqd = true;\n-                if (mAllowUndeclaredRTE) {\n+                if (allowUndeclaredRTE) {\n                     reqd = !isUnchecked(documentedCI.getClazz());\n                 }\n \n-                if (reqd && mValidateThrows) {\n+                if (reqd && validateThrows) {\n                     log(tag.getLineNo(), tag.getColumnNo(),\n                         \"javadoc.unusedTag\",\n                         JavadocTagInfo.THROWS.getText(), tag.getArg1());\n \n                 }\n             }\n         }\n \n         // Now dump out all throws without tags :- unless\n         // the user has chosen to suppress these problems\n-        if (!mAllowMissingThrowsTags && aReportExpectedTags) {\n-            for (ExceptionInfo ei : aThrows) {\n+        if (!allowMissingThrowsTags && reportExpectedTags) {\n+            for (ExceptionInfo ei : throwsList) {\n                 if (!ei.isFound()) {\n                     final Token fi = ei.getName();\n                     log(fi.getLineNo(), fi.getColumnNo(),\n                         \"javadoc.expectedTag\",\n                         JavadocTagInfo.THROWS.getText(), fi.getText());\n                 }\n             }\n         }\n     }\n\\ No newline at end of file\n",
					"extendedDetails": {}
				}
			]
		},
		"e56f3d21ee1a0e8c0eced70ec7990fb03dcb3215": {
			"type": "Ybodychange",
			"commitMessage": "Update for existing Check: JavadocMethodCheck #319\n",
			"commitDate": "2014-10-22, 4:42 PM",
			"commitName": "e56f3d21ee1a0e8c0eced70ec7990fb03dcb3215",
			"commitAuthor": "maxvetrenko",
			"commitDateOld": "2014-07-06, 5:50 AM",
			"commitNameOld": "7dc94ba7ab9a4e330c088e0fbbd441f78628edb0",
			"commitAuthorOld": "Tobias Baum",
			"daysBetweenCommits": 108.45,
			"commitsBetweenForRepo": 164,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,82 +1,82 @@\n     private void checkThrowsTags(List<JavadocTag> aTags,\n             List<ExceptionInfo> aThrows, boolean aReportExpectedTags)\n     {\n         // Loop over the tags, checking to see they exist in the throws.\n         // The foundThrows used for performance only\n         final Set<String> foundThrows = Sets.newHashSet();\n         final ListIterator<JavadocTag> tagIt = aTags.listIterator();\n         while (tagIt.hasNext()) {\n             final JavadocTag tag = tagIt.next();\n \n             if (!tag.isThrowsTag()) {\n                 continue;\n             }\n \n             tagIt.remove();\n \n             // Loop looking for matching throw\n             final String documentedEx = tag.getArg1();\n             final Token token = new Token(tag.getArg1(), tag.getLineNo(), tag\n                     .getColumnNo());\n             final ClassInfo documentedCI = createClassInfo(token,\n                     getCurrentClassName());\n             boolean found = foundThrows.contains(documentedEx);\n \n             // First look for matches on the exception name\n             ListIterator<ExceptionInfo> throwIt = aThrows.listIterator();\n             while (!found && throwIt.hasNext()) {\n                 final ExceptionInfo ei = throwIt.next();\n \n                 if (ei.getName().getText().equals(\n                         documentedCI.getName().getText()))\n                 {\n                     found = true;\n                     ei.setFound();\n                     foundThrows.add(documentedEx);\n                 }\n             }\n \n             // Now match on the exception type\n             throwIt = aThrows.listIterator();\n             while (!found && throwIt.hasNext()) {\n                 final ExceptionInfo ei = throwIt.next();\n \n                 if (documentedCI.getClazz() == ei.getClazz()) {\n                     found = true;\n                     ei.setFound();\n                     foundThrows.add(documentedEx);\n                 }\n                 else if (mAllowThrowsTagsForSubclasses) {\n                     found = isSubclass(documentedCI.getClazz(), ei.getClazz());\n                 }\n             }\n \n             // Handle extra JavadocTag.\n             if (!found) {\n                 boolean reqd = true;\n                 if (mAllowUndeclaredRTE) {\n                     reqd = !isUnchecked(documentedCI.getClazz());\n                 }\n \n-                if (reqd) {\n+                if (reqd && mValidateThrows) {\n                     log(tag.getLineNo(), tag.getColumnNo(),\n                         \"javadoc.unusedTag\",\n                         JavadocTagInfo.THROWS.getText(), tag.getArg1());\n \n                 }\n             }\n         }\n \n         // Now dump out all throws without tags :- unless\n         // the user has chosen to suppress these problems\n         if (!mAllowMissingThrowsTags && aReportExpectedTags) {\n             for (ExceptionInfo ei : aThrows) {\n                 if (!ei.isFound()) {\n                     final Token fi = ei.getName();\n                     log(fi.getLineNo(), fi.getColumnNo(),\n                         \"javadoc.expectedTag\",\n                         JavadocTagInfo.THROWS.getText(), fi.getText());\n                 }\n             }\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"f1efb27670a93690577f1bae17fc9dcbd88a795d": {
			"type": "Yfilerename",
			"commitMessage": "moving to standard directory layout\n",
			"commitDate": "2014-03-04, 9:18 AM",
			"commitName": "f1efb27670a93690577f1bae17fc9dcbd88a795d",
			"commitAuthor": "Ivan Sopov",
			"commitDateOld": "2014-02-26, 10:35 PM",
			"commitNameOld": "1cdaeaaa4fbf02a7388f1fcbea1c86ef0ea32fed",
			"commitAuthorOld": "Andrew Gaul",
			"daysBetweenCommits": 5.45,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "",
			"extendedDetails": {
				"oldPath": "src/checkstyle/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocMethodCheck.java",
				"newPath": "src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocMethodCheck.java"
			}
		},
		"d790eb1dc26141d6ce4c3637a31e06597a54e0e7": {
			"type": "Ybodychange",
			"commitMessage": "Fix JavadocMethod  checking of @throws tags for methods that throw multiple non-runtime exceptions. Thanks to Daan Kets for patch #3039869.\n",
			"commitDate": "2010-09-27, 8:34 PM",
			"commitName": "d790eb1dc26141d6ce4c3637a31e06597a54e0e7",
			"commitAuthor": "Oliver Burn",
			"commitDateOld": "2010-02-12, 6:57 PM",
			"commitNameOld": "523080bbf2be11354b94b851ac85d06e7e8a2c14",
			"commitAuthorOld": "Oliver Burn",
			"daysBetweenCommits": 227.03,
			"commitsBetweenForRepo": 63,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,67 +1,82 @@\n     private void checkThrowsTags(List<JavadocTag> aTags,\n             List<ExceptionInfo> aThrows, boolean aReportExpectedTags)\n     {\n         // Loop over the tags, checking to see they exist in the throws.\n         // The foundThrows used for performance only\n         final Set<String> foundThrows = Sets.newHashSet();\n         final ListIterator<JavadocTag> tagIt = aTags.listIterator();\n         while (tagIt.hasNext()) {\n             final JavadocTag tag = tagIt.next();\n \n             if (!tag.isThrowsTag()) {\n                 continue;\n             }\n \n             tagIt.remove();\n \n             // Loop looking for matching throw\n             final String documentedEx = tag.getArg1();\n             final Token token = new Token(tag.getArg1(), tag.getLineNo(), tag\n                     .getColumnNo());\n             final ClassInfo documentedCI = createClassInfo(token,\n                     getCurrentClassName());\n             boolean found = foundThrows.contains(documentedEx);\n \n-            final ListIterator<ExceptionInfo> throwIt = aThrows.listIterator();\n+            // First look for matches on the exception name\n+            ListIterator<ExceptionInfo> throwIt = aThrows.listIterator();\n+            while (!found && throwIt.hasNext()) {\n+                final ExceptionInfo ei = throwIt.next();\n+\n+                if (ei.getName().getText().equals(\n+                        documentedCI.getName().getText()))\n+                {\n+                    found = true;\n+                    ei.setFound();\n+                    foundThrows.add(documentedEx);\n+                }\n+            }\n+\n+            // Now match on the exception type\n+            throwIt = aThrows.listIterator();\n             while (!found && throwIt.hasNext()) {\n                 final ExceptionInfo ei = throwIt.next();\n \n                 if (documentedCI.getClazz() == ei.getClazz()) {\n                     found = true;\n                     ei.setFound();\n                     foundThrows.add(documentedEx);\n                 }\n                 else if (mAllowThrowsTagsForSubclasses) {\n                     found = isSubclass(documentedCI.getClazz(), ei.getClazz());\n                 }\n             }\n \n             // Handle extra JavadocTag.\n             if (!found) {\n                 boolean reqd = true;\n                 if (mAllowUndeclaredRTE) {\n                     reqd = !isUnchecked(documentedCI.getClazz());\n                 }\n \n                 if (reqd) {\n                     log(tag.getLineNo(), tag.getColumnNo(),\n                         \"javadoc.unusedTag\",\n                         JavadocTagInfo.THROWS.getText(), tag.getArg1());\n \n                 }\n             }\n         }\n \n         // Now dump out all throws without tags :- unless\n         // the user has chosen to suppress these problems\n         if (!mAllowMissingThrowsTags && aReportExpectedTags) {\n             for (ExceptionInfo ei : aThrows) {\n                 if (!ei.isFound()) {\n                     final Token fi = ei.getName();\n                     log(fi.getLineNo(), fi.getColumnNo(),\n                         \"javadoc.expectedTag\",\n                         JavadocTagInfo.THROWS.getText(), fi.getText());\n                 }\n             }\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"8a7713b4f7890e2f6493eacc5806b5eb8cfbe767": {
			"type": "Ybodychange",
			"commitMessage": "record work on patch #2534038 from Travis for new annotation checks. Very good patch as usual from Travis. Shame on me for taking so long to apply it.\n",
			"commitDate": "2009-03-23, 3:49 AM",
			"commitName": "8a7713b4f7890e2f6493eacc5806b5eb8cfbe767",
			"commitAuthor": "Oliver Burn",
			"commitDateOld": "2009-03-21, 9:16 PM",
			"commitNameOld": "216fcb79f9f5bbd05244364e926f261a90e697d1",
			"commitAuthorOld": "Oliver Burn",
			"daysBetweenCommits": 1.27,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,65 +1,67 @@\n     private void checkThrowsTags(List<JavadocTag> aTags,\n             List<ExceptionInfo> aThrows, boolean aReportExpectedTags)\n     {\n         // Loop over the tags, checking to see they exist in the throws.\n         // The foundThrows used for performance only\n         final Set<String> foundThrows = Sets.newHashSet();\n         final ListIterator<JavadocTag> tagIt = aTags.listIterator();\n         while (tagIt.hasNext()) {\n             final JavadocTag tag = tagIt.next();\n \n             if (!tag.isThrowsTag()) {\n                 continue;\n             }\n \n             tagIt.remove();\n \n             // Loop looking for matching throw\n             final String documentedEx = tag.getArg1();\n             final Token token = new Token(tag.getArg1(), tag.getLineNo(), tag\n                     .getColumnNo());\n             final ClassInfo documentedCI = createClassInfo(token,\n                     getCurrentClassName());\n             boolean found = foundThrows.contains(documentedEx);\n \n             final ListIterator<ExceptionInfo> throwIt = aThrows.listIterator();\n             while (!found && throwIt.hasNext()) {\n                 final ExceptionInfo ei = throwIt.next();\n \n                 if (documentedCI.getClazz() == ei.getClazz()) {\n                     found = true;\n                     ei.setFound();\n                     foundThrows.add(documentedEx);\n                 }\n                 else if (mAllowThrowsTagsForSubclasses) {\n                     found = isSubclass(documentedCI.getClazz(), ei.getClazz());\n                 }\n             }\n \n             // Handle extra JavadocTag.\n             if (!found) {\n                 boolean reqd = true;\n                 if (mAllowUndeclaredRTE) {\n                     reqd = !isUnchecked(documentedCI.getClazz());\n                 }\n \n                 if (reqd) {\n                     log(tag.getLineNo(), tag.getColumnNo(),\n-                            \"javadoc.unusedTag\", \"@throws\", tag.getArg1());\n+                        \"javadoc.unusedTag\",\n+                        JavadocTagInfo.THROWS.getText(), tag.getArg1());\n \n                 }\n             }\n         }\n \n         // Now dump out all throws without tags :- unless\n         // the user has chosen to suppress these problems\n         if (!mAllowMissingThrowsTags && aReportExpectedTags) {\n             for (ExceptionInfo ei : aThrows) {\n                 if (!ei.isFound()) {\n                     final Token fi = ei.getName();\n                     log(fi.getLineNo(), fi.getColumnNo(),\n-                            \"javadoc.expectedTag\", \"@throws\", fi.getText());\n+                        \"javadoc.expectedTag\",\n+                        JavadocTagInfo.THROWS.getText(), fi.getText());\n                 }\n             }\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"7552a0b72e07c9a0070e84789b5abe6d293de6e0": {
			"type": "Ybodychange",
			"commitMessage": "Drinking the \"Google Collections\" Kool-Aid.\n\nI like the reduced duplication.\n",
			"commitDate": "2008-04-22, 5:28 AM",
			"commitName": "7552a0b72e07c9a0070e84789b5abe6d293de6e0",
			"commitAuthor": "Oliver Burn",
			"commitDateOld": "2008-01-13, 11:18 PM",
			"commitNameOld": "4d715df131a0c5ae3a9f2eae6ecf636ab52eda0e",
			"commitAuthorOld": "Oliver Burn",
			"daysBetweenCommits": 99.21,
			"commitsBetweenForRepo": 31,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,65 +1,65 @@\n     private void checkThrowsTags(List<JavadocTag> aTags,\n             List<ExceptionInfo> aThrows, boolean aReportExpectedTags)\n     {\n         // Loop over the tags, checking to see they exist in the throws.\n         // The foundThrows used for performance only\n-        final Set<String> foundThrows = new HashSet<String>();\n+        final Set<String> foundThrows = Sets.newHashSet();\n         final ListIterator<JavadocTag> tagIt = aTags.listIterator();\n         while (tagIt.hasNext()) {\n             final JavadocTag tag = tagIt.next();\n \n             if (!tag.isThrowsTag()) {\n                 continue;\n             }\n \n             tagIt.remove();\n \n             // Loop looking for matching throw\n             final String documentedEx = tag.getArg1();\n             final Token token = new Token(tag.getArg1(), tag.getLineNo(), tag\n                     .getColumnNo());\n             final ClassInfo documentedCI = createClassInfo(token,\n                     getCurrentClassName());\n             boolean found = foundThrows.contains(documentedEx);\n \n             final ListIterator<ExceptionInfo> throwIt = aThrows.listIterator();\n             while (!found && throwIt.hasNext()) {\n                 final ExceptionInfo ei = throwIt.next();\n \n                 if (documentedCI.getClazz() == ei.getClazz()) {\n                     found = true;\n                     ei.setFound();\n                     foundThrows.add(documentedEx);\n                 }\n                 else if (mAllowThrowsTagsForSubclasses) {\n                     found = isSubclass(documentedCI.getClazz(), ei.getClazz());\n                 }\n             }\n \n             // Handle extra JavadocTag.\n             if (!found) {\n                 boolean reqd = true;\n                 if (mAllowUndeclaredRTE) {\n                     reqd = !isUnchecked(documentedCI.getClazz());\n                 }\n \n                 if (reqd) {\n                     log(tag.getLineNo(), tag.getColumnNo(),\n                             \"javadoc.unusedTag\", \"@throws\", tag.getArg1());\n \n                 }\n             }\n         }\n \n         // Now dump out all throws without tags :- unless\n         // the user has chosen to suppress these problems\n         if (!mAllowMissingThrowsTags && aReportExpectedTags) {\n             for (ExceptionInfo ei : aThrows) {\n                 if (!ei.isFound()) {\n                     final Token fi = ei.getName();\n                     log(fi.getLineNo(), fi.getColumnNo(),\n                             \"javadoc.expectedTag\", \"@throws\", fi.getText());\n                 }\n             }\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"e50e1fcd1c17ba1f73d11df38382907cc163a1d1": {
			"type": "Ybodychange",
			"commitMessage": "Use the new syntactic sugar \"for loop\".\n\nEnd of the cosmetic changes.\n",
			"commitDate": "2007-12-15, 2:28 AM",
			"commitName": "e50e1fcd1c17ba1f73d11df38382907cc163a1d1",
			"commitAuthor": "Oliver Burn",
			"commitDateOld": "2007-12-14, 8:51 PM",
			"commitNameOld": "85a9c1f13f06baf70c00e62d8bb91507aeb3a72d",
			"commitAuthorOld": "Oliver Burn",
			"daysBetweenCommits": 0.23,
			"commitsBetweenForRepo": 5,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,67 +1,65 @@\n     private void checkThrowsTags(List<JavadocTag> aTags,\n             List<ExceptionInfo> aThrows, boolean aReportExpectedTags)\n     {\n         // Loop over the tags, checking to see they exist in the throws.\n         // The foundThrows used for performance only\n         final Set<String> foundThrows = new HashSet<String>();\n         final ListIterator<JavadocTag> tagIt = aTags.listIterator();\n         while (tagIt.hasNext()) {\n             final JavadocTag tag = tagIt.next();\n \n             if (!tag.isThrowsTag()) {\n                 continue;\n             }\n \n             tagIt.remove();\n \n             // Loop looking for matching throw\n             final String documentedEx = tag.getArg1();\n             final Token token = new Token(tag.getArg1(), tag.getLineNo(), tag\n                     .getColumnNo());\n             final ClassInfo documentedCI = createClassInfo(token,\n                     getCurrentClassName());\n             boolean found = foundThrows.contains(documentedEx);\n \n             final ListIterator<ExceptionInfo> throwIt = aThrows.listIterator();\n             while (!found && throwIt.hasNext()) {\n                 final ExceptionInfo ei = throwIt.next();\n \n                 if (documentedCI.getClazz() == ei.getClazz()) {\n                     found = true;\n                     ei.setFound();\n                     foundThrows.add(documentedEx);\n                 }\n                 else if (mAllowThrowsTagsForSubclasses) {\n                     found = isSubclass(documentedCI.getClazz(), ei.getClazz());\n                 }\n             }\n \n             // Handle extra JavadocTag.\n             if (!found) {\n                 boolean reqd = true;\n                 if (mAllowUndeclaredRTE) {\n                     reqd = !isUnchecked(documentedCI.getClazz());\n                 }\n \n                 if (reqd) {\n                     log(tag.getLineNo(), tag.getColumnNo(),\n                             \"javadoc.unusedTag\", \"@throws\", tag.getArg1());\n \n                 }\n             }\n         }\n \n         // Now dump out all throws without tags :- unless\n         // the user has chosen to suppress these problems\n         if (!mAllowMissingThrowsTags && aReportExpectedTags) {\n-            final ListIterator<ExceptionInfo> throwIt = aThrows.listIterator();\n-            while (throwIt.hasNext()) {\n-                final ExceptionInfo ei = throwIt.next();\n+            for (ExceptionInfo ei : aThrows) {\n                 if (!ei.isFound()) {\n                     final Token fi = ei.getName();\n                     log(fi.getLineNo(), fi.getColumnNo(),\n                             \"javadoc.expectedTag\", \"@throws\", fi.getText());\n                 }\n             }\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"85a9c1f13f06baf70c00e62d8bb91507aeb3a72d": {
			"type": "Ymultichange(Yparameterchange,Ybodychange)",
			"commitMessage": "Start of adding generics.\n",
			"commitDate": "2007-12-14, 8:51 PM",
			"commitName": "85a9c1f13f06baf70c00e62d8bb91507aeb3a72d",
			"commitAuthor": "Oliver Burn",
			"subchanges": [
				{
					"type": "Yparameterchange",
					"commitMessage": "Start of adding generics.\n",
					"commitDate": "2007-12-14, 8:51 PM",
					"commitName": "85a9c1f13f06baf70c00e62d8bb91507aeb3a72d",
					"commitAuthor": "Oliver Burn",
					"commitDateOld": "2007-01-27, 6:51 AM",
					"commitNameOld": "1efc394250b8f1c79bd7f8344b738a7d13396ed3",
					"commitAuthorOld": "Lars Kühne",
					"daysBetweenCommits": 321.58,
					"commitsBetweenForRepo": 29,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,66 +1,67 @@\n-    private void checkThrowsTags(List aTags, List aThrows,\n-        boolean aReportExpectedTags)\n+    private void checkThrowsTags(List<JavadocTag> aTags,\n+            List<ExceptionInfo> aThrows, boolean aReportExpectedTags)\n     {\n         // Loop over the tags, checking to see they exist in the throws.\n-        final Set foundThrows = new HashSet(); //used for performance only\n-        final ListIterator tagIt = aTags.listIterator();\n+        // The foundThrows used for performance only\n+        final Set<String> foundThrows = new HashSet<String>();\n+        final ListIterator<JavadocTag> tagIt = aTags.listIterator();\n         while (tagIt.hasNext()) {\n-            final JavadocTag tag = (JavadocTag) tagIt.next();\n+            final JavadocTag tag = tagIt.next();\n \n             if (!tag.isThrowsTag()) {\n                 continue;\n             }\n \n             tagIt.remove();\n \n             // Loop looking for matching throw\n             final String documentedEx = tag.getArg1();\n             final Token token = new Token(tag.getArg1(), tag.getLineNo(), tag\n                     .getColumnNo());\n             final ClassInfo documentedCI = createClassInfo(token,\n                     getCurrentClassName());\n             boolean found = foundThrows.contains(documentedEx);\n \n-            final ListIterator throwIt = aThrows.listIterator();\n+            final ListIterator<ExceptionInfo> throwIt = aThrows.listIterator();\n             while (!found && throwIt.hasNext()) {\n-                final ExceptionInfo ei = (ExceptionInfo) throwIt.next();\n+                final ExceptionInfo ei = throwIt.next();\n \n                 if (documentedCI.getClazz() == ei.getClazz()) {\n                     found = true;\n                     ei.setFound();\n                     foundThrows.add(documentedEx);\n                 }\n                 else if (mAllowThrowsTagsForSubclasses) {\n                     found = isSubclass(documentedCI.getClazz(), ei.getClazz());\n                 }\n             }\n \n             // Handle extra JavadocTag.\n             if (!found) {\n                 boolean reqd = true;\n                 if (mAllowUndeclaredRTE) {\n                     reqd = !isUnchecked(documentedCI.getClazz());\n                 }\n \n                 if (reqd) {\n                     log(tag.getLineNo(), tag.getColumnNo(),\n                             \"javadoc.unusedTag\", \"@throws\", tag.getArg1());\n \n                 }\n             }\n         }\n \n         // Now dump out all throws without tags :- unless\n         // the user has chosen to suppress these problems\n         if (!mAllowMissingThrowsTags && aReportExpectedTags) {\n-            final ListIterator throwIt = aThrows.listIterator();\n+            final ListIterator<ExceptionInfo> throwIt = aThrows.listIterator();\n             while (throwIt.hasNext()) {\n-                final ExceptionInfo ei = (ExceptionInfo) throwIt.next();\n+                final ExceptionInfo ei = throwIt.next();\n                 if (!ei.isFound()) {\n                     final Token fi = ei.getName();\n                     log(fi.getLineNo(), fi.getColumnNo(),\n                             \"javadoc.expectedTag\", \"@throws\", fi.getText());\n                 }\n             }\n         }\n     }\n\\ No newline at end of file\n",
					"extendedDetails": {
						"oldValue": "[aTags-List, aThrows-List, aReportExpectedTags-boolean]",
						"newValue": "[aTags-List<JavadocTag>, aThrows-List<ExceptionInfo>, aReportExpectedTags-boolean]"
					}
				},
				{
					"type": "Ybodychange",
					"commitMessage": "Start of adding generics.\n",
					"commitDate": "2007-12-14, 8:51 PM",
					"commitName": "85a9c1f13f06baf70c00e62d8bb91507aeb3a72d",
					"commitAuthor": "Oliver Burn",
					"commitDateOld": "2007-01-27, 6:51 AM",
					"commitNameOld": "1efc394250b8f1c79bd7f8344b738a7d13396ed3",
					"commitAuthorOld": "Lars Kühne",
					"daysBetweenCommits": 321.58,
					"commitsBetweenForRepo": 29,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,66 +1,67 @@\n-    private void checkThrowsTags(List aTags, List aThrows,\n-        boolean aReportExpectedTags)\n+    private void checkThrowsTags(List<JavadocTag> aTags,\n+            List<ExceptionInfo> aThrows, boolean aReportExpectedTags)\n     {\n         // Loop over the tags, checking to see they exist in the throws.\n-        final Set foundThrows = new HashSet(); //used for performance only\n-        final ListIterator tagIt = aTags.listIterator();\n+        // The foundThrows used for performance only\n+        final Set<String> foundThrows = new HashSet<String>();\n+        final ListIterator<JavadocTag> tagIt = aTags.listIterator();\n         while (tagIt.hasNext()) {\n-            final JavadocTag tag = (JavadocTag) tagIt.next();\n+            final JavadocTag tag = tagIt.next();\n \n             if (!tag.isThrowsTag()) {\n                 continue;\n             }\n \n             tagIt.remove();\n \n             // Loop looking for matching throw\n             final String documentedEx = tag.getArg1();\n             final Token token = new Token(tag.getArg1(), tag.getLineNo(), tag\n                     .getColumnNo());\n             final ClassInfo documentedCI = createClassInfo(token,\n                     getCurrentClassName());\n             boolean found = foundThrows.contains(documentedEx);\n \n-            final ListIterator throwIt = aThrows.listIterator();\n+            final ListIterator<ExceptionInfo> throwIt = aThrows.listIterator();\n             while (!found && throwIt.hasNext()) {\n-                final ExceptionInfo ei = (ExceptionInfo) throwIt.next();\n+                final ExceptionInfo ei = throwIt.next();\n \n                 if (documentedCI.getClazz() == ei.getClazz()) {\n                     found = true;\n                     ei.setFound();\n                     foundThrows.add(documentedEx);\n                 }\n                 else if (mAllowThrowsTagsForSubclasses) {\n                     found = isSubclass(documentedCI.getClazz(), ei.getClazz());\n                 }\n             }\n \n             // Handle extra JavadocTag.\n             if (!found) {\n                 boolean reqd = true;\n                 if (mAllowUndeclaredRTE) {\n                     reqd = !isUnchecked(documentedCI.getClazz());\n                 }\n \n                 if (reqd) {\n                     log(tag.getLineNo(), tag.getColumnNo(),\n                             \"javadoc.unusedTag\", \"@throws\", tag.getArg1());\n \n                 }\n             }\n         }\n \n         // Now dump out all throws without tags :- unless\n         // the user has chosen to suppress these problems\n         if (!mAllowMissingThrowsTags && aReportExpectedTags) {\n-            final ListIterator throwIt = aThrows.listIterator();\n+            final ListIterator<ExceptionInfo> throwIt = aThrows.listIterator();\n             while (throwIt.hasNext()) {\n-                final ExceptionInfo ei = (ExceptionInfo) throwIt.next();\n+                final ExceptionInfo ei = throwIt.next();\n                 if (!ei.isFound()) {\n                     final Token fi = ei.getName();\n                     log(fi.getLineNo(), fi.getColumnNo(),\n                             \"javadoc.expectedTag\", \"@throws\", fi.getText());\n                 }\n             }\n         }\n     }\n\\ No newline at end of file\n",
					"extendedDetails": {}
				}
			]
		},
		"35d1673788bbbac8263fdb69275dc6a63b095a24": {
			"type": "Ybodychange",
			"commitMessage": "Making local variables final where possible.\n",
			"commitDate": "2006-07-06, 8:44 PM",
			"commitName": "35d1673788bbbac8263fdb69275dc6a63b095a24",
			"commitAuthor": "Oliver Burn",
			"commitDateOld": "2006-05-22, 6:49 AM",
			"commitNameOld": "0a72322796c28266f07df8af6f7e000aa9cf0e48",
			"commitAuthorOld": "Oliver Burn",
			"daysBetweenCommits": 45.58,
			"commitsBetweenForRepo": 9,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,66 +1,66 @@\n     private void checkThrowsTags(List aTags, List aThrows,\n         boolean aReportExpectedTags)\n     {\n         // Loop over the tags, checking to see they exist in the throws.\n         final Set foundThrows = new HashSet(); //used for performance only\n         final ListIterator tagIt = aTags.listIterator();\n         while (tagIt.hasNext()) {\n             final JavadocTag tag = (JavadocTag) tagIt.next();\n \n             if (!tag.isThrowsTag()) {\n                 continue;\n             }\n \n             tagIt.remove();\n \n             // Loop looking for matching throw\n             final String documentedEx = tag.getArg1();\n-            Token token = new Token(tag.getArg1(), tag.getLineNo(), tag\n+            final Token token = new Token(tag.getArg1(), tag.getLineNo(), tag\n                     .getColumnNo());\n-            ClassInfo documentedCI = createClassInfo(token,\n+            final ClassInfo documentedCI = createClassInfo(token,\n                     getCurrentClassName());\n             boolean found = foundThrows.contains(documentedEx);\n \n             final ListIterator throwIt = aThrows.listIterator();\n             while (!found && throwIt.hasNext()) {\n                 final ExceptionInfo ei = (ExceptionInfo) throwIt.next();\n \n                 if (documentedCI.getClazz() == ei.getClazz()) {\n                     found = true;\n                     ei.setFound();\n                     foundThrows.add(documentedEx);\n                 }\n                 else if (mAllowThrowsTagsForSubclasses) {\n                     found = isSubclass(documentedCI.getClazz(), ei.getClazz());\n                 }\n             }\n \n             // Handle extra JavadocTag.\n             if (!found) {\n                 boolean reqd = true;\n                 if (mAllowUndeclaredRTE) {\n                     reqd = !isUnchecked(documentedCI.getClazz());\n                 }\n \n                 if (reqd) {\n                     log(tag.getLineNo(), tag.getColumnNo(),\n                             \"javadoc.unusedTag\", \"@throws\", tag.getArg1());\n \n                 }\n             }\n         }\n \n         // Now dump out all throws without tags :- unless\n         // the user has chosen to suppress these problems\n         if (!mAllowMissingThrowsTags && aReportExpectedTags) {\n             final ListIterator throwIt = aThrows.listIterator();\n             while (throwIt.hasNext()) {\n                 final ExceptionInfo ei = (ExceptionInfo) throwIt.next();\n                 if (!ei.isFound()) {\n                     final Token fi = ei.getName();\n                     log(fi.getLineNo(), fi.getColumnNo(),\n                             \"javadoc.expectedTag\", \"@throws\", fi.getText());\n                 }\n             }\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"788b41973d5747c7b4699a853b62168cf0001df6": {
			"type": "Ybodychange",
			"commitMessage": "Changes to make it possible to identify a module by an id, and then to\nsuppress messages based on the id. The motivation is to allow for finer\ngrained suppressions. For example, can enable multiple instances of the\nRegexp check, and suppress on the individual instance.\n",
			"commitDate": "2005-12-29, 4:35 AM",
			"commitName": "788b41973d5747c7b4699a853b62168cf0001df6",
			"commitAuthor": "Oliver Burn",
			"commitDateOld": "2005-12-15, 6:38 AM",
			"commitNameOld": "dfbaeedf8bc0d68b55699b79ed0d8ff094e444f0",
			"commitAuthorOld": "Oleg Sukhodolsky",
			"daysBetweenCommits": 13.91,
			"commitsBetweenForRepo": 4,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,68 +1,66 @@\n     private void checkThrowsTags(List aTags, List aThrows,\n                                  boolean aReportExpectedTags)\n     {\n         // Loop over the tags, checking to see they exist in the throws.\n         final Set foundThrows = new HashSet(); //used for performance only\n         final ListIterator tagIt = aTags.listIterator();\n         while (tagIt.hasNext()) {\n             final JavadocTag tag = (JavadocTag) tagIt.next();\n \n             if (!tag.isThrowsTag()) {\n                 continue;\n             }\n \n             tagIt.remove();\n \n             // Loop looking for matching throw\n             final String documentedEx = tag.getArg1();\n             Token token = new Token(tag.getArg1(), tag.getLineNo(),\n                                     tag.getColumnNo());\n             ClassInfo documentedCI =\n                 createClassInfo(token, getCurrentClassName());\n             boolean found = foundThrows.contains(documentedEx);\n \n             final ListIterator throwIt = aThrows.listIterator();\n             while (!found && throwIt.hasNext()) {\n                 final ExceptionInfo ei = (ExceptionInfo) throwIt.next();\n-                final Token fi = ei.getName();\n-                final String declaredEx = fi.getText();\n \n                 if (documentedCI.getClazz() == ei.getClazz()) {\n                     found = true;\n                     ei.setFound();\n                     foundThrows.add(documentedEx);\n                 }\n                 else if (mAllowThrowsTagsForSubclasses) {\n                     found = isSubclass(documentedCI.getClazz(), ei.getClazz());\n                 }\n             }\n \n             // Handle extra JavadocTag.\n             if (!found) {\n                 boolean reqd = true;\n                 if (mAllowUndeclaredRTE) {\n                     reqd = !isUnchecked(documentedCI.getClazz());\n                 }\n \n                 if (reqd) {\n                     log(tag.getLineNo(), tag.getColumnNo(),\n                         \"javadoc.unusedTag\", \"@throws\", tag.getArg1());\n \n                 }\n             }\n         }\n \n         // Now dump out all throws without tags :- unless\n         // the user has chosen to suppress these problems\n         if (!mAllowMissingThrowsTags && aReportExpectedTags) {\n             final ListIterator throwIt = aThrows.listIterator();\n             while (throwIt.hasNext()) {\n                 final ExceptionInfo ei = (ExceptionInfo) throwIt.next();\n                 if (!ei.isFound()) {\n                     final Token fi = ei.getName();\n                     log(fi.getLineNo(), fi.getColumnNo(),\n                         \"javadoc.expectedTag\", \"@throws\", fi.getText());\n                 }\n             }\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"dfbaeedf8bc0d68b55699b79ed0d8ff094e444f0": {
			"type": "Ybodychange",
			"commitMessage": "fix for 1379666\n",
			"commitDate": "2005-12-15, 6:38 AM",
			"commitName": "dfbaeedf8bc0d68b55699b79ed0d8ff094e444f0",
			"commitAuthor": "Oleg Sukhodolsky",
			"commitDateOld": "2005-11-06, 3:54 AM",
			"commitNameOld": "ab1e3089135d74b0d8c3296d0074244ca89a55e2",
			"commitAuthorOld": "Oliver Burn",
			"daysBetweenCommits": 39.11,
			"commitsBetweenForRepo": 12,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,68 +1,68 @@\n     private void checkThrowsTags(List aTags, List aThrows,\n                                  boolean aReportExpectedTags)\n     {\n         // Loop over the tags, checking to see they exist in the throws.\n         final Set foundThrows = new HashSet(); //used for performance only\n         final ListIterator tagIt = aTags.listIterator();\n         while (tagIt.hasNext()) {\n             final JavadocTag tag = (JavadocTag) tagIt.next();\n \n             if (!tag.isThrowsTag()) {\n                 continue;\n             }\n \n             tagIt.remove();\n \n             // Loop looking for matching throw\n             final String documentedEx = tag.getArg1();\n             Token token = new Token(tag.getArg1(), tag.getLineNo(),\n                                     tag.getColumnNo());\n             ClassInfo documentedCI =\n                 createClassInfo(token, getCurrentClassName());\n             boolean found = foundThrows.contains(documentedEx);\n \n             final ListIterator throwIt = aThrows.listIterator();\n             while (!found && throwIt.hasNext()) {\n                 final ExceptionInfo ei = (ExceptionInfo) throwIt.next();\n                 final Token fi = ei.getName();\n                 final String declaredEx = fi.getText();\n \n-                if (isSameType(declaredEx, documentedEx)) {\n+                if (documentedCI.getClazz() == ei.getClazz()) {\n                     found = true;\n                     ei.setFound();\n                     foundThrows.add(documentedEx);\n                 }\n                 else if (mAllowThrowsTagsForSubclasses) {\n                     found = isSubclass(documentedCI.getClazz(), ei.getClazz());\n                 }\n             }\n \n             // Handle extra JavadocTag.\n             if (!found) {\n                 boolean reqd = true;\n                 if (mAllowUndeclaredRTE) {\n                     reqd = !isUnchecked(documentedCI.getClazz());\n                 }\n \n                 if (reqd) {\n                     log(tag.getLineNo(), tag.getColumnNo(),\n                         \"javadoc.unusedTag\", \"@throws\", tag.getArg1());\n \n                 }\n             }\n         }\n \n         // Now dump out all throws without tags :- unless\n         // the user has chosen to suppress these problems\n         if (!mAllowMissingThrowsTags && aReportExpectedTags) {\n             final ListIterator throwIt = aThrows.listIterator();\n             while (throwIt.hasNext()) {\n                 final ExceptionInfo ei = (ExceptionInfo) throwIt.next();\n                 if (!ei.isFound()) {\n                     final Token fi = ei.getName();\n                     log(fi.getLineNo(), fi.getColumnNo(),\n                         \"javadoc.expectedTag\", \"@throws\", fi.getText());\n                 }\n             }\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"cbe38280adb03f058f89e8ea81bc0e3be2fc5b94": {
			"type": "Ybodychange",
			"commitMessage": "Fixed 1249707: AbstractTypeAwareCheck doesn't work with types from typeparm\n\nSome pretty big refactoring for typeaware checks performed.\nAlso added handling for type params.  Current handling algorithm\nhas some preconditions and restriction, but it works for most cases\n(not sure I've covered all situation when type param will have name\nof real exception, but I do not think it is critical for now :)\n\nAlso, I've added column number for JavadocTag (mainly to be able use\nClassInfo for it).  So, JavadocTypeCheck also affected.\n\nAnd I've added new logger for TreeWalker (if we have loggers we should\nuse them :)\n",
			"commitDate": "2005-08-05, 6:33 AM",
			"commitName": "cbe38280adb03f058f89e8ea81bc0e3be2fc5b94",
			"commitAuthor": "Oleg Sukhodolsky",
			"commitDateOld": "2005-07-03, 2:37 AM",
			"commitNameOld": "b106eab0414affa16fbc0e2dfce511e3aed9d557",
			"commitAuthorOld": "Lars Kühne",
			"daysBetweenCommits": 33.16,
			"commitsBetweenForRepo": 26,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,73 +1,68 @@\n     private void checkThrowsTags(List aTags, List aThrows,\n                                  boolean aReportExpectedTags)\n     {\n         // Loop over the tags, checking to see they exist in the throws.\n         final Set foundThrows = new HashSet(); //used for performance only\n         final ListIterator tagIt = aTags.listIterator();\n         while (tagIt.hasNext()) {\n             final JavadocTag tag = (JavadocTag) tagIt.next();\n \n             if (!tag.isThrowsTag()) {\n                 continue;\n             }\n \n             tagIt.remove();\n \n             // Loop looking for matching throw\n             final String documentedEx = tag.getArg1();\n+            Token token = new Token(tag.getArg1(), tag.getLineNo(),\n+                                    tag.getColumnNo());\n+            ClassInfo documentedCI =\n+                createClassInfo(token, getCurrentClassName());\n             boolean found = foundThrows.contains(documentedEx);\n-            Class documentedClass = null;\n-            boolean classLoaded = false;\n \n             final ListIterator throwIt = aThrows.listIterator();\n             while (!found && throwIt.hasNext()) {\n                 final ExceptionInfo ei = (ExceptionInfo) throwIt.next();\n-                final FullIdent fi = ei.getName();\n+                final Token fi = ei.getName();\n                 final String declaredEx = fi.getText();\n \n                 if (isSameType(declaredEx, documentedEx)) {\n                     found = true;\n                     ei.setFound();\n                     foundThrows.add(documentedEx);\n                 }\n                 else if (mAllowThrowsTagsForSubclasses) {\n-                    if (!classLoaded) {\n-                        documentedClass = loadClassForTag(tag);\n-                        classLoaded = true;\n-                    }\n-                    found = isSubclass(documentedClass, ei.getClazz());\n+                    found = isSubclass(documentedCI.getClazz(), ei.getClazz());\n                 }\n             }\n \n             // Handle extra JavadocTag.\n             if (!found) {\n                 boolean reqd = true;\n                 if (mAllowUndeclaredRTE) {\n-                    if (!classLoaded) {\n-                        documentedClass = loadClassForTag(tag);\n-                        classLoaded = true;\n-                    }\n-                    reqd = !isUnchecked(documentedClass);\n+                    reqd = !isUnchecked(documentedCI.getClazz());\n                 }\n \n                 if (reqd) {\n-                    log(tag.getLineNo(), \"javadoc.unusedTag\", \"@throws\", tag\n-                        .getArg1());\n+                    log(tag.getLineNo(), tag.getColumnNo(),\n+                        \"javadoc.unusedTag\", \"@throws\", tag.getArg1());\n+\n                 }\n             }\n         }\n \n         // Now dump out all throws without tags :- unless\n         // the user has chosen to suppress these problems\n         if (!mAllowMissingThrowsTags && aReportExpectedTags) {\n             final ListIterator throwIt = aThrows.listIterator();\n             while (throwIt.hasNext()) {\n                 final ExceptionInfo ei = (ExceptionInfo) throwIt.next();\n                 if (!ei.isFound()) {\n-                    final FullIdent fi = ei.getName();\n+                    final Token fi = ei.getName();\n                     log(fi.getLineNo(), fi.getColumnNo(),\n                         \"javadoc.expectedTag\", \"@throws\", fi.getText());\n                 }\n             }\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"72be23f288369fdd9e562999bb9b0e2ff646c897": {
			"type": "Ymultichange(Yparameterchange,Ybodychange)",
			"commitMessage": "Fix for 855839 - JavadocMethod does not correctly treat {@inheritDoc}.\n",
			"commitDate": "2003-12-08, 10:58 AM",
			"commitName": "72be23f288369fdd9e562999bb9b0e2ff646c897",
			"commitAuthor": "Oleg Sukhodolsky",
			"subchanges": [
				{
					"type": "Yparameterchange",
					"commitMessage": "Fix for 855839 - JavadocMethod does not correctly treat {@inheritDoc}.\n",
					"commitDate": "2003-12-08, 10:58 AM",
					"commitName": "72be23f288369fdd9e562999bb9b0e2ff646c897",
					"commitAuthor": "Oleg Sukhodolsky",
					"commitDateOld": "2003-11-23, 10:45 PM",
					"commitNameOld": "8fb2acd39b7db6223486f5e06126c7f0a2642a72",
					"commitAuthorOld": "Lars Kühne",
					"daysBetweenCommits": 14.51,
					"commitsBetweenForRepo": 8,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,71 +1,72 @@\n-    private void checkThrowsTags(List aTags, List aThrows)\n+    private void checkThrowsTags(List aTags, List aThrows,\n+                                 boolean aReportExpectedTags)\n     {\n         // Loop over the tags, checking to see they exist in the throws.\n         final Set foundThrows = new HashSet(); //used for performance only\n         final ListIterator tagIt = aTags.listIterator();\n         while (tagIt.hasNext()) {\n             final JavadocTag tag = (JavadocTag) tagIt.next();\n \n             if (!tag.isThrowsTag()) {\n                 continue;\n             }\n \n             tagIt.remove();\n \n             // Loop looking for matching throw\n             final String documentedEx = tag.getArg1();\n             boolean found = foundThrows.contains(documentedEx);\n             Class documentedClass = null;\n             boolean classLoaded = false;\n \n             final ListIterator throwIt = aThrows.listIterator();\n             while (!found && throwIt.hasNext()) {\n                 final ExceptionInfo ei = (ExceptionInfo) throwIt.next();\n                 final FullIdent fi = ei.getName();\n                 final String declaredEx = fi.getText();\n                 if (isSameType(declaredEx, documentedEx)) {\n                     found = true;\n                     ei.setFound();\n                     foundThrows.add(documentedEx);\n                 }\n                 else if (mAllowThrowsTagsForSubclasses) {\n                     if (!classLoaded) {\n                         documentedClass = loadClassForTag(tag);\n                         classLoaded = true;\n                     }\n                     found = isSubclass(documentedClass, ei.getClazz());\n                 }\n             }\n \n             // Handle extra JavadocTag.\n             if (!found) {\n                 boolean reqd = true;\n                 if (mAllowUndeclaredRTE) {\n                     if (!classLoaded) {\n                         documentedClass = loadClassForTag(tag);\n                         classLoaded = true;\n                     }\n                     reqd = !isUnchecked(documentedClass);\n                 }\n \n                 if (reqd) {\n                     log(tag.getLineNo(), \"javadoc.unusedTag\",\n                                   \"@throws\", tag.getArg1());\n                 }\n             }\n         }\n \n         // Now dump out all throws without tags :- unless\n         // the user has chosen to suppress these problems\n-        if (!mAllowMissingThrowsTags) {\n+        if (!mAllowMissingThrowsTags && aReportExpectedTags) {\n             final ListIterator throwIt = aThrows.listIterator();\n             while (throwIt.hasNext()) {\n                 final ExceptionInfo ei = (ExceptionInfo) throwIt.next();\n                 if (!ei.isFound()) {\n                     final FullIdent fi = ei.getName();\n                     log(fi.getLineNo(), fi.getColumnNo(),\n                         \"javadoc.expectedTag\", \"@throws\", fi.getText());\n                 }\n             }\n         }\n     }\n\\ No newline at end of file\n",
					"extendedDetails": {
						"oldValue": "[aTags-List, aThrows-List]",
						"newValue": "[aTags-List, aThrows-List, aReportExpectedTags-boolean]"
					}
				},
				{
					"type": "Ybodychange",
					"commitMessage": "Fix for 855839 - JavadocMethod does not correctly treat {@inheritDoc}.\n",
					"commitDate": "2003-12-08, 10:58 AM",
					"commitName": "72be23f288369fdd9e562999bb9b0e2ff646c897",
					"commitAuthor": "Oleg Sukhodolsky",
					"commitDateOld": "2003-11-23, 10:45 PM",
					"commitNameOld": "8fb2acd39b7db6223486f5e06126c7f0a2642a72",
					"commitAuthorOld": "Lars Kühne",
					"daysBetweenCommits": 14.51,
					"commitsBetweenForRepo": 8,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,71 +1,72 @@\n-    private void checkThrowsTags(List aTags, List aThrows)\n+    private void checkThrowsTags(List aTags, List aThrows,\n+                                 boolean aReportExpectedTags)\n     {\n         // Loop over the tags, checking to see they exist in the throws.\n         final Set foundThrows = new HashSet(); //used for performance only\n         final ListIterator tagIt = aTags.listIterator();\n         while (tagIt.hasNext()) {\n             final JavadocTag tag = (JavadocTag) tagIt.next();\n \n             if (!tag.isThrowsTag()) {\n                 continue;\n             }\n \n             tagIt.remove();\n \n             // Loop looking for matching throw\n             final String documentedEx = tag.getArg1();\n             boolean found = foundThrows.contains(documentedEx);\n             Class documentedClass = null;\n             boolean classLoaded = false;\n \n             final ListIterator throwIt = aThrows.listIterator();\n             while (!found && throwIt.hasNext()) {\n                 final ExceptionInfo ei = (ExceptionInfo) throwIt.next();\n                 final FullIdent fi = ei.getName();\n                 final String declaredEx = fi.getText();\n                 if (isSameType(declaredEx, documentedEx)) {\n                     found = true;\n                     ei.setFound();\n                     foundThrows.add(documentedEx);\n                 }\n                 else if (mAllowThrowsTagsForSubclasses) {\n                     if (!classLoaded) {\n                         documentedClass = loadClassForTag(tag);\n                         classLoaded = true;\n                     }\n                     found = isSubclass(documentedClass, ei.getClazz());\n                 }\n             }\n \n             // Handle extra JavadocTag.\n             if (!found) {\n                 boolean reqd = true;\n                 if (mAllowUndeclaredRTE) {\n                     if (!classLoaded) {\n                         documentedClass = loadClassForTag(tag);\n                         classLoaded = true;\n                     }\n                     reqd = !isUnchecked(documentedClass);\n                 }\n \n                 if (reqd) {\n                     log(tag.getLineNo(), \"javadoc.unusedTag\",\n                                   \"@throws\", tag.getArg1());\n                 }\n             }\n         }\n \n         // Now dump out all throws without tags :- unless\n         // the user has chosen to suppress these problems\n-        if (!mAllowMissingThrowsTags) {\n+        if (!mAllowMissingThrowsTags && aReportExpectedTags) {\n             final ListIterator throwIt = aThrows.listIterator();\n             while (throwIt.hasNext()) {\n                 final ExceptionInfo ei = (ExceptionInfo) throwIt.next();\n                 if (!ei.isFound()) {\n                     final FullIdent fi = ei.getName();\n                     log(fi.getLineNo(), fi.getColumnNo(),\n                         \"javadoc.expectedTag\", \"@throws\", fi.getText());\n                 }\n             }\n         }\n     }\n\\ No newline at end of file\n",
					"extendedDetails": {}
				}
			]
		},
		"753a3a0c9708a7c050efd1dad93c37b424cf5c73": {
			"type": "Ybodychange",
			"commitMessage": "Cleaned fix for 803577 :)\n",
			"commitDate": "2003-09-10, 8:55 PM",
			"commitName": "753a3a0c9708a7c050efd1dad93c37b424cf5c73",
			"commitAuthor": "Oleg Sukhodolsky",
			"commitDateOld": "2003-09-10, 8:53 PM",
			"commitNameOld": "2acda3b12797a818467773758f1029f7057a271c",
			"commitAuthorOld": "Oleg Sukhodolsky",
			"daysBetweenCommits": 0,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,74 +1,71 @@\n     private void checkThrowsTags(List aTags, List aThrows)\n     {\n         // Loop over the tags, checking to see they exist in the throws.\n         final Set foundThrows = new HashSet(); //used for performance only\n         final ListIterator tagIt = aTags.listIterator();\n         while (tagIt.hasNext()) {\n             final JavadocTag tag = (JavadocTag) tagIt.next();\n \n             if (!tag.isThrowsTag()) {\n                 continue;\n             }\n \n             tagIt.remove();\n \n             // Loop looking for matching throw\n             final String documentedEx = tag.getArg1();\n             boolean found = foundThrows.contains(documentedEx);\n             Class documentedClass = null;\n             boolean classLoaded = false;\n \n             final ListIterator throwIt = aThrows.listIterator();\n             while (!found && throwIt.hasNext()) {\n                 final ExceptionInfo ei = (ExceptionInfo) throwIt.next();\n                 final FullIdent fi = ei.getName();\n                 final String declaredEx = fi.getText();\n                 if (isSameType(declaredEx, documentedEx)) {\n                     found = true;\n                     ei.setFound();\n                     foundThrows.add(documentedEx);\n                 }\n                 else if (mAllowThrowsTagsForSubclasses) {\n                     if (!classLoaded) {\n                         documentedClass = loadClassForTag(tag);\n                         classLoaded = true;\n                     }\n                     found = isSubclass(documentedClass, ei.getClazz());\n-//                     if (found) {\n-//                         ei.setFound();\n-//                     }\n                 }\n             }\n \n             // Handle extra JavadocTag.\n             if (!found) {\n                 boolean reqd = true;\n                 if (mAllowUndeclaredRTE) {\n                     if (!classLoaded) {\n                         documentedClass = loadClassForTag(tag);\n                         classLoaded = true;\n                     }\n                     reqd = !isUnchecked(documentedClass);\n                 }\n \n                 if (reqd) {\n                     log(tag.getLineNo(), \"javadoc.unusedTag\",\n                                   \"@throws\", tag.getArg1());\n                 }\n             }\n         }\n \n         // Now dump out all throws without tags :- unless\n         // the user has chosen to suppress these problems\n         if (!mAllowMissingThrowsTags) {\n             final ListIterator throwIt = aThrows.listIterator();\n             while (throwIt.hasNext()) {\n                 final ExceptionInfo ei = (ExceptionInfo) throwIt.next();\n                 if (!ei.isFound()) {\n                     final FullIdent fi = ei.getName();\n                     log(fi.getLineNo(), fi.getColumnNo(),\n                         \"javadoc.expectedTag\", \"@throws\", fi.getText());\n                 }\n             }\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"2acda3b12797a818467773758f1029f7057a271c": {
			"type": "Ybodychange",
			"commitMessage": "Fix for 803577 (allowThrowsTagsForSubclasses/allowMissingThrowsTag interfere)\n",
			"commitDate": "2003-09-10, 8:53 PM",
			"commitName": "2acda3b12797a818467773758f1029f7057a271c",
			"commitAuthor": "Oleg Sukhodolsky",
			"commitDateOld": "2003-08-07, 1:46 AM",
			"commitNameOld": "15b8debf99b3b0c600084fccde54d9562bd48b71",
			"commitAuthorOld": "Oleg Sukhodolsky",
			"daysBetweenCommits": 34.8,
			"commitsBetweenForRepo": 57,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,74 +1,74 @@\n     private void checkThrowsTags(List aTags, List aThrows)\n     {\n         // Loop over the tags, checking to see they exist in the throws.\n         final Set foundThrows = new HashSet(); //used for performance only\n         final ListIterator tagIt = aTags.listIterator();\n         while (tagIt.hasNext()) {\n             final JavadocTag tag = (JavadocTag) tagIt.next();\n \n             if (!tag.isThrowsTag()) {\n                 continue;\n             }\n \n             tagIt.remove();\n \n             // Loop looking for matching throw\n             final String documentedEx = tag.getArg1();\n             boolean found = foundThrows.contains(documentedEx);\n             Class documentedClass = null;\n             boolean classLoaded = false;\n \n             final ListIterator throwIt = aThrows.listIterator();\n             while (!found && throwIt.hasNext()) {\n                 final ExceptionInfo ei = (ExceptionInfo) throwIt.next();\n                 final FullIdent fi = ei.getName();\n                 final String declaredEx = fi.getText();\n                 if (isSameType(declaredEx, documentedEx)) {\n                     found = true;\n                     ei.setFound();\n                     foundThrows.add(documentedEx);\n                 }\n                 else if (mAllowThrowsTagsForSubclasses) {\n                     if (!classLoaded) {\n                         documentedClass = loadClassForTag(tag);\n                         classLoaded = true;\n                     }\n                     found = isSubclass(documentedClass, ei.getClazz());\n-                    if (found) {\n-                        ei.setFound();\n-                    }\n+//                     if (found) {\n+//                         ei.setFound();\n+//                     }\n                 }\n             }\n \n             // Handle extra JavadocTag.\n             if (!found) {\n                 boolean reqd = true;\n                 if (mAllowUndeclaredRTE) {\n                     if (!classLoaded) {\n                         documentedClass = loadClassForTag(tag);\n                         classLoaded = true;\n                     }\n                     reqd = !isUnchecked(documentedClass);\n                 }\n \n                 if (reqd) {\n                     log(tag.getLineNo(), \"javadoc.unusedTag\",\n                                   \"@throws\", tag.getArg1());\n                 }\n             }\n         }\n \n         // Now dump out all throws without tags :- unless\n         // the user has chosen to suppress these problems\n         if (!mAllowMissingThrowsTags) {\n             final ListIterator throwIt = aThrows.listIterator();\n             while (throwIt.hasNext()) {\n                 final ExceptionInfo ei = (ExceptionInfo) throwIt.next();\n                 if (!ei.isFound()) {\n                     final FullIdent fi = ei.getName();\n                     log(fi.getLineNo(), fi.getColumnNo(),\n                         \"javadoc.expectedTag\", \"@throws\", fi.getText());\n                 }\n             }\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"15b8debf99b3b0c600084fccde54d9562bd48b71": {
			"type": "Ybodychange",
			"commitMessage": "Fix for 784015 (Unable to get class information errors).\n",
			"commitDate": "2003-08-07, 1:46 AM",
			"commitName": "15b8debf99b3b0c600084fccde54d9562bd48b71",
			"commitAuthor": "Oleg Sukhodolsky",
			"commitDateOld": "2003-08-02, 5:02 AM",
			"commitNameOld": "cd89321522d9bf7fc10547e743fb8bbb4c993791",
			"commitAuthorOld": "Oleg Sukhodolsky",
			"daysBetweenCommits": 4.86,
			"commitsBetweenForRepo": 5,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,86 +1,74 @@\n     private void checkThrowsTags(List aTags, List aThrows)\n     {\n         // Loop over the tags, checking to see they exist in the throws.\n         final Set foundThrows = new HashSet(); //used for performance only\n         final ListIterator tagIt = aTags.listIterator();\n         while (tagIt.hasNext()) {\n             final JavadocTag tag = (JavadocTag) tagIt.next();\n \n             if (!tag.isThrowsTag()) {\n                 continue;\n             }\n \n             tagIt.remove();\n \n             // Loop looking for matching throw\n             final String documentedEx = tag.getArg1();\n             boolean found = foundThrows.contains(documentedEx);\n             Class documentedClass = null;\n-            if (!found\n-                && (mAllowThrowsTagsForSubclasses || mAllowUndeclaredRTE))\n-            {\n-                documentedClass = resolveClass(documentedEx);\n-                if (documentedClass == null) {\n-                    log(tag.getLineNo(), \"javadoc.classInfo\",\n-                        \"@throws\", documentedEx);\n-                }\n-            }\n+            boolean classLoaded = false;\n \n             final ListIterator throwIt = aThrows.listIterator();\n             while (!found && throwIt.hasNext()) {\n                 final ExceptionInfo ei = (ExceptionInfo) throwIt.next();\n                 final FullIdent fi = ei.getName();\n                 final String declaredEx = fi.getText();\n                 if (isSameType(declaredEx, documentedEx)) {\n                     found = true;\n                     ei.setFound();\n                     foundThrows.add(documentedEx);\n                 }\n-                else if (mAllowThrowsTagsForSubclasses\n-                         && documentedClass != null)\n-                {\n-                    if (ei.isLoadable() && ei.getClazz() == null) {\n-                        // if the class is not loaded yet.\n-                        // try to load it.\n-                        ei.setClazz(resolveClass(declaredEx));\n-                        if (!ei.isLoadable()) {\n-                            log(fi.getLineNo(), \"javadoc.classInfo\",\n-                                \"@throws\", declaredEx);\n-                        }\n+                else if (mAllowThrowsTagsForSubclasses) {\n+                    if (!classLoaded) {\n+                        documentedClass = loadClassForTag(tag);\n+                        classLoaded = true;\n                     }\n-\n                     found = isSubclass(documentedClass, ei.getClazz());\n                     if (found) {\n                         ei.setFound();\n                     }\n                 }\n             }\n \n             // Handle extra JavadocTag.\n             if (!found) {\n                 boolean reqd = true;\n-                if (mAllowUndeclaredRTE && documentedClass != null) {\n+                if (mAllowUndeclaredRTE) {\n+                    if (!classLoaded) {\n+                        documentedClass = loadClassForTag(tag);\n+                        classLoaded = true;\n+                    }\n                     reqd = !isUnchecked(documentedClass);\n                 }\n \n                 if (reqd) {\n                     log(tag.getLineNo(), \"javadoc.unusedTag\",\n                                   \"@throws\", tag.getArg1());\n                 }\n             }\n         }\n \n         // Now dump out all throws without tags :- unless\n         // the user has chosen to suppress these problems\n         if (!mAllowMissingThrowsTags) {\n             final ListIterator throwIt = aThrows.listIterator();\n             while (throwIt.hasNext()) {\n                 final ExceptionInfo ei = (ExceptionInfo) throwIt.next();\n                 if (!ei.isFound()) {\n                     final FullIdent fi = ei.getName();\n                     log(fi.getLineNo(), fi.getColumnNo(),\n                         \"javadoc.expectedTag\", \"@throws\", fi.getText());\n                 }\n             }\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"cd89321522d9bf7fc10547e743fb8bbb4c993791": {
			"type": "Ybodychange",
			"commitMessage": "Refactoring of RedundantThrows and JavadocMethod checks to minimize\nnumber of \"Unable to get class info\" errors.\n",
			"commitDate": "2003-08-02, 5:02 AM",
			"commitName": "cd89321522d9bf7fc10547e743fb8bbb4c993791",
			"commitAuthor": "Oleg Sukhodolsky",
			"commitDateOld": "2003-07-21, 12:08 PM",
			"commitNameOld": "6e1e8b738d29d67575fb3390864ea786f19725e3",
			"commitAuthorOld": "Rick Giles",
			"daysBetweenCommits": 11.7,
			"commitsBetweenForRepo": 9,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,89 +1,86 @@\n     private void checkThrowsTags(List aTags, List aThrows)\n     {\n         // Loop over the tags, checking to see they exist in the throws.\n         final Set foundThrows = new HashSet(); //used for performance only\n         final ListIterator tagIt = aTags.listIterator();\n         while (tagIt.hasNext()) {\n             final JavadocTag tag = (JavadocTag) tagIt.next();\n \n             if (!tag.isThrowsTag()) {\n                 continue;\n             }\n \n             tagIt.remove();\n \n             // Loop looking for matching throw\n             final String documentedEx = tag.getArg1();\n             boolean found = foundThrows.contains(documentedEx);\n+            Class documentedClass = null;\n+            if (!found\n+                && (mAllowThrowsTagsForSubclasses || mAllowUndeclaredRTE))\n+            {\n+                documentedClass = resolveClass(documentedEx);\n+                if (documentedClass == null) {\n+                    log(tag.getLineNo(), \"javadoc.classInfo\",\n+                        \"@throws\", documentedEx);\n+                }\n+            }\n+\n             final ListIterator throwIt = aThrows.listIterator();\n             while (!found && throwIt.hasNext()) {\n                 final ExceptionInfo ei = (ExceptionInfo) throwIt.next();\n-                final FullIdent fi = ei.getFullIdent();\n+                final FullIdent fi = ei.getName();\n                 final String declaredEx = fi.getText();\n                 if (isSameType(declaredEx, documentedEx)) {\n                     found = true;\n                     ei.setFound();\n                     foundThrows.add(documentedEx);\n                 }\n-                else if (mAllowThrowsTagsForSubclasses) {\n-                    final ClassResolver cr = getClassResolver();\n-                    try {\n-                        final Class documentedClass = cr.resolve(documentedEx);\n-                        try {\n-                            final Class declaredClass = cr.resolve(declaredEx);\n-                            found =\n-                                declaredClass.isAssignableFrom(documentedClass);\n-                            if (found) {\n-                                ei.setFound();\n-                            }\n-                        }\n-                        catch (ClassNotFoundException e) {\n-                            log(tag.getLineNo(), \"javadoc.classInfo\",\n+                else if (mAllowThrowsTagsForSubclasses\n+                         && documentedClass != null)\n+                {\n+                    if (ei.isLoadable() && ei.getClazz() == null) {\n+                        // if the class is not loaded yet.\n+                        // try to load it.\n+                        ei.setClazz(resolveClass(declaredEx));\n+                        if (!ei.isLoadable()) {\n+                            log(fi.getLineNo(), \"javadoc.classInfo\",\n                                 \"@throws\", declaredEx);\n                         }\n                     }\n-                    catch (ClassNotFoundException e) {\n-                        log(tag.getLineNo(), \"javadoc.classInfo\",\n-                                      \"@throws\", documentedEx);\n+\n+                    found = isSubclass(documentedClass, ei.getClazz());\n+                    if (found) {\n+                        ei.setFound();\n                     }\n                 }\n             }\n \n             // Handle extra JavadocTag.\n             if (!found) {\n                 boolean reqd = true;\n-                if (mAllowUndeclaredRTE) {\n-                    final ClassResolver cr = getClassResolver();\n-                    try {\n-                        final Class clazz = cr.resolve(tag.getArg1());\n-                        reqd =\n-                            !RuntimeException.class.isAssignableFrom(clazz)\n-                                && !Error.class.isAssignableFrom(clazz);\n-                    }\n-                    catch (ClassNotFoundException e) {\n-                        log(tag.getLineNo(), \"javadoc.classInfo\",\n-                                      \"@throws\", tag.getArg1());\n-                    }\n+                if (mAllowUndeclaredRTE && documentedClass != null) {\n+                    reqd = !isUnchecked(documentedClass);\n                 }\n \n                 if (reqd) {\n                     log(tag.getLineNo(), \"javadoc.unusedTag\",\n                                   \"@throws\", tag.getArg1());\n                 }\n             }\n         }\n \n         // Now dump out all throws without tags :- unless\n         // the user has chosen to suppress these problems\n         if (!mAllowMissingThrowsTags) {\n             final ListIterator throwIt = aThrows.listIterator();\n             while (throwIt.hasNext()) {\n                 final ExceptionInfo ei = (ExceptionInfo) throwIt.next();\n                 if (!ei.isFound()) {\n-                    final FullIdent fi = ei.getFullIdent();\n+                    final FullIdent fi = ei.getName();\n                     log(fi.getLineNo(), fi.getColumnNo(),\n                         \"javadoc.expectedTag\", \"@throws\", fi.getText());\n                 }\n             }\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"04ac5dd87c11a2bf7b908b45bbca7933382df515": {
			"type": "Yfilerename",
			"commitMessage": "Moving another Javadoc check to see what is involved.\nA suprisingly small amount. Love the Eclipse refactoring\nsupport having the smarts to do the CVS operations.\n",
			"commitDate": "2003-06-03, 6:51 AM",
			"commitName": "04ac5dd87c11a2bf7b908b45bbca7933382df515",
			"commitAuthor": "Oliver Burn",
			"commitDateOld": "2003-06-03, 6:33 AM",
			"commitNameOld": "2ef6dc6a43ede89c5b5b9091dee83e1e58bb5edc",
			"commitAuthorOld": "Oliver Burn",
			"daysBetweenCommits": 0.01,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "",
			"extendedDetails": {
				"oldPath": "src/checkstyle/com/puppycrawl/tools/checkstyle/checks/JavadocMethodCheck.java",
				"newPath": "src/checkstyle/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocMethodCheck.java"
			}
		},
		"4e1f8ef98e9e43d6101a00bdecd040377472f852": {
			"type": "Ybodychange",
			"commitMessage": "One more option for JavadocMethodCheck\n(allowThrowsTagsForSubclasses, request 540383)\n",
			"commitDate": "2003-05-09, 11:14 AM",
			"commitName": "4e1f8ef98e9e43d6101a00bdecd040377472f852",
			"commitAuthor": "Oleg Sukhodolsky",
			"commitDateOld": "2003-03-13, 7:22 PM",
			"commitNameOld": "8dd44cbead07361f2b924a5a4d5d85ace71e4866",
			"commitAuthorOld": "Oliver Burn",
			"daysBetweenCommits": 56.62,
			"commitsBetweenForRepo": 99,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,67 +1,89 @@\n     private void checkThrowsTags(List aTags, List aThrows)\n     {\n         // Loop over the tags, checking to see they exist in the throws.\n-        final Set foundThrows = new HashSet();\n+        final Set foundThrows = new HashSet(); //used for performance only\n         final ListIterator tagIt = aTags.listIterator();\n         while (tagIt.hasNext()) {\n             final JavadocTag tag = (JavadocTag) tagIt.next();\n \n             if (!tag.isThrowsTag()) {\n                 continue;\n             }\n \n             tagIt.remove();\n \n             // Loop looking for matching throw\n             final String documentedEx = tag.getArg1();\n             boolean found = foundThrows.contains(documentedEx);\n             final ListIterator throwIt = aThrows.listIterator();\n             while (!found && throwIt.hasNext()) {\n-                final FullIdent fi = (FullIdent) throwIt.next();\n+                final ExceptionInfo ei = (ExceptionInfo) throwIt.next();\n+                final FullIdent fi = ei.getFullIdent();\n                 final String declaredEx = fi.getText();\n                 if (isSameType(declaredEx, documentedEx)) {\n                     found = true;\n-                    throwIt.remove();\n+                    ei.setFound();\n                     foundThrows.add(documentedEx);\n                 }\n+                else if (mAllowThrowsTagsForSubclasses) {\n+                    final ClassResolver cr = getClassResolver();\n+                    try {\n+                        final Class documentedClass = cr.resolve(documentedEx);\n+                        try {\n+                            final Class declaredClass = cr.resolve(declaredEx);\n+                            found = \n+                                declaredClass.isAssignableFrom(documentedClass);\n+                            if (found) {\n+                                ei.setFound();\n+                            }\n+                        }\n+                        catch (ClassNotFoundException e) {\n+                            log(tag.getLineNo(), \"javadoc.classInfo\",\n+                                \"@throws\", declaredEx);\n+                        }\n+                    }\n+                    catch (ClassNotFoundException e) {\n+                        log(tag.getLineNo(), \"javadoc.classInfo\",\n+                                      \"@throws\", documentedEx);\n+                    }\n+                }\n             }\n \n             // Handle extra JavadocTag.\n             if (!found) {\n                 boolean reqd = true;\n                 if (mAllowUndeclaredRTE) {\n-                    final ClassResolver cr =\n-                        new ClassResolver(\n-                            getClassLoader(),\n-                            mPackageFullIdent.getText(),\n-                            mImports);\n+                    final ClassResolver cr = getClassResolver();\n                     try {\n                         final Class clazz = cr.resolve(tag.getArg1());\n                         reqd =\n                             !RuntimeException.class.isAssignableFrom(clazz)\n                                 && !Error.class.isAssignableFrom(clazz);\n                     }\n                     catch (ClassNotFoundException e) {\n                         log(tag.getLineNo(), \"javadoc.classInfo\",\n                                       \"@throws\", tag.getArg1());\n                     }\n                 }\n \n                 if (reqd) {\n                     log(tag.getLineNo(), \"javadoc.unusedTag\",\n                                   \"@throws\", tag.getArg1());\n                 }\n             }\n         }\n \n         // Now dump out all throws without tags :- unless\n         // the user has chosen to suppress these problems\n         if (!mAllowMissingThrowsTags) {\n             final ListIterator throwIt = aThrows.listIterator();\n             while (throwIt.hasNext()) {\n-                final FullIdent fi = (FullIdent) throwIt.next();\n-                log(fi.getLineNo(), fi.getColumnNo(),\n-                    \"javadoc.expectedTag\", \"@throws\", fi.getText());\n+                final ExceptionInfo ei = (ExceptionInfo) throwIt.next();\n+                if (!ei.isFound()) {\n+                    final FullIdent fi = ei.getFullIdent();\n+                    log(fi.getLineNo(), fi.getColumnNo(),\n+                        \"javadoc.expectedTag\", \"@throws\", fi.getText());\n+                }\n             }\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"4cddf4771cd0b3bb2318912a06ae2ca8089e0f49": {
			"type": "Ybodychange",
			"commitMessage": "Patch from Simon Kitching to allow more configuration control over the\nJavadocMethodCheck.\n",
			"commitDate": "2003-03-11, 2:49 PM",
			"commitName": "4cddf4771cd0b3bb2318912a06ae2ca8089e0f49",
			"commitAuthor": "Oliver Burn",
			"commitDateOld": "2003-02-15, 6:50 PM",
			"commitNameOld": "04b0bd64047e8eee752405a01de145b67f5fb845",
			"commitAuthorOld": "Oliver Burn",
			"daysBetweenCommits": 23.83,
			"commitsBetweenForRepo": 49,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,64 +1,67 @@\n     private void checkThrowsTags(List aTags, List aThrows)\n     {\n         // Loop over the tags, checking to see they exist in the throws.\n         final Set foundThrows = new HashSet();\n         final ListIterator tagIt = aTags.listIterator();\n         while (tagIt.hasNext()) {\n             final JavadocTag tag = (JavadocTag) tagIt.next();\n \n             if (!tag.isThrowsTag()) {\n                 continue;\n             }\n \n             tagIt.remove();\n \n             // Loop looking for matching throw\n             final String documentedEx = tag.getArg1();\n             boolean found = foundThrows.contains(documentedEx);\n             final ListIterator throwIt = aThrows.listIterator();\n             while (!found && throwIt.hasNext()) {\n                 final FullIdent fi = (FullIdent) throwIt.next();\n                 final String declaredEx = fi.getText();\n                 if (isSameType(declaredEx, documentedEx)) {\n                     found = true;\n                     throwIt.remove();\n                     foundThrows.add(documentedEx);\n                 }\n             }\n \n             // Handle extra JavadocTag.\n             if (!found) {\n                 boolean reqd = true;\n                 if (mAllowUndeclaredRTE) {\n                     final ClassResolver cr =\n                         new ClassResolver(\n                             getClassLoader(),\n                             mPackageFullIdent.getText(),\n                             mImports);\n                     try {\n                         final Class clazz = cr.resolve(tag.getArg1());\n                         reqd =\n                             !RuntimeException.class.isAssignableFrom(clazz)\n                                 && !Error.class.isAssignableFrom(clazz);\n                     }\n                     catch (ClassNotFoundException e) {\n                         log(tag.getLineNo(), \"javadoc.classInfo\",\n                                       \"@throws\", tag.getArg1());\n                     }\n                 }\n \n                 if (reqd) {\n                     log(tag.getLineNo(), \"javadoc.unusedTag\",\n                                   \"@throws\", tag.getArg1());\n                 }\n             }\n         }\n \n-        // Now dump out all throws without tags\n-        final ListIterator throwIt = aThrows.listIterator();\n-        while (throwIt.hasNext()) {\n-            final FullIdent fi = (FullIdent) throwIt.next();\n-            log(fi.getLineNo(), fi.getColumnNo(),\n-                \"javadoc.expectedTag\", \"@throws\", fi.getText());\n+        // Now dump out all throws without tags :- unless\n+        // the user has chosen to suppress these problems\n+        if (!mAllowMissingThrowsTags) {\n+            final ListIterator throwIt = aThrows.listIterator();\n+            while (throwIt.hasNext()) {\n+                final FullIdent fi = (FullIdent) throwIt.next();\n+                log(fi.getLineNo(), fi.getColumnNo(),\n+                    \"javadoc.expectedTag\", \"@throws\", fi.getText());\n+            }\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"28d1968038af94b1f169eca09a12f19164daac04": {
			"type": "Ybodychange",
			"commitMessage": "fixed bug #658805, Fully-qualified @throws claimed unused\n",
			"commitDate": "2002-12-29, 2:00 AM",
			"commitName": "28d1968038af94b1f169eca09a12f19164daac04",
			"commitAuthor": "Lars Kühne",
			"commitDateOld": "2002-12-27, 1:31 AM",
			"commitNameOld": "58ce4c40970fc29d00e5740bc6098eb475668e86",
			"commitAuthorOld": "Lars Kühne",
			"daysBetweenCommits": 2.02,
			"commitsBetweenForRepo": 6,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,63 +1,64 @@\n     private void checkThrowsTags(List aTags, List aThrows)\n     {\n         // Loop over the tags, checking to see they exist in the throws.\n         final Set foundThrows = new HashSet();\n         final ListIterator tagIt = aTags.listIterator();\n         while (tagIt.hasNext()) {\n             final JavadocTag tag = (JavadocTag) tagIt.next();\n \n             if (!tag.isThrowsTag()) {\n                 continue;\n             }\n \n             tagIt.remove();\n \n             // Loop looking for matching throw\n             final String documentedEx = tag.getArg1();\n             boolean found = foundThrows.contains(documentedEx);\n             final ListIterator throwIt = aThrows.listIterator();\n             while (!found && throwIt.hasNext()) {\n                 final FullIdent fi = (FullIdent) throwIt.next();\n-                if (fi.getText().equals(documentedEx)) {\n+                final String declaredEx = fi.getText();\n+                if (isSameType(declaredEx, documentedEx)) {\n                     found = true;\n                     throwIt.remove();\n                     foundThrows.add(documentedEx);\n                 }\n             }\n \n             // Handle extra JavadocTag.\n             if (!found) {\n                 boolean reqd = true;\n                 if (mAllowUndeclaredRTE) {\n                     final ClassResolver cr =\n                         new ClassResolver(\n                             getClassLoader(),\n                             mPackageFullIdent.getText(),\n                             mImports);\n                     try {\n                         final Class clazz = cr.resolve(tag.getArg1());\n                         reqd =\n                             !RuntimeException.class.isAssignableFrom(clazz)\n                                 && !Error.class.isAssignableFrom(clazz);\n                     }\n                     catch (ClassNotFoundException e) {\n                         log(tag.getLineNo(), \"javadoc.classInfo\",\n                                       \"@throws\", tag.getArg1());\n                     }\n                 }\n \n                 if (reqd) {\n                     log(tag.getLineNo(), \"javadoc.unusedTag\",\n                                   \"@throws\", tag.getArg1());\n                 }\n             }\n         }\n \n         // Now dump out all throws without tags\n         final ListIterator throwIt = aThrows.listIterator();\n         while (throwIt.hasNext()) {\n             final FullIdent fi = (FullIdent) throwIt.next();\n             log(fi.getLineNo(), fi.getColumnNo(),\n                 \"javadoc.expectedTag\", \"@throws\", fi.getText());\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"58ce4c40970fc29d00e5740bc6098eb475668e86": {
			"type": "Ybodychange",
			"commitMessage": "fixed bug #648708, Misleading doc for checkUnusedThrows\nRenamed property checkUnusedThrows to allowUndeclaredRTE to better reflect the meaning of the property.\n",
			"commitDate": "2002-12-27, 1:31 AM",
			"commitName": "58ce4c40970fc29d00e5740bc6098eb475668e86",
			"commitAuthor": "Lars Kühne",
			"commitDateOld": "2002-12-18, 2:55 AM",
			"commitNameOld": "95a5040ccc98d1138a82c9e0ebcfe983651219b6",
			"commitAuthorOld": "Rick Giles",
			"daysBetweenCommits": 8.94,
			"commitsBetweenForRepo": 70,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,63 +1,63 @@\n     private void checkThrowsTags(List aTags, List aThrows)\n     {\n         // Loop over the tags, checking to see they exist in the throws.\n         final Set foundThrows = new HashSet();\n         final ListIterator tagIt = aTags.listIterator();\n         while (tagIt.hasNext()) {\n             final JavadocTag tag = (JavadocTag) tagIt.next();\n \n             if (!tag.isThrowsTag()) {\n                 continue;\n             }\n \n             tagIt.remove();\n \n             // Loop looking for matching throw\n             final String documentedEx = tag.getArg1();\n             boolean found = foundThrows.contains(documentedEx);\n             final ListIterator throwIt = aThrows.listIterator();\n             while (!found && throwIt.hasNext()) {\n                 final FullIdent fi = (FullIdent) throwIt.next();\n                 if (fi.getText().equals(documentedEx)) {\n                     found = true;\n                     throwIt.remove();\n                     foundThrows.add(documentedEx);\n                 }\n             }\n \n             // Handle extra JavadocTag.\n             if (!found) {\n                 boolean reqd = true;\n-                if (mCheckUnusedThrows) {\n+                if (mAllowUndeclaredRTE) {\n                     final ClassResolver cr =\n                         new ClassResolver(\n                             getClassLoader(),\n                             mPackageFullIdent.getText(),\n                             mImports);\n                     try {\n                         final Class clazz = cr.resolve(tag.getArg1());\n                         reqd =\n                             !RuntimeException.class.isAssignableFrom(clazz)\n                                 && !Error.class.isAssignableFrom(clazz);\n                     }\n                     catch (ClassNotFoundException e) {\n                         log(tag.getLineNo(), \"javadoc.classInfo\",\n                                       \"@throws\", tag.getArg1());\n                     }\n                 }\n \n                 if (reqd) {\n                     log(tag.getLineNo(), \"javadoc.unusedTag\",\n                                   \"@throws\", tag.getArg1());\n                 }\n             }\n         }\n \n         // Now dump out all throws without tags\n         final ListIterator throwIt = aThrows.listIterator();\n         while (throwIt.hasNext()) {\n             final FullIdent fi = (FullIdent) throwIt.next();\n             log(fi.getLineNo(), fi.getColumnNo(),\n                 \"javadoc.expectedTag\", \"@throws\", fi.getText());\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"5fc3ff2bfbed94f88e1af95f38e970a832e4dbe6": {
			"type": "Ybodychange",
			"commitMessage": "Please ensure you thoroughly test code before committing it. As a sanity test,\nensure that the target \"checkstyle.checkstyle\" will run! If in doubt, do not\ncommit, but instead said a patch to the devel mailing list for a review.\n\nFinished the port of the ClassResolver code. Even though it compiled, it had\nno chance of working due to class casting problems. They have not been\nfixed. Also needed to ensure the correct class loader is being used.\n",
			"commitDate": "2002-11-05, 7:57 PM",
			"commitName": "5fc3ff2bfbed94f88e1af95f38e970a832e4dbe6",
			"commitAuthor": "Oliver Burn",
			"commitDateOld": "2002-11-05, 6:52 PM",
			"commitNameOld": "e7556f4af60fa1602c1b74289c6c64e1a83e4235",
			"commitAuthorOld": "Oliver Burn",
			"daysBetweenCommits": 0.05,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,60 +1,63 @@\n     private void checkThrowsTags(List aTags, List aThrows)\n     {\n         // Loop over the tags, checking to see they exist in the throws.\n         final Set foundThrows = new HashSet();\n         final ListIterator tagIt = aTags.listIterator();\n         while (tagIt.hasNext()) {\n             final JavadocTag tag = (JavadocTag) tagIt.next();\n \n             if (!tag.isThrowsTag()) {\n                 continue;\n             }\n \n             tagIt.remove();\n \n             // Loop looking for matching throw\n             final String documentedEx = tag.getArg1();\n             boolean found = foundThrows.contains(documentedEx);\n             final ListIterator throwIt = aThrows.listIterator();\n             while (!found && throwIt.hasNext()) {\n                 final FullIdent fi = (FullIdent) throwIt.next();\n                 if (fi.getText().equals(documentedEx)) {\n                     found = true;\n                     throwIt.remove();\n                     foundThrows.add(documentedEx);\n                 }\n             }\n \n             // Handle extra JavadocTag.\n             if (!found) {\n                 boolean reqd = true;\n                 if (mCheckUnusedThrows) {\n-                    final ClassResolver cr = new ClassResolver(\n-                        Thread.currentThread().getContextClassLoader(),\n-                        mPackageFullIdent.getText(), mImports);\n+                    final ClassResolver cr =\n+                        new ClassResolver(\n+                            getClassLoader(),\n+                            mPackageFullIdent.getText(),\n+                            mImports);\n                     try {\n                         final Class clazz = cr.resolve(tag.getArg1());\n-                        reqd = !RuntimeException.class.isAssignableFrom(clazz)\n-                            && !Error.class.isAssignableFrom(clazz);\n+                        reqd =\n+                            !RuntimeException.class.isAssignableFrom(clazz)\n+                                && !Error.class.isAssignableFrom(clazz);\n                     }\n                     catch (ClassNotFoundException e) {\n                         log(tag.getLineNo(), \"javadoc.classInfo\",\n                                       \"@throws\", tag.getArg1());\n                     }\n                 }\n \n                 if (reqd) {\n                     log(tag.getLineNo(), \"javadoc.unusedTag\",\n                                   \"@throws\", tag.getArg1());\n                 }\n             }\n         }\n \n         // Now dump out all throws without tags\n         final ListIterator throwIt = aThrows.listIterator();\n         while (throwIt.hasNext()) {\n             final FullIdent fi = (FullIdent) throwIt.next();\n             log(fi.getLineNo(), fi.getColumnNo(),\n                 \"javadoc.expectedTag\", \"@throws\", fi.getText());\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"c75f97dbc2123f550a1acc64886a8bebf4b888cf": {
			"type": "Yintroduced",
			"commitMessage": "Javadoc method check\n",
			"commitDate": "2002-11-05, 5:13 AM",
			"commitName": "c75f97dbc2123f550a1acc64886a8bebf4b888cf",
			"commitAuthor": "Rick Giles",
			"diff": "@@ -0,0 +1,60 @@\n+    private void checkThrowsTags(List aTags, List aThrows)\n+    {\n+        // Loop over the tags, checking to see they exist in the throws.\n+        final Set foundThrows = new HashSet();\n+        final ListIterator tagIt = aTags.listIterator();\n+        while (tagIt.hasNext()) {\n+            final JavadocTag tag = (JavadocTag) tagIt.next();\n+\n+            if (!tag.isThrowsTag()) {\n+                continue;\n+            }\n+\n+            tagIt.remove();\n+\n+            // Loop looking for matching throw\n+            final String documentedEx = tag.getArg1();\n+            boolean found = foundThrows.contains(documentedEx);\n+            final ListIterator throwIt = aThrows.listIterator();\n+            while (!found && throwIt.hasNext()) {\n+                final FullIdent fi = (FullIdent) throwIt.next();\n+                if (fi.getText().equals(documentedEx)) {\n+                    found = true;\n+                    throwIt.remove();\n+                    foundThrows.add(documentedEx);\n+                }\n+            }\n+\n+            // Handle extra JavadocTag.\n+            if (!found) {\n+                boolean reqd = true;\n+                if (mCheckUnusedThrows) {\n+                    final ClassResolver cr = new ClassResolver(\n+                        Thread.currentThread().getContextClassLoader(),\n+                        mPackageFullIdent.getText(), mImports);\n+                    try {\n+                        final Class clazz = cr.resolve(tag.getArg1());\n+                        reqd = !RuntimeException.class.isAssignableFrom(clazz)\n+                            && !Error.class.isAssignableFrom(clazz);\n+                    }\n+                    catch (ClassNotFoundException e) {\n+                        log(tag.getLineNo(), \"javadoc.classInfo\",\n+                                      \"@throws\", tag.getArg1());\n+                    }\n+                }\n+\n+                if (reqd) {\n+                    log(tag.getLineNo(), \"javadoc.unusedTag\",\n+                                  \"@throws\", tag.getArg1());\n+                }\n+            }\n+        }\n+\n+        // Now dump out all throws without tags\n+        final ListIterator throwIt = aThrows.listIterator();\n+        while (throwIt.hasNext()) {\n+            final FullIdent fi = (FullIdent) throwIt.next();\n+            log(fi.getLineNo(), fi.getColumnNo(),\n+                \"javadoc.expectedTag\", \"@throws\", fi.getText());\n+        }\n+    }\n\\ No newline at end of file\n"
		}
	},
	"sha": "119fd4fb33bef9f5c66fc950396669af842c21a3"
}