{
	"repo": "https://github.com/apache/commons-lang.git",
	"file": "src/main/java/org/apache/commons/lang3/math/NumberUtils.java",
	"method": {
		"longName": "NumberUtils::isNumber(String str)",
		"startLine": 1372,
		"methodName": "isNumber",
		"isStatic": true,
		"isAbstract": false,
		"visibility": "public"
	},
	"history": {
		"c503d742f094dc2048b72c3f78f5e2e6070a44e1": {
			"type": "Ybodychange",
			"commitMessage": "LANG-1252: better naming and java 6 specifics around handling a leading +\n",
			"commitDate": "2016-09-10, 7:01 PM",
			"commitName": "c503d742f094dc2048b72c3f78f5e2e6070a44e1",
			"commitAuthor": "Rob Tompkins",
			"commitDateOld": "2016-06-12, 5:23 AM",
			"commitNameOld": "8d6bc0ca625f3a1a98b486541fa613b2fac4b41c",
			"commitAuthorOld": "Nick Manley",
			"daysBetweenCommits": 90.57,
			"commitsBetweenForRepo": 12,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,115 +1,3 @@\n     public static boolean isNumber(final String str) {\n-        if (StringUtils.isEmpty(str)) {\n-            return false;\n-        }\n-        final char[] chars = str.toCharArray();\n-        int sz = chars.length;\n-        boolean hasExp = false;\n-        boolean hasDecPoint = false;\n-        boolean allowSigns = false;\n-        boolean foundDigit = false;\n-        // deal with any possible sign up front\n-        final int start = (chars[0] == '-') ? 1 : 0;\n-        if (sz > start + 1 && chars[start] == '0') { // leading 0\n-            if (\n-                 (chars[start + 1] == 'x') || \n-                 (chars[start + 1] == 'X') \n-            ) { // leading 0x/0X\n-                int i = start + 2;\n-                if (i == sz) {\n-                    return false; // str == \"0x\"\n-                }\n-                // checking hex (it can't be anything else)\n-                for (; i < chars.length; i++) {\n-                    if ((chars[i] < '0' || chars[i] > '9')\n-                        && (chars[i] < 'a' || chars[i] > 'f')\n-                        && (chars[i] < 'A' || chars[i] > 'F')) {\n-                        return false;\n-                    }\n-                }\n-                return true;\n-           } else if (Character.isDigit(chars[start + 1])) {\n-               // leading 0, but not hex, must be octal\n-               int i = start + 1;\n-               for (; i < chars.length; i++) {\n-                   if (chars[i] < '0' || chars[i] > '7') {\n-                       return false;\n-                   }\n-               }\n-               return true;               \n-           }\n-        }\n-        sz--; // don't want to loop to the last char, check it afterwords\n-              // for type qualifiers\n-        int i = start;\n-        // loop to the next to last char or to the last char if we need another digit to\n-        // make a valid number (e.g. chars[0..5] = \"1234E\")\n-        while (i < sz || (i < sz + 1 && allowSigns && !foundDigit)) {\n-            if (chars[i] >= '0' && chars[i] <= '9') {\n-                foundDigit = true;\n-                allowSigns = false;\n-\n-            } else if (chars[i] == '.') {\n-                if (hasDecPoint || hasExp) {\n-                    // two decimal points or dec in exponent   \n-                    return false;\n-                }\n-                hasDecPoint = true;\n-            } else if (chars[i] == 'e' || chars[i] == 'E') {\n-                // we've already taken care of hex.\n-                if (hasExp) {\n-                    // two E's\n-                    return false;\n-                }\n-                if (!foundDigit) {\n-                    return false;\n-                }\n-                hasExp = true;\n-                allowSigns = true;\n-            } else if (chars[i] == '+' || chars[i] == '-') {\n-                if (!allowSigns) {\n-                    return false;\n-                }\n-                allowSigns = false;\n-                foundDigit = false; // we need a digit after the E\n-            } else {\n-                return false;\n-            }\n-            i++;\n-        }\n-        if (i < chars.length) {\n-            if (chars[i] >= '0' && chars[i] <= '9') {\n-                // no type qualifier, OK\n-                return true;\n-            }\n-            if (chars[i] == 'e' || chars[i] == 'E') {\n-                // can't have an E at the last byte\n-                return false;\n-            }\n-            if (chars[i] == '.') {\n-                if (hasDecPoint || hasExp) {\n-                    // two decimal points or dec in exponent\n-                    return false;\n-                }\n-                // single trailing decimal point after non-exponent is ok\n-                return foundDigit;\n-            }\n-            if (!allowSigns\n-                && (chars[i] == 'd'\n-                    || chars[i] == 'D'\n-                    || chars[i] == 'f'\n-                    || chars[i] == 'F')) {\n-                return foundDigit;\n-            }\n-            if (chars[i] == 'l'\n-                || chars[i] == 'L') {\n-                // not allowing L with an exponent or decimal point\n-                return foundDigit && !hasExp && !hasDecPoint;\n-            }\n-            // last character is illegal\n-            return false;\n-        }\n-        // allowSigns is true iff the val ends in 'E'\n-        // found digit it to make sure weird stuff like '.' and '1E-' doesn't pass\n-        return !allowSigns && foundDigit;\n+        return isCreatable(str);\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"cf03e6173b70ad64337704402bea51600cddd1ba": {
			"type": "Ybodychange",
			"commitMessage": "LANG-992 Fix NumberUtils#isNumber() returns false for \"0.0\", \"0.4790\", et al\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@1582585 13f79535-47bb-0310-9956-ffa450edef68\n",
			"commitDate": "2014-03-27, 9:10 PM",
			"commitName": "cf03e6173b70ad64337704402bea51600cddd1ba",
			"commitAuthor": "Niall Pemberton",
			"commitDateOld": "2014-02-10, 7:57 PM",
			"commitNameOld": "3269d1bc7a28ba4536d4c1ac5a9aaadf5b8f48c3",
			"commitAuthorOld": "Sebastian Bazley",
			"daysBetweenCommits": 45.01,
			"commitsBetweenForRepo": 61,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,114 +1,115 @@\n     public static boolean isNumber(final String str) {\n         if (StringUtils.isEmpty(str)) {\n             return false;\n         }\n         final char[] chars = str.toCharArray();\n         int sz = chars.length;\n         boolean hasExp = false;\n         boolean hasDecPoint = false;\n         boolean allowSigns = false;\n         boolean foundDigit = false;\n         // deal with any possible sign up front\n         final int start = (chars[0] == '-') ? 1 : 0;\n         if (sz > start + 1 && chars[start] == '0') { // leading 0\n             if (\n                  (chars[start + 1] == 'x') || \n                  (chars[start + 1] == 'X') \n             ) { // leading 0x/0X\n                 int i = start + 2;\n                 if (i == sz) {\n                     return false; // str == \"0x\"\n                 }\n                 // checking hex (it can't be anything else)\n                 for (; i < chars.length; i++) {\n                     if ((chars[i] < '0' || chars[i] > '9')\n                         && (chars[i] < 'a' || chars[i] > 'f')\n                         && (chars[i] < 'A' || chars[i] > 'F')) {\n                         return false;\n                     }\n                 }\n                 return true;\n-           } else { // leading 0, but not hex, must be octal\n+           } else if (Character.isDigit(chars[start + 1])) {\n+               // leading 0, but not hex, must be octal\n                int i = start + 1;\n                for (; i < chars.length; i++) {\n                    if (chars[i] < '0' || chars[i] > '7') {\n                        return false;\n                    }\n                }\n                return true;               \n            }\n         }\n         sz--; // don't want to loop to the last char, check it afterwords\n               // for type qualifiers\n         int i = start;\n         // loop to the next to last char or to the last char if we need another digit to\n         // make a valid number (e.g. chars[0..5] = \"1234E\")\n         while (i < sz || (i < sz + 1 && allowSigns && !foundDigit)) {\n             if (chars[i] >= '0' && chars[i] <= '9') {\n                 foundDigit = true;\n                 allowSigns = false;\n \n             } else if (chars[i] == '.') {\n                 if (hasDecPoint || hasExp) {\n                     // two decimal points or dec in exponent   \n                     return false;\n                 }\n                 hasDecPoint = true;\n             } else if (chars[i] == 'e' || chars[i] == 'E') {\n                 // we've already taken care of hex.\n                 if (hasExp) {\n                     // two E's\n                     return false;\n                 }\n                 if (!foundDigit) {\n                     return false;\n                 }\n                 hasExp = true;\n                 allowSigns = true;\n             } else if (chars[i] == '+' || chars[i] == '-') {\n                 if (!allowSigns) {\n                     return false;\n                 }\n                 allowSigns = false;\n                 foundDigit = false; // we need a digit after the E\n             } else {\n                 return false;\n             }\n             i++;\n         }\n         if (i < chars.length) {\n             if (chars[i] >= '0' && chars[i] <= '9') {\n                 // no type qualifier, OK\n                 return true;\n             }\n             if (chars[i] == 'e' || chars[i] == 'E') {\n                 // can't have an E at the last byte\n                 return false;\n             }\n             if (chars[i] == '.') {\n                 if (hasDecPoint || hasExp) {\n                     // two decimal points or dec in exponent\n                     return false;\n                 }\n                 // single trailing decimal point after non-exponent is ok\n                 return foundDigit;\n             }\n             if (!allowSigns\n                 && (chars[i] == 'd'\n                     || chars[i] == 'D'\n                     || chars[i] == 'f'\n                     || chars[i] == 'F')) {\n                 return foundDigit;\n             }\n             if (chars[i] == 'l'\n                 || chars[i] == 'L') {\n                 // not allowing L with an exponent or decimal point\n                 return foundDigit && !hasExp && !hasDecPoint;\n             }\n             // last character is illegal\n             return false;\n         }\n         // allowSigns is true iff the val ends in 'E'\n         // found digit it to make sure weird stuff like '.' and '1E-' doesn't pass\n         return !allowSigns && foundDigit;\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"9397608dd35a335d5e14813c0923f9419782980a": {
			"type": "Ybodychange",
			"commitMessage": "LANG-971 NumberUtils#isNumber(String) fails to reject invalid Octal numbers\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@1566967 13f79535-47bb-0310-9956-ffa450edef68\n",
			"commitDate": "2014-02-10, 7:53 PM",
			"commitName": "9397608dd35a335d5e14813c0923f9419782980a",
			"commitAuthor": "Sebastian Bazley",
			"commitDateOld": "2014-02-10, 7:34 PM",
			"commitNameOld": "5a509030a946646780e963b9f492a4eaff734116",
			"commitAuthorOld": "Sebastian Bazley",
			"daysBetweenCommits": 0.01,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,107 +1,114 @@\n     public static boolean isNumber(final String str) {\n         if (StringUtils.isEmpty(str)) {\n             return false;\n         }\n         final char[] chars = str.toCharArray();\n         int sz = chars.length;\n         boolean hasExp = false;\n         boolean hasDecPoint = false;\n         boolean allowSigns = false;\n         boolean foundDigit = false;\n         // deal with any possible sign up front\n         final int start = (chars[0] == '-') ? 1 : 0;\n-        if (sz > start + 1 && chars[start] == '0'\n-                           && \n-                           (\n-                             (chars[start + 1] == 'x') || \n-                             (chars[start + 1] == 'X') \n-                           )\n-           ) {\n-            int i = start + 2;\n-            if (i == sz) {\n-                return false; // str == \"0x\"\n-            }\n-            // checking hex (it can't be anything else)\n-            for (; i < chars.length; i++) {\n-                if ((chars[i] < '0' || chars[i] > '9')\n-                    && (chars[i] < 'a' || chars[i] > 'f')\n-                    && (chars[i] < 'A' || chars[i] > 'F')) {\n-                    return false;\n+        if (sz > start + 1 && chars[start] == '0') { // leading 0\n+            if (\n+                 (chars[start + 1] == 'x') || \n+                 (chars[start + 1] == 'X') \n+            ) { // leading 0x/0X\n+                int i = start + 2;\n+                if (i == sz) {\n+                    return false; // str == \"0x\"\n                 }\n-            }\n-            return true;\n+                // checking hex (it can't be anything else)\n+                for (; i < chars.length; i++) {\n+                    if ((chars[i] < '0' || chars[i] > '9')\n+                        && (chars[i] < 'a' || chars[i] > 'f')\n+                        && (chars[i] < 'A' || chars[i] > 'F')) {\n+                        return false;\n+                    }\n+                }\n+                return true;\n+           } else { // leading 0, but not hex, must be octal\n+               int i = start + 1;\n+               for (; i < chars.length; i++) {\n+                   if (chars[i] < '0' || chars[i] > '7') {\n+                       return false;\n+                   }\n+               }\n+               return true;               \n+           }\n         }\n         sz--; // don't want to loop to the last char, check it afterwords\n               // for type qualifiers\n         int i = start;\n         // loop to the next to last char or to the last char if we need another digit to\n         // make a valid number (e.g. chars[0..5] = \"1234E\")\n         while (i < sz || (i < sz + 1 && allowSigns && !foundDigit)) {\n             if (chars[i] >= '0' && chars[i] <= '9') {\n                 foundDigit = true;\n                 allowSigns = false;\n \n             } else if (chars[i] == '.') {\n                 if (hasDecPoint || hasExp) {\n                     // two decimal points or dec in exponent   \n                     return false;\n                 }\n                 hasDecPoint = true;\n             } else if (chars[i] == 'e' || chars[i] == 'E') {\n                 // we've already taken care of hex.\n                 if (hasExp) {\n                     // two E's\n                     return false;\n                 }\n                 if (!foundDigit) {\n                     return false;\n                 }\n                 hasExp = true;\n                 allowSigns = true;\n             } else if (chars[i] == '+' || chars[i] == '-') {\n                 if (!allowSigns) {\n                     return false;\n                 }\n                 allowSigns = false;\n                 foundDigit = false; // we need a digit after the E\n             } else {\n                 return false;\n             }\n             i++;\n         }\n         if (i < chars.length) {\n             if (chars[i] >= '0' && chars[i] <= '9') {\n                 // no type qualifier, OK\n                 return true;\n             }\n             if (chars[i] == 'e' || chars[i] == 'E') {\n                 // can't have an E at the last byte\n                 return false;\n             }\n             if (chars[i] == '.') {\n                 if (hasDecPoint || hasExp) {\n                     // two decimal points or dec in exponent\n                     return false;\n                 }\n                 // single trailing decimal point after non-exponent is ok\n                 return foundDigit;\n             }\n             if (!allowSigns\n                 && (chars[i] == 'd'\n                     || chars[i] == 'D'\n                     || chars[i] == 'f'\n                     || chars[i] == 'F')) {\n                 return foundDigit;\n             }\n             if (chars[i] == 'l'\n                 || chars[i] == 'L') {\n                 // not allowing L with an exponent or decimal point\n                 return foundDigit && !hasExp && !hasDecPoint;\n             }\n             // last character is illegal\n             return false;\n         }\n         // allowSigns is true iff the val ends in 'E'\n         // found digit it to make sure weird stuff like '.' and '1E-' doesn't pass\n         return !allowSigns && foundDigit;\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"5a509030a946646780e963b9f492a4eaff734116": {
			"type": "Ybodychange",
			"commitMessage": "LANG-972 NumberUtils#isNumber does not allow for hex 0XABCD\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@1566963 13f79535-47bb-0310-9956-ffa450edef68\n",
			"commitDate": "2014-02-10, 7:34 PM",
			"commitName": "5a509030a946646780e963b9f492a4eaff734116",
			"commitAuthor": "Sebastian Bazley",
			"commitDateOld": "2014-02-06, 6:29 AM",
			"commitNameOld": "5a001837b4ae6ca3b55f61179577f6d1d8f38d37",
			"commitAuthorOld": "Sebastian Bazley",
			"daysBetweenCommits": 4.55,
			"commitsBetweenForRepo": 15,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,101 +1,107 @@\n     public static boolean isNumber(final String str) {\n         if (StringUtils.isEmpty(str)) {\n             return false;\n         }\n         final char[] chars = str.toCharArray();\n         int sz = chars.length;\n         boolean hasExp = false;\n         boolean hasDecPoint = false;\n         boolean allowSigns = false;\n         boolean foundDigit = false;\n         // deal with any possible sign up front\n         final int start = (chars[0] == '-') ? 1 : 0;\n-        if (sz > start + 1 && chars[start] == '0' && chars[start + 1] == 'x') {\n+        if (sz > start + 1 && chars[start] == '0'\n+                           && \n+                           (\n+                             (chars[start + 1] == 'x') || \n+                             (chars[start + 1] == 'X') \n+                           )\n+           ) {\n             int i = start + 2;\n             if (i == sz) {\n                 return false; // str == \"0x\"\n             }\n             // checking hex (it can't be anything else)\n             for (; i < chars.length; i++) {\n                 if ((chars[i] < '0' || chars[i] > '9')\n                     && (chars[i] < 'a' || chars[i] > 'f')\n                     && (chars[i] < 'A' || chars[i] > 'F')) {\n                     return false;\n                 }\n             }\n             return true;\n         }\n         sz--; // don't want to loop to the last char, check it afterwords\n               // for type qualifiers\n         int i = start;\n         // loop to the next to last char or to the last char if we need another digit to\n         // make a valid number (e.g. chars[0..5] = \"1234E\")\n         while (i < sz || (i < sz + 1 && allowSigns && !foundDigit)) {\n             if (chars[i] >= '0' && chars[i] <= '9') {\n                 foundDigit = true;\n                 allowSigns = false;\n \n             } else if (chars[i] == '.') {\n                 if (hasDecPoint || hasExp) {\n                     // two decimal points or dec in exponent   \n                     return false;\n                 }\n                 hasDecPoint = true;\n             } else if (chars[i] == 'e' || chars[i] == 'E') {\n                 // we've already taken care of hex.\n                 if (hasExp) {\n                     // two E's\n                     return false;\n                 }\n                 if (!foundDigit) {\n                     return false;\n                 }\n                 hasExp = true;\n                 allowSigns = true;\n             } else if (chars[i] == '+' || chars[i] == '-') {\n                 if (!allowSigns) {\n                     return false;\n                 }\n                 allowSigns = false;\n                 foundDigit = false; // we need a digit after the E\n             } else {\n                 return false;\n             }\n             i++;\n         }\n         if (i < chars.length) {\n             if (chars[i] >= '0' && chars[i] <= '9') {\n                 // no type qualifier, OK\n                 return true;\n             }\n             if (chars[i] == 'e' || chars[i] == 'E') {\n                 // can't have an E at the last byte\n                 return false;\n             }\n             if (chars[i] == '.') {\n                 if (hasDecPoint || hasExp) {\n                     // two decimal points or dec in exponent\n                     return false;\n                 }\n                 // single trailing decimal point after non-exponent is ok\n                 return foundDigit;\n             }\n             if (!allowSigns\n                 && (chars[i] == 'd'\n                     || chars[i] == 'D'\n                     || chars[i] == 'f'\n                     || chars[i] == 'F')) {\n                 return foundDigit;\n             }\n             if (chars[i] == 'l'\n                 || chars[i] == 'L') {\n                 // not allowing L with an exponent or decimal point\n                 return foundDigit && !hasExp && !hasDecPoint;\n             }\n             // last character is illegal\n             return false;\n         }\n         // allowSigns is true iff the val ends in 'E'\n         // found digit it to make sure weird stuff like '.' and '1E-' doesn't pass\n         return !allowSigns && foundDigit;\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"5292526e476ffbb19c6613a98464054236c86ace": {
			"type": "Ybodychange",
			"commitMessage": "Add final modifier to local variables.\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@1436770 13f79535-47bb-0310-9956-ffa450edef68\n",
			"commitDate": "2013-01-22, 12:09 AM",
			"commitName": "5292526e476ffbb19c6613a98464054236c86ace",
			"commitAuthor": "Gary D. Gregory",
			"commitDateOld": "2013-01-22, 12:07 AM",
			"commitNameOld": "5bd622dab027ef37001a630a7c825c5b8c19d1db",
			"commitAuthorOld": "Gary D. Gregory",
			"daysBetweenCommits": 0,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,101 +1,101 @@\n     public static boolean isNumber(final String str) {\n         if (StringUtils.isEmpty(str)) {\n             return false;\n         }\n-        char[] chars = str.toCharArray();\n+        final char[] chars = str.toCharArray();\n         int sz = chars.length;\n         boolean hasExp = false;\n         boolean hasDecPoint = false;\n         boolean allowSigns = false;\n         boolean foundDigit = false;\n         // deal with any possible sign up front\n-        int start = (chars[0] == '-') ? 1 : 0;\n+        final int start = (chars[0] == '-') ? 1 : 0;\n         if (sz > start + 1 && chars[start] == '0' && chars[start + 1] == 'x') {\n             int i = start + 2;\n             if (i == sz) {\n                 return false; // str == \"0x\"\n             }\n             // checking hex (it can't be anything else)\n             for (; i < chars.length; i++) {\n                 if ((chars[i] < '0' || chars[i] > '9')\n                     && (chars[i] < 'a' || chars[i] > 'f')\n                     && (chars[i] < 'A' || chars[i] > 'F')) {\n                     return false;\n                 }\n             }\n             return true;\n         }\n         sz--; // don't want to loop to the last char, check it afterwords\n               // for type qualifiers\n         int i = start;\n         // loop to the next to last char or to the last char if we need another digit to\n         // make a valid number (e.g. chars[0..5] = \"1234E\")\n         while (i < sz || (i < sz + 1 && allowSigns && !foundDigit)) {\n             if (chars[i] >= '0' && chars[i] <= '9') {\n                 foundDigit = true;\n                 allowSigns = false;\n \n             } else if (chars[i] == '.') {\n                 if (hasDecPoint || hasExp) {\n                     // two decimal points or dec in exponent   \n                     return false;\n                 }\n                 hasDecPoint = true;\n             } else if (chars[i] == 'e' || chars[i] == 'E') {\n                 // we've already taken care of hex.\n                 if (hasExp) {\n                     // two E's\n                     return false;\n                 }\n                 if (!foundDigit) {\n                     return false;\n                 }\n                 hasExp = true;\n                 allowSigns = true;\n             } else if (chars[i] == '+' || chars[i] == '-') {\n                 if (!allowSigns) {\n                     return false;\n                 }\n                 allowSigns = false;\n                 foundDigit = false; // we need a digit after the E\n             } else {\n                 return false;\n             }\n             i++;\n         }\n         if (i < chars.length) {\n             if (chars[i] >= '0' && chars[i] <= '9') {\n                 // no type qualifier, OK\n                 return true;\n             }\n             if (chars[i] == 'e' || chars[i] == 'E') {\n                 // can't have an E at the last byte\n                 return false;\n             }\n             if (chars[i] == '.') {\n                 if (hasDecPoint || hasExp) {\n                     // two decimal points or dec in exponent\n                     return false;\n                 }\n                 // single trailing decimal point after non-exponent is ok\n                 return foundDigit;\n             }\n             if (!allowSigns\n                 && (chars[i] == 'd'\n                     || chars[i] == 'D'\n                     || chars[i] == 'f'\n                     || chars[i] == 'F')) {\n                 return foundDigit;\n             }\n             if (chars[i] == 'l'\n                 || chars[i] == 'L') {\n                 // not allowing L with an exponent or decimal point\n                 return foundDigit && !hasExp && !hasDecPoint;\n             }\n             // last character is illegal\n             return false;\n         }\n         // allowSigns is true iff the val ends in 'E'\n         // found digit it to make sure weird stuff like '.' and '1E-' doesn't pass\n         return !allowSigns && foundDigit;\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"5bd622dab027ef37001a630a7c825c5b8c19d1db": {
			"type": "Yparametermetachange",
			"commitMessage": "Add final modifier to method parameters.\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@1436768 13f79535-47bb-0310-9956-ffa450edef68\n",
			"commitDate": "2013-01-22, 12:07 AM",
			"commitName": "5bd622dab027ef37001a630a7c825c5b8c19d1db",
			"commitAuthor": "Gary D. Gregory",
			"commitDateOld": "2012-11-13, 6:21 AM",
			"commitNameOld": "f5a83bb90cf7b318ac72823e6b99d01d060abe41",
			"commitAuthorOld": "Sebastian Bazley",
			"daysBetweenCommits": 69.74,
			"commitsBetweenForRepo": 18,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,101 +1,101 @@\n-    public static boolean isNumber(String str) {\n+    public static boolean isNumber(final String str) {\n         if (StringUtils.isEmpty(str)) {\n             return false;\n         }\n         char[] chars = str.toCharArray();\n         int sz = chars.length;\n         boolean hasExp = false;\n         boolean hasDecPoint = false;\n         boolean allowSigns = false;\n         boolean foundDigit = false;\n         // deal with any possible sign up front\n         int start = (chars[0] == '-') ? 1 : 0;\n         if (sz > start + 1 && chars[start] == '0' && chars[start + 1] == 'x') {\n             int i = start + 2;\n             if (i == sz) {\n                 return false; // str == \"0x\"\n             }\n             // checking hex (it can't be anything else)\n             for (; i < chars.length; i++) {\n                 if ((chars[i] < '0' || chars[i] > '9')\n                     && (chars[i] < 'a' || chars[i] > 'f')\n                     && (chars[i] < 'A' || chars[i] > 'F')) {\n                     return false;\n                 }\n             }\n             return true;\n         }\n         sz--; // don't want to loop to the last char, check it afterwords\n               // for type qualifiers\n         int i = start;\n         // loop to the next to last char or to the last char if we need another digit to\n         // make a valid number (e.g. chars[0..5] = \"1234E\")\n         while (i < sz || (i < sz + 1 && allowSigns && !foundDigit)) {\n             if (chars[i] >= '0' && chars[i] <= '9') {\n                 foundDigit = true;\n                 allowSigns = false;\n \n             } else if (chars[i] == '.') {\n                 if (hasDecPoint || hasExp) {\n                     // two decimal points or dec in exponent   \n                     return false;\n                 }\n                 hasDecPoint = true;\n             } else if (chars[i] == 'e' || chars[i] == 'E') {\n                 // we've already taken care of hex.\n                 if (hasExp) {\n                     // two E's\n                     return false;\n                 }\n                 if (!foundDigit) {\n                     return false;\n                 }\n                 hasExp = true;\n                 allowSigns = true;\n             } else if (chars[i] == '+' || chars[i] == '-') {\n                 if (!allowSigns) {\n                     return false;\n                 }\n                 allowSigns = false;\n                 foundDigit = false; // we need a digit after the E\n             } else {\n                 return false;\n             }\n             i++;\n         }\n         if (i < chars.length) {\n             if (chars[i] >= '0' && chars[i] <= '9') {\n                 // no type qualifier, OK\n                 return true;\n             }\n             if (chars[i] == 'e' || chars[i] == 'E') {\n                 // can't have an E at the last byte\n                 return false;\n             }\n             if (chars[i] == '.') {\n                 if (hasDecPoint || hasExp) {\n                     // two decimal points or dec in exponent\n                     return false;\n                 }\n                 // single trailing decimal point after non-exponent is ok\n                 return foundDigit;\n             }\n             if (!allowSigns\n                 && (chars[i] == 'd'\n                     || chars[i] == 'D'\n                     || chars[i] == 'f'\n                     || chars[i] == 'F')) {\n                 return foundDigit;\n             }\n             if (chars[i] == 'l'\n                 || chars[i] == 'L') {\n                 // not allowing L with an exponent or decimal point\n                 return foundDigit && !hasExp && !hasDecPoint;\n             }\n             // last character is illegal\n             return false;\n         }\n         // allowSigns is true iff the val ends in 'E'\n         // found digit it to make sure weird stuff like '.' and '1E-' doesn't pass\n         return !allowSigns && foundDigit;\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {
				"oldValue": "[str-String]",
				"newValue": "[str-String(modifiers-final)]"
			}
		},
		"2b5f7a79b0fc561a0dee8dddc46e31c2c8bf6818": {
			"type": "Ybodychange",
			"commitMessage": "Fix PMD issues: \"These nested if statements could be combined\"\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@1153241 13f79535-47bb-0310-9956-ffa450edef68\n",
			"commitDate": "2011-08-02, 12:49 PM",
			"commitName": "2b5f7a79b0fc561a0dee8dddc46e31c2c8bf6818",
			"commitAuthor": "Gary D. Gregory",
			"commitDateOld": "2011-07-19, 2:53 PM",
			"commitNameOld": "2c3fa8366e133200d2a6e0c7f309a876ff9b8675",
			"commitAuthorOld": "Gary D. Gregory",
			"daysBetweenCommits": 13.91,
			"commitsBetweenForRepo": 20,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,103 +1,101 @@\n     public static boolean isNumber(String str) {\n         if (StringUtils.isEmpty(str)) {\n             return false;\n         }\n         char[] chars = str.toCharArray();\n         int sz = chars.length;\n         boolean hasExp = false;\n         boolean hasDecPoint = false;\n         boolean allowSigns = false;\n         boolean foundDigit = false;\n         // deal with any possible sign up front\n         int start = (chars[0] == '-') ? 1 : 0;\n-        if (sz > start + 1) {\n-            if (chars[start] == '0' && chars[start + 1] == 'x') {\n-                int i = start + 2;\n-                if (i == sz) {\n-                    return false; // str == \"0x\"\n-                }\n-                // checking hex (it can't be anything else)\n-                for (; i < chars.length; i++) {\n-                    if ((chars[i] < '0' || chars[i] > '9')\n-                        && (chars[i] < 'a' || chars[i] > 'f')\n-                        && (chars[i] < 'A' || chars[i] > 'F')) {\n-                        return false;\n-                    }\n-                }\n-                return true;\n+        if (sz > start + 1 && chars[start] == '0' && chars[start + 1] == 'x') {\n+            int i = start + 2;\n+            if (i == sz) {\n+                return false; // str == \"0x\"\n             }\n+            // checking hex (it can't be anything else)\n+            for (; i < chars.length; i++) {\n+                if ((chars[i] < '0' || chars[i] > '9')\n+                    && (chars[i] < 'a' || chars[i] > 'f')\n+                    && (chars[i] < 'A' || chars[i] > 'F')) {\n+                    return false;\n+                }\n+            }\n+            return true;\n         }\n         sz--; // don't want to loop to the last char, check it afterwords\n               // for type qualifiers\n         int i = start;\n         // loop to the next to last char or to the last char if we need another digit to\n         // make a valid number (e.g. chars[0..5] = \"1234E\")\n         while (i < sz || (i < sz + 1 && allowSigns && !foundDigit)) {\n             if (chars[i] >= '0' && chars[i] <= '9') {\n                 foundDigit = true;\n                 allowSigns = false;\n \n             } else if (chars[i] == '.') {\n                 if (hasDecPoint || hasExp) {\n                     // two decimal points or dec in exponent   \n                     return false;\n                 }\n                 hasDecPoint = true;\n             } else if (chars[i] == 'e' || chars[i] == 'E') {\n                 // we've already taken care of hex.\n                 if (hasExp) {\n                     // two E's\n                     return false;\n                 }\n                 if (!foundDigit) {\n                     return false;\n                 }\n                 hasExp = true;\n                 allowSigns = true;\n             } else if (chars[i] == '+' || chars[i] == '-') {\n                 if (!allowSigns) {\n                     return false;\n                 }\n                 allowSigns = false;\n                 foundDigit = false; // we need a digit after the E\n             } else {\n                 return false;\n             }\n             i++;\n         }\n         if (i < chars.length) {\n             if (chars[i] >= '0' && chars[i] <= '9') {\n                 // no type qualifier, OK\n                 return true;\n             }\n             if (chars[i] == 'e' || chars[i] == 'E') {\n                 // can't have an E at the last byte\n                 return false;\n             }\n             if (chars[i] == '.') {\n                 if (hasDecPoint || hasExp) {\n                     // two decimal points or dec in exponent\n                     return false;\n                 }\n                 // single trailing decimal point after non-exponent is ok\n                 return foundDigit;\n             }\n             if (!allowSigns\n                 && (chars[i] == 'd'\n                     || chars[i] == 'D'\n                     || chars[i] == 'f'\n                     || chars[i] == 'F')) {\n                 return foundDigit;\n             }\n             if (chars[i] == 'l'\n                 || chars[i] == 'L') {\n                 // not allowing L with an exponent or decimal point\n                 return foundDigit && !hasExp && !hasDecPoint;\n             }\n             // last character is illegal\n             return false;\n         }\n         // allowSigns is true iff the val ends in 'E'\n         // found digit it to make sure weird stuff like '.' and '1E-' doesn't pass\n         return !allowSigns && foundDigit;\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"8e2f4ddb9a1ecd7a1bf7d752c2c891d630287036": {
			"type": "Ybodychange",
			"commitMessage": "Fixing NumberUtils.isNumber so that 1.1L is not considered a number. LANG-664\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@1054202 13f79535-47bb-0310-9956-ffa450edef68\n",
			"commitDate": "2010-12-31, 11:56 PM",
			"commitName": "8e2f4ddb9a1ecd7a1bf7d752c2c891d630287036",
			"commitAuthor": "Henri Yandell",
			"commitDateOld": "2010-08-02, 10:41 PM",
			"commitNameOld": "50c1fdecb4ed33ec1bb0d449f294c299d5369701",
			"commitAuthorOld": "Henri Yandell",
			"daysBetweenCommits": 151.09,
			"commitsBetweenForRepo": 90,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,103 +1,103 @@\n     public static boolean isNumber(String str) {\n         if (StringUtils.isEmpty(str)) {\n             return false;\n         }\n         char[] chars = str.toCharArray();\n         int sz = chars.length;\n         boolean hasExp = false;\n         boolean hasDecPoint = false;\n         boolean allowSigns = false;\n         boolean foundDigit = false;\n         // deal with any possible sign up front\n         int start = (chars[0] == '-') ? 1 : 0;\n         if (sz > start + 1) {\n             if (chars[start] == '0' && chars[start + 1] == 'x') {\n                 int i = start + 2;\n                 if (i == sz) {\n                     return false; // str == \"0x\"\n                 }\n                 // checking hex (it can't be anything else)\n                 for (; i < chars.length; i++) {\n                     if ((chars[i] < '0' || chars[i] > '9')\n                         && (chars[i] < 'a' || chars[i] > 'f')\n                         && (chars[i] < 'A' || chars[i] > 'F')) {\n                         return false;\n                     }\n                 }\n                 return true;\n             }\n         }\n         sz--; // don't want to loop to the last char, check it afterwords\n               // for type qualifiers\n         int i = start;\n         // loop to the next to last char or to the last char if we need another digit to\n         // make a valid number (e.g. chars[0..5] = \"1234E\")\n         while (i < sz || (i < sz + 1 && allowSigns && !foundDigit)) {\n             if (chars[i] >= '0' && chars[i] <= '9') {\n                 foundDigit = true;\n                 allowSigns = false;\n \n             } else if (chars[i] == '.') {\n                 if (hasDecPoint || hasExp) {\n                     // two decimal points or dec in exponent   \n                     return false;\n                 }\n                 hasDecPoint = true;\n             } else if (chars[i] == 'e' || chars[i] == 'E') {\n                 // we've already taken care of hex.\n                 if (hasExp) {\n                     // two E's\n                     return false;\n                 }\n                 if (!foundDigit) {\n                     return false;\n                 }\n                 hasExp = true;\n                 allowSigns = true;\n             } else if (chars[i] == '+' || chars[i] == '-') {\n                 if (!allowSigns) {\n                     return false;\n                 }\n                 allowSigns = false;\n                 foundDigit = false; // we need a digit after the E\n             } else {\n                 return false;\n             }\n             i++;\n         }\n         if (i < chars.length) {\n             if (chars[i] >= '0' && chars[i] <= '9') {\n                 // no type qualifier, OK\n                 return true;\n             }\n             if (chars[i] == 'e' || chars[i] == 'E') {\n                 // can't have an E at the last byte\n                 return false;\n             }\n             if (chars[i] == '.') {\n                 if (hasDecPoint || hasExp) {\n                     // two decimal points or dec in exponent\n                     return false;\n                 }\n                 // single trailing decimal point after non-exponent is ok\n                 return foundDigit;\n             }\n             if (!allowSigns\n                 && (chars[i] == 'd'\n                     || chars[i] == 'D'\n                     || chars[i] == 'f'\n                     || chars[i] == 'F')) {\n                 return foundDigit;\n             }\n             if (chars[i] == 'l'\n                 || chars[i] == 'L') {\n-                // not allowing L with an exponent\n-                return foundDigit && !hasExp;\n+                // not allowing L with an exponent or decimal point\n+                return foundDigit && !hasExp && !hasDecPoint;\n             }\n             // last character is illegal\n             return false;\n         }\n         // allowSigns is true iff the val ends in 'E'\n         // found digit it to make sure weird stuff like '.' and '1E-' doesn't pass\n         return !allowSigns && foundDigit;\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"fc5c081e22a61bb5a6810af302be3f22f7966df4": {
			"type": "Yfilerename",
			"commitMessage": "Move main source to src/main/java\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@895322 13f79535-47bb-0310-9956-ffa450edef68\n",
			"commitDate": "2010-01-02, 7:11 PM",
			"commitName": "fc5c081e22a61bb5a6810af302be3f22f7966df4",
			"commitAuthor": "Paul C. Benedict Jr",
			"commitDateOld": "2010-01-02, 7:09 PM",
			"commitNameOld": "6b32246f5f9f77c74b32a5290cdbdd4e0f5c71c6",
			"commitAuthorOld": "Paul C. Benedict Jr",
			"daysBetweenCommits": 0,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "",
			"extendedDetails": {
				"oldPath": "src/java/org/apache/commons/lang3/math/NumberUtils.java",
				"newPath": "src/main/java/org/apache/commons/lang3/math/NumberUtils.java"
			}
		},
		"26bc3fe010d5154d3ccac526ec22c429fc3af499": {
			"type": "Ybodychange",
			"commitMessage": "isNumber(String) and createNumber(String) both modified to support \"2.\". LANG-521\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@893088 13f79535-47bb-0310-9956-ffa450edef68\n",
			"commitDate": "2009-12-21, 11:52 PM",
			"commitName": "26bc3fe010d5154d3ccac526ec22c429fc3af499",
			"commitAuthor": "Henri Yandell",
			"commitDateOld": "2009-12-10, 4:56 AM",
			"commitNameOld": "c6e8f706dc7a236cc2a49f979d857ee92d0abd7c",
			"commitAuthorOld": "Henri Yandell",
			"daysBetweenCommits": 11.79,
			"commitsBetweenForRepo": 37,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,95 +1,103 @@\n     public static boolean isNumber(String str) {\n         if (StringUtils.isEmpty(str)) {\n             return false;\n         }\n         char[] chars = str.toCharArray();\n         int sz = chars.length;\n         boolean hasExp = false;\n         boolean hasDecPoint = false;\n         boolean allowSigns = false;\n         boolean foundDigit = false;\n         // deal with any possible sign up front\n         int start = (chars[0] == '-') ? 1 : 0;\n         if (sz > start + 1) {\n             if (chars[start] == '0' && chars[start + 1] == 'x') {\n                 int i = start + 2;\n                 if (i == sz) {\n                     return false; // str == \"0x\"\n                 }\n                 // checking hex (it can't be anything else)\n                 for (; i < chars.length; i++) {\n                     if ((chars[i] < '0' || chars[i] > '9')\n                         && (chars[i] < 'a' || chars[i] > 'f')\n                         && (chars[i] < 'A' || chars[i] > 'F')) {\n                         return false;\n                     }\n                 }\n                 return true;\n             }\n         }\n         sz--; // don't want to loop to the last char, check it afterwords\n               // for type qualifiers\n         int i = start;\n         // loop to the next to last char or to the last char if we need another digit to\n         // make a valid number (e.g. chars[0..5] = \"1234E\")\n         while (i < sz || (i < sz + 1 && allowSigns && !foundDigit)) {\n             if (chars[i] >= '0' && chars[i] <= '9') {\n                 foundDigit = true;\n                 allowSigns = false;\n \n             } else if (chars[i] == '.') {\n                 if (hasDecPoint || hasExp) {\n                     // two decimal points or dec in exponent   \n                     return false;\n                 }\n                 hasDecPoint = true;\n             } else if (chars[i] == 'e' || chars[i] == 'E') {\n                 // we've already taken care of hex.\n                 if (hasExp) {\n                     // two E's\n                     return false;\n                 }\n                 if (!foundDigit) {\n                     return false;\n                 }\n                 hasExp = true;\n                 allowSigns = true;\n             } else if (chars[i] == '+' || chars[i] == '-') {\n                 if (!allowSigns) {\n                     return false;\n                 }\n                 allowSigns = false;\n                 foundDigit = false; // we need a digit after the E\n             } else {\n                 return false;\n             }\n             i++;\n         }\n         if (i < chars.length) {\n             if (chars[i] >= '0' && chars[i] <= '9') {\n                 // no type qualifier, OK\n                 return true;\n             }\n             if (chars[i] == 'e' || chars[i] == 'E') {\n                 // can't have an E at the last byte\n                 return false;\n             }\n+            if (chars[i] == '.') {\n+                if (hasDecPoint || hasExp) {\n+                    // two decimal points or dec in exponent\n+                    return false;\n+                }\n+                // single trailing decimal point after non-exponent is ok\n+                return foundDigit;\n+            }\n             if (!allowSigns\n                 && (chars[i] == 'd'\n                     || chars[i] == 'D'\n                     || chars[i] == 'f'\n                     || chars[i] == 'F')) {\n                 return foundDigit;\n             }\n             if (chars[i] == 'l'\n                 || chars[i] == 'L') {\n                 // not allowing L with an exponent\n                 return foundDigit && !hasExp;\n             }\n             // last character is illegal\n             return false;\n         }\n         // allowSigns is true iff the val ends in 'E'\n         // found digit it to make sure weird stuff like '.' and '1E-' doesn't pass\n         return !allowSigns && foundDigit;\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"debc02c6d9b94c717b4182ae4dd7a97d47293a52": {
			"type": "Yfilerename",
			"commitMessage": "Changing directory name from lang to lang3. Build will fail (probably) until Java code is changed in subsequent commit. LANG-563\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@889202 13f79535-47bb-0310-9956-ffa450edef68\n",
			"commitDate": "2009-12-10, 4:33 AM",
			"commitName": "debc02c6d9b94c717b4182ae4dd7a97d47293a52",
			"commitAuthor": "Henri Yandell",
			"commitDateOld": "2009-12-10, 4:31 AM",
			"commitNameOld": "375d7d0954cae60c4c7292cc65abbc972178857c",
			"commitAuthorOld": "Henri Yandell",
			"daysBetweenCommits": 0,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "",
			"extendedDetails": {
				"oldPath": "src/java/org/apache/commons/lang/math/NumberUtils.java",
				"newPath": "src/java/org/apache/commons/lang3/math/NumberUtils.java"
			}
		},
		"0531f837cba9ad5a34b12f26310f05f593b3b7e0": {
			"type": "Ybodychange",
			"commitMessage": "Using StringUtils.isEmpty() when testing Strings.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/lang/trunk@137705 13f79535-47bb-0310-9956-ffa450edef68\n",
			"commitDate": "2003-11-04, 1:26 PM",
			"commitName": "0531f837cba9ad5a34b12f26310f05f593b3b7e0",
			"commitAuthor": "Fredrik Westermarck",
			"commitDateOld": "2003-09-23, 11:02 AM",
			"commitNameOld": "c978c7f029c19a87cf14b4af9a3dc22b812c5190",
			"commitAuthorOld": "Fredrik Westermarck",
			"daysBetweenCommits": 42.14,
			"commitsBetweenForRepo": 33,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,95 +1,95 @@\n     public static boolean isNumber(String str) {\n-        if ((str == null) || (str.length() == 0)) {\n+        if (StringUtils.isEmpty(str)) {\n             return false;\n         }\n         char[] chars = str.toCharArray();\n         int sz = chars.length;\n         boolean hasExp = false;\n         boolean hasDecPoint = false;\n         boolean allowSigns = false;\n         boolean foundDigit = false;\n         // deal with any possible sign up front\n         int start = (chars[0] == '-') ? 1 : 0;\n         if (sz > start + 1) {\n             if (chars[start] == '0' && chars[start + 1] == 'x') {\n                 int i = start + 2;\n                 if (i == sz) {\n                     return false; // str == \"0x\"\n                 }\n                 // checking hex (it can't be anything else)\n                 for (; i < chars.length; i++) {\n                     if ((chars[i] < '0' || chars[i] > '9')\n                         && (chars[i] < 'a' || chars[i] > 'f')\n                         && (chars[i] < 'A' || chars[i] > 'F')) {\n                         return false;\n                     }\n                 }\n                 return true;\n             }\n         }\n         sz--; // don't want to loop to the last char, check it afterwords\n               // for type qualifiers\n         int i = start;\n         // loop to the next to last char or to the last char if we need another digit to\n         // make a valid number (e.g. chars[0..5] = \"1234E\")\n         while (i < sz || (i < sz + 1 && allowSigns && !foundDigit)) {\n             if (chars[i] >= '0' && chars[i] <= '9') {\n                 foundDigit = true;\n                 allowSigns = false;\n \n             } else if (chars[i] == '.') {\n                 if (hasDecPoint || hasExp) {\n                     // two decimal points or dec in exponent   \n                     return false;\n                 }\n                 hasDecPoint = true;\n             } else if (chars[i] == 'e' || chars[i] == 'E') {\n                 // we've already taken care of hex.\n                 if (hasExp) {\n                     // two E's\n                     return false;\n                 }\n                 if (!foundDigit) {\n                     return false;\n                 }\n                 hasExp = true;\n                 allowSigns = true;\n             } else if (chars[i] == '+' || chars[i] == '-') {\n                 if (!allowSigns) {\n                     return false;\n                 }\n                 allowSigns = false;\n                 foundDigit = false; // we need a digit after the E\n             } else {\n                 return false;\n             }\n             i++;\n         }\n         if (i < chars.length) {\n             if (chars[i] >= '0' && chars[i] <= '9') {\n                 // no type qualifier, OK\n                 return true;\n             }\n             if (chars[i] == 'e' || chars[i] == 'E') {\n                 // can't have an E at the last byte\n                 return false;\n             }\n             if (!allowSigns\n                 && (chars[i] == 'd'\n                     || chars[i] == 'D'\n                     || chars[i] == 'f'\n                     || chars[i] == 'F')) {\n                 return foundDigit;\n             }\n             if (chars[i] == 'l'\n                 || chars[i] == 'L') {\n                 // not allowing L with an exponent\n                 return foundDigit && !hasExp;\n             }\n             // last character is illegal\n             return false;\n         }\n         // allowSigns is true iff the val ends in 'E'\n         // found digit it to make sure weird stuff like '.' and '1E-' doesn't pass\n         return !allowSigns && foundDigit;\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"fd3bd5bdd2ef9f6dd184a2d3c587d1a73e19334c": {
			"type": "Ybodychange",
			"commitMessage": "Fixed typos in javadoc and some inline comments.\nPr #22908.\nPatch submitted by Janek Bogucki.\nReviewed by Phil Steitz.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/lang/trunk@137666 13f79535-47bb-0310-9956-ffa450edef68\n",
			"commitDate": "2003-09-07, 8:32 AM",
			"commitName": "fd3bd5bdd2ef9f6dd184a2d3c587d1a73e19334c",
			"commitAuthor": "Phil Steitz",
			"commitDateOld": "2003-09-05, 9:55 AM",
			"commitNameOld": "69b8f445d74f22ba99a75c47a38d97d5e85248cc",
			"commitAuthorOld": "Phil Steitz",
			"daysBetweenCommits": 1.94,
			"commitsBetweenForRepo": 2,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,95 +1,95 @@\n     public static boolean isNumber(String str) {\n         if ((str == null) || (str.length() == 0)) {\n             return false;\n         }\n         char[] chars = str.toCharArray();\n         int sz = chars.length;\n         boolean hasExp = false;\n         boolean hasDecPoint = false;\n         boolean allowSigns = false;\n         boolean foundDigit = false;\n         // deal with any possible sign up front\n         int start = (chars[0] == '-') ? 1 : 0;\n         if (sz > start + 1) {\n             if (chars[start] == '0' && chars[start + 1] == 'x') {\n                 int i = start + 2;\n                 if (i == sz) {\n                     return false; // str == \"0x\"\n                 }\n                 // checking hex (it can't be anything else)\n                 for (; i < chars.length; i++) {\n                     if ((chars[i] < '0' || chars[i] > '9')\n                         && (chars[i] < 'a' || chars[i] > 'f')\n                         && (chars[i] < 'A' || chars[i] > 'F')) {\n                         return false;\n                     }\n                 }\n                 return true;\n             }\n         }\n         sz--; // don't want to loop to the last char, check it afterwords\n               // for type qualifiers\n         int i = start;\n         // loop to the next to last char or to the last char if we need another digit to\n         // make a valid number (e.g. chars[0..5] = \"1234E\")\n         while (i < sz || (i < sz + 1 && allowSigns && !foundDigit)) {\n             if (chars[i] >= '0' && chars[i] <= '9') {\n                 foundDigit = true;\n                 allowSigns = false;\n \n             } else if (chars[i] == '.') {\n                 if (hasDecPoint || hasExp) {\n                     // two decimal points or dec in exponent   \n                     return false;\n                 }\n                 hasDecPoint = true;\n             } else if (chars[i] == 'e' || chars[i] == 'E') {\n                 // we've already taken care of hex.\n                 if (hasExp) {\n                     // two E's\n                     return false;\n                 }\n                 if (!foundDigit) {\n                     return false;\n                 }\n                 hasExp = true;\n                 allowSigns = true;\n             } else if (chars[i] == '+' || chars[i] == '-') {\n                 if (!allowSigns) {\n                     return false;\n                 }\n                 allowSigns = false;\n                 foundDigit = false; // we need a digit after the E\n             } else {\n                 return false;\n             }\n             i++;\n         }\n         if (i < chars.length) {\n             if (chars[i] >= '0' && chars[i] <= '9') {\n                 // no type qualifier, OK\n                 return true;\n             }\n             if (chars[i] == 'e' || chars[i] == 'E') {\n                 // can't have an E at the last byte\n                 return false;\n             }\n             if (!allowSigns\n                 && (chars[i] == 'd'\n                     || chars[i] == 'D'\n                     || chars[i] == 'f'\n                     || chars[i] == 'F')) {\n                 return foundDigit;\n             }\n             if (chars[i] == 'l'\n                 || chars[i] == 'L') {\n-                // not allowing L with an exponoent\n+                // not allowing L with an exponent\n                 return foundDigit && !hasExp;\n             }\n             // last character is illegal\n             return false;\n         }\n         // allowSigns is true iff the val ends in 'E'\n         // found digit it to make sure weird stuff like '.' and '1E-' doesn't pass\n         return !allowSigns && foundDigit;\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"2d06a7ce861432fc702168fd4c94bc00ddfc39eb": {
			"type": "Yintroduced",
			"commitMessage": "NumberUtils moved to math subpackage\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/lang/trunk@137379 13f79535-47bb-0310-9956-ffa450edef68\n",
			"commitDate": "2003-06-24, 3:14 PM",
			"commitName": "2d06a7ce861432fc702168fd4c94bc00ddfc39eb",
			"commitAuthor": "Stephen Colebourne"
		}
	},
	"sha": "a36c903d4f1065bc59f5e6d2bb0f9d92a5e71d83"
}