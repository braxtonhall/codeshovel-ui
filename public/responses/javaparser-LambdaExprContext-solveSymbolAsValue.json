{
	"repo": "https://github.com/javaparser/javaparser.git",
	"file": "javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/LambdaExprContext.java",
	"method": {
		"longName": "public Optional<Value> solveSymbolAsValue(String name, TypeSolver typeSolver);",
		"startLine": 56,
		"methodName": "solveSymbolAsValue",
		"isStatic": false,
		"isAbstract": false,
		"visibility": "public"
	},
	"history": {
		"b54617e765d73b3ce0d187cf12ad8da382bce439": {
			"type": "Ybodychange",
			"commitMessage": "Cleaning up JSS code\n",
			"commitDate": "2018-02-03, 10:46 AM",
			"commitName": "b54617e765d73b3ce0d187cf12ad8da382bce439",
			"commitAuthor": "Danny van Bruggen",
			"commitDateOld": "2018-01-10, 4:52 AM",
			"commitNameOld": "09232ff6b0ea19e850482f3a87ac6ef1c063c759",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 24.25,
			"commitsBetweenForRepo": 68,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,83 +1,83 @@\n     public Optional<Value> solveSymbolAsValue(String name, TypeSolver typeSolver) {\n         for (Parameter parameter : wrappedNode.getParameters()) {\n             SymbolDeclarator sb = JavaParserFactory.getSymbolDeclarator(parameter, typeSolver);\n             int index = 0;\n             for (ResolvedValueDeclaration decl : sb.getSymbolDeclarations()) {\n                 if (decl.getName().equals(name)) {\n-                    if (getParentNode(wrappedNode) instanceof MethodCallExpr) {\n-                        MethodCallExpr methodCallExpr = (MethodCallExpr) getParentNode(wrappedNode);\n+                    if (requireParentNode(wrappedNode) instanceof MethodCallExpr) {\n+                        MethodCallExpr methodCallExpr = (MethodCallExpr) requireParentNode(wrappedNode);\n                         MethodUsage methodUsage = JavaParserFacade.get(typeSolver).solveMethodAsUsage(methodCallExpr);\n                         int i = pos(methodCallExpr, wrappedNode);\n                         ResolvedType lambdaType = methodUsage.getParamTypes().get(i);\n \n                         // Get the functional method in order for us to resolve it's type arguments properly\n                         Optional<MethodUsage> functionalMethodOpt = FunctionalInterfaceLogic.getFunctionalMethod(lambdaType);\n                         if (functionalMethodOpt.isPresent()){\n                             MethodUsage functionalMethod = functionalMethodOpt.get();\n                             InferenceContext inferenceContext = new InferenceContext(MyObjectProvider.INSTANCE);\n \n                             // Resolve each type variable of the lambda, and use this later to infer the type of each\n                             // implicit parameter\n                             inferenceContext.addPair(lambdaType, new ReferenceTypeImpl(lambdaType.asReferenceType().getTypeDeclaration(), typeSolver));\n \n                             // Find the position of this lambda argument\n                             boolean found = false;\n                             int lambdaParamIndex;\n                             for (lambdaParamIndex = 0; lambdaParamIndex < wrappedNode.getParameters().size(); lambdaParamIndex++){\n                                 if (wrappedNode.getParameter(lambdaParamIndex).getName().getIdentifier().equals(name)){\n                                     found = true;\n                                     break;\n                                 }\n                             }\n                             if (!found) { return Optional.empty(); }\n \n                             // Now resolve the argument type using the inference context\n                             ResolvedType argType = inferenceContext.resolve(inferenceContext.addSingle(functionalMethod.getParamType(lambdaParamIndex)));\n \n                             ResolvedLambdaConstraintType conType;\n                             if (argType.isWildcard()){\n                                 conType = ResolvedLambdaConstraintType.bound(argType.asWildcard().getBoundedType());\n                             } else {\n                                 conType = ResolvedLambdaConstraintType.bound(argType);\n                             }\n                             Value value = new Value(conType, name);\n                             return Optional.of(value);\n                         } else{\n                             return Optional.empty();\n                         }\n-                    } else if (getParentNode(wrappedNode) instanceof VariableDeclarator) {\n-                        VariableDeclarator variableDeclarator = (VariableDeclarator) getParentNode(wrappedNode);\n+                    } else if (requireParentNode(wrappedNode) instanceof VariableDeclarator) {\n+                        VariableDeclarator variableDeclarator = (VariableDeclarator) requireParentNode(wrappedNode);\n                         ResolvedType t = JavaParserFacade.get(typeSolver).convertToUsageVariableType(variableDeclarator);\n                         Optional<MethodUsage> functionalMethod = FunctionalInterfaceLogic.getFunctionalMethod(t);\n                         if (functionalMethod.isPresent()) {\n                             ResolvedType lambdaType = functionalMethod.get().getParamType(index);\n \n                             // Replace parameter from declarator\n                             Map<ResolvedTypeParameterDeclaration, ResolvedType> inferredTypes = new HashMap<>();\n                             if (lambdaType.isReferenceType()) {\n                                 for (com.github.javaparser.utils.Pair<ResolvedTypeParameterDeclaration, ResolvedType> entry : lambdaType.asReferenceType().getTypeParametersMap()) {\n                                     if (entry.b.isTypeVariable() && entry.b.asTypeParameter().declaredOnType()) {\n                                         ResolvedType ot = t.asReferenceType().typeParametersMap().getValue(entry.a);\n                                         lambdaType = lambdaType.replaceTypeVariables(entry.a, ot, inferredTypes);\n                                     }\n                                 }\n                             } else if (lambdaType.isTypeVariable() && lambdaType.asTypeParameter().declaredOnType()) {\n                                 lambdaType = t.asReferenceType().typeParametersMap().getValue(lambdaType.asTypeParameter());\n                             }\n \n                             Value value = new Value(lambdaType, name);\n                             return Optional.of(value);\n                         } else {\n                             throw new UnsupportedOperationException();\n                         }\n                     } else {\n                         throw new UnsupportedOperationException();\n                     }\n                 }\n                 index++;\n             }\n         }\n \n         // if nothing is found we should ask the parent context\n         return getParent().solveSymbolAsValue(name, typeSolver);\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"09232ff6b0ea19e850482f3a87ac6ef1c063c759": {
			"type": "Yfilerename",
			"commitMessage": "rename JSS modules\n",
			"commitDate": "2018-01-10, 4:52 AM",
			"commitName": "09232ff6b0ea19e850482f3a87ac6ef1c063c759",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2018-01-10, 12:01 AM",
			"commitNameOld": "30c04db173cc439556df2a238c99cd81ada320ff",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 0.2,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "",
			"extendedDetails": {
				"oldPath": "java-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/LambdaExprContext.java",
				"newPath": "javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/LambdaExprContext.java"
			}
		},
		"5d8d0cb7947efcf2282f7d056302dd905f348532": {
			"type": "Ybodychange",
			"commitMessage": "more work on converting to moved classes\n",
			"commitDate": "2017-09-28, 1:36 PM",
			"commitName": "5d8d0cb7947efcf2282f7d056302dd905f348532",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2017-03-10, 1:50 PM",
			"commitNameOld": "5da7835cd514233e05ff8ceb07b4f82063b0d08e",
			"commitAuthorOld": "xdrop",
			"daysBetweenCommits": 201.95,
			"commitsBetweenForRepo": 162,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,83 +1,83 @@\n     public Optional<Value> solveSymbolAsValue(String name, TypeSolver typeSolver) {\n         for (Parameter parameter : wrappedNode.getParameters()) {\n             SymbolDeclarator sb = JavaParserFactory.getSymbolDeclarator(parameter, typeSolver);\n             int index = 0;\n-            for (ValueDeclaration decl : sb.getSymbolDeclarations()) {\n+            for (ResolvedValueDeclaration decl : sb.getSymbolDeclarations()) {\n                 if (decl.getName().equals(name)) {\n                     if (getParentNode(wrappedNode) instanceof MethodCallExpr) {\n                         MethodCallExpr methodCallExpr = (MethodCallExpr) getParentNode(wrappedNode);\n                         MethodUsage methodUsage = JavaParserFacade.get(typeSolver).solveMethodAsUsage(methodCallExpr);\n                         int i = pos(methodCallExpr, wrappedNode);\n-                        Type lambdaType = methodUsage.getParamTypes().get(i);\n+                        ResolvedType lambdaType = methodUsage.getParamTypes().get(i);\n \n                         // Get the functional method in order for us to resolve it's type arguments properly\n                         Optional<MethodUsage> functionalMethodOpt = FunctionalInterfaceLogic.getFunctionalMethod(lambdaType);\n                         if (functionalMethodOpt.isPresent()){\n                             MethodUsage functionalMethod = functionalMethodOpt.get();\n                             InferenceContext inferenceContext = new InferenceContext(MyObjectProvider.INSTANCE);\n \n                             // Resolve each type variable of the lambda, and use this later to infer the type of each\n                             // implicit parameter\n                             inferenceContext.addPair(lambdaType, new ReferenceTypeImpl(lambdaType.asReferenceType().getTypeDeclaration(), typeSolver));\n \n                             // Find the position of this lambda argument\n                             boolean found = false;\n                             int lambdaParamIndex;\n                             for (lambdaParamIndex = 0; lambdaParamIndex < wrappedNode.getParameters().size(); lambdaParamIndex++){\n                                 if (wrappedNode.getParameter(lambdaParamIndex).getName().getIdentifier().equals(name)){\n                                     found = true;\n                                     break;\n                                 }\n                             }\n                             if (!found) { return Optional.empty(); }\n \n                             // Now resolve the argument type using the inference context\n-                            Type argType = inferenceContext.resolve(inferenceContext.addSingle(functionalMethod.getParamType(lambdaParamIndex)));\n+                            ResolvedType argType = inferenceContext.resolve(inferenceContext.addSingle(functionalMethod.getParamType(lambdaParamIndex)));\n \n-                            LambdaConstraintType conType;\n+                            ResolvedLambdaConstraintType conType;\n                             if (argType.isWildcard()){\n-                                conType = LambdaConstraintType.bound(argType.asWildcard().getBoundedType());\n+                                conType = ResolvedLambdaConstraintType.bound(argType.asWildcard().getBoundedType());\n                             } else {\n-                                conType = LambdaConstraintType.bound(argType);\n+                                conType = ResolvedLambdaConstraintType.bound(argType);\n                             }\n                             Value value = new Value(conType, name);\n                             return Optional.of(value);\n                         } else{\n                             return Optional.empty();\n                         }\n                     } else if (getParentNode(wrappedNode) instanceof VariableDeclarator) {\n                         VariableDeclarator variableDeclarator = (VariableDeclarator) getParentNode(wrappedNode);\n-                        Type t = JavaParserFacade.get(typeSolver).convertToUsageVariableType(variableDeclarator);\n+                        ResolvedType t = JavaParserFacade.get(typeSolver).convertToUsageVariableType(variableDeclarator);\n                         Optional<MethodUsage> functionalMethod = FunctionalInterfaceLogic.getFunctionalMethod(t);\n                         if (functionalMethod.isPresent()) {\n-                            Type lambdaType = functionalMethod.get().getParamType(index);\n+                            ResolvedType lambdaType = functionalMethod.get().getParamType(index);\n \n                             // Replace parameter from declarator\n-                            Map<TypeParameterDeclaration, Type> inferredTypes = new HashMap<>();\n+                            Map<ResolvedTypeParameterDeclaration, ResolvedType> inferredTypes = new HashMap<>();\n                             if (lambdaType.isReferenceType()) {\n-                                for (Tuple2<TypeParameterDeclaration, Type> entry : lambdaType.asReferenceType().getTypeParametersMap()) {\n-                                    if (entry._2.isTypeVariable() && entry._2.asTypeParameter().declaredOnType()) {\n-                                        Type ot = t.asReferenceType().typeParametersMap().getValue(entry._1);\n-                                        lambdaType = lambdaType.replaceTypeVariables(entry._1, ot, inferredTypes);\n+                                for (com.github.javaparser.utils.Pair<ResolvedTypeParameterDeclaration, ResolvedType> entry : lambdaType.asReferenceType().getTypeParametersMap()) {\n+                                    if (entry.b.isTypeVariable() && entry.b.asTypeParameter().declaredOnType()) {\n+                                        ResolvedType ot = t.asReferenceType().typeParametersMap().getValue(entry.a);\n+                                        lambdaType = lambdaType.replaceTypeVariables(entry.a, ot, inferredTypes);\n                                     }\n                                 }\n                             } else if (lambdaType.isTypeVariable() && lambdaType.asTypeParameter().declaredOnType()) {\n                                 lambdaType = t.asReferenceType().typeParametersMap().getValue(lambdaType.asTypeParameter());\n                             }\n \n                             Value value = new Value(lambdaType, name);\n                             return Optional.of(value);\n                         } else {\n                             throw new UnsupportedOperationException();\n                         }\n                     } else {\n                         throw new UnsupportedOperationException();\n                     }\n                 }\n                 index++;\n             }\n         }\n \n         // if nothing is found we should ask the parent context\n         return getParent().solveSymbolAsValue(name, typeSolver);\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"5da7835cd514233e05ff8ceb07b4f82063b0d08e": {
			"type": "Ybodychange",
			"commitMessage": "Small readability changes\n",
			"commitDate": "2017-03-10, 1:50 PM",
			"commitName": "5da7835cd514233e05ff8ceb07b4f82063b0d08e",
			"commitAuthor": "xdrop",
			"commitDateOld": "2017-03-10, 11:11 AM",
			"commitNameOld": "0aaa5e5b086a557801d54f8a3ac236e08513e774",
			"commitAuthorOld": "xdrop",
			"daysBetweenCommits": 0.11,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,83 +1,83 @@\n     public Optional<Value> solveSymbolAsValue(String name, TypeSolver typeSolver) {\n         for (Parameter parameter : wrappedNode.getParameters()) {\n             SymbolDeclarator sb = JavaParserFactory.getSymbolDeclarator(parameter, typeSolver);\n             int index = 0;\n             for (ValueDeclaration decl : sb.getSymbolDeclarations()) {\n                 if (decl.getName().equals(name)) {\n                     if (getParentNode(wrappedNode) instanceof MethodCallExpr) {\n                         MethodCallExpr methodCallExpr = (MethodCallExpr) getParentNode(wrappedNode);\n                         MethodUsage methodUsage = JavaParserFacade.get(typeSolver).solveMethodAsUsage(methodCallExpr);\n                         int i = pos(methodCallExpr, wrappedNode);\n                         Type lambdaType = methodUsage.getParamTypes().get(i);\n \n                         // Get the functional method in order for us to resolve it's type arguments properly\n                         Optional<MethodUsage> functionalMethodOpt = FunctionalInterfaceLogic.getFunctionalMethod(lambdaType);\n                         if (functionalMethodOpt.isPresent()){\n                             MethodUsage functionalMethod = functionalMethodOpt.get();\n                             InferenceContext inferenceContext = new InferenceContext(MyObjectProvider.INSTANCE);\n \n                             // Resolve each type variable of the lambda, and use this later to infer the type of each\n                             // implicit parameter\n                             inferenceContext.addPair(lambdaType, new ReferenceTypeImpl(lambdaType.asReferenceType().getTypeDeclaration(), typeSolver));\n \n                             // Find the position of this lambda argument\n                             boolean found = false;\n                             int lambdaParamIndex;\n                             for (lambdaParamIndex = 0; lambdaParamIndex < wrappedNode.getParameters().size(); lambdaParamIndex++){\n                                 if (wrappedNode.getParameter(lambdaParamIndex).getName().getIdentifier().equals(name)){\n-                                    found =true;\n+                                    found = true;\n                                     break;\n                                 }\n                             }\n-                            if (!found) return Optional.empty();\n+                            if (!found) { return Optional.empty(); }\n \n                             // Now resolve the argument type using the inference context\n                             Type argType = inferenceContext.resolve(inferenceContext.addSingle(functionalMethod.getParamType(lambdaParamIndex)));\n \n                             LambdaConstraintType conType;\n                             if (argType.isWildcard()){\n                                 conType = LambdaConstraintType.bound(argType.asWildcard().getBoundedType());\n                             } else {\n                                 conType = LambdaConstraintType.bound(argType);\n                             }\n                             Value value = new Value(conType, name);\n                             return Optional.of(value);\n                         } else{\n                             return Optional.empty();\n                         }\n                     } else if (getParentNode(wrappedNode) instanceof VariableDeclarator) {\n                         VariableDeclarator variableDeclarator = (VariableDeclarator) getParentNode(wrappedNode);\n                         Type t = JavaParserFacade.get(typeSolver).convertToUsageVariableType(variableDeclarator);\n                         Optional<MethodUsage> functionalMethod = FunctionalInterfaceLogic.getFunctionalMethod(t);\n                         if (functionalMethod.isPresent()) {\n                             Type lambdaType = functionalMethod.get().getParamType(index);\n \n                             // Replace parameter from declarator\n                             Map<TypeParameterDeclaration, Type> inferredTypes = new HashMap<>();\n                             if (lambdaType.isReferenceType()) {\n                                 for (Tuple2<TypeParameterDeclaration, Type> entry : lambdaType.asReferenceType().getTypeParametersMap()) {\n                                     if (entry._2.isTypeVariable() && entry._2.asTypeParameter().declaredOnType()) {\n                                         Type ot = t.asReferenceType().typeParametersMap().getValue(entry._1);\n                                         lambdaType = lambdaType.replaceTypeVariables(entry._1, ot, inferredTypes);\n                                     }\n                                 }\n                             } else if (lambdaType.isTypeVariable() && lambdaType.asTypeParameter().declaredOnType()) {\n                                 lambdaType = t.asReferenceType().typeParametersMap().getValue(lambdaType.asTypeParameter());\n                             }\n \n                             Value value = new Value(lambdaType, name);\n                             return Optional.of(value);\n                         } else {\n                             throw new UnsupportedOperationException();\n                         }\n                     } else {\n                         throw new UnsupportedOperationException();\n                     }\n                 }\n                 index++;\n             }\n         }\n \n         // if nothing is found we should ask the parent context\n         return getParent().solveSymbolAsValue(name, typeSolver);\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"0aaa5e5b086a557801d54f8a3ac236e08513e774": {
			"type": "Ybodychange",
			"commitMessage": "Fix some issues with recovering types of lambda arguments\n",
			"commitDate": "2017-03-10, 11:11 AM",
			"commitName": "0aaa5e5b086a557801d54f8a3ac236e08513e774",
			"commitAuthor": "xdrop",
			"commitDateOld": "2017-03-09, 5:22 PM",
			"commitNameOld": "acdac6790f4424f8097b3aa6c888e825cac485f9",
			"commitAuthorOld": "xdrop",
			"daysBetweenCommits": 0.74,
			"commitsBetweenForRepo": 3,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,56 +1,83 @@\n     public Optional<Value> solveSymbolAsValue(String name, TypeSolver typeSolver) {\n         for (Parameter parameter : wrappedNode.getParameters()) {\n             SymbolDeclarator sb = JavaParserFactory.getSymbolDeclarator(parameter, typeSolver);\n             int index = 0;\n             for (ValueDeclaration decl : sb.getSymbolDeclarations()) {\n                 if (decl.getName().equals(name)) {\n                     if (getParentNode(wrappedNode) instanceof MethodCallExpr) {\n                         MethodCallExpr methodCallExpr = (MethodCallExpr) getParentNode(wrappedNode);\n                         MethodUsage methodUsage = JavaParserFacade.get(typeSolver).solveMethodAsUsage(methodCallExpr);\n                         int i = pos(methodCallExpr, wrappedNode);\n                         Type lambdaType = methodUsage.getParamTypes().get(i);\n-                        Type argType = lambdaType.asReferenceType().typeParametersValues().get(0);\n-                        LambdaConstraintType conType;\n-                        if (argType.isWildcard()){\n-                            conType = LambdaConstraintType.bound(argType.asWildcard().getBoundedType());\n-                        } else {\n-                            conType = LambdaConstraintType.bound(argType);\n+\n+                        // Get the functional method in order for us to resolve it's type arguments properly\n+                        Optional<MethodUsage> functionalMethodOpt = FunctionalInterfaceLogic.getFunctionalMethod(lambdaType);\n+                        if (functionalMethodOpt.isPresent()){\n+                            MethodUsage functionalMethod = functionalMethodOpt.get();\n+                            InferenceContext inferenceContext = new InferenceContext(MyObjectProvider.INSTANCE);\n+\n+                            // Resolve each type variable of the lambda, and use this later to infer the type of each\n+                            // implicit parameter\n+                            inferenceContext.addPair(lambdaType, new ReferenceTypeImpl(lambdaType.asReferenceType().getTypeDeclaration(), typeSolver));\n+\n+                            // Find the position of this lambda argument\n+                            boolean found = false;\n+                            int lambdaParamIndex;\n+                            for (lambdaParamIndex = 0; lambdaParamIndex < wrappedNode.getParameters().size(); lambdaParamIndex++){\n+                                if (wrappedNode.getParameter(lambdaParamIndex).getName().getIdentifier().equals(name)){\n+                                    found =true;\n+                                    break;\n+                                }\n+                            }\n+                            if (!found) return Optional.empty();\n+\n+                            // Now resolve the argument type using the inference context\n+                            Type argType = inferenceContext.resolve(inferenceContext.addSingle(functionalMethod.getParamType(lambdaParamIndex)));\n+\n+                            LambdaConstraintType conType;\n+                            if (argType.isWildcard()){\n+                                conType = LambdaConstraintType.bound(argType.asWildcard().getBoundedType());\n+                            } else {\n+                                conType = LambdaConstraintType.bound(argType);\n+                            }\n+                            Value value = new Value(conType, name);\n+                            return Optional.of(value);\n+                        } else{\n+                            return Optional.empty();\n                         }\n-                        Value value = new Value(conType, name);\n-                        return Optional.of(value);\n                     } else if (getParentNode(wrappedNode) instanceof VariableDeclarator) {\n                         VariableDeclarator variableDeclarator = (VariableDeclarator) getParentNode(wrappedNode);\n                         Type t = JavaParserFacade.get(typeSolver).convertToUsageVariableType(variableDeclarator);\n                         Optional<MethodUsage> functionalMethod = FunctionalInterfaceLogic.getFunctionalMethod(t);\n                         if (functionalMethod.isPresent()) {\n                             Type lambdaType = functionalMethod.get().getParamType(index);\n \n                             // Replace parameter from declarator\n                             Map<TypeParameterDeclaration, Type> inferredTypes = new HashMap<>();\n                             if (lambdaType.isReferenceType()) {\n                                 for (Tuple2<TypeParameterDeclaration, Type> entry : lambdaType.asReferenceType().getTypeParametersMap()) {\n                                     if (entry._2.isTypeVariable() && entry._2.asTypeParameter().declaredOnType()) {\n                                         Type ot = t.asReferenceType().typeParametersMap().getValue(entry._1);\n                                         lambdaType = lambdaType.replaceTypeVariables(entry._1, ot, inferredTypes);\n                                     }\n                                 }\n                             } else if (lambdaType.isTypeVariable() && lambdaType.asTypeParameter().declaredOnType()) {\n                                 lambdaType = t.asReferenceType().typeParametersMap().getValue(lambdaType.asTypeParameter());\n                             }\n \n                             Value value = new Value(lambdaType, name);\n                             return Optional.of(value);\n                         } else {\n                             throw new UnsupportedOperationException();\n                         }\n                     } else {\n                         throw new UnsupportedOperationException();\n                     }\n                 }\n                 index++;\n             }\n         }\n \n         // if nothing is found we should ask the parent context\n         return getParent().solveSymbolAsValue(name, typeSolver);\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"acdac6790f4424f8097b3aa6c888e825cac485f9": {
			"type": "Ybodychange",
			"commitMessage": "Fixes for type inference\n",
			"commitDate": "2017-03-09, 5:22 PM",
			"commitName": "acdac6790f4424f8097b3aa6c888e825cac485f9",
			"commitAuthor": "xdrop",
			"commitDateOld": "2017-03-08, 7:31 PM",
			"commitNameOld": "17ac5ada0476c72aa79a2e0c39311e90bfa0fe60",
			"commitAuthorOld": "xdrop",
			"daysBetweenCommits": 0.91,
			"commitsBetweenForRepo": 3,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,49 +1,56 @@\n     public Optional<Value> solveSymbolAsValue(String name, TypeSolver typeSolver) {\n         for (Parameter parameter : wrappedNode.getParameters()) {\n             SymbolDeclarator sb = JavaParserFactory.getSymbolDeclarator(parameter, typeSolver);\n             int index = 0;\n             for (ValueDeclaration decl : sb.getSymbolDeclarations()) {\n                 if (decl.getName().equals(name)) {\n                     if (getParentNode(wrappedNode) instanceof MethodCallExpr) {\n                         MethodCallExpr methodCallExpr = (MethodCallExpr) getParentNode(wrappedNode);\n                         MethodUsage methodUsage = JavaParserFacade.get(typeSolver).solveMethodAsUsage(methodCallExpr);\n                         int i = pos(methodCallExpr, wrappedNode);\n                         Type lambdaType = methodUsage.getParamTypes().get(i);\n-                        Value value = new Value(lambdaType.asReferenceType().typeParametersValues().get(0), name);\n+                        Type argType = lambdaType.asReferenceType().typeParametersValues().get(0);\n+                        LambdaConstraintType conType;\n+                        if (argType.isWildcard()){\n+                            conType = LambdaConstraintType.bound(argType.asWildcard().getBoundedType());\n+                        } else {\n+                            conType = LambdaConstraintType.bound(argType);\n+                        }\n+                        Value value = new Value(conType, name);\n                         return Optional.of(value);\n                     } else if (getParentNode(wrappedNode) instanceof VariableDeclarator) {\n                         VariableDeclarator variableDeclarator = (VariableDeclarator) getParentNode(wrappedNode);\n                         Type t = JavaParserFacade.get(typeSolver).convertToUsageVariableType(variableDeclarator);\n                         Optional<MethodUsage> functionalMethod = FunctionalInterfaceLogic.getFunctionalMethod(t);\n                         if (functionalMethod.isPresent()) {\n                             Type lambdaType = functionalMethod.get().getParamType(index);\n \n                             // Replace parameter from declarator\n                             Map<TypeParameterDeclaration, Type> inferredTypes = new HashMap<>();\n                             if (lambdaType.isReferenceType()) {\n                                 for (Tuple2<TypeParameterDeclaration, Type> entry : lambdaType.asReferenceType().getTypeParametersMap()) {\n                                     if (entry._2.isTypeVariable() && entry._2.asTypeParameter().declaredOnType()) {\n                                         Type ot = t.asReferenceType().typeParametersMap().getValue(entry._1);\n                                         lambdaType = lambdaType.replaceTypeVariables(entry._1, ot, inferredTypes);\n                                     }\n                                 }\n                             } else if (lambdaType.isTypeVariable() && lambdaType.asTypeParameter().declaredOnType()) {\n                                 lambdaType = t.asReferenceType().typeParametersMap().getValue(lambdaType.asTypeParameter());\n                             }\n \n                             Value value = new Value(lambdaType, name);\n                             return Optional.of(value);\n                         } else {\n                             throw new UnsupportedOperationException();\n                         }\n                     } else {\n                         throw new UnsupportedOperationException();\n                     }\n                 }\n                 index++;\n             }\n         }\n \n         // if nothing is found we should ask the parent context\n         return getParent().solveSymbolAsValue(name, typeSolver);\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"2082034e8c3eb434e3df25dd420c98cae5a6d518": {
			"type": "Ybodychange",
			"commitMessage": "type inference\n",
			"commitDate": "2016-10-24, 10:19 AM",
			"commitName": "2082034e8c3eb434e3df25dd420c98cae5a6d518",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2016-10-23, 2:26 AM",
			"commitNameOld": "631896a1d2f34eed89c41cc717f463ebbd69e401",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 1.33,
			"commitsBetweenForRepo": 12,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,48 +1,49 @@\n     public Optional<Value> solveSymbolAsValue(String name, TypeSolver typeSolver) {\n         for (Parameter parameter : wrappedNode.getParameters()) {\n             SymbolDeclarator sb = JavaParserFactory.getSymbolDeclarator(parameter, typeSolver);\n             int index = 0;\n             for (ValueDeclaration decl : sb.getSymbolDeclarations()) {\n                 if (decl.getName().equals(name)) {\n                     if (getParentNode(wrappedNode) instanceof MethodCallExpr) {\n                         MethodCallExpr methodCallExpr = (MethodCallExpr) getParentNode(wrappedNode);\n                         MethodUsage methodUsage = JavaParserFacade.get(typeSolver).solveMethodAsUsage(methodCallExpr);\n                         int i = pos(methodCallExpr, wrappedNode);\n                         Type lambdaType = methodUsage.getParamTypes().get(i);\n                         Value value = new Value(lambdaType.asReferenceType().typeParametersValues().get(0), name);\n                         return Optional.of(value);\n                     } else if (getParentNode(wrappedNode) instanceof VariableDeclarator) {\n                         VariableDeclarator variableDeclarator = (VariableDeclarator) getParentNode(wrappedNode);\n                         Type t = JavaParserFacade.get(typeSolver).convertToUsageVariableType(variableDeclarator);\n                         Optional<MethodUsage> functionalMethod = FunctionalInterfaceLogic.getFunctionalMethod(t);\n                         if (functionalMethod.isPresent()) {\n                             Type lambdaType = functionalMethod.get().getParamType(index);\n \n                             // Replace parameter from declarator\n+                            Map<TypeParameterDeclaration, Type> inferredTypes = new HashMap<>();\n                             if (lambdaType.isReferenceType()) {\n                                 for (Tuple2<TypeParameterDeclaration, Type> entry : lambdaType.asReferenceType().getTypeParametersMap()) {\n                                     if (entry._2.isTypeVariable() && entry._2.asTypeParameter().declaredOnType()) {\n                                         Type ot = t.asReferenceType().typeParametersMap().getValue(entry._1);\n-                                        lambdaType = lambdaType.replaceTypeVariables(entry._1, ot);\n+                                        lambdaType = lambdaType.replaceTypeVariables(entry._1, ot, inferredTypes);\n                                     }\n                                 }\n                             } else if (lambdaType.isTypeVariable() && lambdaType.asTypeParameter().declaredOnType()) {\n                                 lambdaType = t.asReferenceType().typeParametersMap().getValue(lambdaType.asTypeParameter());\n                             }\n \n                             Value value = new Value(lambdaType, name);\n                             return Optional.of(value);\n                         } else {\n                             throw new UnsupportedOperationException();\n                         }\n                     } else {\n                         throw new UnsupportedOperationException();\n                     }\n                 }\n                 index++;\n             }\n         }\n \n         // if nothing is found we should ask the parent context\n         return getParent().solveSymbolAsValue(name, typeSolver);\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"631896a1d2f34eed89c41cc717f463ebbd69e401": {
			"type": "Ybodychange",
			"commitMessage": "commenting classes in model\n",
			"commitDate": "2016-10-23, 2:26 AM",
			"commitName": "631896a1d2f34eed89c41cc717f463ebbd69e401",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2016-10-22, 5:39 AM",
			"commitNameOld": "dc093e9ac9ae3239375c654c4cfff92ee0fb3927",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 0.87,
			"commitsBetweenForRepo": 26,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,48 +1,48 @@\n     public Optional<Value> solveSymbolAsValue(String name, TypeSolver typeSolver) {\n         for (Parameter parameter : wrappedNode.getParameters()) {\n             SymbolDeclarator sb = JavaParserFactory.getSymbolDeclarator(parameter, typeSolver);\n             int index = 0;\n             for (ValueDeclaration decl : sb.getSymbolDeclarations()) {\n                 if (decl.getName().equals(name)) {\n                     if (getParentNode(wrappedNode) instanceof MethodCallExpr) {\n                         MethodCallExpr methodCallExpr = (MethodCallExpr) getParentNode(wrappedNode);\n                         MethodUsage methodUsage = JavaParserFacade.get(typeSolver).solveMethodAsUsage(methodCallExpr);\n                         int i = pos(methodCallExpr, wrappedNode);\n                         Type lambdaType = methodUsage.getParamTypes().get(i);\n                         Value value = new Value(lambdaType.asReferenceType().typeParametersValues().get(0), name);\n                         return Optional.of(value);\n                     } else if (getParentNode(wrappedNode) instanceof VariableDeclarator) {\n                         VariableDeclarator variableDeclarator = (VariableDeclarator) getParentNode(wrappedNode);\n                         Type t = JavaParserFacade.get(typeSolver).convertToUsageVariableType(variableDeclarator);\n                         Optional<MethodUsage> functionalMethod = FunctionalInterfaceLogic.getFunctionalMethod(t);\n                         if (functionalMethod.isPresent()) {\n                             Type lambdaType = functionalMethod.get().getParamType(index);\n \n                             // Replace parameter from declarator\n                             if (lambdaType.isReferenceType()) {\n                                 for (Tuple2<TypeParameterDeclaration, Type> entry : lambdaType.asReferenceType().getTypeParametersMap()) {\n                                     if (entry._2.isTypeVariable() && entry._2.asTypeParameter().declaredOnType()) {\n                                         Type ot = t.asReferenceType().typeParametersMap().getValue(entry._1);\n-                                        lambdaType = lambdaType.replaceParam(entry._1, ot);\n+                                        lambdaType = lambdaType.replaceTypeVariables(entry._1, ot);\n                                     }\n                                 }\n                             } else if (lambdaType.isTypeVariable() && lambdaType.asTypeParameter().declaredOnType()) {\n                                 lambdaType = t.asReferenceType().typeParametersMap().getValue(lambdaType.asTypeParameter());\n                             }\n \n                             Value value = new Value(lambdaType, name);\n                             return Optional.of(value);\n                         } else {\n                             throw new UnsupportedOperationException();\n                         }\n                     } else {\n                         throw new UnsupportedOperationException();\n                     }\n                 }\n                 index++;\n             }\n         }\n \n         // if nothing is found we should ask the parent context\n         return getParent().solveSymbolAsValue(name, typeSolver);\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"dc093e9ac9ae3239375c654c4cfff92ee0fb3927": {
			"type": "Ybodychange",
			"commitMessage": "more usages of TypeParameterDeclaration instead of just the name\n",
			"commitDate": "2016-10-22, 5:39 AM",
			"commitName": "dc093e9ac9ae3239375c654c4cfff92ee0fb3927",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2016-10-22, 5:36 AM",
			"commitNameOld": "7c43ba3c700d72a0d613bce3659af6d74bc87434",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 0,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,48 +1,48 @@\n     public Optional<Value> solveSymbolAsValue(String name, TypeSolver typeSolver) {\n         for (Parameter parameter : wrappedNode.getParameters()) {\n             SymbolDeclarator sb = JavaParserFactory.getSymbolDeclarator(parameter, typeSolver);\n             int index = 0;\n             for (ValueDeclaration decl : sb.getSymbolDeclarations()) {\n                 if (decl.getName().equals(name)) {\n                     if (getParentNode(wrappedNode) instanceof MethodCallExpr) {\n                         MethodCallExpr methodCallExpr = (MethodCallExpr) getParentNode(wrappedNode);\n                         MethodUsage methodUsage = JavaParserFacade.get(typeSolver).solveMethodAsUsage(methodCallExpr);\n                         int i = pos(methodCallExpr, wrappedNode);\n                         Type lambdaType = methodUsage.getParamTypes().get(i);\n                         Value value = new Value(lambdaType.asReferenceType().typeParametersValues().get(0), name);\n                         return Optional.of(value);\n                     } else if (getParentNode(wrappedNode) instanceof VariableDeclarator) {\n                         VariableDeclarator variableDeclarator = (VariableDeclarator) getParentNode(wrappedNode);\n                         Type t = JavaParserFacade.get(typeSolver).convertToUsageVariableType(variableDeclarator);\n                         Optional<MethodUsage> functionalMethod = FunctionalInterfaceLogic.getFunctionalMethod(t);\n                         if (functionalMethod.isPresent()) {\n                             Type lambdaType = functionalMethod.get().getParamType(index);\n \n                             // Replace parameter from declarator\n                             if (lambdaType.isReferenceType()) {\n                                 for (Tuple2<TypeParameterDeclaration, Type> entry : lambdaType.asReferenceType().getTypeParametersMap()) {\n                                     if (entry._2.isTypeVariable() && entry._2.asTypeParameter().declaredOnType()) {\n                                         Type ot = t.asReferenceType().typeParametersMap().getValue(entry._1);\n-                                        lambdaType = lambdaType.replaceParam(entry._1.getName(), ot);\n+                                        lambdaType = lambdaType.replaceParam(entry._1, ot);\n                                     }\n                                 }\n                             } else if (lambdaType.isTypeVariable() && lambdaType.asTypeParameter().declaredOnType()) {\n                                 lambdaType = t.asReferenceType().typeParametersMap().getValue(lambdaType.asTypeParameter());\n                             }\n \n                             Value value = new Value(lambdaType, name);\n                             return Optional.of(value);\n                         } else {\n                             throw new UnsupportedOperationException();\n                         }\n                     } else {\n                         throw new UnsupportedOperationException();\n                     }\n                 }\n                 index++;\n             }\n         }\n \n         // if nothing is found we should ask the parent context\n         return getParent().solveSymbolAsValue(name, typeSolver);\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"6fcf6356a95a250db103245c1c5f2d596f9493d6": {
			"type": "Ybodychange",
			"commitMessage": "model: refactoring\n",
			"commitDate": "2016-10-22, 2:18 AM",
			"commitName": "6fcf6356a95a250db103245c1c5f2d596f9493d6",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2016-10-21, 4:23 AM",
			"commitNameOld": "ecc1af475857cf3c62b3a07eb35ad080ed435dea",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 0.91,
			"commitsBetweenForRepo": 7,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,53 +1,48 @@\n     public Optional<Value> solveSymbolAsValue(String name, TypeSolver typeSolver) {\n         for (Parameter parameter : wrappedNode.getParameters()) {\n             SymbolDeclarator sb = JavaParserFactory.getSymbolDeclarator(parameter, typeSolver);\n             int index = 0;\n             for (ValueDeclaration decl : sb.getSymbolDeclarations()) {\n                 if (decl.getName().equals(name)) {\n                     if (getParentNode(wrappedNode) instanceof MethodCallExpr) {\n                         MethodCallExpr methodCallExpr = (MethodCallExpr) getParentNode(wrappedNode);\n                         MethodUsage methodUsage = JavaParserFacade.get(typeSolver).solveMethodAsUsage(methodCallExpr);\n                         int i = pos(methodCallExpr, wrappedNode);\n                         Type lambdaType = methodUsage.getParamTypes().get(i);\n                         Value value = new Value(lambdaType.asReferenceType().typeParametersValues().get(0), name);\n                         return Optional.of(value);\n                     } else if (getParentNode(wrappedNode) instanceof VariableDeclarator) {\n                         VariableDeclarator variableDeclarator = (VariableDeclarator) getParentNode(wrappedNode);\n                         Type t = JavaParserFacade.get(typeSolver).convertToUsageVariableType(variableDeclarator);\n                         Optional<MethodUsage> functionalMethod = FunctionalInterfaceLogic.getFunctionalMethod(t);\n                         if (functionalMethod.isPresent()) {\n                             Type lambdaType = functionalMethod.get().getParamType(index);\n \n                             // Replace parameter from declarator\n                             if (lambdaType.isReferenceType()) {\n                                 for (Tuple2<TypeParameterDeclaration, Type> entry : lambdaType.asReferenceType().getTypeParametersMap()) {\n                                     if (entry._2.isTypeVariable() && entry._2.asTypeParameter().declaredOnType()) {\n-                                        Optional<Type> ot = t.asReferenceType().getGenericParameterByName(entry._1.getName());\n-                                        if (ot.isPresent()) {\n-                                            lambdaType = lambdaType.replaceParam(entry._1.getName(), ot.get());\n-                                        }\n+                                        Type ot = t.asReferenceType().typeParametersMap().getValue(entry._1);\n+                                        lambdaType = lambdaType.replaceParam(entry._1.getName(), ot);\n                                     }\n                                 }\n                             } else if (lambdaType.isTypeVariable() && lambdaType.asTypeParameter().declaredOnType()) {\n-                                Optional<Type> ot = t.asReferenceType().getGenericParameterByName(lambdaType.asTypeParameter().getName());\n-                                if (ot.isPresent()) {\n-                                    lambdaType = ot.get();\n-                                }\n+                                lambdaType = t.asReferenceType().typeParametersMap().getValue(lambdaType.asTypeParameter());\n                             }\n \n                             Value value = new Value(lambdaType, name);\n                             return Optional.of(value);\n                         } else {\n                             throw new UnsupportedOperationException();\n                         }\n                     } else {\n                         throw new UnsupportedOperationException();\n                     }\n                 }\n                 index++;\n             }\n         }\n \n         // if nothing is found we should ask the parent context\n         return getParent().solveSymbolAsValue(name, typeSolver);\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"ecc1af475857cf3c62b3a07eb35ad080ed435dea": {
			"type": "Ybodychange",
			"commitMessage": "more comments on model\n",
			"commitDate": "2016-10-21, 4:23 AM",
			"commitName": "ecc1af475857cf3c62b3a07eb35ad080ed435dea",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2016-10-20, 11:55 PM",
			"commitNameOld": "b32947e8c85bc21fe533173f50d4a0a91036fdaf",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 0.19,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,53 +1,53 @@\n     public Optional<Value> solveSymbolAsValue(String name, TypeSolver typeSolver) {\n         for (Parameter parameter : wrappedNode.getParameters()) {\n             SymbolDeclarator sb = JavaParserFactory.getSymbolDeclarator(parameter, typeSolver);\n             int index = 0;\n             for (ValueDeclaration decl : sb.getSymbolDeclarations()) {\n                 if (decl.getName().equals(name)) {\n                     if (getParentNode(wrappedNode) instanceof MethodCallExpr) {\n                         MethodCallExpr methodCallExpr = (MethodCallExpr) getParentNode(wrappedNode);\n                         MethodUsage methodUsage = JavaParserFacade.get(typeSolver).solveMethodAsUsage(methodCallExpr);\n                         int i = pos(methodCallExpr, wrappedNode);\n                         Type lambdaType = methodUsage.getParamTypes().get(i);\n-                        Value value = new Value(lambdaType.asReferenceType().typeParametersValues().get(0), name, false);\n+                        Value value = new Value(lambdaType.asReferenceType().typeParametersValues().get(0), name);\n                         return Optional.of(value);\n                     } else if (getParentNode(wrappedNode) instanceof VariableDeclarator) {\n                         VariableDeclarator variableDeclarator = (VariableDeclarator) getParentNode(wrappedNode);\n                         Type t = JavaParserFacade.get(typeSolver).convertToUsageVariableType(variableDeclarator);\n                         Optional<MethodUsage> functionalMethod = FunctionalInterfaceLogic.getFunctionalMethod(t);\n                         if (functionalMethod.isPresent()) {\n                             Type lambdaType = functionalMethod.get().getParamType(index);\n \n                             // Replace parameter from declarator\n                             if (lambdaType.isReferenceType()) {\n                                 for (Tuple2<TypeParameterDeclaration, Type> entry : lambdaType.asReferenceType().getTypeParametersMap()) {\n                                     if (entry._2.isTypeVariable() && entry._2.asTypeParameter().declaredOnType()) {\n                                         Optional<Type> ot = t.asReferenceType().getGenericParameterByName(entry._1.getName());\n                                         if (ot.isPresent()) {\n                                             lambdaType = lambdaType.replaceParam(entry._1.getName(), ot.get());\n                                         }\n                                     }\n                                 }\n                             } else if (lambdaType.isTypeVariable() && lambdaType.asTypeParameter().declaredOnType()) {\n                                 Optional<Type> ot = t.asReferenceType().getGenericParameterByName(lambdaType.asTypeParameter().getName());\n                                 if (ot.isPresent()) {\n                                     lambdaType = ot.get();\n                                 }\n                             }\n \n-                            Value value = new Value(lambdaType, name, false);\n+                            Value value = new Value(lambdaType, name);\n                             return Optional.of(value);\n                         } else {\n                             throw new UnsupportedOperationException();\n                         }\n                     } else {\n                         throw new UnsupportedOperationException();\n                     }\n                 }\n                 index++;\n             }\n         }\n \n         // if nothing is found we should ask the parent context\n         return getParent().solveSymbolAsValue(name, typeSolver);\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"b32947e8c85bc21fe533173f50d4a0a91036fdaf": {
			"type": "Ybodychange",
			"commitMessage": "adding more comments in model declarations\n",
			"commitDate": "2016-10-20, 11:55 PM",
			"commitName": "b32947e8c85bc21fe533173f50d4a0a91036fdaf",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2016-10-20, 1:06 PM",
			"commitNameOld": "1e7780e554428a10c73de88ca64e5933b2291593",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 0.45,
			"commitsBetweenForRepo": 2,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,53 +1,53 @@\n     public Optional<Value> solveSymbolAsValue(String name, TypeSolver typeSolver) {\n         for (Parameter parameter : wrappedNode.getParameters()) {\n             SymbolDeclarator sb = JavaParserFactory.getSymbolDeclarator(parameter, typeSolver);\n             int index = 0;\n             for (ValueDeclaration decl : sb.getSymbolDeclarations()) {\n                 if (decl.getName().equals(name)) {\n                     if (getParentNode(wrappedNode) instanceof MethodCallExpr) {\n                         MethodCallExpr methodCallExpr = (MethodCallExpr) getParentNode(wrappedNode);\n                         MethodUsage methodUsage = JavaParserFacade.get(typeSolver).solveMethodAsUsage(methodCallExpr);\n                         int i = pos(methodCallExpr, wrappedNode);\n                         Type lambdaType = methodUsage.getParamTypes().get(i);\n                         Value value = new Value(lambdaType.asReferenceType().typeParametersValues().get(0), name, false);\n                         return Optional.of(value);\n                     } else if (getParentNode(wrappedNode) instanceof VariableDeclarator) {\n                         VariableDeclarator variableDeclarator = (VariableDeclarator) getParentNode(wrappedNode);\n                         Type t = JavaParserFacade.get(typeSolver).convertToUsageVariableType(variableDeclarator);\n                         Optional<MethodUsage> functionalMethod = FunctionalInterfaceLogic.getFunctionalMethod(t);\n                         if (functionalMethod.isPresent()) {\n                             Type lambdaType = functionalMethod.get().getParamType(index);\n \n                             // Replace parameter from declarator\n                             if (lambdaType.isReferenceType()) {\n                                 for (Tuple2<TypeParameterDeclaration, Type> entry : lambdaType.asReferenceType().getTypeParametersMap()) {\n-                                    if (entry._2.isTypeVariable() && entry._2.asTypeParameter().declaredOnClass()) {\n+                                    if (entry._2.isTypeVariable() && entry._2.asTypeParameter().declaredOnType()) {\n                                         Optional<Type> ot = t.asReferenceType().getGenericParameterByName(entry._1.getName());\n                                         if (ot.isPresent()) {\n                                             lambdaType = lambdaType.replaceParam(entry._1.getName(), ot.get());\n                                         }\n                                     }\n                                 }\n-                            } else if (lambdaType.isTypeVariable() && lambdaType.asTypeParameter().declaredOnClass()) {\n+                            } else if (lambdaType.isTypeVariable() && lambdaType.asTypeParameter().declaredOnType()) {\n                                 Optional<Type> ot = t.asReferenceType().getGenericParameterByName(lambdaType.asTypeParameter().getName());\n                                 if (ot.isPresent()) {\n                                     lambdaType = ot.get();\n                                 }\n                             }\n \n                             Value value = new Value(lambdaType, name, false);\n                             return Optional.of(value);\n                         } else {\n                             throw new UnsupportedOperationException();\n                         }\n                     } else {\n                         throw new UnsupportedOperationException();\n                     }\n                 }\n                 index++;\n             }\n         }\n \n         // if nothing is found we should ask the parent context\n         return getParent().solveSymbolAsValue(name, typeSolver);\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"9c53c2cbc607ea694438ade8630be0c155a33162": {
			"type": "Yfilerename",
			"commitMessage": "renamed packages to com.github.javapaerser\n",
			"commitDate": "2016-10-19, 11:39 PM",
			"commitName": "9c53c2cbc607ea694438ade8630be0c155a33162",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2016-10-19, 11:32 PM",
			"commitNameOld": "b1da215b407e8cfc2c77182f0ab3e67e0ab16ef3",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 0,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "",
			"extendedDetails": {
				"oldPath": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/javaparsermodel/contexts/LambdaExprContext.java",
				"newPath": "java-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/LambdaExprContext.java"
			}
		},
		"967b0302143d4d6868c3d9035a8615ccfd198b6e": {
			"type": "Ybodychange",
			"commitMessage": "use VariableDeclarator.getType\n",
			"commitDate": "2016-10-19, 10:36 AM",
			"commitName": "967b0302143d4d6868c3d9035a8615ccfd198b6e",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2016-10-19, 10:35 AM",
			"commitNameOld": "0d14741fef3a17451db153cfe379e398da4b4b79",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 0,
			"commitsBetweenForRepo": 14,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,63 +1,53 @@\n     public Optional<Value> solveSymbolAsValue(String name, TypeSolver typeSolver) {\n         for (Parameter parameter : wrappedNode.getParameters()) {\n             SymbolDeclarator sb = JavaParserFactory.getSymbolDeclarator(parameter, typeSolver);\n             int index = 0;\n             for (ValueDeclaration decl : sb.getSymbolDeclarations()) {\n                 if (decl.getName().equals(name)) {\n                     if (getParentNode(wrappedNode) instanceof MethodCallExpr) {\n                         MethodCallExpr methodCallExpr = (MethodCallExpr) getParentNode(wrappedNode);\n                         MethodUsage methodUsage = JavaParserFacade.get(typeSolver).solveMethodAsUsage(methodCallExpr);\n                         int i = pos(methodCallExpr, wrappedNode);\n                         Type lambdaType = methodUsage.getParamTypes().get(i);\n                         Value value = new Value(lambdaType.asReferenceType().typeParametersValues().get(0), name, false);\n                         return Optional.of(value);\n                     } else if (getParentNode(wrappedNode) instanceof VariableDeclarator) {\n-                        com.github.javaparser.ast.type.Type declaratorType = null;\n-                        \n                         VariableDeclarator variableDeclarator = (VariableDeclarator) getParentNode(wrappedNode);\n-                        if (getParentNode(variableDeclarator) instanceof VariableDeclarationExpr) {\n-                            declaratorType = ((VariableDeclarationExpr) getParentNode(variableDeclarator)).getElementType();\n-                        } else if (getParentNode(variableDeclarator) instanceof FieldDeclaration) {\n-                            declaratorType = ((FieldDeclaration) getParentNode(variableDeclarator)).getElementType();\n-                        } else {\n-                            throw new UnsupportedOperationException(getParentNode(variableDeclarator).getClass().getCanonicalName());\n-                        }\n-\n-                        Type t = JavaParserFacade.get(typeSolver).convert(declaratorType, declaratorType);\n+                        Type t = JavaParserFacade.get(typeSolver).convertToUsageVariableType(variableDeclarator);\n                         Optional<MethodUsage> functionalMethod = FunctionalInterfaceLogic.getFunctionalMethod(t);\n                         if (functionalMethod.isPresent()) {\n                             Type lambdaType = functionalMethod.get().getParamType(index);\n \n                             // Replace parameter from declarator\n                             if (lambdaType.isReferenceType()) {\n                                 for (Tuple2<TypeParameterDeclaration, Type> entry : lambdaType.asReferenceType().getTypeParametersMap()) {\n                                     if (entry._2.isTypeVariable() && entry._2.asTypeParameter().declaredOnClass()) {\n                                         Optional<Type> ot = t.asReferenceType().getGenericParameterByName(entry._1.getName());\n                                         if (ot.isPresent()) {\n                                             lambdaType = lambdaType.replaceParam(entry._1.getName(), ot.get());\n                                         }\n                                     }\n                                 }\n                             } else if (lambdaType.isTypeVariable() && lambdaType.asTypeParameter().declaredOnClass()) {\n                                 Optional<Type> ot = t.asReferenceType().getGenericParameterByName(lambdaType.asTypeParameter().getName());\n                                 if (ot.isPresent()) {\n                                     lambdaType = ot.get();\n                                 }\n                             }\n \n                             Value value = new Value(lambdaType, name, false);\n                             return Optional.of(value);\n                         } else {\n                             throw new UnsupportedOperationException();\n                         }\n                     } else {\n                         throw new UnsupportedOperationException();\n                     }\n                 }\n                 index++;\n             } \n         }\n \n         // if nothing is found we should ask the parent context\n         return getParent().solveSymbolAsValue(name, typeSolver);\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"4601dfb9d1acf7f564948b7ddbb9201d62849ad7": {
			"type": "Ybodychange",
			"commitMessage": "revision of modified code to use Navigator.getParentNode\n",
			"commitDate": "2016-10-19, 10:35 AM",
			"commitName": "4601dfb9d1acf7f564948b7ddbb9201d62849ad7",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2016-10-19, 10:34 AM",
			"commitNameOld": "03e407957d600a18ef0a4a83224c17d155ef8645",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 0,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,63 +1,63 @@\n     public Optional<Value> solveSymbolAsValue(String name, TypeSolver typeSolver) {\n         for (Parameter parameter : wrappedNode.getParameters()) {\n             SymbolDeclarator sb = JavaParserFactory.getSymbolDeclarator(parameter, typeSolver);\n             int index = 0;\n             for (ValueDeclaration decl : sb.getSymbolDeclarations()) {\n                 if (decl.getName().equals(name)) {\n-                    if (wrappedNode.getParentNode() instanceof MethodCallExpr) {\n-                        MethodCallExpr methodCallExpr = (MethodCallExpr) wrappedNode.getParentNode();\n+                    if (getParentNode(wrappedNode) instanceof MethodCallExpr) {\n+                        MethodCallExpr methodCallExpr = (MethodCallExpr) getParentNode(wrappedNode);\n                         MethodUsage methodUsage = JavaParserFacade.get(typeSolver).solveMethodAsUsage(methodCallExpr);\n                         int i = pos(methodCallExpr, wrappedNode);\n                         Type lambdaType = methodUsage.getParamTypes().get(i);\n                         Value value = new Value(lambdaType.asReferenceType().typeParametersValues().get(0), name, false);\n                         return Optional.of(value);\n-                    } else if (wrappedNode.getParentNode() instanceof VariableDeclarator) {\n+                    } else if (getParentNode(wrappedNode) instanceof VariableDeclarator) {\n                         com.github.javaparser.ast.type.Type declaratorType = null;\n                         \n-                        VariableDeclarator variableDeclarator = (VariableDeclarator) wrappedNode.getParentNode();\n-                        if (variableDeclarator.getParentNode().getParentNode() instanceof VariableDeclarationExpr) {\n-                            declaratorType = ((VariableDeclarationExpr) variableDeclarator.getParentNode().getParentNode()).getElementType();\n-                        } else if (variableDeclarator.getParentNode().getParentNode() instanceof FieldDeclaration) {\n-                            declaratorType = ((FieldDeclaration) variableDeclarator.getParentNode().getParentNode()).getElementType();\n+                        VariableDeclarator variableDeclarator = (VariableDeclarator) getParentNode(wrappedNode);\n+                        if (getParentNode(variableDeclarator) instanceof VariableDeclarationExpr) {\n+                            declaratorType = ((VariableDeclarationExpr) getParentNode(variableDeclarator)).getElementType();\n+                        } else if (getParentNode(variableDeclarator) instanceof FieldDeclaration) {\n+                            declaratorType = ((FieldDeclaration) getParentNode(variableDeclarator)).getElementType();\n                         } else {\n-                            throw new UnsupportedOperationException(variableDeclarator.getParentNode().getParentNode().getClass().getCanonicalName());\n+                            throw new UnsupportedOperationException(getParentNode(variableDeclarator).getClass().getCanonicalName());\n                         }\n \n                         Type t = JavaParserFacade.get(typeSolver).convert(declaratorType, declaratorType);\n                         Optional<MethodUsage> functionalMethod = FunctionalInterfaceLogic.getFunctionalMethod(t);\n                         if (functionalMethod.isPresent()) {\n                             Type lambdaType = functionalMethod.get().getParamType(index);\n \n                             // Replace parameter from declarator\n                             if (lambdaType.isReferenceType()) {\n                                 for (Tuple2<TypeParameterDeclaration, Type> entry : lambdaType.asReferenceType().getTypeParametersMap()) {\n                                     if (entry._2.isTypeVariable() && entry._2.asTypeParameter().declaredOnClass()) {\n                                         Optional<Type> ot = t.asReferenceType().getGenericParameterByName(entry._1.getName());\n                                         if (ot.isPresent()) {\n                                             lambdaType = lambdaType.replaceParam(entry._1.getName(), ot.get());\n                                         }\n                                     }\n                                 }\n                             } else if (lambdaType.isTypeVariable() && lambdaType.asTypeParameter().declaredOnClass()) {\n                                 Optional<Type> ot = t.asReferenceType().getGenericParameterByName(lambdaType.asTypeParameter().getName());\n                                 if (ot.isPresent()) {\n                                     lambdaType = ot.get();\n                                 }\n                             }\n \n                             Value value = new Value(lambdaType, name, false);\n                             return Optional.of(value);\n                         } else {\n                             throw new UnsupportedOperationException();\n                         }\n                     } else {\n                         throw new UnsupportedOperationException();\n                     }\n                 }\n                 index++;\n             } \n         }\n \n         // if nothing is found we should ask the parent context\n         return getParent().solveSymbolAsValue(name, typeSolver);\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"03e407957d600a18ef0a4a83224c17d155ef8645": {
			"type": "Ybodychange",
			"commitMessage": "fixing a few more tests\n",
			"commitDate": "2016-10-19, 10:34 AM",
			"commitName": "03e407957d600a18ef0a4a83224c17d155ef8645",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2016-10-19, 10:33 AM",
			"commitNameOld": "341e081a5f8909a3a467671befcca2941b786d3d",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 0,
			"commitsBetweenForRepo": 4,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,63 +1,63 @@\n     public Optional<Value> solveSymbolAsValue(String name, TypeSolver typeSolver) {\n         for (Parameter parameter : wrappedNode.getParameters()) {\n             SymbolDeclarator sb = JavaParserFactory.getSymbolDeclarator(parameter, typeSolver);\n             int index = 0;\n             for (ValueDeclaration decl : sb.getSymbolDeclarations()) {\n                 if (decl.getName().equals(name)) {\n                     if (wrappedNode.getParentNode() instanceof MethodCallExpr) {\n                         MethodCallExpr methodCallExpr = (MethodCallExpr) wrappedNode.getParentNode();\n                         MethodUsage methodUsage = JavaParserFacade.get(typeSolver).solveMethodAsUsage(methodCallExpr);\n                         int i = pos(methodCallExpr, wrappedNode);\n                         Type lambdaType = methodUsage.getParamTypes().get(i);\n                         Value value = new Value(lambdaType.asReferenceType().typeParametersValues().get(0), name, false);\n                         return Optional.of(value);\n                     } else if (wrappedNode.getParentNode() instanceof VariableDeclarator) {\n                         com.github.javaparser.ast.type.Type declaratorType = null;\n                         \n                         VariableDeclarator variableDeclarator = (VariableDeclarator) wrappedNode.getParentNode();\n-                        if (variableDeclarator.getParentNode() instanceof VariableDeclarationExpr) {\n-                            declaratorType = ((VariableDeclarationExpr) variableDeclarator.getParentNode()).getElementType();\n-                        } else if (variableDeclarator.getParentNode() instanceof FieldDeclaration) {\n-                            declaratorType = ((FieldDeclaration) variableDeclarator.getParentNode()).getElementType();\n+                        if (variableDeclarator.getParentNode().getParentNode() instanceof VariableDeclarationExpr) {\n+                            declaratorType = ((VariableDeclarationExpr) variableDeclarator.getParentNode().getParentNode()).getElementType();\n+                        } else if (variableDeclarator.getParentNode().getParentNode() instanceof FieldDeclaration) {\n+                            declaratorType = ((FieldDeclaration) variableDeclarator.getParentNode().getParentNode()).getElementType();\n                         } else {\n-                            throw new UnsupportedOperationException();\n+                            throw new UnsupportedOperationException(variableDeclarator.getParentNode().getParentNode().getClass().getCanonicalName());\n                         }\n \n                         Type t = JavaParserFacade.get(typeSolver).convert(declaratorType, declaratorType);\n                         Optional<MethodUsage> functionalMethod = FunctionalInterfaceLogic.getFunctionalMethod(t);\n                         if (functionalMethod.isPresent()) {\n                             Type lambdaType = functionalMethod.get().getParamType(index);\n \n                             // Replace parameter from declarator\n                             if (lambdaType.isReferenceType()) {\n                                 for (Tuple2<TypeParameterDeclaration, Type> entry : lambdaType.asReferenceType().getTypeParametersMap()) {\n                                     if (entry._2.isTypeVariable() && entry._2.asTypeParameter().declaredOnClass()) {\n                                         Optional<Type> ot = t.asReferenceType().getGenericParameterByName(entry._1.getName());\n                                         if (ot.isPresent()) {\n                                             lambdaType = lambdaType.replaceParam(entry._1.getName(), ot.get());\n                                         }\n                                     }\n                                 }\n                             } else if (lambdaType.isTypeVariable() && lambdaType.asTypeParameter().declaredOnClass()) {\n                                 Optional<Type> ot = t.asReferenceType().getGenericParameterByName(lambdaType.asTypeParameter().getName());\n                                 if (ot.isPresent()) {\n                                     lambdaType = ot.get();\n                                 }\n                             }\n \n                             Value value = new Value(lambdaType, name, false);\n                             return Optional.of(value);\n                         } else {\n                             throw new UnsupportedOperationException();\n                         }\n                     } else {\n                         throw new UnsupportedOperationException();\n                     }\n                 }\n                 index++;\n             } \n         }\n \n         // if nothing is found we should ask the parent context\n         return getParent().solveSymbolAsValue(name, typeSolver);\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"341e081a5f8909a3a467671befcca2941b786d3d": {
			"type": "Ybodychange",
			"commitMessage": "issue91: solve compilation issues\n",
			"commitDate": "2016-10-19, 10:33 AM",
			"commitName": "341e081a5f8909a3a467671befcca2941b786d3d",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2016-10-19, 8:04 AM",
			"commitNameOld": "683012de2a3a28358e848f8b145d462eb8b322ba",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 0.1,
			"commitsBetweenForRepo": 6,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,63 +1,63 @@\n     public Optional<Value> solveSymbolAsValue(String name, TypeSolver typeSolver) {\n         for (Parameter parameter : wrappedNode.getParameters()) {\n             SymbolDeclarator sb = JavaParserFactory.getSymbolDeclarator(parameter, typeSolver);\n             int index = 0;\n             for (ValueDeclaration decl : sb.getSymbolDeclarations()) {\n                 if (decl.getName().equals(name)) {\n                     if (wrappedNode.getParentNode() instanceof MethodCallExpr) {\n                         MethodCallExpr methodCallExpr = (MethodCallExpr) wrappedNode.getParentNode();\n                         MethodUsage methodUsage = JavaParserFacade.get(typeSolver).solveMethodAsUsage(methodCallExpr);\n                         int i = pos(methodCallExpr, wrappedNode);\n                         Type lambdaType = methodUsage.getParamTypes().get(i);\n                         Value value = new Value(lambdaType.asReferenceType().typeParametersValues().get(0), name, false);\n                         return Optional.of(value);\n                     } else if (wrappedNode.getParentNode() instanceof VariableDeclarator) {\n                         com.github.javaparser.ast.type.Type declaratorType = null;\n                         \n                         VariableDeclarator variableDeclarator = (VariableDeclarator) wrappedNode.getParentNode();\n                         if (variableDeclarator.getParentNode() instanceof VariableDeclarationExpr) {\n-                            declaratorType = ((VariableDeclarationExpr) variableDeclarator.getParentNode()).getType();\n+                            declaratorType = ((VariableDeclarationExpr) variableDeclarator.getParentNode()).getElementType();\n                         } else if (variableDeclarator.getParentNode() instanceof FieldDeclaration) {\n-                            declaratorType = ((FieldDeclaration) variableDeclarator.getParentNode()).getType();\n+                            declaratorType = ((FieldDeclaration) variableDeclarator.getParentNode()).getElementType();\n                         } else {\n                             throw new UnsupportedOperationException();\n                         }\n \n                         Type t = JavaParserFacade.get(typeSolver).convert(declaratorType, declaratorType);\n                         Optional<MethodUsage> functionalMethod = FunctionalInterfaceLogic.getFunctionalMethod(t);\n                         if (functionalMethod.isPresent()) {\n                             Type lambdaType = functionalMethod.get().getParamType(index);\n \n                             // Replace parameter from declarator\n                             if (lambdaType.isReferenceType()) {\n                                 for (Tuple2<TypeParameterDeclaration, Type> entry : lambdaType.asReferenceType().getTypeParametersMap()) {\n                                     if (entry._2.isTypeVariable() && entry._2.asTypeParameter().declaredOnClass()) {\n                                         Optional<Type> ot = t.asReferenceType().getGenericParameterByName(entry._1.getName());\n                                         if (ot.isPresent()) {\n                                             lambdaType = lambdaType.replaceParam(entry._1.getName(), ot.get());\n                                         }\n                                     }\n                                 }\n                             } else if (lambdaType.isTypeVariable() && lambdaType.asTypeParameter().declaredOnClass()) {\n                                 Optional<Type> ot = t.asReferenceType().getGenericParameterByName(lambdaType.asTypeParameter().getName());\n                                 if (ot.isPresent()) {\n                                     lambdaType = ot.get();\n                                 }\n                             }\n \n                             Value value = new Value(lambdaType, name, false);\n                             return Optional.of(value);\n                         } else {\n                             throw new UnsupportedOperationException();\n                         }\n                     } else {\n                         throw new UnsupportedOperationException();\n                     }\n                 }\n                 index++;\n             } \n         }\n \n         // if nothing is found we should ask the parent context\n         return getParent().solveSymbolAsValue(name, typeSolver);\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"051dbd94c17c4f142d3fe9e8fbd03c29d09ace54": {
			"type": "Ybodychange",
			"commitMessage": "add test JavaParserClassDeclarationTest.testGetSuperclassWithTypeParameters\n",
			"commitDate": "2016-10-14, 1:57 PM",
			"commitName": "051dbd94c17c4f142d3fe9e8fbd03c29d09ace54",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2016-10-14, 10:24 AM",
			"commitNameOld": "70f3e66c944670a818922f101162226ef604b263",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 0.15,
			"commitsBetweenForRepo": 2,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,63 +1,63 @@\n     public Optional<Value> solveSymbolAsValue(String name, TypeSolver typeSolver) {\n         for (Parameter parameter : wrappedNode.getParameters()) {\n             SymbolDeclarator sb = JavaParserFactory.getSymbolDeclarator(parameter, typeSolver);\n             int index = 0;\n             for (ValueDeclaration decl : sb.getSymbolDeclarations()) {\n                 if (decl.getName().equals(name)) {\n                     if (wrappedNode.getParentNode() instanceof MethodCallExpr) {\n                         MethodCallExpr methodCallExpr = (MethodCallExpr) wrappedNode.getParentNode();\n                         MethodUsage methodUsage = JavaParserFacade.get(typeSolver).solveMethodAsUsage(methodCallExpr);\n                         int i = pos(methodCallExpr, wrappedNode);\n                         Type lambdaType = methodUsage.getParamTypes().get(i);\n-                        Value value = new Value(lambdaType.asReferenceTypeUsage().typeParametersValues().get(0), name, false);\n+                        Value value = new Value(lambdaType.asReferenceType().typeParametersValues().get(0), name, false);\n                         return Optional.of(value);\n                     } else if (wrappedNode.getParentNode() instanceof VariableDeclarator) {\n                         com.github.javaparser.ast.type.Type declaratorType = null;\n                         \n                         VariableDeclarator variableDeclarator = (VariableDeclarator) wrappedNode.getParentNode();\n                         if (variableDeclarator.getParentNode() instanceof VariableDeclarationExpr) {\n                             declaratorType = ((VariableDeclarationExpr) variableDeclarator.getParentNode()).getType();\n                         } else if (variableDeclarator.getParentNode() instanceof FieldDeclaration) {\n                             declaratorType = ((FieldDeclaration) variableDeclarator.getParentNode()).getType();\n                         } else {\n                             throw new UnsupportedOperationException();\n                         }\n \n                         Type t = JavaParserFacade.get(typeSolver).convert(declaratorType, declaratorType);\n                         Optional<MethodUsage> functionalMethod = FunctionalInterfaceLogic.getFunctionalMethod(t);\n                         if (functionalMethod.isPresent()) {\n                             Type lambdaType = functionalMethod.get().getParamType(index);\n \n                             // Replace parameter from declarator\n                             if (lambdaType.isReferenceType()) {\n-                                for (Tuple2<TypeParameterDeclaration, Type> entry : lambdaType.asReferenceTypeUsage().getTypeParametersMap()) {\n+                                for (Tuple2<TypeParameterDeclaration, Type> entry : lambdaType.asReferenceType().getTypeParametersMap()) {\n                                     if (entry._2.isTypeVariable() && entry._2.asTypeParameter().declaredOnClass()) {\n-                                        Optional<Type> ot = t.asReferenceTypeUsage().getGenericParameterByName(entry._1.getName());\n+                                        Optional<Type> ot = t.asReferenceType().getGenericParameterByName(entry._1.getName());\n                                         if (ot.isPresent()) {\n                                             lambdaType = lambdaType.replaceParam(entry._1.getName(), ot.get());\n                                         }\n                                     }\n                                 }\n                             } else if (lambdaType.isTypeVariable() && lambdaType.asTypeParameter().declaredOnClass()) {\n-                                Optional<Type> ot = t.asReferenceTypeUsage().getGenericParameterByName(lambdaType.asTypeParameter().getName());\n+                                Optional<Type> ot = t.asReferenceType().getGenericParameterByName(lambdaType.asTypeParameter().getName());\n                                 if (ot.isPresent()) {\n                                     lambdaType = ot.get();\n                                 }\n                             }\n \n                             Value value = new Value(lambdaType, name, false);\n                             return Optional.of(value);\n                         } else {\n                             throw new UnsupportedOperationException();\n                         }\n                     } else {\n                         throw new UnsupportedOperationException();\n                     }\n                 }\n                 index++;\n             } \n         }\n \n         // if nothing is found we should ask the parent context\n         return getParent().solveSymbolAsValue(name, typeSolver);\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"70f3e66c944670a818922f101162226ef604b263": {
			"type": "Ybodychange",
			"commitMessage": "deprecating some methods involving type parameters\n",
			"commitDate": "2016-10-14, 10:24 AM",
			"commitName": "70f3e66c944670a818922f101162226ef604b263",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2016-10-14, 9:51 AM",
			"commitNameOld": "ecc78c8b480ceb41019f764c983aaa69c2dabfe3",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 0.02,
			"commitsBetweenForRepo": 4,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,63 +1,63 @@\n     public Optional<Value> solveSymbolAsValue(String name, TypeSolver typeSolver) {\n         for (Parameter parameter : wrappedNode.getParameters()) {\n             SymbolDeclarator sb = JavaParserFactory.getSymbolDeclarator(parameter, typeSolver);\n             int index = 0;\n             for (ValueDeclaration decl : sb.getSymbolDeclarations()) {\n                 if (decl.getName().equals(name)) {\n                     if (wrappedNode.getParentNode() instanceof MethodCallExpr) {\n                         MethodCallExpr methodCallExpr = (MethodCallExpr) wrappedNode.getParentNode();\n                         MethodUsage methodUsage = JavaParserFacade.get(typeSolver).solveMethodAsUsage(methodCallExpr);\n                         int i = pos(methodCallExpr, wrappedNode);\n                         Type lambdaType = methodUsage.getParamTypes().get(i);\n-                        Value value = new Value(lambdaType.asReferenceTypeUsage().parameters().get(0), name, false);\n+                        Value value = new Value(lambdaType.asReferenceTypeUsage().typeParametersValues().get(0), name, false);\n                         return Optional.of(value);\n                     } else if (wrappedNode.getParentNode() instanceof VariableDeclarator) {\n                         com.github.javaparser.ast.type.Type declaratorType = null;\n                         \n                         VariableDeclarator variableDeclarator = (VariableDeclarator) wrappedNode.getParentNode();\n                         if (variableDeclarator.getParentNode() instanceof VariableDeclarationExpr) {\n                             declaratorType = ((VariableDeclarationExpr) variableDeclarator.getParentNode()).getType();\n                         } else if (variableDeclarator.getParentNode() instanceof FieldDeclaration) {\n                             declaratorType = ((FieldDeclaration) variableDeclarator.getParentNode()).getType();\n                         } else {\n                             throw new UnsupportedOperationException();\n                         }\n \n                         Type t = JavaParserFacade.get(typeSolver).convert(declaratorType, declaratorType);\n                         Optional<MethodUsage> functionalMethod = FunctionalInterfaceLogic.getFunctionalMethod(t);\n                         if (functionalMethod.isPresent()) {\n                             Type lambdaType = functionalMethod.get().getParamType(index);\n \n                             // Replace parameter from declarator\n                             if (lambdaType.isReferenceType()) {\n                                 for (Tuple2<TypeParameterDeclaration, Type> entry : lambdaType.asReferenceTypeUsage().getTypeParametersMap()) {\n                                     if (entry._2.isTypeVariable() && entry._2.asTypeParameter().declaredOnClass()) {\n                                         Optional<Type> ot = t.asReferenceTypeUsage().getGenericParameterByName(entry._1.getName());\n                                         if (ot.isPresent()) {\n                                             lambdaType = lambdaType.replaceParam(entry._1.getName(), ot.get());\n                                         }\n                                     }\n                                 }\n                             } else if (lambdaType.isTypeVariable() && lambdaType.asTypeParameter().declaredOnClass()) {\n                                 Optional<Type> ot = t.asReferenceTypeUsage().getGenericParameterByName(lambdaType.asTypeParameter().getName());\n                                 if (ot.isPresent()) {\n                                     lambdaType = ot.get();\n                                 }\n                             }\n \n                             Value value = new Value(lambdaType, name, false);\n                             return Optional.of(value);\n                         } else {\n                             throw new UnsupportedOperationException();\n                         }\n                     } else {\n                         throw new UnsupportedOperationException();\n                     }\n                 }\n                 index++;\n             } \n         }\n \n         // if nothing is found we should ask the parent context\n         return getParent().solveSymbolAsValue(name, typeSolver);\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"ecc78c8b480ceb41019f764c983aaa69c2dabfe3": {
			"type": "Ybodychange",
			"commitMessage": "reorganize packages in model\n",
			"commitDate": "2016-10-14, 9:51 AM",
			"commitName": "ecc78c8b480ceb41019f764c983aaa69c2dabfe3",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2016-10-13, 11:36 PM",
			"commitNameOld": "8d234965b572759181da7787fead07b225e9e5ca",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 0.43,
			"commitsBetweenForRepo": 5,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,63 +1,63 @@\n     public Optional<Value> solveSymbolAsValue(String name, TypeSolver typeSolver) {\n         for (Parameter parameter : wrappedNode.getParameters()) {\n             SymbolDeclarator sb = JavaParserFactory.getSymbolDeclarator(parameter, typeSolver);\n             int index = 0;\n             for (ValueDeclaration decl : sb.getSymbolDeclarations()) {\n                 if (decl.getName().equals(name)) {\n                     if (wrappedNode.getParentNode() instanceof MethodCallExpr) {\n                         MethodCallExpr methodCallExpr = (MethodCallExpr) wrappedNode.getParentNode();\n                         MethodUsage methodUsage = JavaParserFacade.get(typeSolver).solveMethodAsUsage(methodCallExpr);\n                         int i = pos(methodCallExpr, wrappedNode);\n                         Type lambdaType = methodUsage.getParamTypes().get(i);\n                         Value value = new Value(lambdaType.asReferenceTypeUsage().parameters().get(0), name, false);\n                         return Optional.of(value);\n                     } else if (wrappedNode.getParentNode() instanceof VariableDeclarator) {\n                         com.github.javaparser.ast.type.Type declaratorType = null;\n                         \n                         VariableDeclarator variableDeclarator = (VariableDeclarator) wrappedNode.getParentNode();\n                         if (variableDeclarator.getParentNode() instanceof VariableDeclarationExpr) {\n                             declaratorType = ((VariableDeclarationExpr) variableDeclarator.getParentNode()).getType();\n                         } else if (variableDeclarator.getParentNode() instanceof FieldDeclaration) {\n                             declaratorType = ((FieldDeclaration) variableDeclarator.getParentNode()).getType();\n                         } else {\n                             throw new UnsupportedOperationException();\n                         }\n \n                         Type t = JavaParserFacade.get(typeSolver).convert(declaratorType, declaratorType);\n                         Optional<MethodUsage> functionalMethod = FunctionalInterfaceLogic.getFunctionalMethod(t);\n                         if (functionalMethod.isPresent()) {\n                             Type lambdaType = functionalMethod.get().getParamType(index);\n \n                             // Replace parameter from declarator\n                             if (lambdaType.isReferenceType()) {\n-                                for (Tuple2<TypeParameter, Type> entry : lambdaType.asReferenceTypeUsage().getTypeParametersMap()) {\n+                                for (Tuple2<TypeParameterDeclaration, Type> entry : lambdaType.asReferenceTypeUsage().getTypeParametersMap()) {\n                                     if (entry._2.isTypeVariable() && entry._2.asTypeParameter().declaredOnClass()) {\n                                         Optional<Type> ot = t.asReferenceTypeUsage().getGenericParameterByName(entry._1.getName());\n                                         if (ot.isPresent()) {\n                                             lambdaType = lambdaType.replaceParam(entry._1.getName(), ot.get());\n                                         }\n                                     }\n                                 }\n                             } else if (lambdaType.isTypeVariable() && lambdaType.asTypeParameter().declaredOnClass()) {\n                                 Optional<Type> ot = t.asReferenceTypeUsage().getGenericParameterByName(lambdaType.asTypeParameter().getName());\n                                 if (ot.isPresent()) {\n                                     lambdaType = ot.get();\n                                 }\n                             }\n \n                             Value value = new Value(lambdaType, name, false);\n                             return Optional.of(value);\n                         } else {\n                             throw new UnsupportedOperationException();\n                         }\n                     } else {\n                         throw new UnsupportedOperationException();\n                     }\n                 }\n                 index++;\n             } \n         }\n \n         // if nothing is found we should ask the parent context\n         return getParent().solveSymbolAsValue(name, typeSolver);\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"8d234965b572759181da7787fead07b225e9e5ca": {
			"type": "Ybodychange",
			"commitMessage": "remove TypeSolver from MethodUsage\n",
			"commitDate": "2016-10-13, 11:36 PM",
			"commitName": "8d234965b572759181da7787fead07b225e9e5ca",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2016-10-13, 1:11 PM",
			"commitNameOld": "82eb44707b620803d424188a1eb8708fcaf093cb",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 0.43,
			"commitsBetweenForRepo": 6,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,63 +1,63 @@\n     public Optional<Value> solveSymbolAsValue(String name, TypeSolver typeSolver) {\n         for (Parameter parameter : wrappedNode.getParameters()) {\n             SymbolDeclarator sb = JavaParserFactory.getSymbolDeclarator(parameter, typeSolver);\n             int index = 0;\n             for (ValueDeclaration decl : sb.getSymbolDeclarations()) {\n                 if (decl.getName().equals(name)) {\n                     if (wrappedNode.getParentNode() instanceof MethodCallExpr) {\n                         MethodCallExpr methodCallExpr = (MethodCallExpr) wrappedNode.getParentNode();\n                         MethodUsage methodUsage = JavaParserFacade.get(typeSolver).solveMethodAsUsage(methodCallExpr);\n                         int i = pos(methodCallExpr, wrappedNode);\n                         Type lambdaType = methodUsage.getParamTypes().get(i);\n                         Value value = new Value(lambdaType.asReferenceTypeUsage().parameters().get(0), name, false);\n                         return Optional.of(value);\n                     } else if (wrappedNode.getParentNode() instanceof VariableDeclarator) {\n                         com.github.javaparser.ast.type.Type declaratorType = null;\n                         \n                         VariableDeclarator variableDeclarator = (VariableDeclarator) wrappedNode.getParentNode();\n                         if (variableDeclarator.getParentNode() instanceof VariableDeclarationExpr) {\n                             declaratorType = ((VariableDeclarationExpr) variableDeclarator.getParentNode()).getType();\n                         } else if (variableDeclarator.getParentNode() instanceof FieldDeclaration) {\n                             declaratorType = ((FieldDeclaration) variableDeclarator.getParentNode()).getType();\n                         } else {\n                             throw new UnsupportedOperationException();\n                         }\n \n                         Type t = JavaParserFacade.get(typeSolver).convert(declaratorType, declaratorType);\n                         Optional<MethodUsage> functionalMethod = FunctionalInterfaceLogic.getFunctionalMethod(t);\n                         if (functionalMethod.isPresent()) {\n-                            Type lambdaType = functionalMethod.get().getParamType(index, typeSolver);\n+                            Type lambdaType = functionalMethod.get().getParamType(index);\n \n                             // Replace parameter from declarator\n                             if (lambdaType.isReferenceType()) {\n                                 for (Tuple2<TypeParameter, Type> entry : lambdaType.asReferenceTypeUsage().getTypeParametersMap()) {\n                                     if (entry._2.isTypeVariable() && entry._2.asTypeParameter().declaredOnClass()) {\n                                         Optional<Type> ot = t.asReferenceTypeUsage().getGenericParameterByName(entry._1.getName());\n                                         if (ot.isPresent()) {\n                                             lambdaType = lambdaType.replaceParam(entry._1.getName(), ot.get());\n                                         }\n                                     }\n                                 }\n                             } else if (lambdaType.isTypeVariable() && lambdaType.asTypeParameter().declaredOnClass()) {\n                                 Optional<Type> ot = t.asReferenceTypeUsage().getGenericParameterByName(lambdaType.asTypeParameter().getName());\n                                 if (ot.isPresent()) {\n                                     lambdaType = ot.get();\n                                 }\n                             }\n \n                             Value value = new Value(lambdaType, name, false);\n                             return Optional.of(value);\n                         } else {\n                             throw new UnsupportedOperationException();\n                         }\n                     } else {\n                         throw new UnsupportedOperationException();\n                     }\n                 }\n                 index++;\n             } \n         }\n \n         // if nothing is found we should ask the parent context\n         return getParent().solveSymbolAsValue(name, typeSolver);\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"82eb44707b620803d424188a1eb8708fcaf093cb": {
			"type": "Ybodychange",
			"commitMessage": "rename TypeUsage into Type\n",
			"commitDate": "2016-10-13, 1:11 PM",
			"commitName": "82eb44707b620803d424188a1eb8708fcaf093cb",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2016-10-12, 2:43 PM",
			"commitNameOld": "401a56f412ca186a00a2282d9088e8cb7b67e0e5",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 0.94,
			"commitsBetweenForRepo": 21,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,63 +1,63 @@\n     public Optional<Value> solveSymbolAsValue(String name, TypeSolver typeSolver) {\n         for (Parameter parameter : wrappedNode.getParameters()) {\n             SymbolDeclarator sb = JavaParserFactory.getSymbolDeclarator(parameter, typeSolver);\n             int index = 0;\n             for (ValueDeclaration decl : sb.getSymbolDeclarations()) {\n                 if (decl.getName().equals(name)) {\n                     if (wrappedNode.getParentNode() instanceof MethodCallExpr) {\n                         MethodCallExpr methodCallExpr = (MethodCallExpr) wrappedNode.getParentNode();\n                         MethodUsage methodUsage = JavaParserFacade.get(typeSolver).solveMethodAsUsage(methodCallExpr);\n                         int i = pos(methodCallExpr, wrappedNode);\n-                        TypeUsage lambdaType = methodUsage.getParamTypes().get(i);\n+                        Type lambdaType = methodUsage.getParamTypes().get(i);\n                         Value value = new Value(lambdaType.asReferenceTypeUsage().parameters().get(0), name, false);\n                         return Optional.of(value);\n                     } else if (wrappedNode.getParentNode() instanceof VariableDeclarator) {\n-                        Type declaratorType = null;\n+                        com.github.javaparser.ast.type.Type declaratorType = null;\n                         \n                         VariableDeclarator variableDeclarator = (VariableDeclarator) wrappedNode.getParentNode();\n                         if (variableDeclarator.getParentNode() instanceof VariableDeclarationExpr) {\n                             declaratorType = ((VariableDeclarationExpr) variableDeclarator.getParentNode()).getType();\n                         } else if (variableDeclarator.getParentNode() instanceof FieldDeclaration) {\n                             declaratorType = ((FieldDeclaration) variableDeclarator.getParentNode()).getType();\n                         } else {\n                             throw new UnsupportedOperationException();\n                         }\n \n-                        TypeUsage t = JavaParserFacade.get(typeSolver).convert(declaratorType, declaratorType);\n+                        Type t = JavaParserFacade.get(typeSolver).convert(declaratorType, declaratorType);\n                         Optional<MethodUsage> functionalMethod = FunctionalInterfaceLogic.getFunctionalMethod(t);\n                         if (functionalMethod.isPresent()) {\n-                            TypeUsage lambdaType = functionalMethod.get().getParamType(index, typeSolver);\n+                            Type lambdaType = functionalMethod.get().getParamType(index, typeSolver);\n \n                             // Replace parameter from declarator\n                             if (lambdaType.isReferenceType()) {\n-                                for (Tuple2<TypeParameter, TypeUsage> entry : lambdaType.asReferenceTypeUsage().getTypeParametersMap()) {\n+                                for (Tuple2<TypeParameter, Type> entry : lambdaType.asReferenceTypeUsage().getTypeParametersMap()) {\n                                     if (entry._2.isTypeVariable() && entry._2.asTypeParameter().declaredOnClass()) {\n-                                        Optional<TypeUsage> ot = t.asReferenceTypeUsage().getGenericParameterByName(entry._1.getName());\n+                                        Optional<Type> ot = t.asReferenceTypeUsage().getGenericParameterByName(entry._1.getName());\n                                         if (ot.isPresent()) {\n                                             lambdaType = lambdaType.replaceParam(entry._1.getName(), ot.get());\n                                         }\n                                     }\n                                 }\n                             } else if (lambdaType.isTypeVariable() && lambdaType.asTypeParameter().declaredOnClass()) {\n-                                Optional<TypeUsage> ot = t.asReferenceTypeUsage().getGenericParameterByName(lambdaType.asTypeParameter().getName());\n+                                Optional<Type> ot = t.asReferenceTypeUsage().getGenericParameterByName(lambdaType.asTypeParameter().getName());\n                                 if (ot.isPresent()) {\n                                     lambdaType = ot.get();\n                                 }\n                             }\n \n                             Value value = new Value(lambdaType, name, false);\n                             return Optional.of(value);\n                         } else {\n                             throw new UnsupportedOperationException();\n                         }\n                     } else {\n                         throw new UnsupportedOperationException();\n                     }\n                 }\n                 index++;\n             } \n         }\n \n         // if nothing is found we should ask the parent context\n         return getParent().solveSymbolAsValue(name, typeSolver);\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"401a56f412ca186a00a2282d9088e8cb7b67e0e5": {
			"type": "Ybodychange",
			"commitMessage": "issue80: working on lambdas assigned to variables\n",
			"commitDate": "2016-10-12, 2:43 PM",
			"commitName": "401a56f412ca186a00a2282d9088e8cb7b67e0e5",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2016-09-23, 7:49 AM",
			"commitNameOld": "e529ad59cb7c1766706162cbc3a4fca49cd88e3e",
			"commitAuthorOld": "malte_langkabel",
			"daysBetweenCommits": 19.29,
			"commitsBetweenForRepo": 56,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,42 +1,63 @@\n     public Optional<Value> solveSymbolAsValue(String name, TypeSolver typeSolver) {\n         for (Parameter parameter : wrappedNode.getParameters()) {\n             SymbolDeclarator sb = JavaParserFactory.getSymbolDeclarator(parameter, typeSolver);\n+            int index = 0;\n             for (ValueDeclaration decl : sb.getSymbolDeclarations()) {\n                 if (decl.getName().equals(name)) {\n                     if (wrappedNode.getParentNode() instanceof MethodCallExpr) {\n                         MethodCallExpr methodCallExpr = (MethodCallExpr) wrappedNode.getParentNode();\n                         MethodUsage methodUsage = JavaParserFacade.get(typeSolver).solveMethodAsUsage(methodCallExpr);\n                         int i = pos(methodCallExpr, wrappedNode);\n                         TypeUsage lambdaType = methodUsage.getParamTypes().get(i);\n                         Value value = new Value(lambdaType.asReferenceTypeUsage().parameters().get(0), name, false);\n                         return Optional.of(value);\n                     } else if (wrappedNode.getParentNode() instanceof VariableDeclarator) {\n                         Type declaratorType = null;\n                         \n                         VariableDeclarator variableDeclarator = (VariableDeclarator) wrappedNode.getParentNode();\n                         if (variableDeclarator.getParentNode() instanceof VariableDeclarationExpr) {\n                             declaratorType = ((VariableDeclarationExpr) variableDeclarator.getParentNode()).getType();\n                         } else if (variableDeclarator.getParentNode() instanceof FieldDeclaration) {\n                             declaratorType = ((FieldDeclaration) variableDeclarator.getParentNode()).getType();\n                         } else {\n                             throw new UnsupportedOperationException();\n                         }\n \n-                        Optional<MethodUsage> functionalMethod = FunctionalInterfaceLogic.getFunctionalMethod(JavaParserFacade.get(typeSolver).convert(declaratorType, declaratorType));\n-                        if (functionalMethod.isPresent() && functionalMethod.get().getNoParams() == 1) {\n-                            TypeUsage lambdaType = functionalMethod.get().getParamType(0, typeSolver);\n+                        TypeUsage t = JavaParserFacade.get(typeSolver).convert(declaratorType, declaratorType);\n+                        Optional<MethodUsage> functionalMethod = FunctionalInterfaceLogic.getFunctionalMethod(t);\n+                        if (functionalMethod.isPresent()) {\n+                            TypeUsage lambdaType = functionalMethod.get().getParamType(index, typeSolver);\n+\n+                            // Replace parameter from declarator\n+                            if (lambdaType.isReferenceType()) {\n+                                for (Tuple2<TypeParameter, TypeUsage> entry : lambdaType.asReferenceTypeUsage().getTypeParametersMap()) {\n+                                    if (entry._2.isTypeVariable() && entry._2.asTypeParameter().declaredOnClass()) {\n+                                        Optional<TypeUsage> ot = t.asReferenceTypeUsage().getGenericParameterByName(entry._1.getName());\n+                                        if (ot.isPresent()) {\n+                                            lambdaType = lambdaType.replaceParam(entry._1.getName(), ot.get());\n+                                        }\n+                                    }\n+                                }\n+                            } else if (lambdaType.isTypeVariable() && lambdaType.asTypeParameter().declaredOnClass()) {\n+                                Optional<TypeUsage> ot = t.asReferenceTypeUsage().getGenericParameterByName(lambdaType.asTypeParameter().getName());\n+                                if (ot.isPresent()) {\n+                                    lambdaType = ot.get();\n+                                }\n+                            }\n+\n                             Value value = new Value(lambdaType, name, false);\n                             return Optional.of(value);\n                         } else {\n                             throw new UnsupportedOperationException();\n                         }\n                     } else {\n                         throw new UnsupportedOperationException();\n                     }\n                 }\n+                index++;\n             } \n         }\n \n         // if nothing is found we should ask the parent context\n         return getParent().solveSymbolAsValue(name, typeSolver);\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"e529ad59cb7c1766706162cbc3a4fca49cd88e3e": {
			"type": "Ybodychange",
			"commitMessage": "expanded LambdaExprContext to solve lambda parameter types in contexts other than method calls and implemented tests for newly supported cases.\n",
			"commitDate": "2016-09-23, 7:49 AM",
			"commitName": "e529ad59cb7c1766706162cbc3a4fca49cd88e3e",
			"commitAuthor": "malte_langkabel",
			"commitDateOld": "2015-12-03, 12:36 PM",
			"commitNameOld": "45898d6dbf0eab3b7258bd74125c70f498fca373",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 294.76,
			"commitsBetweenForRepo": 46,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,18 +1,42 @@\n     public Optional<Value> solveSymbolAsValue(String name, TypeSolver typeSolver) {\n         for (Parameter parameter : wrappedNode.getParameters()) {\n             SymbolDeclarator sb = JavaParserFactory.getSymbolDeclarator(parameter, typeSolver);\n-            if (wrappedNode.getParentNode() instanceof MethodCallExpr) {\n-                MethodCallExpr methodCallExpr = (MethodCallExpr) wrappedNode.getParentNode();\n-                MethodUsage methodUsage = JavaParserFacade.get(typeSolver).solveMethodAsUsage(methodCallExpr);\n-                int i = pos(methodCallExpr, wrappedNode);\n-                TypeUsage lambdaType = methodUsage.getParamTypes().get(i);\n-                Value value = new Value(lambdaType.asReferenceTypeUsage().parameters().get(0), name, false);\n-                return Optional.of(value);\n-            } else {\n-                throw new UnsupportedOperationException();\n-            }\n+            for (ValueDeclaration decl : sb.getSymbolDeclarations()) {\n+                if (decl.getName().equals(name)) {\n+                    if (wrappedNode.getParentNode() instanceof MethodCallExpr) {\n+                        MethodCallExpr methodCallExpr = (MethodCallExpr) wrappedNode.getParentNode();\n+                        MethodUsage methodUsage = JavaParserFacade.get(typeSolver).solveMethodAsUsage(methodCallExpr);\n+                        int i = pos(methodCallExpr, wrappedNode);\n+                        TypeUsage lambdaType = methodUsage.getParamTypes().get(i);\n+                        Value value = new Value(lambdaType.asReferenceTypeUsage().parameters().get(0), name, false);\n+                        return Optional.of(value);\n+                    } else if (wrappedNode.getParentNode() instanceof VariableDeclarator) {\n+                        Type declaratorType = null;\n+                        \n+                        VariableDeclarator variableDeclarator = (VariableDeclarator) wrappedNode.getParentNode();\n+                        if (variableDeclarator.getParentNode() instanceof VariableDeclarationExpr) {\n+                            declaratorType = ((VariableDeclarationExpr) variableDeclarator.getParentNode()).getType();\n+                        } else if (variableDeclarator.getParentNode() instanceof FieldDeclaration) {\n+                            declaratorType = ((FieldDeclaration) variableDeclarator.getParentNode()).getType();\n+                        } else {\n+                            throw new UnsupportedOperationException();\n+                        }\n+\n+                        Optional<MethodUsage> functionalMethod = FunctionalInterfaceLogic.getFunctionalMethod(JavaParserFacade.get(typeSolver).convert(declaratorType, declaratorType));\n+                        if (functionalMethod.isPresent() && functionalMethod.get().getNoParams() == 1) {\n+                            TypeUsage lambdaType = functionalMethod.get().getParamType(0, typeSolver);\n+                            Value value = new Value(lambdaType, name, false);\n+                            return Optional.of(value);\n+                        } else {\n+                            throw new UnsupportedOperationException();\n+                        }\n+                    } else {\n+                        throw new UnsupportedOperationException();\n+                    }\n+                }\n+            } \n         }\n \n         // if nothing is found we should ask the parent context\n         return getParent().solveSymbolAsValue(name, typeSolver);\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"8e655d386a595ea1927ebeded58939d7b8a7ce0c": {
			"type": "Yfilerename",
			"commitMessage": "test JavaParserClassDeclaration\n",
			"commitDate": "2015-11-22, 2:45 AM",
			"commitName": "8e655d386a595ea1927ebeded58939d7b8a7ce0c",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2015-11-22, 2:03 AM",
			"commitNameOld": "68d87977d826a8c48711297732b7ae10f3dc1f1f",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 0.03,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "",
			"extendedDetails": {
				"oldPath": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/resolution/javaparser/contexts/LambdaExprContext.java",
				"newPath": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/javaparsermodel/contexts/LambdaExprContext.java"
			}
		},
		"f4b07b1a2deac6d1b562424ac2380b92cec77a90": {
			"type": "Yfilerename",
			"commitMessage": "modules: organization in modules\n",
			"commitDate": "2015-11-13, 1:12 AM",
			"commitName": "f4b07b1a2deac6d1b562424ac2380b92cec77a90",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2015-11-13, 12:53 AM",
			"commitNameOld": "d96a8ff67d857a2988488f1fc31202f0e2ed8061",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 0.01,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "",
			"extendedDetails": {
				"oldPath": "src/main/java/me/tomassetti/symbolsolver/resolution/javaparser/contexts/LambdaExprContext.java",
				"newPath": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/resolution/javaparser/contexts/LambdaExprContext.java"
			}
		},
		"d2d7f3eb20f7095fa49a43b20bed11d32e64da7f": {
			"type": "Ybodychange",
			"commitMessage": "remove TypeUsage.typeParameters\n",
			"commitDate": "2015-10-30, 8:48 AM",
			"commitName": "d2d7f3eb20f7095fa49a43b20bed11d32e64da7f",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2015-10-30, 2:53 AM",
			"commitNameOld": "b36f33050149a62a5b3c8c7451ae93f736715029",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 0.25,
			"commitsBetweenForRepo": 12,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,18 +1,18 @@\n     public Optional<Value> solveSymbolAsValue(String name, TypeSolver typeSolver) {\n         for (Parameter parameter : wrappedNode.getParameters()) {\n             SymbolDeclarator sb = JavaParserFactory.getSymbolDeclarator(parameter, typeSolver);\n             if (wrappedNode.getParentNode() instanceof MethodCallExpr){\n                 MethodCallExpr methodCallExpr = (MethodCallExpr)wrappedNode.getParentNode();\n                 MethodUsage methodUsage = JavaParserFacade.get(typeSolver).solveMethodAsUsage(methodCallExpr);\n                 int i = pos(methodCallExpr, wrappedNode);\n                 TypeUsage lambdaType = methodUsage.getParamTypes().get(i);\n-                Value value = new Value(lambdaType.parameters().get(0), name, false);\n+                Value value = new Value(lambdaType.asReferenceTypeUsage().parameters().get(0), name, false);\n                 return Optional.of(value);\n             } else {\n                 throw new UnsupportedOperationException();\n             }\n         }\n \n         // if nothing is found we should ask the parent context\n         return getParent().solveSymbolAsValue(name, typeSolver);\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"b36f33050149a62a5b3c8c7451ae93f736715029": {
			"type": "Yfilerename",
			"commitMessage": "reorganize packages\n",
			"commitDate": "2015-10-30, 2:53 AM",
			"commitName": "b36f33050149a62a5b3c8c7451ae93f736715029",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2015-10-30, 2:29 AM",
			"commitNameOld": "90999800bdc73eacb5ef25dafcd36c8518af3072",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 0.02,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "",
			"extendedDetails": {
				"oldPath": "src/main/java/me/tomassetti/symbolsolver/model/javaparser/contexts/LambdaExprContext.java",
				"newPath": "src/main/java/me/tomassetti/symbolsolver/resolution/javaparser/contexts/LambdaExprContext.java"
			}
		},
		"627b56302d259409e9bc50b20d77803484f18b5c": {
			"type": "Ybodychange",
			"commitMessage": "introduce cache in JavaParserFacade\n",
			"commitDate": "2015-08-05, 7:25 AM",
			"commitName": "627b56302d259409e9bc50b20d77803484f18b5c",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2015-08-05, 7:08 AM",
			"commitNameOld": "1adb8b4c97103ac5b15d009f3eda791a53b83d6f",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 0.01,
			"commitsBetweenForRepo": 2,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,18 +1,18 @@\n     public Optional<Value> solveSymbolAsValue(String name, TypeSolver typeSolver) {\n         for (Parameter parameter : wrappedNode.getParameters()) {\n             SymbolDeclarator sb = JavaParserFactory.getSymbolDeclarator(parameter, typeSolver);\n             if (wrappedNode.getParentNode() instanceof MethodCallExpr){\n                 MethodCallExpr methodCallExpr = (MethodCallExpr)wrappedNode.getParentNode();\n-                MethodUsage methodUsage = new JavaParserFacade(typeSolver).solveMethodAsUsage(methodCallExpr);\n+                MethodUsage methodUsage = JavaParserFacade.get(typeSolver).solveMethodAsUsage(methodCallExpr);\n                 int i = pos(methodCallExpr, wrappedNode);\n                 TypeUsage lambdaType = methodUsage.getParamTypes().get(i);\n                 Value value = new Value(lambdaType.parameters().get(0), name, false);\n                 return Optional.of(value);\n             } else {\n                 throw new UnsupportedOperationException();\n             }\n         }\n \n         // if nothing is found we should ask the parent context\n         return getParent().solveSymbolAsValue(name, typeSolver);\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"1adb8b4c97103ac5b15d009f3eda791a53b83d6f": {
			"type": "Yintroduced",
			"commitMessage": "add resolveReferenceToLambdaParamBase\n",
			"commitDate": "2015-08-05, 7:08 AM",
			"commitName": "1adb8b4c97103ac5b15d009f3eda791a53b83d6f",
			"commitAuthor": "Federico Tomassetti",
			"diff": "@@ -0,0 +1,18 @@\n+    public Optional<Value> solveSymbolAsValue(String name, TypeSolver typeSolver) {\n+        for (Parameter parameter : wrappedNode.getParameters()) {\n+            SymbolDeclarator sb = JavaParserFactory.getSymbolDeclarator(parameter, typeSolver);\n+            if (wrappedNode.getParentNode() instanceof MethodCallExpr){\n+                MethodCallExpr methodCallExpr = (MethodCallExpr)wrappedNode.getParentNode();\n+                MethodUsage methodUsage = new JavaParserFacade(typeSolver).solveMethodAsUsage(methodCallExpr);\n+                int i = pos(methodCallExpr, wrappedNode);\n+                TypeUsage lambdaType = methodUsage.getParamTypes().get(i);\n+                Value value = new Value(lambdaType.parameters().get(0), name, false);\n+                return Optional.of(value);\n+            } else {\n+                throw new UnsupportedOperationException();\n+            }\n+        }\n+\n+        // if nothing is found we should ask the parent context\n+        return getParent().solveSymbolAsValue(name, typeSolver);\n+    }\n\\ No newline at end of file\n"
		}
	},
	"sha": "97555053af3025556efe1a168fd7943dac28a2a6"
}