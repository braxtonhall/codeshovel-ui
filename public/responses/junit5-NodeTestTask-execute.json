{
	"repo": "https://github.com/junit-team/junit5.git",
	"file": "junit-platform-engine/src/main/java/org/junit/platform/engine/support/hierarchical/NodeTestTask.java",
	"method": {
		"longName": "public void execute();",
		"startLine": 100,
		"methodName": "execute",
		"isStatic": false,
		"isAbstract": false,
		"visibility": "public"
	},
	"history": {
		"137f831bba9d0f45085d64fad47947cbc91a30e9": {
			"type": "Ybodychange",
			"commitMessage": "Make ThrowableCollector configurable\n\nThis commit generalizes `ThrowableCollector` to take a predicate that\nis used to decide whether a `Throwable` is aborted or failed execution.\nThe Jupiter engines uses a specialized implementation that treats OTA's\n`TestAbortedExceptions` as aborting and everything else as failing:\n`OpenTest4JAwareThrowableCollector`.\n\nIn addition, this commit introduces `ThrowableCollector.Factory` and\nlets `HierarchicalTestEngines` create them in order to allow the engine\nto decide how to configure its `ThrowableCollectors`. For backwards\ncompatibility, the default implementation returns a factory that\nalways creates instances of `OpenTest4JAwareThrowableCollector`.\n\nIssue: #1313\n",
			"commitDate": "2018-07-07, 1:15 PM",
			"commitName": "137f831bba9d0f45085d64fad47947cbc91a30e9",
			"commitAuthor": "Marc Philipp",
			"commitDateOld": "2018-07-07, 1:15 PM",
			"commitNameOld": "c1d682aee5da5738fc3be071df45330c005f4cf1",
			"commitAuthorOld": "Marc Philipp",
			"daysBetweenCommits": 0,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,13 +1,14 @@\n \tpublic void execute() {\n+\t\tthrowableCollector = throwableCollectorFactory.create();\n \t\tprepare();\n \t\tif (throwableCollector.isEmpty()) {\n \t\t\tcheckWhetherSkipped();\n \t\t}\n \t\tif (throwableCollector.isEmpty() && !skipResult.isSkipped()) {\n \t\t\texecuteRecursively();\n \t\t}\n \t\tif (context != null) {\n \t\t\tcleanUp();\n \t\t}\n \t\treportCompletion();\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"c1d682aee5da5738fc3be071df45330c005f4cf1": {
			"type": "Ybodychange",
			"commitMessage": "Exceptions in `@AfterAll` methods fail aborted containers\n\nIssue: #1313\n",
			"commitDate": "2018-07-07, 1:15 PM",
			"commitName": "c1d682aee5da5738fc3be071df45330c005f4cf1",
			"commitAuthor": "Marc Philipp",
			"commitDateOld": "2018-06-28, 11:59 AM",
			"commitNameOld": "38e149f626bc7722922f87989fb9776d4fe325e9",
			"commitAuthorOld": "Sam Brannen",
			"daysBetweenCommits": 9.05,
			"commitsBetweenForRepo": 39,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,13 +1,13 @@\n \tpublic void execute() {\n \t\tprepare();\n-\t\tif (executionErrors.isEmpty()) {\n+\t\tif (throwableCollector.isEmpty()) {\n \t\t\tcheckWhetherSkipped();\n \t\t}\n-\t\tif (executionErrors.isEmpty() && !skipResult.isSkipped()) {\n+\t\tif (throwableCollector.isEmpty() && !skipResult.isSkipped()) {\n \t\t\texecuteRecursively();\n \t\t}\n \t\tif (context != null) {\n \t\t\tcleanUp();\n \t\t}\n \t\treportCompletion();\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"2f3440e0f221255a83b28c42cf77407bde92a8b4": {
			"type": "Ymultichange(Ymovefromfile,Ymodifierchange,Ybodychange,Yparameterchange)",
			"commitMessage": "Introduce support for parallel test execution\n\nThis commit adds opt-in support for parallel test execution and\ncapturing output to `System.out` and `System.err`. Both features are\ndisabled by default but can be enabled and configured using\nconfiguration parameters.\n\nThe implementation is based on the Fork/Join Framework and designed to\nbe reusable by other test engines that extend HierarchicalTestEngine.\n\nThe Jupiter API provides annotations to declare which shared resources a\ntest needs to access and in which way. Moreover, the execution mode of a\ntest can be influenced.\n\nIn addition, a number of TestExecutionListeners have been made\nthread-safe.\n\nThe documentation subproject is now configured to execute tests in\nparallel. All other subprojects will have to wait as Gradle currently\nblows up when used with parallel test execution.\n\nResolves #60. Closes #1461.\n\nCo-authored-by: Leonard Brünings <lord_damokles@gmx.net>\nCo-authored-by: Christian Stein <sormuras@gmail.com>\n",
			"commitDate": "2018-06-22, 10:55 AM",
			"commitName": "2f3440e0f221255a83b28c42cf77407bde92a8b4",
			"commitAuthor": "Marc Philipp",
			"subchanges": [
				{
					"type": "Ymovefromfile",
					"commitMessage": "Introduce support for parallel test execution\n\nThis commit adds opt-in support for parallel test execution and\ncapturing output to `System.out` and `System.err`. Both features are\ndisabled by default but can be enabled and configured using\nconfiguration parameters.\n\nThe implementation is based on the Fork/Join Framework and designed to\nbe reusable by other test engines that extend HierarchicalTestEngine.\n\nThe Jupiter API provides annotations to declare which shared resources a\ntest needs to access and in which way. Moreover, the execution mode of a\ntest can be influenced.\n\nIn addition, a number of TestExecutionListeners have been made\nthread-safe.\n\nThe documentation subproject is now configured to execute tests in\nparallel. All other subprojects will have to wait as Gradle currently\nblows up when used with parallel test execution.\n\nResolves #60. Closes #1461.\n\nCo-authored-by: Leonard Brünings <lord_damokles@gmx.net>\nCo-authored-by: Christian Stein <sormuras@gmail.com>\n",
					"commitDate": "2018-06-22, 10:55 AM",
					"commitName": "2f3440e0f221255a83b28c42cf77407bde92a8b4",
					"commitAuthor": "Marc Philipp",
					"commitDateOld": "2018-06-22, 7:23 AM",
					"commitNameOld": "948841c03c646c98866d0121bc3c89ad4ddbf277",
					"commitAuthorOld": "Sam Brannen",
					"daysBetweenCommits": 0.15,
					"commitsBetweenForRepo": 1,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,14 +1,13 @@\n-\t\tvoid execute(C parentContext, ExecutionTracker tracker) {\n-\t\t\ttracker.markExecuted(testDescriptor);\n-\t\t\tprepare(parentContext);\n-\t\t\tif (executionErrors.isEmpty()) {\n-\t\t\t\tcheckWhetherSkipped();\n-\t\t\t}\n-\t\t\tif (executionErrors.isEmpty() && !skipResult.isSkipped()) {\n-\t\t\t\texecuteRecursively(tracker);\n-\t\t\t}\n-\t\t\tif (context != null) {\n-\t\t\t\tcleanUp();\n-\t\t\t}\n-\t\t\treportDone();\n-\t\t}\n\\ No newline at end of file\n+\tpublic void execute() {\n+\t\tprepare();\n+\t\tif (executionErrors.isEmpty()) {\n+\t\t\tcheckWhetherSkipped();\n+\t\t}\n+\t\tif (executionErrors.isEmpty() && !skipResult.isSkipped()) {\n+\t\t\texecuteRecursively();\n+\t\t}\n+\t\tif (context != null) {\n+\t\t\tcleanUp();\n+\t\t}\n+\t\treportCompletion();\n+\t}\n\\ No newline at end of file\n",
					"extendedDetails": {
						"oldPath": "junit-platform-engine/src/main/java/org/junit/platform/engine/support/hierarchical/HierarchicalTestExecutor.java",
						"newPath": "junit-platform-engine/src/main/java/org/junit/platform/engine/support/hierarchical/NodeTestTask.java",
						"oldMethodName": "execute",
						"newMethodName": "execute"
					}
				},
				{
					"type": "Ymodifierchange",
					"commitMessage": "Introduce support for parallel test execution\n\nThis commit adds opt-in support for parallel test execution and\ncapturing output to `System.out` and `System.err`. Both features are\ndisabled by default but can be enabled and configured using\nconfiguration parameters.\n\nThe implementation is based on the Fork/Join Framework and designed to\nbe reusable by other test engines that extend HierarchicalTestEngine.\n\nThe Jupiter API provides annotations to declare which shared resources a\ntest needs to access and in which way. Moreover, the execution mode of a\ntest can be influenced.\n\nIn addition, a number of TestExecutionListeners have been made\nthread-safe.\n\nThe documentation subproject is now configured to execute tests in\nparallel. All other subprojects will have to wait as Gradle currently\nblows up when used with parallel test execution.\n\nResolves #60. Closes #1461.\n\nCo-authored-by: Leonard Brünings <lord_damokles@gmx.net>\nCo-authored-by: Christian Stein <sormuras@gmail.com>\n",
					"commitDate": "2018-06-22, 10:55 AM",
					"commitName": "2f3440e0f221255a83b28c42cf77407bde92a8b4",
					"commitAuthor": "Marc Philipp",
					"commitDateOld": "2018-06-22, 7:23 AM",
					"commitNameOld": "948841c03c646c98866d0121bc3c89ad4ddbf277",
					"commitAuthorOld": "Sam Brannen",
					"daysBetweenCommits": 0.15,
					"commitsBetweenForRepo": 1,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,14 +1,13 @@\n-\t\tvoid execute(C parentContext, ExecutionTracker tracker) {\n-\t\t\ttracker.markExecuted(testDescriptor);\n-\t\t\tprepare(parentContext);\n-\t\t\tif (executionErrors.isEmpty()) {\n-\t\t\t\tcheckWhetherSkipped();\n-\t\t\t}\n-\t\t\tif (executionErrors.isEmpty() && !skipResult.isSkipped()) {\n-\t\t\t\texecuteRecursively(tracker);\n-\t\t\t}\n-\t\t\tif (context != null) {\n-\t\t\t\tcleanUp();\n-\t\t\t}\n-\t\t\treportDone();\n-\t\t}\n\\ No newline at end of file\n+\tpublic void execute() {\n+\t\tprepare();\n+\t\tif (executionErrors.isEmpty()) {\n+\t\t\tcheckWhetherSkipped();\n+\t\t}\n+\t\tif (executionErrors.isEmpty() && !skipResult.isSkipped()) {\n+\t\t\texecuteRecursively();\n+\t\t}\n+\t\tif (context != null) {\n+\t\t\tcleanUp();\n+\t\t}\n+\t\treportCompletion();\n+\t}\n\\ No newline at end of file\n",
					"extendedDetails": {
						"oldValue": "[]",
						"newValue": "[public]"
					}
				},
				{
					"type": "Ybodychange",
					"commitMessage": "Introduce support for parallel test execution\n\nThis commit adds opt-in support for parallel test execution and\ncapturing output to `System.out` and `System.err`. Both features are\ndisabled by default but can be enabled and configured using\nconfiguration parameters.\n\nThe implementation is based on the Fork/Join Framework and designed to\nbe reusable by other test engines that extend HierarchicalTestEngine.\n\nThe Jupiter API provides annotations to declare which shared resources a\ntest needs to access and in which way. Moreover, the execution mode of a\ntest can be influenced.\n\nIn addition, a number of TestExecutionListeners have been made\nthread-safe.\n\nThe documentation subproject is now configured to execute tests in\nparallel. All other subprojects will have to wait as Gradle currently\nblows up when used with parallel test execution.\n\nResolves #60. Closes #1461.\n\nCo-authored-by: Leonard Brünings <lord_damokles@gmx.net>\nCo-authored-by: Christian Stein <sormuras@gmail.com>\n",
					"commitDate": "2018-06-22, 10:55 AM",
					"commitName": "2f3440e0f221255a83b28c42cf77407bde92a8b4",
					"commitAuthor": "Marc Philipp",
					"commitDateOld": "2018-06-22, 7:23 AM",
					"commitNameOld": "948841c03c646c98866d0121bc3c89ad4ddbf277",
					"commitAuthorOld": "Sam Brannen",
					"daysBetweenCommits": 0.15,
					"commitsBetweenForRepo": 1,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,14 +1,13 @@\n-\t\tvoid execute(C parentContext, ExecutionTracker tracker) {\n-\t\t\ttracker.markExecuted(testDescriptor);\n-\t\t\tprepare(parentContext);\n-\t\t\tif (executionErrors.isEmpty()) {\n-\t\t\t\tcheckWhetherSkipped();\n-\t\t\t}\n-\t\t\tif (executionErrors.isEmpty() && !skipResult.isSkipped()) {\n-\t\t\t\texecuteRecursively(tracker);\n-\t\t\t}\n-\t\t\tif (context != null) {\n-\t\t\t\tcleanUp();\n-\t\t\t}\n-\t\t\treportDone();\n-\t\t}\n\\ No newline at end of file\n+\tpublic void execute() {\n+\t\tprepare();\n+\t\tif (executionErrors.isEmpty()) {\n+\t\t\tcheckWhetherSkipped();\n+\t\t}\n+\t\tif (executionErrors.isEmpty() && !skipResult.isSkipped()) {\n+\t\t\texecuteRecursively();\n+\t\t}\n+\t\tif (context != null) {\n+\t\t\tcleanUp();\n+\t\t}\n+\t\treportCompletion();\n+\t}\n\\ No newline at end of file\n",
					"extendedDetails": {}
				},
				{
					"type": "Yparameterchange",
					"commitMessage": "Introduce support for parallel test execution\n\nThis commit adds opt-in support for parallel test execution and\ncapturing output to `System.out` and `System.err`. Both features are\ndisabled by default but can be enabled and configured using\nconfiguration parameters.\n\nThe implementation is based on the Fork/Join Framework and designed to\nbe reusable by other test engines that extend HierarchicalTestEngine.\n\nThe Jupiter API provides annotations to declare which shared resources a\ntest needs to access and in which way. Moreover, the execution mode of a\ntest can be influenced.\n\nIn addition, a number of TestExecutionListeners have been made\nthread-safe.\n\nThe documentation subproject is now configured to execute tests in\nparallel. All other subprojects will have to wait as Gradle currently\nblows up when used with parallel test execution.\n\nResolves #60. Closes #1461.\n\nCo-authored-by: Leonard Brünings <lord_damokles@gmx.net>\nCo-authored-by: Christian Stein <sormuras@gmail.com>\n",
					"commitDate": "2018-06-22, 10:55 AM",
					"commitName": "2f3440e0f221255a83b28c42cf77407bde92a8b4",
					"commitAuthor": "Marc Philipp",
					"commitDateOld": "2018-06-22, 7:23 AM",
					"commitNameOld": "948841c03c646c98866d0121bc3c89ad4ddbf277",
					"commitAuthorOld": "Sam Brannen",
					"daysBetweenCommits": 0.15,
					"commitsBetweenForRepo": 1,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,14 +1,13 @@\n-\t\tvoid execute(C parentContext, ExecutionTracker tracker) {\n-\t\t\ttracker.markExecuted(testDescriptor);\n-\t\t\tprepare(parentContext);\n-\t\t\tif (executionErrors.isEmpty()) {\n-\t\t\t\tcheckWhetherSkipped();\n-\t\t\t}\n-\t\t\tif (executionErrors.isEmpty() && !skipResult.isSkipped()) {\n-\t\t\t\texecuteRecursively(tracker);\n-\t\t\t}\n-\t\t\tif (context != null) {\n-\t\t\t\tcleanUp();\n-\t\t\t}\n-\t\t\treportDone();\n-\t\t}\n\\ No newline at end of file\n+\tpublic void execute() {\n+\t\tprepare();\n+\t\tif (executionErrors.isEmpty()) {\n+\t\t\tcheckWhetherSkipped();\n+\t\t}\n+\t\tif (executionErrors.isEmpty() && !skipResult.isSkipped()) {\n+\t\t\texecuteRecursively();\n+\t\t}\n+\t\tif (context != null) {\n+\t\t\tcleanUp();\n+\t\t}\n+\t\treportCompletion();\n+\t}\n\\ No newline at end of file\n",
					"extendedDetails": {
						"oldValue": "[parentContext-C, tracker-ExecutionTracker]",
						"newValue": "[]"
					}
				}
			]
		},
		"1092538773cba2058658bc41515a4d05cb50f19e": {
			"type": "Ybodychange",
			"commitMessage": "Only clean up non-null execution contexts\n\nIssue: #742\n",
			"commitDate": "2017-12-28, 9:23 AM",
			"commitName": "1092538773cba2058658bc41515a4d05cb50f19e",
			"commitAuthor": "Marc Philipp",
			"commitDateOld": "2017-12-28, 9:23 AM",
			"commitNameOld": "805d4dad6d3893b8e973019b824167d7b6f2cb8c",
			"commitAuthorOld": "Marc Philipp",
			"daysBetweenCommits": 0,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,12 +1,14 @@\n \t\tvoid execute(C parentContext, ExecutionTracker tracker) {\n \t\t\ttracker.markExecuted(testDescriptor);\n \t\t\tprepare(parentContext);\n \t\t\tif (executionErrors.isEmpty()) {\n \t\t\t\tcheckWhetherSkipped();\n \t\t\t}\n \t\t\tif (executionErrors.isEmpty() && !skipResult.isSkipped()) {\n \t\t\t\texecuteRecursively(tracker);\n \t\t\t}\n-\t\t\tcleanUp();\n+\t\t\tif (context != null) {\n+\t\t\t\tcleanUp();\n+\t\t\t}\n \t\t\treportDone();\n \t\t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"805d4dad6d3893b8e973019b824167d7b6f2cb8c": {
			"type": "Ymultichange(Yparameterchange,Ymodifierchange,Ybodychange)",
			"commitMessage": "Refactor HierarchicalTestExecutor\n\nIssue: #742\n",
			"commitDate": "2017-12-28, 9:23 AM",
			"commitName": "805d4dad6d3893b8e973019b824167d7b6f2cb8c",
			"commitAuthor": "Marc Philipp",
			"subchanges": [
				{
					"type": "Yparameterchange",
					"commitMessage": "Refactor HierarchicalTestExecutor\n\nIssue: #742\n",
					"commitDate": "2017-12-28, 9:23 AM",
					"commitName": "805d4dad6d3893b8e973019b824167d7b6f2cb8c",
					"commitAuthor": "Marc Philipp",
					"commitDateOld": "2017-12-28, 9:23 AM",
					"commitNameOld": "e0a49d10ffb6505755fc8a0308e898382e3cc1eb",
					"commitAuthorOld": "Christian Stein",
					"daysBetweenCommits": 0,
					"commitsBetweenForRepo": 1,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,75 +1,12 @@\n-\tprivate void execute(TestDescriptor testDescriptor, C parentContext, ExecutionTracker tracker) {\n-\t\tNode<C> node = asNode(testDescriptor);\n-\t\ttracker.markExecuted(testDescriptor);\n-\n-\t\tC preparedContext;\n-\t\ttry {\n-\t\t\tpreparedContext = node.prepare(parentContext);\n-\t\t}\n-\t\tcatch (Throwable throwable) {\n-\t\t\trethrowIfBlacklisted(throwable);\n-\t\t\treportAsFailed(testDescriptor, throwable);\n-\t\t\treturn;\n-\t\t}\n-\n-\t\tSkipResult skipResult;\n-\t\ttry {\n-\t\t\tskipResult = node.shouldBeSkipped(preparedContext);\n-\t\t}\n-\t\tcatch (Exception exception) {\n-\t\t\trethrowIfBlacklisted(exception);\n-\t\t\ttry {\n-\t\t\t\tnode.cleanUp(preparedContext);\n+\t\tvoid execute(C parentContext, ExecutionTracker tracker) {\n+\t\t\ttracker.markExecuted(testDescriptor);\n+\t\t\tprepare(parentContext);\n+\t\t\tif (executionErrors.isEmpty()) {\n+\t\t\t\tcheckWhetherSkipped();\n \t\t\t}\n-\t\t\tcatch (Exception cleanupException) {\n-\t\t\t\texception.addSuppressed(cleanupException);\n+\t\t\tif (executionErrors.isEmpty() && !skipResult.isSkipped()) {\n+\t\t\t\texecuteRecursively(tracker);\n \t\t\t}\n-\t\t\tfinally {\n-\t\t\t\treportAsFailed(testDescriptor, exception);\n-\t\t\t}\n-\t\t\treturn;\n-\t\t}\n-\n-\t\tif (skipResult.isSkipped()) {\n-\t\t\ttry {\n-\t\t\t\tnode.cleanUp(preparedContext);\n-\t\t\t\tthis.listener.executionSkipped(testDescriptor, skipResult.getReason().orElse(\"<unknown>\"));\n-\t\t\t}\n-\t\t\tcatch (Exception exception) {\n-\t\t\t\treportAsFailed(testDescriptor, exception);\n-\t\t\t}\n-\t\t\treturn;\n-\t\t}\n-\n-\t\tthis.listener.executionStarted(testDescriptor);\n-\n-\t\tTestExecutionResult result = singleTestExecutor.executeSafely(() -> {\n-\t\t\tC context = preparedContext;\n-\t\t\ttry {\n-\t\t\t\tcontext = node.before(context);\n-\n-\t\t\t\tC contextForDynamicChildren = context;\n-\t\t\t\tcontext = node.execute(context, dynamicTestDescriptor -> {\n-\t\t\t\t\tthis.listener.dynamicTestRegistered(dynamicTestDescriptor);\n-\t\t\t\t\texecute(dynamicTestDescriptor, contextForDynamicChildren, tracker);\n-\t\t\t\t});\n-\n-\t\t\t\tC contextForStaticChildren = context;\n-\t\t\t\t// @formatter:off\n-\t\t\t\ttestDescriptor.getChildren().stream()\n-\t\t\t\t\t\t.filter(child -> !tracker.wasAlreadyExecuted(child))\n-\t\t\t\t\t\t.forEach(child -> execute(child, contextForStaticChildren, tracker));\n-\t\t\t\t// @formatter:on\n-\t\t\t}\n-\t\t\tfinally {\n-\t\t\t\ttry {\n-\t\t\t\t\tnode.after(context);\n-\t\t\t\t}\n-\t\t\t\tfinally {\n-\t\t\t\t\tnode.cleanUp(context);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t});\n-\n-\t\tthis.listener.executionFinished(testDescriptor, result);\n-\t}\n\\ No newline at end of file\n+\t\t\tcleanUp();\n+\t\t\treportDone();\n+\t\t}\n\\ No newline at end of file\n",
					"extendedDetails": {
						"oldValue": "[testDescriptor-TestDescriptor, parentContext-C, tracker-ExecutionTracker]",
						"newValue": "[parentContext-C, tracker-ExecutionTracker]"
					}
				},
				{
					"type": "Ymodifierchange",
					"commitMessage": "Refactor HierarchicalTestExecutor\n\nIssue: #742\n",
					"commitDate": "2017-12-28, 9:23 AM",
					"commitName": "805d4dad6d3893b8e973019b824167d7b6f2cb8c",
					"commitAuthor": "Marc Philipp",
					"commitDateOld": "2017-12-28, 9:23 AM",
					"commitNameOld": "e0a49d10ffb6505755fc8a0308e898382e3cc1eb",
					"commitAuthorOld": "Christian Stein",
					"daysBetweenCommits": 0,
					"commitsBetweenForRepo": 1,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,75 +1,12 @@\n-\tprivate void execute(TestDescriptor testDescriptor, C parentContext, ExecutionTracker tracker) {\n-\t\tNode<C> node = asNode(testDescriptor);\n-\t\ttracker.markExecuted(testDescriptor);\n-\n-\t\tC preparedContext;\n-\t\ttry {\n-\t\t\tpreparedContext = node.prepare(parentContext);\n-\t\t}\n-\t\tcatch (Throwable throwable) {\n-\t\t\trethrowIfBlacklisted(throwable);\n-\t\t\treportAsFailed(testDescriptor, throwable);\n-\t\t\treturn;\n-\t\t}\n-\n-\t\tSkipResult skipResult;\n-\t\ttry {\n-\t\t\tskipResult = node.shouldBeSkipped(preparedContext);\n-\t\t}\n-\t\tcatch (Exception exception) {\n-\t\t\trethrowIfBlacklisted(exception);\n-\t\t\ttry {\n-\t\t\t\tnode.cleanUp(preparedContext);\n+\t\tvoid execute(C parentContext, ExecutionTracker tracker) {\n+\t\t\ttracker.markExecuted(testDescriptor);\n+\t\t\tprepare(parentContext);\n+\t\t\tif (executionErrors.isEmpty()) {\n+\t\t\t\tcheckWhetherSkipped();\n \t\t\t}\n-\t\t\tcatch (Exception cleanupException) {\n-\t\t\t\texception.addSuppressed(cleanupException);\n+\t\t\tif (executionErrors.isEmpty() && !skipResult.isSkipped()) {\n+\t\t\t\texecuteRecursively(tracker);\n \t\t\t}\n-\t\t\tfinally {\n-\t\t\t\treportAsFailed(testDescriptor, exception);\n-\t\t\t}\n-\t\t\treturn;\n-\t\t}\n-\n-\t\tif (skipResult.isSkipped()) {\n-\t\t\ttry {\n-\t\t\t\tnode.cleanUp(preparedContext);\n-\t\t\t\tthis.listener.executionSkipped(testDescriptor, skipResult.getReason().orElse(\"<unknown>\"));\n-\t\t\t}\n-\t\t\tcatch (Exception exception) {\n-\t\t\t\treportAsFailed(testDescriptor, exception);\n-\t\t\t}\n-\t\t\treturn;\n-\t\t}\n-\n-\t\tthis.listener.executionStarted(testDescriptor);\n-\n-\t\tTestExecutionResult result = singleTestExecutor.executeSafely(() -> {\n-\t\t\tC context = preparedContext;\n-\t\t\ttry {\n-\t\t\t\tcontext = node.before(context);\n-\n-\t\t\t\tC contextForDynamicChildren = context;\n-\t\t\t\tcontext = node.execute(context, dynamicTestDescriptor -> {\n-\t\t\t\t\tthis.listener.dynamicTestRegistered(dynamicTestDescriptor);\n-\t\t\t\t\texecute(dynamicTestDescriptor, contextForDynamicChildren, tracker);\n-\t\t\t\t});\n-\n-\t\t\t\tC contextForStaticChildren = context;\n-\t\t\t\t// @formatter:off\n-\t\t\t\ttestDescriptor.getChildren().stream()\n-\t\t\t\t\t\t.filter(child -> !tracker.wasAlreadyExecuted(child))\n-\t\t\t\t\t\t.forEach(child -> execute(child, contextForStaticChildren, tracker));\n-\t\t\t\t// @formatter:on\n-\t\t\t}\n-\t\t\tfinally {\n-\t\t\t\ttry {\n-\t\t\t\t\tnode.after(context);\n-\t\t\t\t}\n-\t\t\t\tfinally {\n-\t\t\t\t\tnode.cleanUp(context);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t});\n-\n-\t\tthis.listener.executionFinished(testDescriptor, result);\n-\t}\n\\ No newline at end of file\n+\t\t\tcleanUp();\n+\t\t\treportDone();\n+\t\t}\n\\ No newline at end of file\n",
					"extendedDetails": {
						"oldValue": "[private]",
						"newValue": "[]"
					}
				},
				{
					"type": "Ybodychange",
					"commitMessage": "Refactor HierarchicalTestExecutor\n\nIssue: #742\n",
					"commitDate": "2017-12-28, 9:23 AM",
					"commitName": "805d4dad6d3893b8e973019b824167d7b6f2cb8c",
					"commitAuthor": "Marc Philipp",
					"commitDateOld": "2017-12-28, 9:23 AM",
					"commitNameOld": "e0a49d10ffb6505755fc8a0308e898382e3cc1eb",
					"commitAuthorOld": "Christian Stein",
					"daysBetweenCommits": 0,
					"commitsBetweenForRepo": 1,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,75 +1,12 @@\n-\tprivate void execute(TestDescriptor testDescriptor, C parentContext, ExecutionTracker tracker) {\n-\t\tNode<C> node = asNode(testDescriptor);\n-\t\ttracker.markExecuted(testDescriptor);\n-\n-\t\tC preparedContext;\n-\t\ttry {\n-\t\t\tpreparedContext = node.prepare(parentContext);\n-\t\t}\n-\t\tcatch (Throwable throwable) {\n-\t\t\trethrowIfBlacklisted(throwable);\n-\t\t\treportAsFailed(testDescriptor, throwable);\n-\t\t\treturn;\n-\t\t}\n-\n-\t\tSkipResult skipResult;\n-\t\ttry {\n-\t\t\tskipResult = node.shouldBeSkipped(preparedContext);\n-\t\t}\n-\t\tcatch (Exception exception) {\n-\t\t\trethrowIfBlacklisted(exception);\n-\t\t\ttry {\n-\t\t\t\tnode.cleanUp(preparedContext);\n+\t\tvoid execute(C parentContext, ExecutionTracker tracker) {\n+\t\t\ttracker.markExecuted(testDescriptor);\n+\t\t\tprepare(parentContext);\n+\t\t\tif (executionErrors.isEmpty()) {\n+\t\t\t\tcheckWhetherSkipped();\n \t\t\t}\n-\t\t\tcatch (Exception cleanupException) {\n-\t\t\t\texception.addSuppressed(cleanupException);\n+\t\t\tif (executionErrors.isEmpty() && !skipResult.isSkipped()) {\n+\t\t\t\texecuteRecursively(tracker);\n \t\t\t}\n-\t\t\tfinally {\n-\t\t\t\treportAsFailed(testDescriptor, exception);\n-\t\t\t}\n-\t\t\treturn;\n-\t\t}\n-\n-\t\tif (skipResult.isSkipped()) {\n-\t\t\ttry {\n-\t\t\t\tnode.cleanUp(preparedContext);\n-\t\t\t\tthis.listener.executionSkipped(testDescriptor, skipResult.getReason().orElse(\"<unknown>\"));\n-\t\t\t}\n-\t\t\tcatch (Exception exception) {\n-\t\t\t\treportAsFailed(testDescriptor, exception);\n-\t\t\t}\n-\t\t\treturn;\n-\t\t}\n-\n-\t\tthis.listener.executionStarted(testDescriptor);\n-\n-\t\tTestExecutionResult result = singleTestExecutor.executeSafely(() -> {\n-\t\t\tC context = preparedContext;\n-\t\t\ttry {\n-\t\t\t\tcontext = node.before(context);\n-\n-\t\t\t\tC contextForDynamicChildren = context;\n-\t\t\t\tcontext = node.execute(context, dynamicTestDescriptor -> {\n-\t\t\t\t\tthis.listener.dynamicTestRegistered(dynamicTestDescriptor);\n-\t\t\t\t\texecute(dynamicTestDescriptor, contextForDynamicChildren, tracker);\n-\t\t\t\t});\n-\n-\t\t\t\tC contextForStaticChildren = context;\n-\t\t\t\t// @formatter:off\n-\t\t\t\ttestDescriptor.getChildren().stream()\n-\t\t\t\t\t\t.filter(child -> !tracker.wasAlreadyExecuted(child))\n-\t\t\t\t\t\t.forEach(child -> execute(child, contextForStaticChildren, tracker));\n-\t\t\t\t// @formatter:on\n-\t\t\t}\n-\t\t\tfinally {\n-\t\t\t\ttry {\n-\t\t\t\t\tnode.after(context);\n-\t\t\t\t}\n-\t\t\t\tfinally {\n-\t\t\t\t\tnode.cleanUp(context);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t});\n-\n-\t\tthis.listener.executionFinished(testDescriptor, result);\n-\t}\n\\ No newline at end of file\n+\t\t\tcleanUp();\n+\t\t\treportDone();\n+\t\t}\n\\ No newline at end of file\n",
					"extendedDetails": {}
				}
			]
		},
		"e0a49d10ffb6505755fc8a0308e898382e3cc1eb": {
			"type": "Ybodychange",
			"commitMessage": "Introduce ExtensionContext.Store.CloseableResource interface\n\nAn extension context store is bound to its extension context lifecycle.\nWhen an extension context lifecycle ends it closes its associated store.\nAll stored values that are instances of\n{@link ExtensionContext.Store.CloseableResource} are notified by\ninvoking their {@code close()} method.\n\nCloses #742\n",
			"commitDate": "2017-12-28, 9:23 AM",
			"commitName": "e0a49d10ffb6505755fc8a0308e898382e3cc1eb",
			"commitAuthor": "Christian Stein",
			"commitDateOld": "2017-09-08, 12:18 PM",
			"commitNameOld": "3c37e59640deaf1f8d9761c655c80193f8d9226a",
			"commitAuthorOld": "JUnit Team",
			"daysBetweenCommits": 110.92,
			"commitsBetweenForRepo": 306,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,48 +1,75 @@\n \tprivate void execute(TestDescriptor testDescriptor, C parentContext, ExecutionTracker tracker) {\n \t\tNode<C> node = asNode(testDescriptor);\n \t\ttracker.markExecuted(testDescriptor);\n \n \t\tC preparedContext;\n \t\ttry {\n \t\t\tpreparedContext = node.prepare(parentContext);\n-\t\t\tSkipResult skipResult = node.shouldBeSkipped(preparedContext);\n-\t\t\tif (skipResult.isSkipped()) {\n-\t\t\t\tthis.listener.executionSkipped(testDescriptor, skipResult.getReason().orElse(\"<unknown>\"));\n-\t\t\t\treturn;\n-\t\t\t}\n \t\t}\n \t\tcatch (Throwable throwable) {\n \t\t\trethrowIfBlacklisted(throwable);\n-\t\t\t// We call executionStarted first to comply with the contract of EngineExecutionListener\n-\t\t\tthis.listener.executionStarted(testDescriptor);\n-\t\t\tthis.listener.executionFinished(testDescriptor, TestExecutionResult.failed(throwable));\n+\t\t\treportAsFailed(testDescriptor, throwable);\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tSkipResult skipResult;\n+\t\ttry {\n+\t\t\tskipResult = node.shouldBeSkipped(preparedContext);\n+\t\t}\n+\t\tcatch (Exception exception) {\n+\t\t\trethrowIfBlacklisted(exception);\n+\t\t\ttry {\n+\t\t\t\tnode.cleanUp(preparedContext);\n+\t\t\t}\n+\t\t\tcatch (Exception cleanupException) {\n+\t\t\t\texception.addSuppressed(cleanupException);\n+\t\t\t}\n+\t\t\tfinally {\n+\t\t\t\treportAsFailed(testDescriptor, exception);\n+\t\t\t}\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tif (skipResult.isSkipped()) {\n+\t\t\ttry {\n+\t\t\t\tnode.cleanUp(preparedContext);\n+\t\t\t\tthis.listener.executionSkipped(testDescriptor, skipResult.getReason().orElse(\"<unknown>\"));\n+\t\t\t}\n+\t\t\tcatch (Exception exception) {\n+\t\t\t\treportAsFailed(testDescriptor, exception);\n+\t\t\t}\n \t\t\treturn;\n \t\t}\n \n \t\tthis.listener.executionStarted(testDescriptor);\n \n \t\tTestExecutionResult result = singleTestExecutor.executeSafely(() -> {\n \t\t\tC context = preparedContext;\n \t\t\ttry {\n \t\t\t\tcontext = node.before(context);\n \n \t\t\t\tC contextForDynamicChildren = context;\n \t\t\t\tcontext = node.execute(context, dynamicTestDescriptor -> {\n \t\t\t\t\tthis.listener.dynamicTestRegistered(dynamicTestDescriptor);\n \t\t\t\t\texecute(dynamicTestDescriptor, contextForDynamicChildren, tracker);\n \t\t\t\t});\n \n \t\t\t\tC contextForStaticChildren = context;\n \t\t\t\t// @formatter:off\n \t\t\t\ttestDescriptor.getChildren().stream()\n \t\t\t\t\t\t.filter(child -> !tracker.wasAlreadyExecuted(child))\n \t\t\t\t\t\t.forEach(child -> execute(child, contextForStaticChildren, tracker));\n \t\t\t\t// @formatter:on\n \t\t\t}\n \t\t\tfinally {\n-\t\t\t\tnode.after(context);\n+\t\t\t\ttry {\n+\t\t\t\t\tnode.after(context);\n+\t\t\t\t}\n+\t\t\t\tfinally {\n+\t\t\t\t\tnode.cleanUp(context);\n+\t\t\t\t}\n \t\t\t}\n \t\t});\n \n \t\tthis.listener.executionFinished(testDescriptor, result);\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"a3e4b97efb03bd7b52d18c17b9dc185d112a04e8": {
			"type": "Ymultichange(Yparameterchange,Ybodychange)",
			"commitMessage": "Replace Node.isLeaf() with explicit tracking of executed descriptors\n\nFixes #812.",
			"commitDate": "2017-05-03, 2:52 AM",
			"commitName": "a3e4b97efb03bd7b52d18c17b9dc185d112a04e8",
			"commitAuthor": "Marc Philipp",
			"subchanges": [
				{
					"type": "Yparameterchange",
					"commitMessage": "Replace Node.isLeaf() with explicit tracking of executed descriptors\n\nFixes #812.",
					"commitDate": "2017-05-03, 2:52 AM",
					"commitName": "a3e4b97efb03bd7b52d18c17b9dc185d112a04e8",
					"commitAuthor": "Marc Philipp",
					"commitDateOld": "2017-02-24, 12:20 PM",
					"commitNameOld": "4b41518fa052b28a953e99b087d505603a22c175",
					"commitAuthorOld": "Marc Philipp",
					"daysBetweenCommits": 67.56,
					"commitsBetweenForRepo": 317,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,48 +1,48 @@\n-\tprivate void execute(TestDescriptor testDescriptor, C parentContext) {\n+\tprivate void execute(TestDescriptor testDescriptor, C parentContext, ExecutionTracker tracker) {\n \t\tNode<C> node = asNode(testDescriptor);\n+\t\ttracker.markExecuted(testDescriptor);\n \n \t\tC preparedContext;\n \t\ttry {\n \t\t\tpreparedContext = node.prepare(parentContext);\n \t\t\tSkipResult skipResult = node.shouldBeSkipped(preparedContext);\n \t\t\tif (skipResult.isSkipped()) {\n \t\t\t\tthis.listener.executionSkipped(testDescriptor, skipResult.getReason().orElse(\"<unknown>\"));\n \t\t\t\treturn;\n \t\t\t}\n \t\t}\n \t\tcatch (Throwable throwable) {\n \t\t\trethrowIfBlacklisted(throwable);\n \t\t\t// We call executionStarted first to comply with the contract of EngineExecutionListener\n \t\t\tthis.listener.executionStarted(testDescriptor);\n \t\t\tthis.listener.executionFinished(testDescriptor, TestExecutionResult.failed(throwable));\n \t\t\treturn;\n \t\t}\n \n \t\tthis.listener.executionStarted(testDescriptor);\n \n \t\tTestExecutionResult result = singleTestExecutor.executeSafely(() -> {\n \t\t\tC context = preparedContext;\n \t\t\ttry {\n \t\t\t\tcontext = node.before(context);\n-\t\t\t\tC dynamicTestContext = context;\n+\n+\t\t\t\tC contextForDynamicChildren = context;\n \t\t\t\tcontext = node.execute(context, dynamicTestDescriptor -> {\n \t\t\t\t\tthis.listener.dynamicTestRegistered(dynamicTestDescriptor);\n-\t\t\t\t\texecute(dynamicTestDescriptor, dynamicTestContext);\n+\t\t\t\t\texecute(dynamicTestDescriptor, contextForDynamicChildren, tracker);\n \t\t\t\t});\n \n-\t\t\t\t// If a node is NOT a leaf, execute its children recursively.\n-\t\t\t\t// Note: executing children for a leaf could result in accidental\n-\t\t\t\t// execution of dynamically added children.\n-\t\t\t\tif (!node.isLeaf()) {\n-\t\t\t\t\tfor (TestDescriptor child : testDescriptor.getChildren()) {\n-\t\t\t\t\t\texecute(child, context);\n-\t\t\t\t\t}\n-\t\t\t\t}\n+\t\t\t\tC contextForStaticChildren = context;\n+\t\t\t\t// @formatter:off\n+\t\t\t\ttestDescriptor.getChildren().stream()\n+\t\t\t\t\t\t.filter(child -> !tracker.wasAlreadyExecuted(child))\n+\t\t\t\t\t\t.forEach(child -> execute(child, contextForStaticChildren, tracker));\n+\t\t\t\t// @formatter:on\n \t\t\t}\n \t\t\tfinally {\n \t\t\t\tnode.after(context);\n \t\t\t}\n \t\t});\n \n \t\tthis.listener.executionFinished(testDescriptor, result);\n \t}\n\\ No newline at end of file\n",
					"extendedDetails": {
						"oldValue": "[testDescriptor-TestDescriptor, parentContext-C]",
						"newValue": "[testDescriptor-TestDescriptor, parentContext-C, tracker-ExecutionTracker]"
					}
				},
				{
					"type": "Ybodychange",
					"commitMessage": "Replace Node.isLeaf() with explicit tracking of executed descriptors\n\nFixes #812.",
					"commitDate": "2017-05-03, 2:52 AM",
					"commitName": "a3e4b97efb03bd7b52d18c17b9dc185d112a04e8",
					"commitAuthor": "Marc Philipp",
					"commitDateOld": "2017-02-24, 12:20 PM",
					"commitNameOld": "4b41518fa052b28a953e99b087d505603a22c175",
					"commitAuthorOld": "Marc Philipp",
					"daysBetweenCommits": 67.56,
					"commitsBetweenForRepo": 317,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,48 +1,48 @@\n-\tprivate void execute(TestDescriptor testDescriptor, C parentContext) {\n+\tprivate void execute(TestDescriptor testDescriptor, C parentContext, ExecutionTracker tracker) {\n \t\tNode<C> node = asNode(testDescriptor);\n+\t\ttracker.markExecuted(testDescriptor);\n \n \t\tC preparedContext;\n \t\ttry {\n \t\t\tpreparedContext = node.prepare(parentContext);\n \t\t\tSkipResult skipResult = node.shouldBeSkipped(preparedContext);\n \t\t\tif (skipResult.isSkipped()) {\n \t\t\t\tthis.listener.executionSkipped(testDescriptor, skipResult.getReason().orElse(\"<unknown>\"));\n \t\t\t\treturn;\n \t\t\t}\n \t\t}\n \t\tcatch (Throwable throwable) {\n \t\t\trethrowIfBlacklisted(throwable);\n \t\t\t// We call executionStarted first to comply with the contract of EngineExecutionListener\n \t\t\tthis.listener.executionStarted(testDescriptor);\n \t\t\tthis.listener.executionFinished(testDescriptor, TestExecutionResult.failed(throwable));\n \t\t\treturn;\n \t\t}\n \n \t\tthis.listener.executionStarted(testDescriptor);\n \n \t\tTestExecutionResult result = singleTestExecutor.executeSafely(() -> {\n \t\t\tC context = preparedContext;\n \t\t\ttry {\n \t\t\t\tcontext = node.before(context);\n-\t\t\t\tC dynamicTestContext = context;\n+\n+\t\t\t\tC contextForDynamicChildren = context;\n \t\t\t\tcontext = node.execute(context, dynamicTestDescriptor -> {\n \t\t\t\t\tthis.listener.dynamicTestRegistered(dynamicTestDescriptor);\n-\t\t\t\t\texecute(dynamicTestDescriptor, dynamicTestContext);\n+\t\t\t\t\texecute(dynamicTestDescriptor, contextForDynamicChildren, tracker);\n \t\t\t\t});\n \n-\t\t\t\t// If a node is NOT a leaf, execute its children recursively.\n-\t\t\t\t// Note: executing children for a leaf could result in accidental\n-\t\t\t\t// execution of dynamically added children.\n-\t\t\t\tif (!node.isLeaf()) {\n-\t\t\t\t\tfor (TestDescriptor child : testDescriptor.getChildren()) {\n-\t\t\t\t\t\texecute(child, context);\n-\t\t\t\t\t}\n-\t\t\t\t}\n+\t\t\t\tC contextForStaticChildren = context;\n+\t\t\t\t// @formatter:off\n+\t\t\t\ttestDescriptor.getChildren().stream()\n+\t\t\t\t\t\t.filter(child -> !tracker.wasAlreadyExecuted(child))\n+\t\t\t\t\t\t.forEach(child -> execute(child, contextForStaticChildren, tracker));\n+\t\t\t\t// @formatter:on\n \t\t\t}\n \t\t\tfinally {\n \t\t\t\tnode.after(context);\n \t\t\t}\n \t\t});\n \n \t\tthis.listener.executionFinished(testDescriptor, result);\n \t}\n\\ No newline at end of file\n",
					"extendedDetails": {}
				}
			]
		},
		"4b41518fa052b28a953e99b087d505603a22c175": {
			"type": "Ybodychange",
			"commitMessage": "Add support for dynamic test descriptors to HierarchicalTestExecutor\n\nIssue: #14\n",
			"commitDate": "2017-02-24, 12:20 PM",
			"commitName": "4b41518fa052b28a953e99b087d505603a22c175",
			"commitAuthor": "Marc Philipp",
			"commitDateOld": "2017-01-02, 12:10 PM",
			"commitNameOld": "73f3eeb436e78226f19554f2c2b5dab63e103670",
			"commitAuthorOld": "JUnit Team",
			"daysBetweenCommits": 53.01,
			"commitsBetweenForRepo": 78,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,44 +1,48 @@\n \tprivate void execute(TestDescriptor testDescriptor, C parentContext) {\n \t\tNode<C> node = asNode(testDescriptor);\n \n \t\tC preparedContext;\n \t\ttry {\n \t\t\tpreparedContext = node.prepare(parentContext);\n \t\t\tSkipResult skipResult = node.shouldBeSkipped(preparedContext);\n \t\t\tif (skipResult.isSkipped()) {\n \t\t\t\tthis.listener.executionSkipped(testDescriptor, skipResult.getReason().orElse(\"<unknown>\"));\n \t\t\t\treturn;\n \t\t\t}\n \t\t}\n \t\tcatch (Throwable throwable) {\n \t\t\trethrowIfBlacklisted(throwable);\n \t\t\t// We call executionStarted first to comply with the contract of EngineExecutionListener\n \t\t\tthis.listener.executionStarted(testDescriptor);\n \t\t\tthis.listener.executionFinished(testDescriptor, TestExecutionResult.failed(throwable));\n \t\t\treturn;\n \t\t}\n \n \t\tthis.listener.executionStarted(testDescriptor);\n \n \t\tTestExecutionResult result = singleTestExecutor.executeSafely(() -> {\n \t\t\tC context = preparedContext;\n \t\t\ttry {\n \t\t\t\tcontext = node.before(context);\n-\t\t\t\tcontext = node.execute(context);\n+\t\t\t\tC dynamicTestContext = context;\n+\t\t\t\tcontext = node.execute(context, dynamicTestDescriptor -> {\n+\t\t\t\t\tthis.listener.dynamicTestRegistered(dynamicTestDescriptor);\n+\t\t\t\t\texecute(dynamicTestDescriptor, dynamicTestContext);\n+\t\t\t\t});\n \n \t\t\t\t// If a node is NOT a leaf, execute its children recursively.\n \t\t\t\t// Note: executing children for a leaf could result in accidental\n \t\t\t\t// execution of dynamically added children.\n \t\t\t\tif (!node.isLeaf()) {\n \t\t\t\t\tfor (TestDescriptor child : testDescriptor.getChildren()) {\n \t\t\t\t\t\texecute(child, context);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t\tfinally {\n \t\t\t\tnode.after(context);\n \t\t\t}\n \t\t});\n \n \t\tthis.listener.executionFinished(testDescriptor, result);\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"67f3391ab9887e5956a650c7a6b645ab04a62157": {
			"type": "Ybodychange",
			"commitMessage": "Resolve TODO wrt. executionStarted() call on premature container failure\n\nFixes #336.\n",
			"commitDate": "2016-07-27, 12:51 PM",
			"commitName": "67f3391ab9887e5956a650c7a6b645ab04a62157",
			"commitAuthor": "Marc Philipp",
			"commitDateOld": "2016-07-20, 9:25 AM",
			"commitNameOld": "389de48c2a18c5a93a7203ef424aa47a8a835a74",
			"commitAuthorOld": "Matthias Merdes",
			"daysBetweenCommits": 7.14,
			"commitsBetweenForRepo": 45,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,45 +1,44 @@\n \tprivate void execute(TestDescriptor testDescriptor, C parentContext) {\n \t\tNode<C> node = asNode(testDescriptor);\n \n \t\tC preparedContext;\n \t\ttry {\n \t\t\tpreparedContext = node.prepare(parentContext);\n \t\t\tSkipResult skipResult = node.shouldBeSkipped(preparedContext);\n \t\t\tif (skipResult.isSkipped()) {\n \t\t\t\tthis.listener.executionSkipped(testDescriptor, skipResult.getReason().orElse(\"<unknown>\"));\n \t\t\t\treturn;\n \t\t\t}\n \t\t}\n \t\tcatch (Throwable throwable) {\n \t\t\trethrowIfBlacklisted(throwable);\n-\n-\t\t\t// TODO [#336] Decide if exceptions thrown during preparation should result in the node being marked as \"started\".\n+\t\t\t// We call executionStarted first to comply with the contract of EngineExecutionListener\n \t\t\tthis.listener.executionStarted(testDescriptor);\n \t\t\tthis.listener.executionFinished(testDescriptor, TestExecutionResult.failed(throwable));\n \t\t\treturn;\n \t\t}\n \n \t\tthis.listener.executionStarted(testDescriptor);\n \n \t\tTestExecutionResult result = singleTestExecutor.executeSafely(() -> {\n \t\t\tC context = preparedContext;\n \t\t\ttry {\n \t\t\t\tcontext = node.before(context);\n \t\t\t\tcontext = node.execute(context);\n \n \t\t\t\t// If a node is NOT a leaf, execute its children recursively.\n \t\t\t\t// Note: executing children for a leaf could result in accidental\n \t\t\t\t// execution of dynamically added children.\n \t\t\t\tif (!node.isLeaf()) {\n \t\t\t\t\tfor (TestDescriptor child : testDescriptor.getChildren()) {\n \t\t\t\t\t\texecute(child, context);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t\tfinally {\n \t\t\t\tnode.after(context);\n \t\t\t}\n \t\t});\n \n \t\tthis.listener.executionFinished(testDescriptor, result);\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"62c433c14ce9d70fa5b82ef385a6e15c22cc0003": {
			"type": "Ybodychange",
			"commitMessage": "Ensure AfterAlls are invoked if exception is thrown by a BeforeAll\n\n- BeforeAll: @BeforeAll method or BeforeAllCallback\n- AfterAll:  @AfterAll method or AfterAllCallback\n\nPrior to this commit, if an exception was thrown by a BeforeAll, then\nAfterAlls were never invoked, which is in strict contrast to the\nsemantics of JUnit 4 and other frameworks.\n\nThis commit fixes this problem by ensuring that AfterAlls (for the\nappropriate nesting level) are invoked even if a BeforeAll throws an\nexception.\n\nFixes: #359\n",
			"commitDate": "2016-06-25, 12:29 PM",
			"commitName": "62c433c14ce9d70fa5b82ef385a6e15c22cc0003",
			"commitAuthor": "Sam Brannen",
			"commitDateOld": "2016-06-21, 3:45 AM",
			"commitNameOld": "5ca993afb2db6a2dd10e3fb4f0790cf30200a6ec",
			"commitAuthorOld": "Sam Brannen",
			"daysBetweenCommits": 4.36,
			"commitsBetweenForRepo": 32,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,41 +1,45 @@\n \tprivate void execute(TestDescriptor testDescriptor, C parentContext) {\n \t\tNode<C> node = asNode(testDescriptor);\n \n \t\tC preparedContext;\n \t\ttry {\n \t\t\tpreparedContext = node.prepare(parentContext);\n \t\t\tSkipResult skipResult = node.shouldBeSkipped(preparedContext);\n \t\t\tif (skipResult.isSkipped()) {\n \t\t\t\tthis.listener.executionSkipped(testDescriptor, skipResult.getReason().orElse(\"<unknown>\"));\n \t\t\t\treturn;\n \t\t\t}\n \t\t}\n \t\tcatch (Throwable throwable) {\n \t\t\trethrowIfBlacklisted(throwable);\n \n \t\t\t// TODO [#336] Decide if exceptions thrown during preparation should result in the node being marked as \"started\".\n \t\t\tthis.listener.executionStarted(testDescriptor);\n \t\t\tthis.listener.executionFinished(testDescriptor, TestExecutionResult.failed(throwable));\n \t\t\treturn;\n \t\t}\n \n \t\tthis.listener.executionStarted(testDescriptor);\n \n \t\tTestExecutionResult result = singleTestExecutor.executeSafely(() -> {\n-\t\t\tC context = node.before(preparedContext);\n-\t\t\tcontext = node.execute(context);\n+\t\t\tC context = preparedContext;\n+\t\t\ttry {\n+\t\t\t\tcontext = node.before(context);\n+\t\t\t\tcontext = node.execute(context);\n \n-\t\t\t// If a node is not a leaf, execute its children recursively.\n-\t\t\t// Note: executing children for a leaf would result in accidental\n-\t\t\t// execution of dynamically added children.\n-\t\t\tif (!node.isLeaf()) {\n-\t\t\t\tfor (TestDescriptor child : testDescriptor.getChildren()) {\n-\t\t\t\t\texecute(child, context);\n+\t\t\t\t// If a node is NOT a leaf, execute its children recursively.\n+\t\t\t\t// Note: executing children for a leaf could result in accidental\n+\t\t\t\t// execution of dynamically added children.\n+\t\t\t\tif (!node.isLeaf()) {\n+\t\t\t\t\tfor (TestDescriptor child : testDescriptor.getChildren()) {\n+\t\t\t\t\t\texecute(child, context);\n+\t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n-\n-\t\t\tnode.after(context);\n+\t\t\tfinally {\n+\t\t\t\tnode.after(context);\n+\t\t\t}\n \t\t});\n \n \t\tthis.listener.executionFinished(testDescriptor, result);\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"5ca993afb2db6a2dd10e3fb4f0790cf30200a6ec": {
			"type": "Ybodychange",
			"commitMessage": "Track TODOs\n",
			"commitDate": "2016-06-21, 3:45 AM",
			"commitName": "5ca993afb2db6a2dd10e3fb4f0790cf30200a6ec",
			"commitAuthor": "Sam Brannen",
			"commitDateOld": "2016-06-20, 4:43 AM",
			"commitNameOld": "f05183091a62cbbd58df338fc58f599f7994ec74",
			"commitAuthorOld": "JUnit Team",
			"daysBetweenCommits": 0.96,
			"commitsBetweenForRepo": 18,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,41 +1,41 @@\n \tprivate void execute(TestDescriptor testDescriptor, C parentContext) {\n \t\tNode<C> node = asNode(testDescriptor);\n \n \t\tC preparedContext;\n \t\ttry {\n \t\t\tpreparedContext = node.prepare(parentContext);\n \t\t\tSkipResult skipResult = node.shouldBeSkipped(preparedContext);\n \t\t\tif (skipResult.isSkipped()) {\n \t\t\t\tthis.listener.executionSkipped(testDescriptor, skipResult.getReason().orElse(\"<unknown>\"));\n \t\t\t\treturn;\n \t\t\t}\n \t\t}\n \t\tcatch (Throwable throwable) {\n \t\t\trethrowIfBlacklisted(throwable);\n \n-\t\t\t// TODO Decide if exceptions thrown during preparation should result in the node being marked as \"started\".\n+\t\t\t// TODO [#336] Decide if exceptions thrown during preparation should result in the node being marked as \"started\".\n \t\t\tthis.listener.executionStarted(testDescriptor);\n \t\t\tthis.listener.executionFinished(testDescriptor, TestExecutionResult.failed(throwable));\n \t\t\treturn;\n \t\t}\n \n \t\tthis.listener.executionStarted(testDescriptor);\n \n \t\tTestExecutionResult result = singleTestExecutor.executeSafely(() -> {\n \t\t\tC context = node.before(preparedContext);\n \t\t\tcontext = node.execute(context);\n \n \t\t\t// If a node is not a leaf, execute its children recursively.\n \t\t\t// Note: executing children for a leaf would result in accidental\n \t\t\t// execution of dynamically added children.\n \t\t\tif (!node.isLeaf()) {\n \t\t\t\tfor (TestDescriptor child : testDescriptor.getChildren()) {\n \t\t\t\t\texecute(child, context);\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tnode.after(context);\n \t\t});\n \n \t\tthis.listener.executionFinished(testDescriptor, result);\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"4972eb58d680a30e8fbd1ffb6cdc6477bef83374": {
			"type": "Yfilerename",
			"commitMessage": "Rename all JUnit 5 artifacts to platform, jupiter, & vintage\n\nIssue: #286\n",
			"commitDate": "2016-06-20, 1:59 AM",
			"commitName": "4972eb58d680a30e8fbd1ffb6cdc6477bef83374",
			"commitAuthor": "JUnit Team",
			"commitDateOld": "2016-06-19, 11:04 AM",
			"commitNameOld": "e5b7300ba40a0420e310d463a63ea4c10cc8d9b9",
			"commitAuthorOld": "Sam Brannen",
			"daysBetweenCommits": 0.62,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "",
			"extendedDetails": {
				"oldPath": "junit-engine-api/src/main/java/org/junit/platform/engine/support/hierarchical/HierarchicalTestExecutor.java",
				"newPath": "junit-platform-engine/src/main/java/org/junit/platform/engine/support/hierarchical/HierarchicalTestExecutor.java"
			}
		},
		"4537bec58804c392a8bce296dced0337c8ec1a8d": {
			"type": "Yfilerename",
			"commitMessage": "Rename remaining org.junit.gen5 base packages to org.junit.platform\n\nIssue: #286\n",
			"commitDate": "2016-06-19, 10:22 AM",
			"commitName": "4537bec58804c392a8bce296dced0337c8ec1a8d",
			"commitAuthor": "JUnit Team",
			"commitDateOld": "2016-06-19, 9:25 AM",
			"commitNameOld": "4dd821ac0cf681f17f14e1dcd383b10c99104e70",
			"commitAuthorOld": "Sam Brannen",
			"daysBetweenCommits": 0.04,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "",
			"extendedDetails": {
				"oldPath": "junit-engine-api/src/main/java/org/junit/gen5/engine/support/hierarchical/HierarchicalTestExecutor.java",
				"newPath": "junit-engine-api/src/main/java/org/junit/platform/engine/support/hierarchical/HierarchicalTestExecutor.java"
			}
		},
		"6b46df0ee35ef56021ca5f4dc9e41ac96b19de0e": {
			"type": "Ybodychange",
			"commitMessage": "Introduce default semantics for Node.isLeaf()\n",
			"commitDate": "2016-05-31, 5:41 AM",
			"commitName": "6b46df0ee35ef56021ca5f4dc9e41ac96b19de0e",
			"commitAuthor": "Sam Brannen",
			"commitDateOld": "2016-05-30, 6:54 PM",
			"commitNameOld": "c8e52a7cde0579562c51c838ef1c83b68b0c31cf",
			"commitAuthorOld": "Sam Brannen",
			"daysBetweenCommits": 0.45,
			"commitsBetweenForRepo": 5,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,37 +1,41 @@\n \tprivate void execute(TestDescriptor testDescriptor, C parentContext) {\n \t\tNode<C> node = asNode(testDescriptor);\n \n \t\tC preparedContext;\n \t\ttry {\n \t\t\tpreparedContext = node.prepare(parentContext);\n \t\t\tSkipResult skipResult = node.shouldBeSkipped(preparedContext);\n \t\t\tif (skipResult.isSkipped()) {\n \t\t\t\tthis.listener.executionSkipped(testDescriptor, skipResult.getReason().orElse(\"<unknown>\"));\n \t\t\t\treturn;\n \t\t\t}\n \t\t}\n \t\tcatch (Throwable throwable) {\n \t\t\trethrowIfBlacklisted(throwable);\n \n \t\t\t// TODO Decide if exceptions thrown during preparation should result in the node being marked as \"started\".\n \t\t\tthis.listener.executionStarted(testDescriptor);\n \t\t\tthis.listener.executionFinished(testDescriptor, TestExecutionResult.failed(throwable));\n \t\t\treturn;\n \t\t}\n \n \t\tthis.listener.executionStarted(testDescriptor);\n \n \t\tTestExecutionResult result = singleTestExecutor.executeSafely(() -> {\n \t\t\tC context = node.before(preparedContext);\n \t\t\tcontext = node.execute(context);\n \n-\t\t\tif (!node.isLeaf()) { // Prevent execution of dynamically added children\n+\t\t\t// If a node is not a leaf, execute its children recursively.\n+\t\t\t// Note: executing children for a leaf would result in accidental\n+\t\t\t// execution of dynamically added children.\n+\t\t\tif (!node.isLeaf()) {\n \t\t\t\tfor (TestDescriptor child : testDescriptor.getChildren()) {\n \t\t\t\t\texecute(child, context);\n \t\t\t\t}\n \t\t\t}\n+\n \t\t\tnode.after(context);\n \t\t});\n \n \t\tthis.listener.executionFinished(testDescriptor, result);\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"c8e52a7cde0579562c51c838ef1c83b68b0c31cf": {
			"type": "Ymultichange(Yrename,Ybodychange)",
			"commitMessage": "Remove Container & Leaf abstractions from the HierarchicalTestEngine\n",
			"commitDate": "2016-05-30, 6:54 PM",
			"commitName": "c8e52a7cde0579562c51c838ef1c83b68b0c31cf",
			"commitAuthor": "Sam Brannen",
			"subchanges": [
				{
					"type": "Yrename",
					"commitMessage": "Remove Container & Leaf abstractions from the HierarchicalTestEngine\n",
					"commitDate": "2016-05-30, 6:54 PM",
					"commitName": "c8e52a7cde0579562c51c838ef1c83b68b0c31cf",
					"commitAuthor": "Sam Brannen",
					"commitDateOld": "2016-05-23, 12:21 PM",
					"commitNameOld": "ac7bb522519cd8a600324aa909a5c17a110cb97f",
					"commitAuthorOld": "Johannes Link",
					"daysBetweenCommits": 7.27,
					"commitsBetweenForRepo": 91,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,35 +1,37 @@\n-\tprivate void executeAll(TestDescriptor testDescriptor, C parentContext) {\n+\tprivate void execute(TestDescriptor testDescriptor, C parentContext) {\n+\t\tNode<C> node = asNode(testDescriptor);\n \n \t\tC preparedContext;\n \t\ttry {\n-\t\t\tpreparedContext = adapter.asNode(testDescriptor).prepare(parentContext);\n-\t\t\tSkipResult skipResult = adapter.asNode(testDescriptor).shouldBeSkipped(preparedContext);\n+\t\t\tpreparedContext = node.prepare(parentContext);\n+\t\t\tSkipResult skipResult = node.shouldBeSkipped(preparedContext);\n \t\t\tif (skipResult.isSkipped()) {\n-\t\t\t\tlistener.executionSkipped(testDescriptor, skipResult.getReason().orElse(\"<unknown>\"));\n+\t\t\t\tthis.listener.executionSkipped(testDescriptor, skipResult.getReason().orElse(\"<unknown>\"));\n \t\t\t\treturn;\n \t\t\t}\n \t\t}\n \t\tcatch (Throwable throwable) {\n \t\t\trethrowIfBlacklisted(throwable);\n \n \t\t\t// TODO Decide if exceptions thrown during preparation should result in the node being marked as \"started\".\n-\t\t\tlistener.executionStarted(testDescriptor);\n-\t\t\tlistener.executionFinished(testDescriptor, TestExecutionResult.failed(throwable));\n+\t\t\tthis.listener.executionStarted(testDescriptor);\n+\t\t\tthis.listener.executionFinished(testDescriptor, TestExecutionResult.failed(throwable));\n \t\t\treturn;\n \t\t}\n \n-\t\tlistener.executionStarted(testDescriptor);\n+\t\tthis.listener.executionStarted(testDescriptor);\n \n \t\tTestExecutionResult result = singleTestExecutor.executeSafely(() -> {\n-\t\t\tC context = adapter.asContainer(testDescriptor).beforeAll(preparedContext);\n-\t\t\tcontext = adapter.asLeaf(testDescriptor).execute(context);\n+\t\t\tC context = node.before(preparedContext);\n+\t\t\tcontext = node.execute(context);\n \n-\t\t\tif (testDescriptor instanceof Container) { // to prevent execution of dynamically added children\n+\t\t\tif (!node.isLeaf()) { // Prevent execution of dynamically added children\n \t\t\t\tfor (TestDescriptor child : testDescriptor.getChildren()) {\n-\t\t\t\t\texecuteAll(child, context);\n+\t\t\t\t\texecute(child, context);\n \t\t\t\t}\n \t\t\t}\n-\t\t\tcontext = adapter.asContainer(testDescriptor).afterAll(context);\n+\t\t\tnode.after(context);\n \t\t});\n-\t\tlistener.executionFinished(testDescriptor, result);\n+\n+\t\tthis.listener.executionFinished(testDescriptor, result);\n \t}\n\\ No newline at end of file\n",
					"extendedDetails": {
						"oldValue": "executeAll",
						"newValue": "execute"
					}
				},
				{
					"type": "Ybodychange",
					"commitMessage": "Remove Container & Leaf abstractions from the HierarchicalTestEngine\n",
					"commitDate": "2016-05-30, 6:54 PM",
					"commitName": "c8e52a7cde0579562c51c838ef1c83b68b0c31cf",
					"commitAuthor": "Sam Brannen",
					"commitDateOld": "2016-05-23, 12:21 PM",
					"commitNameOld": "ac7bb522519cd8a600324aa909a5c17a110cb97f",
					"commitAuthorOld": "Johannes Link",
					"daysBetweenCommits": 7.27,
					"commitsBetweenForRepo": 91,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,35 +1,37 @@\n-\tprivate void executeAll(TestDescriptor testDescriptor, C parentContext) {\n+\tprivate void execute(TestDescriptor testDescriptor, C parentContext) {\n+\t\tNode<C> node = asNode(testDescriptor);\n \n \t\tC preparedContext;\n \t\ttry {\n-\t\t\tpreparedContext = adapter.asNode(testDescriptor).prepare(parentContext);\n-\t\t\tSkipResult skipResult = adapter.asNode(testDescriptor).shouldBeSkipped(preparedContext);\n+\t\t\tpreparedContext = node.prepare(parentContext);\n+\t\t\tSkipResult skipResult = node.shouldBeSkipped(preparedContext);\n \t\t\tif (skipResult.isSkipped()) {\n-\t\t\t\tlistener.executionSkipped(testDescriptor, skipResult.getReason().orElse(\"<unknown>\"));\n+\t\t\t\tthis.listener.executionSkipped(testDescriptor, skipResult.getReason().orElse(\"<unknown>\"));\n \t\t\t\treturn;\n \t\t\t}\n \t\t}\n \t\tcatch (Throwable throwable) {\n \t\t\trethrowIfBlacklisted(throwable);\n \n \t\t\t// TODO Decide if exceptions thrown during preparation should result in the node being marked as \"started\".\n-\t\t\tlistener.executionStarted(testDescriptor);\n-\t\t\tlistener.executionFinished(testDescriptor, TestExecutionResult.failed(throwable));\n+\t\t\tthis.listener.executionStarted(testDescriptor);\n+\t\t\tthis.listener.executionFinished(testDescriptor, TestExecutionResult.failed(throwable));\n \t\t\treturn;\n \t\t}\n \n-\t\tlistener.executionStarted(testDescriptor);\n+\t\tthis.listener.executionStarted(testDescriptor);\n \n \t\tTestExecutionResult result = singleTestExecutor.executeSafely(() -> {\n-\t\t\tC context = adapter.asContainer(testDescriptor).beforeAll(preparedContext);\n-\t\t\tcontext = adapter.asLeaf(testDescriptor).execute(context);\n+\t\t\tC context = node.before(preparedContext);\n+\t\t\tcontext = node.execute(context);\n \n-\t\t\tif (testDescriptor instanceof Container) { // to prevent execution of dynamically added children\n+\t\t\tif (!node.isLeaf()) { // Prevent execution of dynamically added children\n \t\t\t\tfor (TestDescriptor child : testDescriptor.getChildren()) {\n-\t\t\t\t\texecuteAll(child, context);\n+\t\t\t\t\texecute(child, context);\n \t\t\t\t}\n \t\t\t}\n-\t\t\tcontext = adapter.asContainer(testDescriptor).afterAll(context);\n+\t\t\tnode.after(context);\n \t\t});\n-\t\tlistener.executionFinished(testDescriptor, result);\n+\n+\t\tthis.listener.executionFinished(testDescriptor, result);\n \t}\n\\ No newline at end of file\n",
					"extendedDetails": {}
				}
			]
		},
		"ac7bb522519cd8a600324aa909a5c17a110cb97f": {
			"type": "Ybodychange",
			"commitMessage": "Execution of simple dynamic tests (#58)\n\n- HierarchicalTestExecutor only executes children from containers\n- Unique IDs for dynamic tests are created using index\n- Add tests for discovery of dynamic test by method selector (#58)\n",
			"commitDate": "2016-05-23, 12:21 PM",
			"commitName": "ac7bb522519cd8a600324aa909a5c17a110cb97f",
			"commitAuthor": "Johannes Link",
			"commitDateOld": "2016-01-22, 12:27 PM",
			"commitNameOld": "2d0b61d00defaa534532d5541cfcb818307ff0d0",
			"commitAuthorOld": "Sam Brannen",
			"daysBetweenCommits": 121.95,
			"commitsBetweenForRepo": 504,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,33 +1,35 @@\n \tprivate void executeAll(TestDescriptor testDescriptor, C parentContext) {\n \n \t\tC preparedContext;\n \t\ttry {\n \t\t\tpreparedContext = adapter.asNode(testDescriptor).prepare(parentContext);\n \t\t\tSkipResult skipResult = adapter.asNode(testDescriptor).shouldBeSkipped(preparedContext);\n \t\t\tif (skipResult.isSkipped()) {\n \t\t\t\tlistener.executionSkipped(testDescriptor, skipResult.getReason().orElse(\"<unknown>\"));\n \t\t\t\treturn;\n \t\t\t}\n \t\t}\n \t\tcatch (Throwable throwable) {\n \t\t\trethrowIfBlacklisted(throwable);\n \n \t\t\t// TODO Decide if exceptions thrown during preparation should result in the node being marked as \"started\".\n \t\t\tlistener.executionStarted(testDescriptor);\n \t\t\tlistener.executionFinished(testDescriptor, TestExecutionResult.failed(throwable));\n \t\t\treturn;\n \t\t}\n \n \t\tlistener.executionStarted(testDescriptor);\n \n \t\tTestExecutionResult result = singleTestExecutor.executeSafely(() -> {\n \t\t\tC context = adapter.asContainer(testDescriptor).beforeAll(preparedContext);\n \t\t\tcontext = adapter.asLeaf(testDescriptor).execute(context);\n \n-\t\t\tfor (TestDescriptor child : testDescriptor.getChildren()) {\n-\t\t\t\texecuteAll(child, context);\n+\t\t\tif (testDescriptor instanceof Container) { // to prevent execution of dynamically added children\n+\t\t\t\tfor (TestDescriptor child : testDescriptor.getChildren()) {\n+\t\t\t\t\texecuteAll(child, context);\n+\t\t\t\t}\n \t\t\t}\n \t\t\tcontext = adapter.asContainer(testDescriptor).afterAll(context);\n \t\t});\n \t\tlistener.executionFinished(testDescriptor, result);\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"2d0b61d00defaa534532d5541cfcb818307ff0d0": {
			"type": "Ybodychange",
			"commitMessage": "Consistent use of <unknown> for unknown results in evaluations\n\n- conditions\n- filters\n",
			"commitDate": "2016-01-22, 12:27 PM",
			"commitName": "2d0b61d00defaa534532d5541cfcb818307ff0d0",
			"commitAuthor": "Sam Brannen",
			"commitDateOld": "2016-01-22, 9:09 AM",
			"commitNameOld": "ebd537b73796d734739fa6aabb78b4e88bbdd907",
			"commitAuthorOld": "Sam Brannen",
			"daysBetweenCommits": 0.14,
			"commitsBetweenForRepo": 14,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,33 +1,33 @@\n \tprivate void executeAll(TestDescriptor testDescriptor, C parentContext) {\n \n \t\tC preparedContext;\n \t\ttry {\n \t\t\tpreparedContext = adapter.asNode(testDescriptor).prepare(parentContext);\n \t\t\tSkipResult skipResult = adapter.asNode(testDescriptor).shouldBeSkipped(preparedContext);\n \t\t\tif (skipResult.isSkipped()) {\n-\t\t\t\tlistener.executionSkipped(testDescriptor, skipResult.getReason().orElse(\"\"));\n+\t\t\t\tlistener.executionSkipped(testDescriptor, skipResult.getReason().orElse(\"<unknown>\"));\n \t\t\t\treturn;\n \t\t\t}\n \t\t}\n \t\tcatch (Throwable throwable) {\n \t\t\trethrowIfBlacklisted(throwable);\n \n \t\t\t// TODO Decide if exceptions thrown during preparation should result in the node being marked as \"started\".\n \t\t\tlistener.executionStarted(testDescriptor);\n \t\t\tlistener.executionFinished(testDescriptor, TestExecutionResult.failed(throwable));\n \t\t\treturn;\n \t\t}\n \n \t\tlistener.executionStarted(testDescriptor);\n \n \t\tTestExecutionResult result = singleTestExecutor.executeSafely(() -> {\n \t\t\tC context = adapter.asContainer(testDescriptor).beforeAll(preparedContext);\n \t\t\tcontext = adapter.asLeaf(testDescriptor).execute(context);\n \n \t\t\tfor (TestDescriptor child : testDescriptor.getChildren()) {\n \t\t\t\texecuteAll(child, context);\n \t\t\t}\n \t\t\tcontext = adapter.asContainer(testDescriptor).afterAll(context);\n \t\t});\n \t\tlistener.executionFinished(testDescriptor, result);\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"ebd537b73796d734739fa6aabb78b4e88bbdd907": {
			"type": "Ybodychange",
			"commitMessage": "Document collaborators of HierarchicalTestEngine\n",
			"commitDate": "2016-01-22, 9:09 AM",
			"commitName": "ebd537b73796d734739fa6aabb78b4e88bbdd907",
			"commitAuthor": "Sam Brannen",
			"commitDateOld": "2016-01-22, 9:09 AM",
			"commitNameOld": "52b564dce77ed9f2fb055758c78cc6de4acc78b5",
			"commitAuthorOld": "Sam Brannen",
			"daysBetweenCommits": 0,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,33 +1,33 @@\n \tprivate void executeAll(TestDescriptor testDescriptor, C parentContext) {\n \n \t\tC preparedContext;\n \t\ttry {\n \t\t\tpreparedContext = adapter.asNode(testDescriptor).prepare(parentContext);\n \t\t\tSkipResult skipResult = adapter.asNode(testDescriptor).shouldBeSkipped(preparedContext);\n \t\t\tif (skipResult.isSkipped()) {\n \t\t\t\tlistener.executionSkipped(testDescriptor, skipResult.getReason().orElse(\"\"));\n \t\t\t\treturn;\n \t\t\t}\n \t\t}\n \t\tcatch (Throwable throwable) {\n \t\t\trethrowIfBlacklisted(throwable);\n \n-\t\t\t// TODO Is this what we want?\n+\t\t\t// TODO Decide if exceptions thrown during preparation should result in the node being marked as \"started\".\n \t\t\tlistener.executionStarted(testDescriptor);\n \t\t\tlistener.executionFinished(testDescriptor, TestExecutionResult.failed(throwable));\n \t\t\treturn;\n \t\t}\n \n \t\tlistener.executionStarted(testDescriptor);\n \n \t\tTestExecutionResult result = singleTestExecutor.executeSafely(() -> {\n \t\t\tC context = adapter.asContainer(testDescriptor).beforeAll(preparedContext);\n \t\t\tcontext = adapter.asLeaf(testDescriptor).execute(context);\n \n \t\t\tfor (TestDescriptor child : testDescriptor.getChildren()) {\n \t\t\t\texecuteAll(child, context);\n \t\t\t}\n \t\t\tcontext = adapter.asContainer(testDescriptor).afterAll(context);\n \t\t});\n \t\tlistener.executionFinished(testDescriptor, result);\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"0d2aa7088f7a586113524ba74448febcf6c70c51": {
			"type": "Yfilerename",
			"commitMessage": "Move support classes to separate packages\n\nIssue: #54\n",
			"commitDate": "2016-01-18, 5:44 AM",
			"commitName": "0d2aa7088f7a586113524ba74448febcf6c70c51",
			"commitAuthor": "Marc Philipp",
			"commitDateOld": "2016-01-18, 3:13 AM",
			"commitNameOld": "e99b1638955130803cd723245c4a797f03388b9b",
			"commitAuthorOld": "Stefan Bechtold",
			"daysBetweenCommits": 0.1,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "",
			"extendedDetails": {
				"oldPath": "junit-engine-api/src/main/java/org/junit/gen5/engine/HierarchicalTestExecutor.java",
				"newPath": "junit-engine-api/src/main/java/org/junit/gen5/engine/support/hierarchical/HierarchicalTestExecutor.java"
			}
		},
		"742e38c48236556233c280ddafe8a55e570de1a2": {
			"type": "Ybodychange",
			"commitMessage": "Polishing\n\nIssue: #83\n\n------------------------------------------------------------------------\nOn behalf of the community, the JUnit Lambda Team thanks msg systems ag\n(http://www.msg-systems.com) for supporting the JUnit crowdfunding\ncampaign!\n------------------------------------------------------------------------\n",
			"commitDate": "2016-01-05, 8:21 AM",
			"commitName": "742e38c48236556233c280ddafe8a55e570de1a2",
			"commitAuthor": "Sam Brannen",
			"commitDateOld": "2016-01-05, 8:14 AM",
			"commitNameOld": "614df95c0ec68977bb02515585340418fc3d7a6e",
			"commitAuthorOld": "Sam Brannen",
			"daysBetweenCommits": 0,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,31 +1,31 @@\n \tprivate void executeAll(TestDescriptor testDescriptor, C parentContext) {\n \n \t\tC preparedContext;\n \t\ttry {\n \t\t\tpreparedContext = adapter.asNode(testDescriptor).prepare(parentContext);\n \t\t\tSkipResult skipResult = adapter.asNode(testDescriptor).shouldBeSkipped(preparedContext);\n \t\t\tif (skipResult.isSkipped()) {\n \t\t\t\tlistener.executionSkipped(testDescriptor, skipResult.getReason().orElse(\"\"));\n \t\t\t\treturn;\n \t\t\t}\n \t\t}\n \t\tcatch (Throwable throwable) {\n-\t\t\trethrowIfBlackListed(throwable);\n+\t\t\trethrowIfBlacklisted(throwable);\n \n \t\t\t// TODO Is this what we want?\n \t\t\tlistener.executionStarted(testDescriptor);\n \t\t\tlistener.executionFinished(testDescriptor, TestExecutionResult.failed(throwable));\n \t\t\treturn;\n \t\t}\n \n \t\tlistener.executionStarted(testDescriptor);\n \t\tTestExecutionResult result = singleTestExecutor.executeSafely(() -> {\n \t\t\tC context = adapter.asContainer(testDescriptor).beforeAll(preparedContext);\n \t\t\tcontext = adapter.asLeaf(testDescriptor).execute(context);\n \t\t\tfor (TestDescriptor child : testDescriptor.getChildren()) {\n \t\t\t\texecuteAll(child, context);\n \t\t\t}\n \t\t\tcontext = adapter.asContainer(testDescriptor).afterAll(context);\n \t\t});\n \t\tlistener.executionFinished(testDescriptor, result);\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"a02c0e24af370ced24d8fa9d758b1a1db396796f": {
			"type": "Ybodychange",
			"commitMessage": "Introduce support for blacklisted exceptions\n\nThis commit introduces a BlacklistedExceptions utility class for\nrethrowing blacklisted exceptions (i.e., errors that always terminate\nthe test plan execution immediately).\n\nHierarchicalTestExecutor and SingleTestExecutor have been retrofitted to\nsupport blacklisted exceptions.\n\nIssue: #83\n\n------------------------------------------------------------------------\nOn behalf of the community, the JUnit Lambda Team thanks msg systems ag\n(http://www.msg-systems.com) for supporting the JUnit crowdfunding\ncampaign!\n------------------------------------------------------------------------\n",
			"commitDate": "2016-01-05, 8:14 AM",
			"commitName": "a02c0e24af370ced24d8fa9d758b1a1db396796f",
			"commitAuthor": "Sam Brannen",
			"commitDateOld": "2016-01-01, 10:57 AM",
			"commitNameOld": "a6e3e77eeb01b8e6fdc91be3120c6d07af1b5a91",
			"commitAuthorOld": "Marc Philipp",
			"daysBetweenCommits": 3.89,
			"commitsBetweenForRepo": 97,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,29 +1,31 @@\n \tprivate void executeAll(TestDescriptor testDescriptor, C parentContext) {\n \n \t\tC preparedContext;\n \t\ttry {\n \t\t\tpreparedContext = adapter.asNode(testDescriptor).prepare(parentContext);\n \t\t\tSkipResult skipResult = adapter.asNode(testDescriptor).shouldBeSkipped(preparedContext);\n \t\t\tif (skipResult.isSkipped()) {\n \t\t\t\tlistener.executionSkipped(testDescriptor, skipResult.getReason().orElse(\"\"));\n \t\t\t\treturn;\n \t\t\t}\n \t\t}\n \t\tcatch (Throwable throwable) {\n-\t\t\t//TODO: Is this what we want?\n+\t\t\trethrowIfBlackListed(throwable);\n+\n+\t\t\t// TODO Is this what we want?\n \t\t\tlistener.executionStarted(testDescriptor);\n \t\t\tlistener.executionFinished(testDescriptor, TestExecutionResult.failed(throwable));\n \t\t\treturn;\n \t\t}\n \n \t\tlistener.executionStarted(testDescriptor);\n \t\tTestExecutionResult result = singleTestExecutor.executeSafely(() -> {\n \t\t\tC context = adapter.asContainer(testDescriptor).beforeAll(preparedContext);\n \t\t\tcontext = adapter.asLeaf(testDescriptor).execute(context);\n \t\t\tfor (TestDescriptor child : testDescriptor.getChildren()) {\n \t\t\t\texecuteAll(child, context);\n \t\t\t}\n \t\t\tcontext = adapter.asContainer(testDescriptor).afterAll(context);\n \t\t});\n \t\tlistener.executionFinished(testDescriptor, result);\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"c54786d16f1c5f5ac5384a68893d069eba062e39": {
			"type": "Ybodychange",
			"commitMessage": "Added exception handling for errors in test preparation.\n\n------------------------------------------------------------------------\nOn behalf of the community, the JUnit Lambda Team thanks\nGradleware (https://gradle.org) for supporting the\nJUnit crowdfunding campaign!\n------------------------------------------------------------------------\n",
			"commitDate": "2015-12-23, 12:39 AM",
			"commitName": "c54786d16f1c5f5ac5384a68893d069eba062e39",
			"commitAuthor": "Johannes Link",
			"commitDateOld": "2015-12-22, 1:34 AM",
			"commitNameOld": "0027ade00fd483e08714ece1021a7715bb1855da",
			"commitAuthorOld": "Johannes Link",
			"daysBetweenCommits": 0.96,
			"commitsBetweenForRepo": 5,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,27 +1,29 @@\n \tprivate void executeAll(TestDescriptor testDescriptor, C parentContext) {\n \n \t\tC preparedContext;\n \t\ttry {\n \t\t\tpreparedContext = adapter.asNode(testDescriptor).prepare(parentContext);\n \t\t\tSkipResult skipResult = adapter.asNode(testDescriptor).shouldBeSkipped(preparedContext);\n \t\t\tif (skipResult.isSkipped()) {\n \t\t\t\tlistener.executionSkipped(testDescriptor, skipResult.getReason().orElse(\"\"));\n \t\t\t\treturn;\n \t\t\t}\n \t\t}\n \t\tcatch (Throwable throwable) {\n-\t\t\t//TODO: What should happen if prepare or shouldBeSkipped thrown an exception?\n-\t\t\tthrow new RuntimeException(throwable);\n+\t\t\t//TODO: Is this what we want?\n+\t\t\tlistener.executionStarted(testDescriptor);\n+\t\t\tlistener.executionFinished(testDescriptor, TestExecutionResult.failed(throwable));\n+\t\t\treturn;\n \t\t}\n \n \t\tlistener.executionStarted(testDescriptor);\n \t\tTestExecutionResult result = singleTestExecutor.executeSafely(() -> {\n \t\t\tC context = adapter.asContainer(testDescriptor).beforeAll(preparedContext);\n \t\t\tcontext = adapter.asLeaf(testDescriptor).execute(context);\n \t\t\tfor (TestDescriptor child : testDescriptor.getChildren()) {\n \t\t\t\texecuteAll(child, context);\n \t\t\t}\n \t\t\tcontext = adapter.asContainer(testDescriptor).afterAll(context);\n \t\t});\n \t\tlistener.executionFinished(testDescriptor, result);\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"0027ade00fd483e08714ece1021a7715bb1855da": {
			"type": "Ybodychange",
			"commitMessage": "Added skipping for methods and classes.\nSome duplication and naming issues left.\n------------------------------------------------------------------------\nOn behalf of the community, the JUnit Lambda Team thanks\nGradleware (https://gradle.org) for supporting the\nJUnit crowdfunding campaign!\n------------------------------------------------------------------------\n",
			"commitDate": "2015-12-22, 1:34 AM",
			"commitName": "0027ade00fd483e08714ece1021a7715bb1855da",
			"commitAuthor": "Johannes Link",
			"commitDateOld": "2015-12-13, 1:24 PM",
			"commitNameOld": "55a1054a3310fdbf6e7a0c03f9a6ba9366aa2ece",
			"commitAuthorOld": "Marc Philipp",
			"daysBetweenCommits": 8.51,
			"commitsBetweenForRepo": 64,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,14 +1,27 @@\n \tprivate void executeAll(TestDescriptor testDescriptor, C parentContext) {\n-\t\t// TODO Check whether TestDescriptor should be skipped and fire executionSkipped\n-\t\t// event instead.\n+\n+\t\tC preparedContext;\n+\t\ttry {\n+\t\t\tpreparedContext = adapter.asNode(testDescriptor).prepare(parentContext);\n+\t\t\tSkipResult skipResult = adapter.asNode(testDescriptor).shouldBeSkipped(preparedContext);\n+\t\t\tif (skipResult.isSkipped()) {\n+\t\t\t\tlistener.executionSkipped(testDescriptor, skipResult.getReason().orElse(\"\"));\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t}\n+\t\tcatch (Throwable throwable) {\n+\t\t\t//TODO: What should happen if prepare or shouldBeSkipped thrown an exception?\n+\t\t\tthrow new RuntimeException(throwable);\n+\t\t}\n+\n \t\tlistener.executionStarted(testDescriptor);\n \t\tTestExecutionResult result = singleTestExecutor.executeSafely(() -> {\n-\t\t\tC context = adapter.asContainer(testDescriptor).beforeAll(parentContext);\n+\t\t\tC context = adapter.asContainer(testDescriptor).beforeAll(preparedContext);\n \t\t\tcontext = adapter.asLeaf(testDescriptor).execute(context);\n \t\t\tfor (TestDescriptor child : testDescriptor.getChildren()) {\n \t\t\t\texecuteAll(child, context);\n \t\t\t}\n \t\t\tcontext = adapter.asContainer(testDescriptor).afterAll(context);\n \t\t});\n \t\tlistener.executionFinished(testDescriptor, result);\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"55a1054a3310fdbf6e7a0c03f9a6ba9366aa2ece": {
			"type": "Ybodychange",
			"commitMessage": "Less @SuppressWarnings\n\n------------------------------------------------------------------------\nOn behalf of the community, the JUnit Lambda Team thanks\nAdNovum Informatik AG (http://www.adnovum.ch) for supporting the\nJUnit crowdfunding campaign!\n------------------------------------------------------------------------\n",
			"commitDate": "2015-12-13, 1:24 PM",
			"commitName": "55a1054a3310fdbf6e7a0c03f9a6ba9366aa2ece",
			"commitAuthor": "Marc Philipp",
			"commitDateOld": "2015-12-13, 12:54 PM",
			"commitNameOld": "d920335e85cfee5444fe3d69d12806d999b9f2ec",
			"commitAuthorOld": "Marc Philipp",
			"daysBetweenCommits": 0.02,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,14 +1,14 @@\n \tprivate void executeAll(TestDescriptor testDescriptor, C parentContext) {\n \t\t// TODO Check whether TestDescriptor should be skipped and fire executionSkipped\n \t\t// event instead.\n \t\tlistener.executionStarted(testDescriptor);\n \t\tTestExecutionResult result = singleTestExecutor.executeSafely(() -> {\n-\t\t\tC context = executeBeforeAll(testDescriptor, parentContext);\n-\t\t\tcontext = executeLeaf(testDescriptor, context);\n+\t\t\tC context = adapter.asContainer(testDescriptor).beforeAll(parentContext);\n+\t\t\tcontext = adapter.asLeaf(testDescriptor).execute(context);\n \t\t\tfor (TestDescriptor child : testDescriptor.getChildren()) {\n \t\t\t\texecuteAll(child, context);\n \t\t\t}\n-\t\t\tcontext = executeAfterAll(testDescriptor, context);\n+\t\t\tcontext = adapter.asContainer(testDescriptor).afterAll(context);\n \t\t});\n \t\tlistener.executionFinished(testDescriptor, result);\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"cfefe1e65034c5e66e0fbcb503fe8ad1a4c086d2": {
			"type": "Ymultichange(Yfilerename,Ybodychange,Yparameterchange)",
			"commitMessage": "Extract stateful HierarchicalTestExecutor\n\n------------------------------------------------------------------------\nOn behalf of the community, the JUnit Lambda Team thanks\nAdNovum Informatik AG (http://www.adnovum.ch) for supporting the\nJUnit crowdfunding campaign!\n------------------------------------------------------------------------\n",
			"commitDate": "2015-12-13, 12:54 PM",
			"commitName": "cfefe1e65034c5e66e0fbcb503fe8ad1a4c086d2",
			"commitAuthor": "Marc Philipp",
			"subchanges": [
				{
					"type": "Yfilerename",
					"commitMessage": "Extract stateful HierarchicalTestExecutor\n\n------------------------------------------------------------------------\nOn behalf of the community, the JUnit Lambda Team thanks\nAdNovum Informatik AG (http://www.adnovum.ch) for supporting the\nJUnit crowdfunding campaign!\n------------------------------------------------------------------------\n",
					"commitDate": "2015-12-13, 12:54 PM",
					"commitName": "cfefe1e65034c5e66e0fbcb503fe8ad1a4c086d2",
					"commitAuthor": "Marc Philipp",
					"commitDateOld": "2015-12-13, 12:41 PM",
					"commitNameOld": "e9d19c214a3117efdd9295bdb1b2ddb4f7e67987",
					"commitAuthorOld": "Johannes Link",
					"daysBetweenCommits": 0.01,
					"commitsBetweenForRepo": 1,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,14 +1,14 @@\n-\tprivate void executeAll(TestDescriptor testDescriptor, EngineExecutionListener listener, C parentContext) {\n+\tprivate void executeAll(TestDescriptor testDescriptor, C parentContext) {\n \t\t// TODO Check whether TestDescriptor should be skipped and fire executionSkipped\n \t\t// event instead.\n \t\tlistener.executionStarted(testDescriptor);\n-\t\tTestExecutionResult result = new SingleTestExecutor().executeSafely(() -> {\n+\t\tTestExecutionResult result = singleTestExecutor.executeSafely(() -> {\n \t\t\tC context = executeBeforeAll(testDescriptor, parentContext);\n \t\t\tcontext = executeLeaf(testDescriptor, context);\n \t\t\tfor (TestDescriptor child : testDescriptor.getChildren()) {\n-\t\t\t\texecuteAll(child, listener, context);\n+\t\t\t\texecuteAll(child, context);\n \t\t\t}\n \t\t\tcontext = executeAfterAll(testDescriptor, context);\n \t\t});\n \t\tlistener.executionFinished(testDescriptor, result);\n \t}\n\\ No newline at end of file\n",
					"extendedDetails": {
						"oldPath": "junit-engine-api/src/main/java/org/junit/gen5/engine/HierarchicalTestEngine.java",
						"newPath": "junit-engine-api/src/main/java/org/junit/gen5/engine/HierarchicalTestExecutor.java"
					}
				},
				{
					"type": "Ybodychange",
					"commitMessage": "Extract stateful HierarchicalTestExecutor\n\n------------------------------------------------------------------------\nOn behalf of the community, the JUnit Lambda Team thanks\nAdNovum Informatik AG (http://www.adnovum.ch) for supporting the\nJUnit crowdfunding campaign!\n------------------------------------------------------------------------\n",
					"commitDate": "2015-12-13, 12:54 PM",
					"commitName": "cfefe1e65034c5e66e0fbcb503fe8ad1a4c086d2",
					"commitAuthor": "Marc Philipp",
					"commitDateOld": "2015-12-13, 12:41 PM",
					"commitNameOld": "e9d19c214a3117efdd9295bdb1b2ddb4f7e67987",
					"commitAuthorOld": "Johannes Link",
					"daysBetweenCommits": 0.01,
					"commitsBetweenForRepo": 1,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,14 +1,14 @@\n-\tprivate void executeAll(TestDescriptor testDescriptor, EngineExecutionListener listener, C parentContext) {\n+\tprivate void executeAll(TestDescriptor testDescriptor, C parentContext) {\n \t\t// TODO Check whether TestDescriptor should be skipped and fire executionSkipped\n \t\t// event instead.\n \t\tlistener.executionStarted(testDescriptor);\n-\t\tTestExecutionResult result = new SingleTestExecutor().executeSafely(() -> {\n+\t\tTestExecutionResult result = singleTestExecutor.executeSafely(() -> {\n \t\t\tC context = executeBeforeAll(testDescriptor, parentContext);\n \t\t\tcontext = executeLeaf(testDescriptor, context);\n \t\t\tfor (TestDescriptor child : testDescriptor.getChildren()) {\n-\t\t\t\texecuteAll(child, listener, context);\n+\t\t\t\texecuteAll(child, context);\n \t\t\t}\n \t\t\tcontext = executeAfterAll(testDescriptor, context);\n \t\t});\n \t\tlistener.executionFinished(testDescriptor, result);\n \t}\n\\ No newline at end of file\n",
					"extendedDetails": {}
				},
				{
					"type": "Yparameterchange",
					"commitMessage": "Extract stateful HierarchicalTestExecutor\n\n------------------------------------------------------------------------\nOn behalf of the community, the JUnit Lambda Team thanks\nAdNovum Informatik AG (http://www.adnovum.ch) for supporting the\nJUnit crowdfunding campaign!\n------------------------------------------------------------------------\n",
					"commitDate": "2015-12-13, 12:54 PM",
					"commitName": "cfefe1e65034c5e66e0fbcb503fe8ad1a4c086d2",
					"commitAuthor": "Marc Philipp",
					"commitDateOld": "2015-12-13, 12:41 PM",
					"commitNameOld": "e9d19c214a3117efdd9295bdb1b2ddb4f7e67987",
					"commitAuthorOld": "Johannes Link",
					"daysBetweenCommits": 0.01,
					"commitsBetweenForRepo": 1,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,14 +1,14 @@\n-\tprivate void executeAll(TestDescriptor testDescriptor, EngineExecutionListener listener, C parentContext) {\n+\tprivate void executeAll(TestDescriptor testDescriptor, C parentContext) {\n \t\t// TODO Check whether TestDescriptor should be skipped and fire executionSkipped\n \t\t// event instead.\n \t\tlistener.executionStarted(testDescriptor);\n-\t\tTestExecutionResult result = new SingleTestExecutor().executeSafely(() -> {\n+\t\tTestExecutionResult result = singleTestExecutor.executeSafely(() -> {\n \t\t\tC context = executeBeforeAll(testDescriptor, parentContext);\n \t\t\tcontext = executeLeaf(testDescriptor, context);\n \t\t\tfor (TestDescriptor child : testDescriptor.getChildren()) {\n-\t\t\t\texecuteAll(child, listener, context);\n+\t\t\t\texecuteAll(child, context);\n \t\t\t}\n \t\t\tcontext = executeAfterAll(testDescriptor, context);\n \t\t});\n \t\tlistener.executionFinished(testDescriptor, result);\n \t}\n\\ No newline at end of file\n",
					"extendedDetails": {
						"oldValue": "[testDescriptor-TestDescriptor, listener-EngineExecutionListener, parentContext-C]",
						"newValue": "[testDescriptor-TestDescriptor, parentContext-C]"
					}
				}
			]
		},
		"94bd5987b3b75c91a41fd70779bae83bb9b5fb9c": {
			"type": "Ybodychange",
			"commitMessage": "TestAbortedException leads to aborted test\n\n------------------------------------------------------------------------\nOn behalf of the community, the JUnit Lambda Team thanks\nAdNovum Informatik AG (http://www.adnovum.ch) for supporting the\nJUnit crowdfunding campaign!\n------------------------------------------------------------------------\n",
			"commitDate": "2015-12-13, 12:08 PM",
			"commitName": "94bd5987b3b75c91a41fd70779bae83bb9b5fb9c",
			"commitAuthor": "Marc Philipp",
			"commitDateOld": "2015-12-11, 1:35 PM",
			"commitNameOld": "f8a1c6b5ae5a144d1a3e85100a4d61b7f059822d",
			"commitAuthorOld": "Marc Philipp",
			"daysBetweenCommits": 1.94,
			"commitsBetweenForRepo": 19,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,19 +1,14 @@\n \tprivate void executeAll(TestDescriptor testDescriptor, EngineExecutionListener listener, C parentContext) {\n \t\t// TODO Check whether TestDescriptor should be skipped and fire executionSkipped\n \t\t// event instead.\n \t\tlistener.executionStarted(testDescriptor);\n-\t\tTestExecutionResult result;\n-\t\ttry {\n+\t\tTestExecutionResult result = new SingleTestExecutor().executeSafely(() -> {\n \t\t\tC context = executeBeforeAll(testDescriptor, parentContext);\n \t\t\tcontext = executeLeaf(testDescriptor, context);\n \t\t\tfor (TestDescriptor child : testDescriptor.getChildren()) {\n \t\t\t\texecuteAll(child, listener, context);\n \t\t\t}\n \t\t\tcontext = executeAfterAll(testDescriptor, context);\n-\t\t\tresult = TestExecutionResult.successful();\n-\t\t}\n-\t\tcatch (Throwable t) {\n-\t\t\tresult = TestExecutionResult.failed(t);\n-\t\t}\n+\t\t});\n \t\tlistener.executionFinished(testDescriptor, result);\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"f8a1c6b5ae5a144d1a3e85100a4d61b7f059822d": {
			"type": "Ybodychange",
			"commitMessage": "Fire started/finished events for containers too\n\nIssue: #34\n\n------------------------------------------------------------------------\nOn behalf of the community, the JUnit Lambda Team thanks Netcetera AG\n(http://netcetera.com) for supporting the JUnit crowdfunding campaign!\n------------------------------------------------------------------------\n",
			"commitDate": "2015-12-11, 1:35 PM",
			"commitName": "f8a1c6b5ae5a144d1a3e85100a4d61b7f059822d",
			"commitAuthor": "Marc Philipp",
			"commitDateOld": "2015-12-11, 1:35 PM",
			"commitNameOld": "fc86dab57883ffcc0c5e6b9ea0999abb98101137",
			"commitAuthorOld": "Marc Philipp",
			"daysBetweenCommits": 0,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,21 +1,19 @@\n \tprivate void executeAll(TestDescriptor testDescriptor, EngineExecutionListener listener, C parentContext) {\n-\t\tif (testDescriptor.isTest()) {\n-\t\t\tlistener.testStarted(testDescriptor);\n-\t\t}\n+\t\t// TODO Check whether TestDescriptor should be skipped and fire executionSkipped\n+\t\t// event instead.\n+\t\tlistener.executionStarted(testDescriptor);\n \t\tTestExecutionResult result;\n \t\ttry {\n \t\t\tC context = executeBeforeAll(testDescriptor, parentContext);\n \t\t\tcontext = executeLeaf(testDescriptor, context);\n \t\t\tfor (TestDescriptor child : testDescriptor.getChildren()) {\n \t\t\t\texecuteAll(child, listener, context);\n \t\t\t}\n \t\t\tcontext = executeAfterAll(testDescriptor, context);\n \t\t\tresult = TestExecutionResult.successful();\n \t\t}\n \t\tcatch (Throwable t) {\n \t\t\tresult = TestExecutionResult.failed(t);\n \t\t}\n-\t\tif (testDescriptor.isTest()) {\n-\t\t\tlistener.testFinished(testDescriptor, result);\n-\t\t}\n+\t\tlistener.executionFinished(testDescriptor, result);\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"fc86dab57883ffcc0c5e6b9ea0999abb98101137": {
			"type": "Ybodychange",
			"commitMessage": "Trigger Finished event instead of separated ones\n\nInstead of triggering Succeeded/Aborted/Failed events we now only\ntrigger a Finished event with a TestExecutionResult parameter.\n\nIssue: #34\n\n------------------------------------------------------------------------\nOn behalf of the community, the JUnit Lambda Team thanks Netcetera AG\n(http://netcetera.com) for supporting the JUnit crowdfunding campaign!\n------------------------------------------------------------------------\n",
			"commitDate": "2015-12-11, 1:35 PM",
			"commitName": "fc86dab57883ffcc0c5e6b9ea0999abb98101137",
			"commitAuthor": "Marc Philipp",
			"commitDateOld": "2015-12-11, 11:07 AM",
			"commitNameOld": "417fd0e92571ec0cc01987c03f3ff112e4d867fc",
			"commitAuthorOld": "Marc Philipp",
			"daysBetweenCommits": 0.1,
			"commitsBetweenForRepo": 6,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,21 +1,21 @@\n \tprivate void executeAll(TestDescriptor testDescriptor, EngineExecutionListener listener, C parentContext) {\n \t\tif (testDescriptor.isTest()) {\n \t\t\tlistener.testStarted(testDescriptor);\n \t\t}\n+\t\tTestExecutionResult result;\n \t\ttry {\n \t\t\tC context = executeBeforeAll(testDescriptor, parentContext);\n \t\t\tcontext = executeLeaf(testDescriptor, context);\n \t\t\tfor (TestDescriptor child : testDescriptor.getChildren()) {\n \t\t\t\texecuteAll(child, listener, context);\n \t\t\t}\n \t\t\tcontext = executeAfterAll(testDescriptor, context);\n-\t\t\tif (testDescriptor.isTest()) {\n-\t\t\t\tlistener.testSucceeded(testDescriptor);\n-\t\t\t}\n+\t\t\tresult = TestExecutionResult.successful();\n \t\t}\n \t\tcatch (Throwable t) {\n-\t\t\tif (testDescriptor.isTest()) {\n-\t\t\t\tlistener.testFailed(testDescriptor, t);\n-\t\t\t}\n+\t\t\tresult = TestExecutionResult.failed(t);\n+\t\t}\n+\t\tif (testDescriptor.isTest()) {\n+\t\t\tlistener.testFinished(testDescriptor, result);\n \t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"417fd0e92571ec0cc01987c03f3ff112e4d867fc": {
			"type": "Ymultichange(Yparameterchange,Yexceptionschange,Ybodychange)",
			"commitMessage": "Cleanup HierarchicalTestEngine\n\n------------------------------------------------------------------------\nOn behalf of the community, the JUnit Lambda Team thanks\nNetcetera AG (http://netcetera.com) for supporting the JUnit crowdfunding campaign!\n------------------------------------------------------------------------\n",
			"commitDate": "2015-12-11, 11:07 AM",
			"commitName": "417fd0e92571ec0cc01987c03f3ff112e4d867fc",
			"commitAuthor": "Marc Philipp",
			"subchanges": [
				{
					"type": "Yparameterchange",
					"commitMessage": "Cleanup HierarchicalTestEngine\n\n------------------------------------------------------------------------\nOn behalf of the community, the JUnit Lambda Team thanks\nNetcetera AG (http://netcetera.com) for supporting the JUnit crowdfunding campaign!\n------------------------------------------------------------------------\n",
					"commitDate": "2015-12-11, 11:07 AM",
					"commitName": "417fd0e92571ec0cc01987c03f3ff112e4d867fc",
					"commitAuthor": "Marc Philipp",
					"commitDateOld": "2015-12-11, 5:32 AM",
					"commitNameOld": "554912b8f895d7ede966afa64fecd6b392eb3072",
					"commitAuthorOld": "Sam Brannen",
					"daysBetweenCommits": 0.23,
					"commitsBetweenForRepo": 3,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,24 +1,21 @@\n-\tprivate void executeAll(TestDescriptor parentDescriptor, EngineExecutionListener listener, C parentContext)\n-\t\t\tthrows Exception {\n-\t\tC context = parentContext;\n-\t\tif (parentDescriptor instanceof Container) {\n-\t\t\tcontext = ((Container<C>) parentDescriptor).beforeAll(context);\n+\tprivate void executeAll(TestDescriptor testDescriptor, EngineExecutionListener listener, C parentContext) {\n+\t\tif (testDescriptor.isTest()) {\n+\t\t\tlistener.testStarted(testDescriptor);\n \t\t}\n-\t\tfor (TestDescriptor childDescriptor : parentDescriptor.getChildren()) {\n-\t\t\tif (childDescriptor instanceof Leaf) {\n-\t\t\t\tLeaf<C> child = (Leaf<C>) childDescriptor;\n-\t\t\t\ttry {\n-\t\t\t\t\tlistener.testStarted(childDescriptor);\n-\t\t\t\t\tC childContext = child.execute(context);\n-\t\t\t\t\tlistener.testSucceeded(childDescriptor);\n-\t\t\t\t}\n-\t\t\t\tcatch (Throwable t) {\n-\t\t\t\t\tlistener.testFailed(childDescriptor, t);\n-\t\t\t\t}\n+\t\ttry {\n+\t\t\tC context = executeBeforeAll(testDescriptor, parentContext);\n+\t\t\tcontext = executeLeaf(testDescriptor, context);\n+\t\t\tfor (TestDescriptor child : testDescriptor.getChildren()) {\n+\t\t\t\texecuteAll(child, listener, context);\n \t\t\t}\n-\t\t\texecuteAll(childDescriptor, listener, context);\n+\t\t\tcontext = executeAfterAll(testDescriptor, context);\n+\t\t\tif (testDescriptor.isTest()) {\n+\t\t\t\tlistener.testSucceeded(testDescriptor);\n+\t\t\t}\n \t\t}\n-\t\tif (parentDescriptor instanceof Container) {\n-\t\t\tcontext = ((Container<C>) parentDescriptor).afterAll(context);\n+\t\tcatch (Throwable t) {\n+\t\t\tif (testDescriptor.isTest()) {\n+\t\t\t\tlistener.testFailed(testDescriptor, t);\n+\t\t\t}\n \t\t}\n \t}\n\\ No newline at end of file\n",
					"extendedDetails": {
						"oldValue": "[parentDescriptor-TestDescriptor, listener-EngineExecutionListener, parentContext-C]",
						"newValue": "[testDescriptor-TestDescriptor, listener-EngineExecutionListener, parentContext-C]"
					}
				},
				{
					"type": "Yexceptionschange",
					"commitMessage": "Cleanup HierarchicalTestEngine\n\n------------------------------------------------------------------------\nOn behalf of the community, the JUnit Lambda Team thanks\nNetcetera AG (http://netcetera.com) for supporting the JUnit crowdfunding campaign!\n------------------------------------------------------------------------\n",
					"commitDate": "2015-12-11, 11:07 AM",
					"commitName": "417fd0e92571ec0cc01987c03f3ff112e4d867fc",
					"commitAuthor": "Marc Philipp",
					"commitDateOld": "2015-12-11, 5:32 AM",
					"commitNameOld": "554912b8f895d7ede966afa64fecd6b392eb3072",
					"commitAuthorOld": "Sam Brannen",
					"daysBetweenCommits": 0.23,
					"commitsBetweenForRepo": 3,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,24 +1,21 @@\n-\tprivate void executeAll(TestDescriptor parentDescriptor, EngineExecutionListener listener, C parentContext)\n-\t\t\tthrows Exception {\n-\t\tC context = parentContext;\n-\t\tif (parentDescriptor instanceof Container) {\n-\t\t\tcontext = ((Container<C>) parentDescriptor).beforeAll(context);\n+\tprivate void executeAll(TestDescriptor testDescriptor, EngineExecutionListener listener, C parentContext) {\n+\t\tif (testDescriptor.isTest()) {\n+\t\t\tlistener.testStarted(testDescriptor);\n \t\t}\n-\t\tfor (TestDescriptor childDescriptor : parentDescriptor.getChildren()) {\n-\t\t\tif (childDescriptor instanceof Leaf) {\n-\t\t\t\tLeaf<C> child = (Leaf<C>) childDescriptor;\n-\t\t\t\ttry {\n-\t\t\t\t\tlistener.testStarted(childDescriptor);\n-\t\t\t\t\tC childContext = child.execute(context);\n-\t\t\t\t\tlistener.testSucceeded(childDescriptor);\n-\t\t\t\t}\n-\t\t\t\tcatch (Throwable t) {\n-\t\t\t\t\tlistener.testFailed(childDescriptor, t);\n-\t\t\t\t}\n+\t\ttry {\n+\t\t\tC context = executeBeforeAll(testDescriptor, parentContext);\n+\t\t\tcontext = executeLeaf(testDescriptor, context);\n+\t\t\tfor (TestDescriptor child : testDescriptor.getChildren()) {\n+\t\t\t\texecuteAll(child, listener, context);\n \t\t\t}\n-\t\t\texecuteAll(childDescriptor, listener, context);\n+\t\t\tcontext = executeAfterAll(testDescriptor, context);\n+\t\t\tif (testDescriptor.isTest()) {\n+\t\t\t\tlistener.testSucceeded(testDescriptor);\n+\t\t\t}\n \t\t}\n-\t\tif (parentDescriptor instanceof Container) {\n-\t\t\tcontext = ((Container<C>) parentDescriptor).afterAll(context);\n+\t\tcatch (Throwable t) {\n+\t\t\tif (testDescriptor.isTest()) {\n+\t\t\t\tlistener.testFailed(testDescriptor, t);\n+\t\t\t}\n \t\t}\n \t}\n\\ No newline at end of file\n",
					"extendedDetails": {
						"oldValue": "[Exception]",
						"newValue": "[]"
					}
				},
				{
					"type": "Ybodychange",
					"commitMessage": "Cleanup HierarchicalTestEngine\n\n------------------------------------------------------------------------\nOn behalf of the community, the JUnit Lambda Team thanks\nNetcetera AG (http://netcetera.com) for supporting the JUnit crowdfunding campaign!\n------------------------------------------------------------------------\n",
					"commitDate": "2015-12-11, 11:07 AM",
					"commitName": "417fd0e92571ec0cc01987c03f3ff112e4d867fc",
					"commitAuthor": "Marc Philipp",
					"commitDateOld": "2015-12-11, 5:32 AM",
					"commitNameOld": "554912b8f895d7ede966afa64fecd6b392eb3072",
					"commitAuthorOld": "Sam Brannen",
					"daysBetweenCommits": 0.23,
					"commitsBetweenForRepo": 3,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,24 +1,21 @@\n-\tprivate void executeAll(TestDescriptor parentDescriptor, EngineExecutionListener listener, C parentContext)\n-\t\t\tthrows Exception {\n-\t\tC context = parentContext;\n-\t\tif (parentDescriptor instanceof Container) {\n-\t\t\tcontext = ((Container<C>) parentDescriptor).beforeAll(context);\n+\tprivate void executeAll(TestDescriptor testDescriptor, EngineExecutionListener listener, C parentContext) {\n+\t\tif (testDescriptor.isTest()) {\n+\t\t\tlistener.testStarted(testDescriptor);\n \t\t}\n-\t\tfor (TestDescriptor childDescriptor : parentDescriptor.getChildren()) {\n-\t\t\tif (childDescriptor instanceof Leaf) {\n-\t\t\t\tLeaf<C> child = (Leaf<C>) childDescriptor;\n-\t\t\t\ttry {\n-\t\t\t\t\tlistener.testStarted(childDescriptor);\n-\t\t\t\t\tC childContext = child.execute(context);\n-\t\t\t\t\tlistener.testSucceeded(childDescriptor);\n-\t\t\t\t}\n-\t\t\t\tcatch (Throwable t) {\n-\t\t\t\t\tlistener.testFailed(childDescriptor, t);\n-\t\t\t\t}\n+\t\ttry {\n+\t\t\tC context = executeBeforeAll(testDescriptor, parentContext);\n+\t\t\tcontext = executeLeaf(testDescriptor, context);\n+\t\t\tfor (TestDescriptor child : testDescriptor.getChildren()) {\n+\t\t\t\texecuteAll(child, listener, context);\n \t\t\t}\n-\t\t\texecuteAll(childDescriptor, listener, context);\n+\t\t\tcontext = executeAfterAll(testDescriptor, context);\n+\t\t\tif (testDescriptor.isTest()) {\n+\t\t\t\tlistener.testSucceeded(testDescriptor);\n+\t\t\t}\n \t\t}\n-\t\tif (parentDescriptor instanceof Container) {\n-\t\t\tcontext = ((Container<C>) parentDescriptor).afterAll(context);\n+\t\tcatch (Throwable t) {\n+\t\t\tif (testDescriptor.isTest()) {\n+\t\t\t\tlistener.testFailed(testDescriptor, t);\n+\t\t\t}\n \t\t}\n \t}\n\\ No newline at end of file\n",
					"extendedDetails": {}
				}
			]
		},
		"3f9c11b9326b7d3051cb2a50568cd91113a0c0da": {
			"type": "Ymultichange(Yfilerename,Ybodychange)",
			"commitMessage": "Group discussion renaming results\n",
			"commitDate": "2015-12-10, 5:39 AM",
			"commitName": "3f9c11b9326b7d3051cb2a50568cd91113a0c0da",
			"commitAuthor": "Marc Philipp",
			"subchanges": [
				{
					"type": "Yfilerename",
					"commitMessage": "Group discussion renaming results\n",
					"commitDate": "2015-12-10, 5:39 AM",
					"commitName": "3f9c11b9326b7d3051cb2a50568cd91113a0c0da",
					"commitAuthor": "Marc Philipp",
					"commitDateOld": "2015-12-09, 2:17 PM",
					"commitNameOld": "0e14ad4525a5ade99dacdd76d0ab27223f57ebd4",
					"commitAuthorOld": "Marc Philipp",
					"daysBetweenCommits": 0.64,
					"commitsBetweenForRepo": 1,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,24 +1,24 @@\n \tprivate <T> void executeAll(TestDescriptor parentDescriptor, EngineExecutionListener listener, C parentContext)\n \t\t\tthrows Exception {\n \t\tC context = parentContext;\n-\t\tif (parentDescriptor instanceof Parent) {\n-\t\t\tcontext = ((Parent<C>) parentDescriptor).beforeAll(context);\n+\t\tif (parentDescriptor instanceof Container) {\n+\t\t\tcontext = ((Container<C>) parentDescriptor).beforeAll(context);\n \t\t}\n \t\tfor (TestDescriptor childDescriptor : parentDescriptor.getChildren()) {\n-\t\t\tif (childDescriptor instanceof Child) {\n-\t\t\t\tChild<C> child = (Child<C>) childDescriptor;\n+\t\t\tif (childDescriptor instanceof Leaf) {\n+\t\t\t\tLeaf<C> child = (Leaf<C>) childDescriptor;\n \t\t\t\ttry {\n \t\t\t\t\tlistener.testStarted(childDescriptor);\n \t\t\t\t\tC childContext = child.execute(context);\n \t\t\t\t\tlistener.testSucceeded(childDescriptor);\n \t\t\t\t}\n \t\t\t\tcatch (Throwable t) {\n \t\t\t\t\tlistener.testFailed(childDescriptor, t);\n \t\t\t\t}\n \t\t\t}\n \t\t\texecuteAll(childDescriptor, listener, context);\n \t\t}\n-\t\tif (parentDescriptor instanceof Parent) {\n-\t\t\tcontext = ((Parent<C>) parentDescriptor).afterAll(context);\n+\t\tif (parentDescriptor instanceof Container) {\n+\t\t\tcontext = ((Container<C>) parentDescriptor).afterAll(context);\n \t\t}\n \t}\n\\ No newline at end of file\n",
					"extendedDetails": {
						"oldPath": "junit-engine-api/src/main/java/org/junit/gen5/engine/TreeBasedTestEngine.java",
						"newPath": "junit-engine-api/src/main/java/org/junit/gen5/engine/HierarchicalTestEngine.java"
					}
				},
				{
					"type": "Ybodychange",
					"commitMessage": "Group discussion renaming results\n",
					"commitDate": "2015-12-10, 5:39 AM",
					"commitName": "3f9c11b9326b7d3051cb2a50568cd91113a0c0da",
					"commitAuthor": "Marc Philipp",
					"commitDateOld": "2015-12-09, 2:17 PM",
					"commitNameOld": "0e14ad4525a5ade99dacdd76d0ab27223f57ebd4",
					"commitAuthorOld": "Marc Philipp",
					"daysBetweenCommits": 0.64,
					"commitsBetweenForRepo": 1,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,24 +1,24 @@\n \tprivate <T> void executeAll(TestDescriptor parentDescriptor, EngineExecutionListener listener, C parentContext)\n \t\t\tthrows Exception {\n \t\tC context = parentContext;\n-\t\tif (parentDescriptor instanceof Parent) {\n-\t\t\tcontext = ((Parent<C>) parentDescriptor).beforeAll(context);\n+\t\tif (parentDescriptor instanceof Container) {\n+\t\t\tcontext = ((Container<C>) parentDescriptor).beforeAll(context);\n \t\t}\n \t\tfor (TestDescriptor childDescriptor : parentDescriptor.getChildren()) {\n-\t\t\tif (childDescriptor instanceof Child) {\n-\t\t\t\tChild<C> child = (Child<C>) childDescriptor;\n+\t\t\tif (childDescriptor instanceof Leaf) {\n+\t\t\t\tLeaf<C> child = (Leaf<C>) childDescriptor;\n \t\t\t\ttry {\n \t\t\t\t\tlistener.testStarted(childDescriptor);\n \t\t\t\t\tC childContext = child.execute(context);\n \t\t\t\t\tlistener.testSucceeded(childDescriptor);\n \t\t\t\t}\n \t\t\t\tcatch (Throwable t) {\n \t\t\t\t\tlistener.testFailed(childDescriptor, t);\n \t\t\t\t}\n \t\t\t}\n \t\t\texecuteAll(childDescriptor, listener, context);\n \t\t}\n-\t\tif (parentDescriptor instanceof Parent) {\n-\t\t\tcontext = ((Parent<C>) parentDescriptor).afterAll(context);\n+\t\tif (parentDescriptor instanceof Container) {\n+\t\t\tcontext = ((Container<C>) parentDescriptor).afterAll(context);\n \t\t}\n \t}\n\\ No newline at end of file\n",
					"extendedDetails": {}
				}
			]
		},
		"57b31220d25f59bb4aa4903dfee4b8ec2be4525e": {
			"type": "Ymultichange(Yparameterchange,Ybodychange)",
			"commitMessage": "TestEngine-specific context using type parameter\n",
			"commitDate": "2015-12-08, 5:55 AM",
			"commitName": "57b31220d25f59bb4aa4903dfee4b8ec2be4525e",
			"commitAuthor": "Marc Philipp",
			"subchanges": [
				{
					"type": "Yparameterchange",
					"commitMessage": "TestEngine-specific context using type parameter\n",
					"commitDate": "2015-12-08, 5:55 AM",
					"commitName": "57b31220d25f59bb4aa4903dfee4b8ec2be4525e",
					"commitAuthor": "Marc Philipp",
					"commitDateOld": "2015-12-08, 5:32 AM",
					"commitNameOld": "28ffd5ee9d1e996133445cac2256407f28380e91",
					"commitAuthorOld": "Marc Philipp",
					"daysBetweenCommits": 0.02,
					"commitsBetweenForRepo": 1,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,25 +1,24 @@\n-\tprivate <T> void executeAll(TestDescriptor parentDescriptor, EngineExecutionListener listener,\n-\t\t\tContext parentContext) throws Exception {\n-\t\tContext context = parentContext;\n+\tprivate <T> void executeAll(TestDescriptor parentDescriptor, EngineExecutionListener listener, C parentContext)\n+\t\t\tthrows Exception {\n+\t\tC context = parentContext;\n \t\tif (parentDescriptor instanceof Parent) {\n-\t\t\tcontext = ((Parent) parentDescriptor).beforeAll(context);\n+\t\t\tcontext = ((Parent<C>) parentDescriptor).beforeAll(context);\n \t\t}\n \t\tfor (TestDescriptor childDescriptor : parentDescriptor.getChildren()) {\n \t\t\tif (childDescriptor instanceof Child) {\n-\t\t\t\tChild child = (Child) childDescriptor;\n+\t\t\t\tChild<C> child = (Child<C>) childDescriptor;\n \t\t\t\ttry {\n \t\t\t\t\tlistener.testStarted(childDescriptor);\n-\t\t\t\t\tcontext = child.execute(context);\n+\t\t\t\t\tC childContext = child.execute(context);\n \t\t\t\t\tlistener.testSucceeded(childDescriptor);\n \t\t\t\t}\n \t\t\t\tcatch (Throwable t) {\n \t\t\t\t\tlistener.testFailed(childDescriptor, t);\n-\t\t\t\t\tcontext = context.with(\"Throwable\", t);\n \t\t\t\t}\n \t\t\t}\n \t\t\texecuteAll(childDescriptor, listener, context);\n \t\t}\n \t\tif (parentDescriptor instanceof Parent) {\n-\t\t\tcontext = ((Parent) parentDescriptor).afterAll(context);\n+\t\t\tcontext = ((Parent<C>) parentDescriptor).afterAll(context);\n \t\t}\n \t}\n\\ No newline at end of file\n",
					"extendedDetails": {
						"oldValue": "[parentDescriptor-TestDescriptor, listener-EngineExecutionListener, parentContext-Context]",
						"newValue": "[parentDescriptor-TestDescriptor, listener-EngineExecutionListener, parentContext-C]"
					}
				},
				{
					"type": "Ybodychange",
					"commitMessage": "TestEngine-specific context using type parameter\n",
					"commitDate": "2015-12-08, 5:55 AM",
					"commitName": "57b31220d25f59bb4aa4903dfee4b8ec2be4525e",
					"commitAuthor": "Marc Philipp",
					"commitDateOld": "2015-12-08, 5:32 AM",
					"commitNameOld": "28ffd5ee9d1e996133445cac2256407f28380e91",
					"commitAuthorOld": "Marc Philipp",
					"daysBetweenCommits": 0.02,
					"commitsBetweenForRepo": 1,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,25 +1,24 @@\n-\tprivate <T> void executeAll(TestDescriptor parentDescriptor, EngineExecutionListener listener,\n-\t\t\tContext parentContext) throws Exception {\n-\t\tContext context = parentContext;\n+\tprivate <T> void executeAll(TestDescriptor parentDescriptor, EngineExecutionListener listener, C parentContext)\n+\t\t\tthrows Exception {\n+\t\tC context = parentContext;\n \t\tif (parentDescriptor instanceof Parent) {\n-\t\t\tcontext = ((Parent) parentDescriptor).beforeAll(context);\n+\t\t\tcontext = ((Parent<C>) parentDescriptor).beforeAll(context);\n \t\t}\n \t\tfor (TestDescriptor childDescriptor : parentDescriptor.getChildren()) {\n \t\t\tif (childDescriptor instanceof Child) {\n-\t\t\t\tChild child = (Child) childDescriptor;\n+\t\t\t\tChild<C> child = (Child<C>) childDescriptor;\n \t\t\t\ttry {\n \t\t\t\t\tlistener.testStarted(childDescriptor);\n-\t\t\t\t\tcontext = child.execute(context);\n+\t\t\t\t\tC childContext = child.execute(context);\n \t\t\t\t\tlistener.testSucceeded(childDescriptor);\n \t\t\t\t}\n \t\t\t\tcatch (Throwable t) {\n \t\t\t\t\tlistener.testFailed(childDescriptor, t);\n-\t\t\t\t\tcontext = context.with(\"Throwable\", t);\n \t\t\t\t}\n \t\t\t}\n \t\t\texecuteAll(childDescriptor, listener, context);\n \t\t}\n \t\tif (parentDescriptor instanceof Parent) {\n-\t\t\tcontext = ((Parent) parentDescriptor).afterAll(context);\n+\t\t\tcontext = ((Parent<C>) parentDescriptor).afterAll(context);\n \t\t}\n \t}\n\\ No newline at end of file\n",
					"extendedDetails": {}
				}
			]
		},
		"28ffd5ee9d1e996133445cac2256407f28380e91": {
			"type": "Yintroduced",
			"commitMessage": "Spike tree-based \"implementation\" of JUnit5 engine\n",
			"commitDate": "2015-12-08, 5:32 AM",
			"commitName": "28ffd5ee9d1e996133445cac2256407f28380e91",
			"commitAuthor": "Marc Philipp",
			"diff": "@@ -0,0 +1,25 @@\n+\tprivate <T> void executeAll(TestDescriptor parentDescriptor, EngineExecutionListener listener,\n+\t\t\tContext parentContext) throws Exception {\n+\t\tContext context = parentContext;\n+\t\tif (parentDescriptor instanceof Parent) {\n+\t\t\tcontext = ((Parent) parentDescriptor).beforeAll(context);\n+\t\t}\n+\t\tfor (TestDescriptor childDescriptor : parentDescriptor.getChildren()) {\n+\t\t\tif (childDescriptor instanceof Child) {\n+\t\t\t\tChild child = (Child) childDescriptor;\n+\t\t\t\ttry {\n+\t\t\t\t\tlistener.testStarted(childDescriptor);\n+\t\t\t\t\tcontext = child.execute(context);\n+\t\t\t\t\tlistener.testSucceeded(childDescriptor);\n+\t\t\t\t}\n+\t\t\t\tcatch (Throwable t) {\n+\t\t\t\t\tlistener.testFailed(childDescriptor, t);\n+\t\t\t\t\tcontext = context.with(\"Throwable\", t);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\texecuteAll(childDescriptor, listener, context);\n+\t\t}\n+\t\tif (parentDescriptor instanceof Parent) {\n+\t\t\tcontext = ((Parent) parentDescriptor).afterAll(context);\n+\t\t}\n+\t}\n\\ No newline at end of file\n"
		}
	},
	"sha": "77cfe71e7f787c59626198e25350545f41e968bd"
}