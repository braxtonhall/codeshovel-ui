{
	"repo": "https://github.com/apache/commons-lang.git",
	"file": "src/main/java/org/apache/commons/lang3/time/DateUtils.java",
	"method": {
		"longName": "DateUtils::modify(Calendar val, int field, ModifyType modType)",
		"startLine": 958,
		"methodName": "modify",
		"isStatic": true,
		"isAbstract": false,
		"visibility": "private"
	},
	"history": {
		"b610707cd072f07efb816074a4844bb1b31e482c": {
			"type": "Ybodychange",
			"commitMessage": "removes unnecessary class reference of static method calls which are declared in the same class\n",
			"commitDate": "2018-06-20, 5:28 AM",
			"commitName": "b610707cd072f07efb816074a4844bb1b31e482c",
			"commitAuthor": "Igor Curdvanovschi",
			"commitDateOld": "2017-06-06, 2:14 PM",
			"commitNameOld": "309b34f0573d0ec593c17008e8ef4151dfc35a12",
			"commitAuthorOld": "Benedikt Ritter",
			"daysBetweenCommits": 378.63,
			"commitsBetweenForRepo": 213,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,139 +1,139 @@\n     private static void modify(final Calendar val, final int field, final ModifyType modType) {\n         if (val.get(Calendar.YEAR) > 280000000) {\n             throw new ArithmeticException(\"Calendar value too large for accurate calculations\");\n         }\n \n         if (field == Calendar.MILLISECOND) {\n             return;\n         }\n \n         // ----------------- Fix for LANG-59 ---------------------- START ---------------\n         // see http://issues.apache.org/jira/browse/LANG-59\n         //\n         // Manually truncate milliseconds, seconds and minutes, rather than using\n         // Calendar methods.\n \n         final Date date = val.getTime();\n         long time = date.getTime();\n         boolean done = false;\n \n         // truncate milliseconds\n         final int millisecs = val.get(Calendar.MILLISECOND);\n         if (ModifyType.TRUNCATE == modType || millisecs < 500) {\n             time = time - millisecs;\n         }\n         if (field == Calendar.SECOND) {\n             done = true;\n         }\n \n         // truncate seconds\n         final int seconds = val.get(Calendar.SECOND);\n         if (!done && (ModifyType.TRUNCATE == modType || seconds < 30)) {\n             time = time - (seconds * 1000L);\n         }\n         if (field == Calendar.MINUTE) {\n             done = true;\n         }\n \n         // truncate minutes\n         final int minutes = val.get(Calendar.MINUTE);\n         if (!done && (ModifyType.TRUNCATE == modType || minutes < 30)) {\n             time = time - (minutes * 60000L);\n         }\n \n         // reset time\n         if (date.getTime() != time) {\n             date.setTime(time);\n             val.setTime(date);\n         }\n         // ----------------- Fix for LANG-59 ----------------------- END ----------------\n \n         boolean roundUp = false;\n         for (final int[] aField : fields) {\n             for (final int element : aField) {\n                 if (element == field) {\n                     //This is our field... we stop looping\n                     if (modType == ModifyType.CEILING || modType == ModifyType.ROUND && roundUp) {\n-                        if (field == DateUtils.SEMI_MONTH) {\n+                        if (field == SEMI_MONTH) {\n                             //This is a special case that's hard to generalize\n                             //If the date is 1, we round up to 16, otherwise\n                             //  we subtract 15 days and add 1 month\n                             if (val.get(Calendar.DATE) == 1) {\n                                 val.add(Calendar.DATE, 15);\n                             } else {\n                                 val.add(Calendar.DATE, -15);\n                                 val.add(Calendar.MONTH, 1);\n                             }\n // ----------------- Fix for LANG-440 ---------------------- START ---------------\n                         } else if (field == Calendar.AM_PM) {\n                             // This is a special case\n                             // If the time is 0, we round up to 12, otherwise\n                             //  we subtract 12 hours and add 1 day\n                             if (val.get(Calendar.HOUR_OF_DAY) == 0) {\n                                 val.add(Calendar.HOUR_OF_DAY, 12);\n                             } else {\n                                 val.add(Calendar.HOUR_OF_DAY, -12);\n                                 val.add(Calendar.DATE, 1);\n                             }\n // ----------------- Fix for LANG-440 ---------------------- END ---------------\n                         } else {\n                             //We need at add one to this field since the\n                             //  last number causes us to round up\n                             val.add(aField[0], 1);\n                         }\n                     }\n                     return;\n                 }\n             }\n             //We have various fields that are not easy roundings\n             int offset = 0;\n             boolean offsetSet = false;\n             //These are special types of fields that require different rounding rules\n             switch (field) {\n-                case DateUtils.SEMI_MONTH:\n+                case SEMI_MONTH:\n                     if (aField[0] == Calendar.DATE) {\n                         //If we're going to drop the DATE field's value,\n                         //  we want to do this our own way.\n                         //We need to subtrace 1 since the date has a minimum of 1\n                         offset = val.get(Calendar.DATE) - 1;\n                         //If we're above 15 days adjustment, that means we're in the\n                         //  bottom half of the month and should stay accordingly.\n                         if (offset >= 15) {\n                             offset -= 15;\n                         }\n                         //Record whether we're in the top or bottom half of that range\n                         roundUp = offset > 7;\n                         offsetSet = true;\n                     }\n                     break;\n                 case Calendar.AM_PM:\n                     if (aField[0] == Calendar.HOUR_OF_DAY) {\n                         //If we're going to drop the HOUR field's value,\n                         //  we want to do this our own way.\n                         offset = val.get(Calendar.HOUR_OF_DAY);\n                         if (offset >= 12) {\n                             offset -= 12;\n                         }\n                         roundUp = offset >= 6;\n                         offsetSet = true;\n                     }\n                     break;\n                 default:\n                     break;\n             }\n             if (!offsetSet) {\n                 final int min = val.getActualMinimum(aField[0]);\n                 final int max = val.getActualMaximum(aField[0]);\n                 //Calculate the offset from the minimum allowed value\n                 offset = val.get(aField[0]) - min;\n                 //Set roundUp if this is more than half way between the minimum and maximum\n                 roundUp = offset > ((max - min) / 2);\n             }\n             //We need to remove this field\n             if (offset != 0) {\n                 val.set(aField[0], val.get(aField[0]) - offset);\n             }\n         }\n         throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n \n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"35f1cc00274122c0274b522d0b544a06faaba931": {
			"type": "Ybodychange",
			"commitMessage": "PMD: Useless parentheses\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@1671675 13f79535-47bb-0310-9956-ffa450edef68\n",
			"commitDate": "2015-04-06, 1:48 PM",
			"commitName": "35f1cc00274122c0274b522d0b544a06faaba931",
			"commitAuthor": "Benedikt Ritter",
			"commitDateOld": "2014-09-27, 11:33 AM",
			"commitNameOld": "2aae22de23bf47566700c0ca2671d25e30c4a857",
			"commitAuthorOld": "Duncan Jones",
			"daysBetweenCommits": 191.09,
			"commitsBetweenForRepo": 139,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,139 +1,139 @@\n     private static void modify(final Calendar val, final int field, final ModifyType modType) {\n         if (val.get(Calendar.YEAR) > 280000000) {\n             throw new ArithmeticException(\"Calendar value too large for accurate calculations\");\n         }\n         \n         if (field == Calendar.MILLISECOND) {\n             return;\n         }\n \n         // ----------------- Fix for LANG-59 ---------------------- START ---------------\n         // see http://issues.apache.org/jira/browse/LANG-59\n         //\n         // Manually truncate milliseconds, seconds and minutes, rather than using\n         // Calendar methods.\n \n         final Date date = val.getTime();\n         long time = date.getTime();\n         boolean done = false;\n \n         // truncate milliseconds\n         final int millisecs = val.get(Calendar.MILLISECOND);\n         if (ModifyType.TRUNCATE == modType || millisecs < 500) {\n             time = time - millisecs;\n         }\n         if (field == Calendar.SECOND) {\n             done = true;\n         }\n \n         // truncate seconds\n         final int seconds = val.get(Calendar.SECOND);\n         if (!done && (ModifyType.TRUNCATE == modType || seconds < 30)) {\n             time = time - (seconds * 1000L);\n         }\n         if (field == Calendar.MINUTE) {\n             done = true;\n         }\n \n         // truncate minutes\n         final int minutes = val.get(Calendar.MINUTE);\n         if (!done && (ModifyType.TRUNCATE == modType || minutes < 30)) {\n             time = time - (minutes * 60000L);\n         }\n \n         // reset time\n         if (date.getTime() != time) {\n             date.setTime(time);\n             val.setTime(date);\n         }\n         // ----------------- Fix for LANG-59 ----------------------- END ----------------\n \n         boolean roundUp = false;\n         for (final int[] aField : fields) {\n             for (final int element : aField) {\n                 if (element == field) {\n                     //This is our field... we stop looping\n-                    if (modType == ModifyType.CEILING || (modType == ModifyType.ROUND && roundUp)) {\n+                    if (modType == ModifyType.CEILING || modType == ModifyType.ROUND && roundUp) {\n                         if (field == DateUtils.SEMI_MONTH) {\n                             //This is a special case that's hard to generalize\n                             //If the date is 1, we round up to 16, otherwise\n                             //  we subtract 15 days and add 1 month\n                             if (val.get(Calendar.DATE) == 1) {\n                                 val.add(Calendar.DATE, 15);\n                             } else {\n                                 val.add(Calendar.DATE, -15);\n                                 val.add(Calendar.MONTH, 1);\n                             }\n // ----------------- Fix for LANG-440 ---------------------- START ---------------\n                         } else if (field == Calendar.AM_PM) {\n                             // This is a special case\n                             // If the time is 0, we round up to 12, otherwise\n                             //  we subtract 12 hours and add 1 day\n                             if (val.get(Calendar.HOUR_OF_DAY) == 0) {\n                                 val.add(Calendar.HOUR_OF_DAY, 12);\n                             } else {\n                                 val.add(Calendar.HOUR_OF_DAY, -12);\n                                 val.add(Calendar.DATE, 1);\n                             }\n // ----------------- Fix for LANG-440 ---------------------- END ---------------\n                         } else {\n                             //We need at add one to this field since the\n                             //  last number causes us to round up\n                             val.add(aField[0], 1);\n                         }\n                     }\n                     return;\n                 }\n             }\n             //We have various fields that are not easy roundings\n             int offset = 0;\n             boolean offsetSet = false;\n             //These are special types of fields that require different rounding rules\n             switch (field) {\n                 case DateUtils.SEMI_MONTH:\n                     if (aField[0] == Calendar.DATE) {\n                         //If we're going to drop the DATE field's value,\n                         //  we want to do this our own way.\n                         //We need to subtrace 1 since the date has a minimum of 1\n                         offset = val.get(Calendar.DATE) - 1;\n                         //If we're above 15 days adjustment, that means we're in the\n                         //  bottom half of the month and should stay accordingly.\n                         if (offset >= 15) {\n                             offset -= 15;\n                         }\n                         //Record whether we're in the top or bottom half of that range\n                         roundUp = offset > 7;\n                         offsetSet = true;\n                     }\n                     break;\n                 case Calendar.AM_PM:\n                     if (aField[0] == Calendar.HOUR_OF_DAY) {\n                         //If we're going to drop the HOUR field's value,\n                         //  we want to do this our own way.\n                         offset = val.get(Calendar.HOUR_OF_DAY);\n                         if (offset >= 12) {\n                             offset -= 12;\n                         }\n                         roundUp = offset >= 6;\n                         offsetSet = true;\n                     }\n                     break;\n                 default:\n                     break;\n             }\n             if (!offsetSet) {\n                 final int min = val.getActualMinimum(aField[0]);\n                 final int max = val.getActualMaximum(aField[0]);\n                 //Calculate the offset from the minimum allowed value\n                 offset = val.get(aField[0]) - min;\n                 //Set roundUp if this is more than half way between the minimum and maximum\n                 roundUp = offset > ((max - min) / 2);\n             }\n             //We need to remove this field\n             if (offset != 0) {\n                 val.set(aField[0], val.get(aField[0]) - offset);\n             }\n         }\n         throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n \n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"52e854e3bda9f1b92471884888f430345f73eca2": {
			"type": "Ymultichange(Yparameterchange,Ybodychange)",
			"commitMessage": "Replaced private integer constants with private static enum.\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@1627974 13f79535-47bb-0310-9956-ffa450edef68\n",
			"commitDate": "2014-09-27, 9:03 AM",
			"commitName": "52e854e3bda9f1b92471884888f430345f73eca2",
			"commitAuthor": "Duncan Jones",
			"subchanges": [
				{
					"type": "Yparameterchange",
					"commitMessage": "Replaced private integer constants with private static enum.\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@1627974 13f79535-47bb-0310-9956-ffa450edef68\n",
					"commitDate": "2014-09-27, 9:03 AM",
					"commitName": "52e854e3bda9f1b92471884888f430345f73eca2",
					"commitAuthor": "Duncan Jones",
					"commitDateOld": "2014-09-26, 5:19 AM",
					"commitNameOld": "bdb1a684a7b3876d6812d4e281c852face5a5229",
					"commitAuthorOld": "Duncan Jones",
					"daysBetweenCommits": 1.16,
					"commitsBetweenForRepo": 2,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,139 +1,139 @@\n-    private static void modify(final Calendar val, final int field, final int modType) {\n+    private static void modify(final Calendar val, final int field, final ModifyType modType) {\n         if (val.get(Calendar.YEAR) > 280000000) {\n             throw new ArithmeticException(\"Calendar value too large for accurate calculations\");\n         }\n         \n         if (field == Calendar.MILLISECOND) {\n             return;\n         }\n \n         // ----------------- Fix for LANG-59 ---------------------- START ---------------\n         // see http://issues.apache.org/jira/browse/LANG-59\n         //\n         // Manually truncate milliseconds, seconds and minutes, rather than using\n         // Calendar methods.\n \n         final Date date = val.getTime();\n         long time = date.getTime();\n         boolean done = false;\n \n         // truncate milliseconds\n         final int millisecs = val.get(Calendar.MILLISECOND);\n-        if (MODIFY_TRUNCATE == modType || millisecs < 500) {\n+        if (ModifyType.TRUNCATE == modType || millisecs < 500) {\n             time = time - millisecs;\n         }\n         if (field == Calendar.SECOND) {\n             done = true;\n         }\n \n         // truncate seconds\n         final int seconds = val.get(Calendar.SECOND);\n-        if (!done && (MODIFY_TRUNCATE == modType || seconds < 30)) {\n+        if (!done && (ModifyType.TRUNCATE == modType || seconds < 30)) {\n             time = time - (seconds * 1000L);\n         }\n         if (field == Calendar.MINUTE) {\n             done = true;\n         }\n \n         // truncate minutes\n         final int minutes = val.get(Calendar.MINUTE);\n-        if (!done && (MODIFY_TRUNCATE == modType || minutes < 30)) {\n+        if (!done && (ModifyType.TRUNCATE == modType || minutes < 30)) {\n             time = time - (minutes * 60000L);\n         }\n \n         // reset time\n         if (date.getTime() != time) {\n             date.setTime(time);\n             val.setTime(date);\n         }\n         // ----------------- Fix for LANG-59 ----------------------- END ----------------\n \n         boolean roundUp = false;\n         for (final int[] aField : fields) {\n             for (final int element : aField) {\n                 if (element == field) {\n                     //This is our field... we stop looping\n-                    if (modType == MODIFY_CEILING || (modType == MODIFY_ROUND && roundUp)) {\n+                    if (modType == ModifyType.CEILING || (modType == ModifyType.ROUND && roundUp)) {\n                         if (field == DateUtils.SEMI_MONTH) {\n                             //This is a special case that's hard to generalize\n                             //If the date is 1, we round up to 16, otherwise\n                             //  we subtract 15 days and add 1 month\n                             if (val.get(Calendar.DATE) == 1) {\n                                 val.add(Calendar.DATE, 15);\n                             } else {\n                                 val.add(Calendar.DATE, -15);\n                                 val.add(Calendar.MONTH, 1);\n                             }\n // ----------------- Fix for LANG-440 ---------------------- START ---------------\n                         } else if (field == Calendar.AM_PM) {\n                             // This is a special case\n                             // If the time is 0, we round up to 12, otherwise\n                             //  we subtract 12 hours and add 1 day\n                             if (val.get(Calendar.HOUR_OF_DAY) == 0) {\n                                 val.add(Calendar.HOUR_OF_DAY, 12);\n                             } else {\n                                 val.add(Calendar.HOUR_OF_DAY, -12);\n                                 val.add(Calendar.DATE, 1);\n                             }\n // ----------------- Fix for LANG-440 ---------------------- END ---------------\n                         } else {\n                             //We need at add one to this field since the\n                             //  last number causes us to round up\n                             val.add(aField[0], 1);\n                         }\n                     }\n                     return;\n                 }\n             }\n             //We have various fields that are not easy roundings\n             int offset = 0;\n             boolean offsetSet = false;\n             //These are special types of fields that require different rounding rules\n             switch (field) {\n                 case DateUtils.SEMI_MONTH:\n                     if (aField[0] == Calendar.DATE) {\n                         //If we're going to drop the DATE field's value,\n                         //  we want to do this our own way.\n                         //We need to subtrace 1 since the date has a minimum of 1\n                         offset = val.get(Calendar.DATE) - 1;\n                         //If we're above 15 days adjustment, that means we're in the\n                         //  bottom half of the month and should stay accordingly.\n                         if (offset >= 15) {\n                             offset -= 15;\n                         }\n                         //Record whether we're in the top or bottom half of that range\n                         roundUp = offset > 7;\n                         offsetSet = true;\n                     }\n                     break;\n                 case Calendar.AM_PM:\n                     if (aField[0] == Calendar.HOUR_OF_DAY) {\n                         //If we're going to drop the HOUR field's value,\n                         //  we want to do this our own way.\n                         offset = val.get(Calendar.HOUR_OF_DAY);\n                         if (offset >= 12) {\n                             offset -= 12;\n                         }\n                         roundUp = offset >= 6;\n                         offsetSet = true;\n                     }\n                     break;\n                 default:\n                     break;\n             }\n             if (!offsetSet) {\n                 final int min = val.getActualMinimum(aField[0]);\n                 final int max = val.getActualMaximum(aField[0]);\n                 //Calculate the offset from the minimum allowed value\n                 offset = val.get(aField[0]) - min;\n                 //Set roundUp if this is more than half way between the minimum and maximum\n                 roundUp = offset > ((max - min) / 2);\n             }\n             //We need to remove this field\n             if (offset != 0) {\n                 val.set(aField[0], val.get(aField[0]) - offset);\n             }\n         }\n         throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n \n     }\n\\ No newline at end of file\n",
					"extendedDetails": {
						"oldValue": "[val-Calendar(modifiers-final), field-int(modifiers-final), modType-int(modifiers-final)]",
						"newValue": "[val-Calendar(modifiers-final), field-int(modifiers-final), modType-ModifyType(modifiers-final)]"
					}
				},
				{
					"type": "Ybodychange",
					"commitMessage": "Replaced private integer constants with private static enum.\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@1627974 13f79535-47bb-0310-9956-ffa450edef68\n",
					"commitDate": "2014-09-27, 9:03 AM",
					"commitName": "52e854e3bda9f1b92471884888f430345f73eca2",
					"commitAuthor": "Duncan Jones",
					"commitDateOld": "2014-09-26, 5:19 AM",
					"commitNameOld": "bdb1a684a7b3876d6812d4e281c852face5a5229",
					"commitAuthorOld": "Duncan Jones",
					"daysBetweenCommits": 1.16,
					"commitsBetweenForRepo": 2,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,139 +1,139 @@\n-    private static void modify(final Calendar val, final int field, final int modType) {\n+    private static void modify(final Calendar val, final int field, final ModifyType modType) {\n         if (val.get(Calendar.YEAR) > 280000000) {\n             throw new ArithmeticException(\"Calendar value too large for accurate calculations\");\n         }\n         \n         if (field == Calendar.MILLISECOND) {\n             return;\n         }\n \n         // ----------------- Fix for LANG-59 ---------------------- START ---------------\n         // see http://issues.apache.org/jira/browse/LANG-59\n         //\n         // Manually truncate milliseconds, seconds and minutes, rather than using\n         // Calendar methods.\n \n         final Date date = val.getTime();\n         long time = date.getTime();\n         boolean done = false;\n \n         // truncate milliseconds\n         final int millisecs = val.get(Calendar.MILLISECOND);\n-        if (MODIFY_TRUNCATE == modType || millisecs < 500) {\n+        if (ModifyType.TRUNCATE == modType || millisecs < 500) {\n             time = time - millisecs;\n         }\n         if (field == Calendar.SECOND) {\n             done = true;\n         }\n \n         // truncate seconds\n         final int seconds = val.get(Calendar.SECOND);\n-        if (!done && (MODIFY_TRUNCATE == modType || seconds < 30)) {\n+        if (!done && (ModifyType.TRUNCATE == modType || seconds < 30)) {\n             time = time - (seconds * 1000L);\n         }\n         if (field == Calendar.MINUTE) {\n             done = true;\n         }\n \n         // truncate minutes\n         final int minutes = val.get(Calendar.MINUTE);\n-        if (!done && (MODIFY_TRUNCATE == modType || minutes < 30)) {\n+        if (!done && (ModifyType.TRUNCATE == modType || minutes < 30)) {\n             time = time - (minutes * 60000L);\n         }\n \n         // reset time\n         if (date.getTime() != time) {\n             date.setTime(time);\n             val.setTime(date);\n         }\n         // ----------------- Fix for LANG-59 ----------------------- END ----------------\n \n         boolean roundUp = false;\n         for (final int[] aField : fields) {\n             for (final int element : aField) {\n                 if (element == field) {\n                     //This is our field... we stop looping\n-                    if (modType == MODIFY_CEILING || (modType == MODIFY_ROUND && roundUp)) {\n+                    if (modType == ModifyType.CEILING || (modType == ModifyType.ROUND && roundUp)) {\n                         if (field == DateUtils.SEMI_MONTH) {\n                             //This is a special case that's hard to generalize\n                             //If the date is 1, we round up to 16, otherwise\n                             //  we subtract 15 days and add 1 month\n                             if (val.get(Calendar.DATE) == 1) {\n                                 val.add(Calendar.DATE, 15);\n                             } else {\n                                 val.add(Calendar.DATE, -15);\n                                 val.add(Calendar.MONTH, 1);\n                             }\n // ----------------- Fix for LANG-440 ---------------------- START ---------------\n                         } else if (field == Calendar.AM_PM) {\n                             // This is a special case\n                             // If the time is 0, we round up to 12, otherwise\n                             //  we subtract 12 hours and add 1 day\n                             if (val.get(Calendar.HOUR_OF_DAY) == 0) {\n                                 val.add(Calendar.HOUR_OF_DAY, 12);\n                             } else {\n                                 val.add(Calendar.HOUR_OF_DAY, -12);\n                                 val.add(Calendar.DATE, 1);\n                             }\n // ----------------- Fix for LANG-440 ---------------------- END ---------------\n                         } else {\n                             //We need at add one to this field since the\n                             //  last number causes us to round up\n                             val.add(aField[0], 1);\n                         }\n                     }\n                     return;\n                 }\n             }\n             //We have various fields that are not easy roundings\n             int offset = 0;\n             boolean offsetSet = false;\n             //These are special types of fields that require different rounding rules\n             switch (field) {\n                 case DateUtils.SEMI_MONTH:\n                     if (aField[0] == Calendar.DATE) {\n                         //If we're going to drop the DATE field's value,\n                         //  we want to do this our own way.\n                         //We need to subtrace 1 since the date has a minimum of 1\n                         offset = val.get(Calendar.DATE) - 1;\n                         //If we're above 15 days adjustment, that means we're in the\n                         //  bottom half of the month and should stay accordingly.\n                         if (offset >= 15) {\n                             offset -= 15;\n                         }\n                         //Record whether we're in the top or bottom half of that range\n                         roundUp = offset > 7;\n                         offsetSet = true;\n                     }\n                     break;\n                 case Calendar.AM_PM:\n                     if (aField[0] == Calendar.HOUR_OF_DAY) {\n                         //If we're going to drop the HOUR field's value,\n                         //  we want to do this our own way.\n                         offset = val.get(Calendar.HOUR_OF_DAY);\n                         if (offset >= 12) {\n                             offset -= 12;\n                         }\n                         roundUp = offset >= 6;\n                         offsetSet = true;\n                     }\n                     break;\n                 default:\n                     break;\n             }\n             if (!offsetSet) {\n                 final int min = val.getActualMinimum(aField[0]);\n                 final int max = val.getActualMaximum(aField[0]);\n                 //Calculate the offset from the minimum allowed value\n                 offset = val.get(aField[0]) - min;\n                 //Set roundUp if this is more than half way between the minimum and maximum\n                 roundUp = offset > ((max - min) / 2);\n             }\n             //We need to remove this field\n             if (offset != 0) {\n                 val.set(aField[0], val.get(aField[0]) - offset);\n             }\n         }\n         throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n \n     }\n\\ No newline at end of file\n",
					"extendedDetails": {}
				}
			]
		},
		"d6a556dad71a7d785b9c40608d0bf56062b134a5": {
			"type": "Ybodychange",
			"commitMessage": "Add explict default case\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@1565257 13f79535-47bb-0310-9956-ffa450edef68\n",
			"commitDate": "2014-02-06, 6:51 AM",
			"commitName": "d6a556dad71a7d785b9c40608d0bf56062b134a5",
			"commitAuthor": "Sebastian Bazley",
			"commitDateOld": "2014-01-20, 10:19 AM",
			"commitNameOld": "0942ef04f1fa911d382b79a92dca1dd4b3eb88e6",
			"commitAuthorOld": "Benedikt Ritter",
			"daysBetweenCommits": 16.86,
			"commitsBetweenForRepo": 69,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,137 +1,139 @@\n     private static void modify(final Calendar val, final int field, final int modType) {\n         if (val.get(Calendar.YEAR) > 280000000) {\n             throw new ArithmeticException(\"Calendar value too large for accurate calculations\");\n         }\n         \n         if (field == Calendar.MILLISECOND) {\n             return;\n         }\n \n         // ----------------- Fix for LANG-59 ---------------------- START ---------------\n         // see http://issues.apache.org/jira/browse/LANG-59\n         //\n         // Manually truncate milliseconds, seconds and minutes, rather than using\n         // Calendar methods.\n \n         final Date date = val.getTime();\n         long time = date.getTime();\n         boolean done = false;\n \n         // truncate milliseconds\n         final int millisecs = val.get(Calendar.MILLISECOND);\n         if (MODIFY_TRUNCATE == modType || millisecs < 500) {\n             time = time - millisecs;\n         }\n         if (field == Calendar.SECOND) {\n             done = true;\n         }\n \n         // truncate seconds\n         final int seconds = val.get(Calendar.SECOND);\n         if (!done && (MODIFY_TRUNCATE == modType || seconds < 30)) {\n             time = time - (seconds * 1000L);\n         }\n         if (field == Calendar.MINUTE) {\n             done = true;\n         }\n \n         // truncate minutes\n         final int minutes = val.get(Calendar.MINUTE);\n         if (!done && (MODIFY_TRUNCATE == modType || minutes < 30)) {\n             time = time - (minutes * 60000L);\n         }\n \n         // reset time\n         if (date.getTime() != time) {\n             date.setTime(time);\n             val.setTime(date);\n         }\n         // ----------------- Fix for LANG-59 ----------------------- END ----------------\n \n         boolean roundUp = false;\n         for (final int[] aField : fields) {\n             for (final int element : aField) {\n                 if (element == field) {\n                     //This is our field... we stop looping\n                     if (modType == MODIFY_CEILING || (modType == MODIFY_ROUND && roundUp)) {\n                         if (field == DateUtils.SEMI_MONTH) {\n                             //This is a special case that's hard to generalize\n                             //If the date is 1, we round up to 16, otherwise\n                             //  we subtract 15 days and add 1 month\n                             if (val.get(Calendar.DATE) == 1) {\n                                 val.add(Calendar.DATE, 15);\n                             } else {\n                                 val.add(Calendar.DATE, -15);\n                                 val.add(Calendar.MONTH, 1);\n                             }\n // ----------------- Fix for LANG-440 ---------------------- START ---------------\n                         } else if (field == Calendar.AM_PM) {\n                             // This is a special case\n                             // If the time is 0, we round up to 12, otherwise\n                             //  we subtract 12 hours and add 1 day\n                             if (val.get(Calendar.HOUR_OF_DAY) == 0) {\n                                 val.add(Calendar.HOUR_OF_DAY, 12);\n                             } else {\n                                 val.add(Calendar.HOUR_OF_DAY, -12);\n                                 val.add(Calendar.DATE, 1);\n                             }\n // ----------------- Fix for LANG-440 ---------------------- END ---------------\n                         } else {\n                             //We need at add one to this field since the\n                             //  last number causes us to round up\n                             val.add(aField[0], 1);\n                         }\n                     }\n                     return;\n                 }\n             }\n             //We have various fields that are not easy roundings\n             int offset = 0;\n             boolean offsetSet = false;\n             //These are special types of fields that require different rounding rules\n             switch (field) {\n                 case DateUtils.SEMI_MONTH:\n                     if (aField[0] == Calendar.DATE) {\n                         //If we're going to drop the DATE field's value,\n                         //  we want to do this our own way.\n                         //We need to subtrace 1 since the date has a minimum of 1\n                         offset = val.get(Calendar.DATE) - 1;\n                         //If we're above 15 days adjustment, that means we're in the\n                         //  bottom half of the month and should stay accordingly.\n                         if (offset >= 15) {\n                             offset -= 15;\n                         }\n                         //Record whether we're in the top or bottom half of that range\n                         roundUp = offset > 7;\n                         offsetSet = true;\n                     }\n                     break;\n                 case Calendar.AM_PM:\n                     if (aField[0] == Calendar.HOUR_OF_DAY) {\n                         //If we're going to drop the HOUR field's value,\n                         //  we want to do this our own way.\n                         offset = val.get(Calendar.HOUR_OF_DAY);\n                         if (offset >= 12) {\n                             offset -= 12;\n                         }\n                         roundUp = offset >= 6;\n                         offsetSet = true;\n                     }\n                     break;\n+                default:\n+                    break;\n             }\n             if (!offsetSet) {\n                 final int min = val.getActualMinimum(aField[0]);\n                 final int max = val.getActualMaximum(aField[0]);\n                 //Calculate the offset from the minimum allowed value\n                 offset = val.get(aField[0]) - min;\n                 //Set roundUp if this is more than half way between the minimum and maximum\n                 roundUp = offset > ((max - min) / 2);\n             }\n             //We need to remove this field\n             if (offset != 0) {\n                 val.set(aField[0], val.get(aField[0]) - offset);\n             }\n         }\n         throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n \n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"5292526e476ffbb19c6613a98464054236c86ace": {
			"type": "Ybodychange",
			"commitMessage": "Add final modifier to local variables.\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@1436770 13f79535-47bb-0310-9956-ffa450edef68\n",
			"commitDate": "2013-01-22, 12:09 AM",
			"commitName": "5292526e476ffbb19c6613a98464054236c86ace",
			"commitAuthor": "Gary D. Gregory",
			"commitDateOld": "2013-01-22, 12:07 AM",
			"commitNameOld": "5bd622dab027ef37001a630a7c825c5b8c19d1db",
			"commitAuthorOld": "Gary D. Gregory",
			"daysBetweenCommits": 0,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,137 +1,137 @@\n     private static void modify(final Calendar val, final int field, final int modType) {\n         if (val.get(Calendar.YEAR) > 280000000) {\n             throw new ArithmeticException(\"Calendar value too large for accurate calculations\");\n         }\n         \n         if (field == Calendar.MILLISECOND) {\n             return;\n         }\n \n         // ----------------- Fix for LANG-59 ---------------------- START ---------------\n         // see http://issues.apache.org/jira/browse/LANG-59\n         //\n         // Manually truncate milliseconds, seconds and minutes, rather than using\n         // Calendar methods.\n \n-        Date date = val.getTime();\n+        final Date date = val.getTime();\n         long time = date.getTime();\n         boolean done = false;\n \n         // truncate milliseconds\n-        int millisecs = val.get(Calendar.MILLISECOND);\n+        final int millisecs = val.get(Calendar.MILLISECOND);\n         if (MODIFY_TRUNCATE == modType || millisecs < 500) {\n             time = time - millisecs;\n         }\n         if (field == Calendar.SECOND) {\n             done = true;\n         }\n \n         // truncate seconds\n-        int seconds = val.get(Calendar.SECOND);\n+        final int seconds = val.get(Calendar.SECOND);\n         if (!done && (MODIFY_TRUNCATE == modType || seconds < 30)) {\n             time = time - (seconds * 1000L);\n         }\n         if (field == Calendar.MINUTE) {\n             done = true;\n         }\n \n         // truncate minutes\n-        int minutes = val.get(Calendar.MINUTE);\n+        final int minutes = val.get(Calendar.MINUTE);\n         if (!done && (MODIFY_TRUNCATE == modType || minutes < 30)) {\n             time = time - (minutes * 60000L);\n         }\n \n         // reset time\n         if (date.getTime() != time) {\n             date.setTime(time);\n             val.setTime(date);\n         }\n         // ----------------- Fix for LANG-59 ----------------------- END ----------------\n \n         boolean roundUp = false;\n-        for (int[] aField : fields) {\n-            for (int element : aField) {\n+        for (final int[] aField : fields) {\n+            for (final int element : aField) {\n                 if (element == field) {\n                     //This is our field... we stop looping\n                     if (modType == MODIFY_CEILING || (modType == MODIFY_ROUND && roundUp)) {\n                         if (field == DateUtils.SEMI_MONTH) {\n                             //This is a special case that's hard to generalize\n                             //If the date is 1, we round up to 16, otherwise\n                             //  we subtract 15 days and add 1 month\n                             if (val.get(Calendar.DATE) == 1) {\n                                 val.add(Calendar.DATE, 15);\n                             } else {\n                                 val.add(Calendar.DATE, -15);\n                                 val.add(Calendar.MONTH, 1);\n                             }\n // ----------------- Fix for LANG-440 ---------------------- START ---------------\n                         } else if (field == Calendar.AM_PM) {\n                             // This is a special case\n                             // If the time is 0, we round up to 12, otherwise\n                             //  we subtract 12 hours and add 1 day\n                             if (val.get(Calendar.HOUR_OF_DAY) == 0) {\n                                 val.add(Calendar.HOUR_OF_DAY, 12);\n                             } else {\n                                 val.add(Calendar.HOUR_OF_DAY, -12);\n                                 val.add(Calendar.DATE, 1);\n                             }\n // ----------------- Fix for LANG-440 ---------------------- END ---------------\n                         } else {\n                             //We need at add one to this field since the\n                             //  last number causes us to round up\n                             val.add(aField[0], 1);\n                         }\n                     }\n                     return;\n                 }\n             }\n             //We have various fields that are not easy roundings\n             int offset = 0;\n             boolean offsetSet = false;\n             //These are special types of fields that require different rounding rules\n             switch (field) {\n                 case DateUtils.SEMI_MONTH:\n                     if (aField[0] == Calendar.DATE) {\n                         //If we're going to drop the DATE field's value,\n                         //  we want to do this our own way.\n                         //We need to subtrace 1 since the date has a minimum of 1\n                         offset = val.get(Calendar.DATE) - 1;\n                         //If we're above 15 days adjustment, that means we're in the\n                         //  bottom half of the month and should stay accordingly.\n                         if (offset >= 15) {\n                             offset -= 15;\n                         }\n                         //Record whether we're in the top or bottom half of that range\n                         roundUp = offset > 7;\n                         offsetSet = true;\n                     }\n                     break;\n                 case Calendar.AM_PM:\n                     if (aField[0] == Calendar.HOUR_OF_DAY) {\n                         //If we're going to drop the HOUR field's value,\n                         //  we want to do this our own way.\n                         offset = val.get(Calendar.HOUR_OF_DAY);\n                         if (offset >= 12) {\n                             offset -= 12;\n                         }\n                         roundUp = offset >= 6;\n                         offsetSet = true;\n                     }\n                     break;\n             }\n             if (!offsetSet) {\n-                int min = val.getActualMinimum(aField[0]);\n-                int max = val.getActualMaximum(aField[0]);\n+                final int min = val.getActualMinimum(aField[0]);\n+                final int max = val.getActualMaximum(aField[0]);\n                 //Calculate the offset from the minimum allowed value\n                 offset = val.get(aField[0]) - min;\n                 //Set roundUp if this is more than half way between the minimum and maximum\n                 roundUp = offset > ((max - min) / 2);\n             }\n             //We need to remove this field\n             if (offset != 0) {\n                 val.set(aField[0], val.get(aField[0]) - offset);\n             }\n         }\n         throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n \n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"5bd622dab027ef37001a630a7c825c5b8c19d1db": {
			"type": "Yparametermetachange",
			"commitMessage": "Add final modifier to method parameters.\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@1436768 13f79535-47bb-0310-9956-ffa450edef68\n",
			"commitDate": "2013-01-22, 12:07 AM",
			"commitName": "5bd622dab027ef37001a630a7c825c5b8c19d1db",
			"commitAuthor": "Gary D. Gregory",
			"commitDateOld": "2012-09-22, 7:22 AM",
			"commitNameOld": "ebdef1b95710b44324d40fa1e67a1bc1b370ee81",
			"commitAuthorOld": "Sebastian Bazley",
			"daysBetweenCommits": 121.74,
			"commitsBetweenForRepo": 124,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,137 +1,137 @@\n-    private static void modify(Calendar val, int field, int modType) {\n+    private static void modify(final Calendar val, final int field, final int modType) {\n         if (val.get(Calendar.YEAR) > 280000000) {\n             throw new ArithmeticException(\"Calendar value too large for accurate calculations\");\n         }\n         \n         if (field == Calendar.MILLISECOND) {\n             return;\n         }\n \n         // ----------------- Fix for LANG-59 ---------------------- START ---------------\n         // see http://issues.apache.org/jira/browse/LANG-59\n         //\n         // Manually truncate milliseconds, seconds and minutes, rather than using\n         // Calendar methods.\n \n         Date date = val.getTime();\n         long time = date.getTime();\n         boolean done = false;\n \n         // truncate milliseconds\n         int millisecs = val.get(Calendar.MILLISECOND);\n         if (MODIFY_TRUNCATE == modType || millisecs < 500) {\n             time = time - millisecs;\n         }\n         if (field == Calendar.SECOND) {\n             done = true;\n         }\n \n         // truncate seconds\n         int seconds = val.get(Calendar.SECOND);\n         if (!done && (MODIFY_TRUNCATE == modType || seconds < 30)) {\n             time = time - (seconds * 1000L);\n         }\n         if (field == Calendar.MINUTE) {\n             done = true;\n         }\n \n         // truncate minutes\n         int minutes = val.get(Calendar.MINUTE);\n         if (!done && (MODIFY_TRUNCATE == modType || minutes < 30)) {\n             time = time - (minutes * 60000L);\n         }\n \n         // reset time\n         if (date.getTime() != time) {\n             date.setTime(time);\n             val.setTime(date);\n         }\n         // ----------------- Fix for LANG-59 ----------------------- END ----------------\n \n         boolean roundUp = false;\n         for (int[] aField : fields) {\n             for (int element : aField) {\n                 if (element == field) {\n                     //This is our field... we stop looping\n                     if (modType == MODIFY_CEILING || (modType == MODIFY_ROUND && roundUp)) {\n                         if (field == DateUtils.SEMI_MONTH) {\n                             //This is a special case that's hard to generalize\n                             //If the date is 1, we round up to 16, otherwise\n                             //  we subtract 15 days and add 1 month\n                             if (val.get(Calendar.DATE) == 1) {\n                                 val.add(Calendar.DATE, 15);\n                             } else {\n                                 val.add(Calendar.DATE, -15);\n                                 val.add(Calendar.MONTH, 1);\n                             }\n // ----------------- Fix for LANG-440 ---------------------- START ---------------\n                         } else if (field == Calendar.AM_PM) {\n                             // This is a special case\n                             // If the time is 0, we round up to 12, otherwise\n                             //  we subtract 12 hours and add 1 day\n                             if (val.get(Calendar.HOUR_OF_DAY) == 0) {\n                                 val.add(Calendar.HOUR_OF_DAY, 12);\n                             } else {\n                                 val.add(Calendar.HOUR_OF_DAY, -12);\n                                 val.add(Calendar.DATE, 1);\n                             }\n // ----------------- Fix for LANG-440 ---------------------- END ---------------\n                         } else {\n                             //We need at add one to this field since the\n                             //  last number causes us to round up\n                             val.add(aField[0], 1);\n                         }\n                     }\n                     return;\n                 }\n             }\n             //We have various fields that are not easy roundings\n             int offset = 0;\n             boolean offsetSet = false;\n             //These are special types of fields that require different rounding rules\n             switch (field) {\n                 case DateUtils.SEMI_MONTH:\n                     if (aField[0] == Calendar.DATE) {\n                         //If we're going to drop the DATE field's value,\n                         //  we want to do this our own way.\n                         //We need to subtrace 1 since the date has a minimum of 1\n                         offset = val.get(Calendar.DATE) - 1;\n                         //If we're above 15 days adjustment, that means we're in the\n                         //  bottom half of the month and should stay accordingly.\n                         if (offset >= 15) {\n                             offset -= 15;\n                         }\n                         //Record whether we're in the top or bottom half of that range\n                         roundUp = offset > 7;\n                         offsetSet = true;\n                     }\n                     break;\n                 case Calendar.AM_PM:\n                     if (aField[0] == Calendar.HOUR_OF_DAY) {\n                         //If we're going to drop the HOUR field's value,\n                         //  we want to do this our own way.\n                         offset = val.get(Calendar.HOUR_OF_DAY);\n                         if (offset >= 12) {\n                             offset -= 12;\n                         }\n                         roundUp = offset >= 6;\n                         offsetSet = true;\n                     }\n                     break;\n             }\n             if (!offsetSet) {\n                 int min = val.getActualMinimum(aField[0]);\n                 int max = val.getActualMaximum(aField[0]);\n                 //Calculate the offset from the minimum allowed value\n                 offset = val.get(aField[0]) - min;\n                 //Set roundUp if this is more than half way between the minimum and maximum\n                 roundUp = offset > ((max - min) / 2);\n             }\n             //We need to remove this field\n             if (offset != 0) {\n                 val.set(aField[0], val.get(aField[0]) - offset);\n             }\n         }\n         throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n \n     }\n\\ No newline at end of file\n",
			"extendedDetails": {
				"oldValue": "[val-Calendar, field-int, modType-int]",
				"newValue": "[val-Calendar(modifiers-final), field-int(modifiers-final), modType-int(modifiers-final)]"
			}
		},
		"14373ad1b11e5dc3a26457647ddee4e8ada97430": {
			"type": "Ybodychange",
			"commitMessage": "Convert to Java 5 enhanced for loops. \n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@1144992 13f79535-47bb-0310-9956-ffa450edef68\n",
			"commitDate": "2011-07-10, 6:49 PM",
			"commitName": "14373ad1b11e5dc3a26457647ddee4e8ada97430",
			"commitAuthor": "Gary D. Gregory",
			"commitDateOld": "2011-07-10, 12:26 PM",
			"commitNameOld": "fab64bbdc726cf06c5993b7b8f50557882086002",
			"commitAuthorOld": "Gary D. Gregory",
			"daysBetweenCommits": 0.27,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,137 +1,137 @@\n     private static void modify(Calendar val, int field, int modType) {\n         if (val.get(Calendar.YEAR) > 280000000) {\n             throw new ArithmeticException(\"Calendar value too large for accurate calculations\");\n         }\n         \n         if (field == Calendar.MILLISECOND) {\n             return;\n         }\n \n         // ----------------- Fix for LANG-59 ---------------------- START ---------------\n         // see http://issues.apache.org/jira/browse/LANG-59\n         //\n         // Manually truncate milliseconds, seconds and minutes, rather than using\n         // Calendar methods.\n \n         Date date = val.getTime();\n         long time = date.getTime();\n         boolean done = false;\n \n         // truncate milliseconds\n         int millisecs = val.get(Calendar.MILLISECOND);\n         if (MODIFY_TRUNCATE == modType || millisecs < 500) {\n             time = time - millisecs;\n         }\n         if (field == Calendar.SECOND) {\n             done = true;\n         }\n \n         // truncate seconds\n         int seconds = val.get(Calendar.SECOND);\n         if (!done && (MODIFY_TRUNCATE == modType || seconds < 30)) {\n             time = time - (seconds * 1000L);\n         }\n         if (field == Calendar.MINUTE) {\n             done = true;\n         }\n \n         // truncate minutes\n         int minutes = val.get(Calendar.MINUTE);\n         if (!done && (MODIFY_TRUNCATE == modType || minutes < 30)) {\n             time = time - (minutes * 60000L);\n         }\n \n         // reset time\n         if (date.getTime() != time) {\n             date.setTime(time);\n             val.setTime(date);\n         }\n         // ----------------- Fix for LANG-59 ----------------------- END ----------------\n \n         boolean roundUp = false;\n         for (int[] aField : fields) {\n-            for (int j = 0; j < aField.length; j++) {\n-                if (aField[j] == field) {\n+            for (int element : aField) {\n+                if (element == field) {\n                     //This is our field... we stop looping\n                     if (modType == MODIFY_CEILING || (modType == MODIFY_ROUND && roundUp)) {\n                         if (field == DateUtils.SEMI_MONTH) {\n                             //This is a special case that's hard to generalize\n                             //If the date is 1, we round up to 16, otherwise\n                             //  we subtract 15 days and add 1 month\n                             if (val.get(Calendar.DATE) == 1) {\n                                 val.add(Calendar.DATE, 15);\n                             } else {\n                                 val.add(Calendar.DATE, -15);\n                                 val.add(Calendar.MONTH, 1);\n                             }\n // ----------------- Fix for LANG-440 ---------------------- START ---------------\n                         } else if (field == Calendar.AM_PM) {\n                             // This is a special case\n                             // If the time is 0, we round up to 12, otherwise\n                             //  we subtract 12 hours and add 1 day\n                             if (val.get(Calendar.HOUR_OF_DAY) == 0) {\n                                 val.add(Calendar.HOUR_OF_DAY, 12);\n                             } else {\n                                 val.add(Calendar.HOUR_OF_DAY, -12);\n                                 val.add(Calendar.DATE, 1);\n                             }\n // ----------------- Fix for LANG-440 ---------------------- END ---------------\n                         } else {\n                             //We need at add one to this field since the\n                             //  last number causes us to round up\n                             val.add(aField[0], 1);\n                         }\n                     }\n                     return;\n                 }\n             }\n             //We have various fields that are not easy roundings\n             int offset = 0;\n             boolean offsetSet = false;\n             //These are special types of fields that require different rounding rules\n             switch (field) {\n                 case DateUtils.SEMI_MONTH:\n                     if (aField[0] == Calendar.DATE) {\n                         //If we're going to drop the DATE field's value,\n                         //  we want to do this our own way.\n                         //We need to subtrace 1 since the date has a minimum of 1\n                         offset = val.get(Calendar.DATE) - 1;\n                         //If we're above 15 days adjustment, that means we're in the\n                         //  bottom half of the month and should stay accordingly.\n                         if (offset >= 15) {\n                             offset -= 15;\n                         }\n                         //Record whether we're in the top or bottom half of that range\n                         roundUp = offset > 7;\n                         offsetSet = true;\n                     }\n                     break;\n                 case Calendar.AM_PM:\n                     if (aField[0] == Calendar.HOUR_OF_DAY) {\n                         //If we're going to drop the HOUR field's value,\n                         //  we want to do this our own way.\n                         offset = val.get(Calendar.HOUR_OF_DAY);\n                         if (offset >= 12) {\n                             offset -= 12;\n                         }\n                         roundUp = offset >= 6;\n                         offsetSet = true;\n                     }\n                     break;\n             }\n             if (!offsetSet) {\n                 int min = val.getActualMinimum(aField[0]);\n                 int max = val.getActualMaximum(aField[0]);\n                 //Calculate the offset from the minimum allowed value\n                 offset = val.get(aField[0]) - min;\n                 //Set roundUp if this is more than half way between the minimum and maximum\n                 roundUp = offset > ((max - min) / 2);\n             }\n             //We need to remove this field\n             if (offset != 0) {\n                 val.set(aField[0], val.get(aField[0]) - offset);\n             }\n         }\n         throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n \n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"fab64bbdc726cf06c5993b7b8f50557882086002": {
			"type": "Ybodychange",
			"commitMessage": "Convert to Java 5 enhanced loops. \n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@1144929 13f79535-47bb-0310-9956-ffa450edef68\n",
			"commitDate": "2011-07-10, 12:26 PM",
			"commitName": "fab64bbdc726cf06c5993b7b8f50557882086002",
			"commitAuthor": "Gary D. Gregory",
			"commitDateOld": "2011-04-12, 9:18 AM",
			"commitNameOld": "47132a3fcc7ba92e2f8028ac5261c03fcf94d67b",
			"commitAuthorOld": "Stephen Colebourne",
			"daysBetweenCommits": 89.13,
			"commitsBetweenForRepo": 111,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,137 +1,137 @@\n     private static void modify(Calendar val, int field, int modType) {\n         if (val.get(Calendar.YEAR) > 280000000) {\n             throw new ArithmeticException(\"Calendar value too large for accurate calculations\");\n         }\n         \n         if (field == Calendar.MILLISECOND) {\n             return;\n         }\n \n         // ----------------- Fix for LANG-59 ---------------------- START ---------------\n         // see http://issues.apache.org/jira/browse/LANG-59\n         //\n         // Manually truncate milliseconds, seconds and minutes, rather than using\n         // Calendar methods.\n \n         Date date = val.getTime();\n         long time = date.getTime();\n         boolean done = false;\n \n         // truncate milliseconds\n         int millisecs = val.get(Calendar.MILLISECOND);\n         if (MODIFY_TRUNCATE == modType || millisecs < 500) {\n             time = time - millisecs;\n         }\n         if (field == Calendar.SECOND) {\n             done = true;\n         }\n \n         // truncate seconds\n         int seconds = val.get(Calendar.SECOND);\n         if (!done && (MODIFY_TRUNCATE == modType || seconds < 30)) {\n             time = time - (seconds * 1000L);\n         }\n         if (field == Calendar.MINUTE) {\n             done = true;\n         }\n \n         // truncate minutes\n         int minutes = val.get(Calendar.MINUTE);\n         if (!done && (MODIFY_TRUNCATE == modType || minutes < 30)) {\n             time = time - (minutes * 60000L);\n         }\n \n         // reset time\n         if (date.getTime() != time) {\n             date.setTime(time);\n             val.setTime(date);\n         }\n         // ----------------- Fix for LANG-59 ----------------------- END ----------------\n \n         boolean roundUp = false;\n-        for (int i = 0; i < fields.length; i++) {\n-            for (int j = 0; j < fields[i].length; j++) {\n-                if (fields[i][j] == field) {\n+        for (int[] aField : fields) {\n+            for (int j = 0; j < aField.length; j++) {\n+                if (aField[j] == field) {\n                     //This is our field... we stop looping\n                     if (modType == MODIFY_CEILING || (modType == MODIFY_ROUND && roundUp)) {\n                         if (field == DateUtils.SEMI_MONTH) {\n                             //This is a special case that's hard to generalize\n                             //If the date is 1, we round up to 16, otherwise\n                             //  we subtract 15 days and add 1 month\n                             if (val.get(Calendar.DATE) == 1) {\n                                 val.add(Calendar.DATE, 15);\n                             } else {\n                                 val.add(Calendar.DATE, -15);\n                                 val.add(Calendar.MONTH, 1);\n                             }\n // ----------------- Fix for LANG-440 ---------------------- START ---------------\n                         } else if (field == Calendar.AM_PM) {\n                             // This is a special case\n                             // If the time is 0, we round up to 12, otherwise\n                             //  we subtract 12 hours and add 1 day\n                             if (val.get(Calendar.HOUR_OF_DAY) == 0) {\n                                 val.add(Calendar.HOUR_OF_DAY, 12);\n                             } else {\n                                 val.add(Calendar.HOUR_OF_DAY, -12);\n                                 val.add(Calendar.DATE, 1);\n                             }\n // ----------------- Fix for LANG-440 ---------------------- END ---------------\n                         } else {\n                             //We need at add one to this field since the\n                             //  last number causes us to round up\n-                            val.add(fields[i][0], 1);\n+                            val.add(aField[0], 1);\n                         }\n                     }\n                     return;\n                 }\n             }\n             //We have various fields that are not easy roundings\n             int offset = 0;\n             boolean offsetSet = false;\n             //These are special types of fields that require different rounding rules\n             switch (field) {\n                 case DateUtils.SEMI_MONTH:\n-                    if (fields[i][0] == Calendar.DATE) {\n+                    if (aField[0] == Calendar.DATE) {\n                         //If we're going to drop the DATE field's value,\n                         //  we want to do this our own way.\n                         //We need to subtrace 1 since the date has a minimum of 1\n                         offset = val.get(Calendar.DATE) - 1;\n                         //If we're above 15 days adjustment, that means we're in the\n                         //  bottom half of the month and should stay accordingly.\n                         if (offset >= 15) {\n                             offset -= 15;\n                         }\n                         //Record whether we're in the top or bottom half of that range\n                         roundUp = offset > 7;\n                         offsetSet = true;\n                     }\n                     break;\n                 case Calendar.AM_PM:\n-                    if (fields[i][0] == Calendar.HOUR_OF_DAY) {\n+                    if (aField[0] == Calendar.HOUR_OF_DAY) {\n                         //If we're going to drop the HOUR field's value,\n                         //  we want to do this our own way.\n                         offset = val.get(Calendar.HOUR_OF_DAY);\n                         if (offset >= 12) {\n                             offset -= 12;\n                         }\n                         roundUp = offset >= 6;\n                         offsetSet = true;\n                     }\n                     break;\n             }\n             if (!offsetSet) {\n-                int min = val.getActualMinimum(fields[i][0]);\n-                int max = val.getActualMaximum(fields[i][0]);\n+                int min = val.getActualMinimum(aField[0]);\n+                int max = val.getActualMaximum(aField[0]);\n                 //Calculate the offset from the minimum allowed value\n-                offset = val.get(fields[i][0]) - min;\n+                offset = val.get(aField[0]) - min;\n                 //Set roundUp if this is more than half way between the minimum and maximum\n                 roundUp = offset > ((max - min) / 2);\n             }\n             //We need to remove this field\n             if (offset != 0) {\n-                val.set(fields[i][0], val.get(fields[i][0]) - offset);\n+                val.set(aField[0], val.get(aField[0]) - offset);\n             }\n         }\n         throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n \n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"fc5c081e22a61bb5a6810af302be3f22f7966df4": {
			"type": "Yfilerename",
			"commitMessage": "Move main source to src/main/java\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@895322 13f79535-47bb-0310-9956-ffa450edef68\n",
			"commitDate": "2010-01-02, 7:11 PM",
			"commitName": "fc5c081e22a61bb5a6810af302be3f22f7966df4",
			"commitAuthor": "Paul C. Benedict Jr",
			"commitDateOld": "2010-01-02, 7:09 PM",
			"commitNameOld": "6b32246f5f9f77c74b32a5290cdbdd4e0f5c71c6",
			"commitAuthorOld": "Paul C. Benedict Jr",
			"daysBetweenCommits": 0,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "",
			"extendedDetails": {
				"oldPath": "src/java/org/apache/commons/lang3/time/DateUtils.java",
				"newPath": "src/main/java/org/apache/commons/lang3/time/DateUtils.java"
			}
		},
		"debc02c6d9b94c717b4182ae4dd7a97d47293a52": {
			"type": "Yfilerename",
			"commitMessage": "Changing directory name from lang to lang3. Build will fail (probably) until Java code is changed in subsequent commit. LANG-563\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@889202 13f79535-47bb-0310-9956-ffa450edef68\n",
			"commitDate": "2009-12-10, 4:33 AM",
			"commitName": "debc02c6d9b94c717b4182ae4dd7a97d47293a52",
			"commitAuthor": "Henri Yandell",
			"commitDateOld": "2009-12-10, 4:31 AM",
			"commitNameOld": "375d7d0954cae60c4c7292cc65abbc972178857c",
			"commitAuthorOld": "Henri Yandell",
			"daysBetweenCommits": 0,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "",
			"extendedDetails": {
				"oldPath": "src/java/org/apache/commons/lang/time/DateUtils.java",
				"newPath": "src/java/org/apache/commons/lang3/time/DateUtils.java"
			}
		},
		"49e68a3f962c0b8e0ac80743db5eecb1b493c9e6": {
			"type": "Ymultichange(Yparameterchange,Ybodychange)",
			"commitMessage": "Applying Robert Scholte's patch to Travis Reeder's request for a DateUtils.ceiling(...) method to complete truncate(...) and round(...) in LANG-434\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@795597 13f79535-47bb-0310-9956-ffa450edef68\n",
			"commitDate": "2009-07-19, 1:21 PM",
			"commitName": "49e68a3f962c0b8e0ac80743db5eecb1b493c9e6",
			"commitAuthor": "Henri Yandell",
			"subchanges": [
				{
					"type": "Yparameterchange",
					"commitMessage": "Applying Robert Scholte's patch to Travis Reeder's request for a DateUtils.ceiling(...) method to complete truncate(...) and round(...) in LANG-434\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@795597 13f79535-47bb-0310-9956-ffa450edef68\n",
					"commitDate": "2009-07-19, 1:21 PM",
					"commitName": "49e68a3f962c0b8e0ac80743db5eecb1b493c9e6",
					"commitAuthor": "Henri Yandell",
					"commitDateOld": "2009-03-15, 8:11 PM",
					"commitNameOld": "950def5b6f5fa146ea6035229f3751f224981f5e",
					"commitAuthorOld": "Sebastian Bazley",
					"daysBetweenCommits": 125.71,
					"commitsBetweenForRepo": 83,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,137 +1,137 @@\n-    private static void modify(Calendar val, int field, boolean round) {\n+    private static void modify(Calendar val, int field, int modType) {\n         if (val.get(Calendar.YEAR) > 280000000) {\n             throw new ArithmeticException(\"Calendar value too large for accurate calculations\");\n         }\n         \n         if (field == Calendar.MILLISECOND) {\n             return;\n         }\n \n         // ----------------- Fix for LANG-59 ---------------------- START ---------------\n         // see http://issues.apache.org/jira/browse/LANG-59\n         //\n         // Manually truncate milliseconds, seconds and minutes, rather than using\n         // Calendar methods.\n \n         Date date = val.getTime();\n         long time = date.getTime();\n         boolean done = false;\n \n         // truncate milliseconds\n         int millisecs = val.get(Calendar.MILLISECOND);\n-        if (!round || millisecs < 500) {\n+        if (MODIFY_TRUNCATE == modType || millisecs < 500) {\n             time = time - millisecs;\n         }\n         if (field == Calendar.SECOND) {\n             done = true;\n         }\n \n         // truncate seconds\n         int seconds = val.get(Calendar.SECOND);\n-        if (!done && (!round || seconds < 30)) {\n+        if (!done && (MODIFY_TRUNCATE == modType || seconds < 30)) {\n             time = time - (seconds * 1000L);\n         }\n         if (field == Calendar.MINUTE) {\n             done = true;\n         }\n \n         // truncate minutes\n         int minutes = val.get(Calendar.MINUTE);\n-        if (!done && (!round || minutes < 30)) {\n+        if (!done && (MODIFY_TRUNCATE == modType || minutes < 30)) {\n             time = time - (minutes * 60000L);\n         }\n \n         // reset time\n         if (date.getTime() != time) {\n             date.setTime(time);\n             val.setTime(date);\n         }\n         // ----------------- Fix for LANG-59 ----------------------- END ----------------\n \n         boolean roundUp = false;\n         for (int i = 0; i < fields.length; i++) {\n             for (int j = 0; j < fields[i].length; j++) {\n                 if (fields[i][j] == field) {\n                     //This is our field... we stop looping\n-                    if (round && roundUp) {\n+                    if (modType == MODIFY_CEILING || (modType == MODIFY_ROUND && roundUp)) {\n                         if (field == DateUtils.SEMI_MONTH) {\n                             //This is a special case that's hard to generalize\n                             //If the date is 1, we round up to 16, otherwise\n                             //  we subtract 15 days and add 1 month\n                             if (val.get(Calendar.DATE) == 1) {\n                                 val.add(Calendar.DATE, 15);\n                             } else {\n                                 val.add(Calendar.DATE, -15);\n                                 val.add(Calendar.MONTH, 1);\n                             }\n // ----------------- Fix for LANG-440 ---------------------- START ---------------\n                         } else if (field == Calendar.AM_PM) {\n                             // This is a special case\n                             // If the time is 0, we round up to 12, otherwise\n                             //  we subtract 12 hours and add 1 day\n                             if (val.get(Calendar.HOUR_OF_DAY) == 0) {\n                                 val.add(Calendar.HOUR_OF_DAY, 12);\n                             } else {\n                                 val.add(Calendar.HOUR_OF_DAY, -12);\n                                 val.add(Calendar.DATE, 1);\n                             }\n // ----------------- Fix for LANG-440 ---------------------- END ---------------\n                         } else {\n                             //We need at add one to this field since the\n                             //  last number causes us to round up\n                             val.add(fields[i][0], 1);\n                         }\n                     }\n                     return;\n                 }\n             }\n             //We have various fields that are not easy roundings\n             int offset = 0;\n             boolean offsetSet = false;\n             //These are special types of fields that require different rounding rules\n             switch (field) {\n                 case DateUtils.SEMI_MONTH:\n                     if (fields[i][0] == Calendar.DATE) {\n                         //If we're going to drop the DATE field's value,\n                         //  we want to do this our own way.\n                         //We need to subtrace 1 since the date has a minimum of 1\n                         offset = val.get(Calendar.DATE) - 1;\n                         //If we're above 15 days adjustment, that means we're in the\n                         //  bottom half of the month and should stay accordingly.\n                         if (offset >= 15) {\n                             offset -= 15;\n                         }\n                         //Record whether we're in the top or bottom half of that range\n                         roundUp = offset > 7;\n                         offsetSet = true;\n                     }\n                     break;\n                 case Calendar.AM_PM:\n                     if (fields[i][0] == Calendar.HOUR_OF_DAY) {\n                         //If we're going to drop the HOUR field's value,\n                         //  we want to do this our own way.\n                         offset = val.get(Calendar.HOUR_OF_DAY);\n                         if (offset >= 12) {\n                             offset -= 12;\n                         }\n                         roundUp = offset >= 6;\n                         offsetSet = true;\n                     }\n                     break;\n             }\n             if (!offsetSet) {\n                 int min = val.getActualMinimum(fields[i][0]);\n                 int max = val.getActualMaximum(fields[i][0]);\n                 //Calculate the offset from the minimum allowed value\n                 offset = val.get(fields[i][0]) - min;\n                 //Set roundUp if this is more than half way between the minimum and maximum\n                 roundUp = offset > ((max - min) / 2);\n             }\n             //We need to remove this field\n             if (offset != 0) {\n                 val.set(fields[i][0], val.get(fields[i][0]) - offset);\n             }\n         }\n         throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n \n     }\n\\ No newline at end of file\n",
					"extendedDetails": {
						"oldValue": "[val-Calendar, field-int, round-boolean]",
						"newValue": "[val-Calendar, field-int, modType-int]"
					}
				},
				{
					"type": "Ybodychange",
					"commitMessage": "Applying Robert Scholte's patch to Travis Reeder's request for a DateUtils.ceiling(...) method to complete truncate(...) and round(...) in LANG-434\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@795597 13f79535-47bb-0310-9956-ffa450edef68\n",
					"commitDate": "2009-07-19, 1:21 PM",
					"commitName": "49e68a3f962c0b8e0ac80743db5eecb1b493c9e6",
					"commitAuthor": "Henri Yandell",
					"commitDateOld": "2009-03-15, 8:11 PM",
					"commitNameOld": "950def5b6f5fa146ea6035229f3751f224981f5e",
					"commitAuthorOld": "Sebastian Bazley",
					"daysBetweenCommits": 125.71,
					"commitsBetweenForRepo": 83,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,137 +1,137 @@\n-    private static void modify(Calendar val, int field, boolean round) {\n+    private static void modify(Calendar val, int field, int modType) {\n         if (val.get(Calendar.YEAR) > 280000000) {\n             throw new ArithmeticException(\"Calendar value too large for accurate calculations\");\n         }\n         \n         if (field == Calendar.MILLISECOND) {\n             return;\n         }\n \n         // ----------------- Fix for LANG-59 ---------------------- START ---------------\n         // see http://issues.apache.org/jira/browse/LANG-59\n         //\n         // Manually truncate milliseconds, seconds and minutes, rather than using\n         // Calendar methods.\n \n         Date date = val.getTime();\n         long time = date.getTime();\n         boolean done = false;\n \n         // truncate milliseconds\n         int millisecs = val.get(Calendar.MILLISECOND);\n-        if (!round || millisecs < 500) {\n+        if (MODIFY_TRUNCATE == modType || millisecs < 500) {\n             time = time - millisecs;\n         }\n         if (field == Calendar.SECOND) {\n             done = true;\n         }\n \n         // truncate seconds\n         int seconds = val.get(Calendar.SECOND);\n-        if (!done && (!round || seconds < 30)) {\n+        if (!done && (MODIFY_TRUNCATE == modType || seconds < 30)) {\n             time = time - (seconds * 1000L);\n         }\n         if (field == Calendar.MINUTE) {\n             done = true;\n         }\n \n         // truncate minutes\n         int minutes = val.get(Calendar.MINUTE);\n-        if (!done && (!round || minutes < 30)) {\n+        if (!done && (MODIFY_TRUNCATE == modType || minutes < 30)) {\n             time = time - (minutes * 60000L);\n         }\n \n         // reset time\n         if (date.getTime() != time) {\n             date.setTime(time);\n             val.setTime(date);\n         }\n         // ----------------- Fix for LANG-59 ----------------------- END ----------------\n \n         boolean roundUp = false;\n         for (int i = 0; i < fields.length; i++) {\n             for (int j = 0; j < fields[i].length; j++) {\n                 if (fields[i][j] == field) {\n                     //This is our field... we stop looping\n-                    if (round && roundUp) {\n+                    if (modType == MODIFY_CEILING || (modType == MODIFY_ROUND && roundUp)) {\n                         if (field == DateUtils.SEMI_MONTH) {\n                             //This is a special case that's hard to generalize\n                             //If the date is 1, we round up to 16, otherwise\n                             //  we subtract 15 days and add 1 month\n                             if (val.get(Calendar.DATE) == 1) {\n                                 val.add(Calendar.DATE, 15);\n                             } else {\n                                 val.add(Calendar.DATE, -15);\n                                 val.add(Calendar.MONTH, 1);\n                             }\n // ----------------- Fix for LANG-440 ---------------------- START ---------------\n                         } else if (field == Calendar.AM_PM) {\n                             // This is a special case\n                             // If the time is 0, we round up to 12, otherwise\n                             //  we subtract 12 hours and add 1 day\n                             if (val.get(Calendar.HOUR_OF_DAY) == 0) {\n                                 val.add(Calendar.HOUR_OF_DAY, 12);\n                             } else {\n                                 val.add(Calendar.HOUR_OF_DAY, -12);\n                                 val.add(Calendar.DATE, 1);\n                             }\n // ----------------- Fix for LANG-440 ---------------------- END ---------------\n                         } else {\n                             //We need at add one to this field since the\n                             //  last number causes us to round up\n                             val.add(fields[i][0], 1);\n                         }\n                     }\n                     return;\n                 }\n             }\n             //We have various fields that are not easy roundings\n             int offset = 0;\n             boolean offsetSet = false;\n             //These are special types of fields that require different rounding rules\n             switch (field) {\n                 case DateUtils.SEMI_MONTH:\n                     if (fields[i][0] == Calendar.DATE) {\n                         //If we're going to drop the DATE field's value,\n                         //  we want to do this our own way.\n                         //We need to subtrace 1 since the date has a minimum of 1\n                         offset = val.get(Calendar.DATE) - 1;\n                         //If we're above 15 days adjustment, that means we're in the\n                         //  bottom half of the month and should stay accordingly.\n                         if (offset >= 15) {\n                             offset -= 15;\n                         }\n                         //Record whether we're in the top or bottom half of that range\n                         roundUp = offset > 7;\n                         offsetSet = true;\n                     }\n                     break;\n                 case Calendar.AM_PM:\n                     if (fields[i][0] == Calendar.HOUR_OF_DAY) {\n                         //If we're going to drop the HOUR field's value,\n                         //  we want to do this our own way.\n                         offset = val.get(Calendar.HOUR_OF_DAY);\n                         if (offset >= 12) {\n                             offset -= 12;\n                         }\n                         roundUp = offset >= 6;\n                         offsetSet = true;\n                     }\n                     break;\n             }\n             if (!offsetSet) {\n                 int min = val.getActualMinimum(fields[i][0]);\n                 int max = val.getActualMaximum(fields[i][0]);\n                 //Calculate the offset from the minimum allowed value\n                 offset = val.get(fields[i][0]) - min;\n                 //Set roundUp if this is more than half way between the minimum and maximum\n                 roundUp = offset > ((max - min) / 2);\n             }\n             //We need to remove this field\n             if (offset != 0) {\n                 val.set(fields[i][0], val.get(fields[i][0]) - offset);\n             }\n         }\n         throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n \n     }\n\\ No newline at end of file\n",
					"extendedDetails": {}
				}
			]
		},
		"a6a2d04877d91a4c7cfff889bb64e2627ca60994": {
			"type": "Ybodychange",
			"commitMessage": "Applying Robert Scholte's excellent unit tests from LANG-443 and his second patch from LANG-440 fixing a discovered boundary case for AM_PM in round\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@711616 13f79535-47bb-0310-9956-ffa450edef68\n",
			"commitDate": "2008-11-05, 10:00 AM",
			"commitName": "a6a2d04877d91a4c7cfff889bb64e2627ca60994",
			"commitAuthor": "Henri Yandell",
			"commitDateOld": "2008-06-09, 1:17 AM",
			"commitNameOld": "db5c7106a44107b94332ee6844514b003f538a51",
			"commitAuthorOld": "Henri Yandell",
			"daysBetweenCommits": 149.41,
			"commitsBetweenForRepo": 13,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,137 +1,137 @@\n     private static void modify(Calendar val, int field, boolean round) {\n         if (val.get(Calendar.YEAR) > 280000000) {\n             throw new ArithmeticException(\"Calendar value too large for accurate calculations\");\n         }\n         \n         if (field == Calendar.MILLISECOND) {\n             return;\n         }\n \n         // ----------------- Fix for LANG-59 ---------------------- START ---------------\n         // see http://issues.apache.org/jira/browse/LANG-59\n         //\n         // Manually truncate milliseconds, seconds and minutes, rather than using\n         // Calendar methods.\n \n         Date date = val.getTime();\n         long time = date.getTime();\n         boolean done = false;\n \n         // truncate milliseconds\n         int millisecs = val.get(Calendar.MILLISECOND);\n         if (!round || millisecs < 500) {\n             time = time - millisecs;\n         }\n         if (field == Calendar.SECOND) {\n             done = true;\n         }\n \n         // truncate seconds\n         int seconds = val.get(Calendar.SECOND);\n         if (!done && (!round || seconds < 30)) {\n             time = time - (seconds * 1000L);\n         }\n         if (field == Calendar.MINUTE) {\n             done = true;\n         }\n \n         // truncate minutes\n         int minutes = val.get(Calendar.MINUTE);\n         if (!done && (!round || minutes < 30)) {\n             time = time - (minutes * 60000L);\n         }\n \n         // reset time\n         if (date.getTime() != time) {\n             date.setTime(time);\n             val.setTime(date);\n         }\n         // ----------------- Fix for LANG-59 ----------------------- END ----------------\n \n         boolean roundUp = false;\n         for (int i = 0; i < fields.length; i++) {\n             for (int j = 0; j < fields[i].length; j++) {\n                 if (fields[i][j] == field) {\n                     //This is our field... we stop looping\n                     if (round && roundUp) {\n                         if (field == DateUtils.SEMI_MONTH) {\n                             //This is a special case that's hard to generalize\n                             //If the date is 1, we round up to 16, otherwise\n                             //  we subtract 15 days and add 1 month\n                             if (val.get(Calendar.DATE) == 1) {\n                                 val.add(Calendar.DATE, 15);\n                             } else {\n                                 val.add(Calendar.DATE, -15);\n                                 val.add(Calendar.MONTH, 1);\n                             }\n // ----------------- Fix for LANG-440 ---------------------- START ---------------\n                         } else if (field == Calendar.AM_PM) {\n                             // This is a special case\n                             // If the time is 0, we round up to 12, otherwise\n                             //  we subtract 12 hours and add 1 day\n                             if (val.get(Calendar.HOUR_OF_DAY) == 0) {\n                                 val.add(Calendar.HOUR_OF_DAY, 12);\n                             } else {\n                                 val.add(Calendar.HOUR_OF_DAY, -12);\n                                 val.add(Calendar.DATE, 1);\n                             }\n // ----------------- Fix for LANG-440 ---------------------- END ---------------\n                         } else {\n                             //We need at add one to this field since the\n                             //  last number causes us to round up\n                             val.add(fields[i][0], 1);\n                         }\n                     }\n                     return;\n                 }\n             }\n             //We have various fields that are not easy roundings\n             int offset = 0;\n             boolean offsetSet = false;\n             //These are special types of fields that require different rounding rules\n             switch (field) {\n                 case DateUtils.SEMI_MONTH:\n                     if (fields[i][0] == Calendar.DATE) {\n                         //If we're going to drop the DATE field's value,\n                         //  we want to do this our own way.\n                         //We need to subtrace 1 since the date has a minimum of 1\n                         offset = val.get(Calendar.DATE) - 1;\n                         //If we're above 15 days adjustment, that means we're in the\n                         //  bottom half of the month and should stay accordingly.\n                         if (offset >= 15) {\n                             offset -= 15;\n                         }\n                         //Record whether we're in the top or bottom half of that range\n                         roundUp = offset > 7;\n                         offsetSet = true;\n                     }\n                     break;\n                 case Calendar.AM_PM:\n                     if (fields[i][0] == Calendar.HOUR_OF_DAY) {\n                         //If we're going to drop the HOUR field's value,\n                         //  we want to do this our own way.\n                         offset = val.get(Calendar.HOUR_OF_DAY);\n                         if (offset >= 12) {\n                             offset -= 12;\n                         }\n-                        roundUp = offset > 6;\n+                        roundUp = offset >= 6;\n                         offsetSet = true;\n                     }\n                     break;\n             }\n             if (!offsetSet) {\n                 int min = val.getActualMinimum(fields[i][0]);\n                 int max = val.getActualMaximum(fields[i][0]);\n                 //Calculate the offset from the minimum allowed value\n                 offset = val.get(fields[i][0]) - min;\n                 //Set roundUp if this is more than half way between the minimum and maximum\n                 roundUp = offset > ((max - min) / 2);\n             }\n             //We need to remove this field\n             if (offset != 0) {\n                 val.set(fields[i][0], val.get(fields[i][0]) - offset);\n             }\n         }\n         throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n \n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"db5c7106a44107b94332ee6844514b003f538a51": {
			"type": "Ybodychange",
			"commitMessage": "Applying Robert Scholte's fix for LANG-440, replicating the SEMI_MONTH logic for AM_PM requests\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@664643 13f79535-47bb-0310-9956-ffa450edef68\n",
			"commitDate": "2008-06-09, 1:17 AM",
			"commitName": "db5c7106a44107b94332ee6844514b003f538a51",
			"commitAuthor": "Henri Yandell",
			"commitDateOld": "2008-03-05, 5:58 PM",
			"commitNameOld": "8e83403ba9a34a2b2540d274c176f025d1ec9f1e",
			"commitAuthorOld": "Niall Pemberton",
			"daysBetweenCommits": 95.26,
			"commitsBetweenForRepo": 71,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,125 +1,137 @@\n     private static void modify(Calendar val, int field, boolean round) {\n         if (val.get(Calendar.YEAR) > 280000000) {\n             throw new ArithmeticException(\"Calendar value too large for accurate calculations\");\n         }\n         \n         if (field == Calendar.MILLISECOND) {\n             return;\n         }\n \n         // ----------------- Fix for LANG-59 ---------------------- START ---------------\n         // see http://issues.apache.org/jira/browse/LANG-59\n         //\n         // Manually truncate milliseconds, seconds and minutes, rather than using\n         // Calendar methods.\n \n         Date date = val.getTime();\n         long time = date.getTime();\n         boolean done = false;\n \n         // truncate milliseconds\n         int millisecs = val.get(Calendar.MILLISECOND);\n         if (!round || millisecs < 500) {\n             time = time - millisecs;\n         }\n         if (field == Calendar.SECOND) {\n             done = true;\n         }\n \n         // truncate seconds\n         int seconds = val.get(Calendar.SECOND);\n         if (!done && (!round || seconds < 30)) {\n             time = time - (seconds * 1000L);\n         }\n         if (field == Calendar.MINUTE) {\n             done = true;\n         }\n \n         // truncate minutes\n         int minutes = val.get(Calendar.MINUTE);\n         if (!done && (!round || minutes < 30)) {\n             time = time - (minutes * 60000L);\n         }\n \n         // reset time\n         if (date.getTime() != time) {\n             date.setTime(time);\n             val.setTime(date);\n         }\n         // ----------------- Fix for LANG-59 ----------------------- END ----------------\n \n         boolean roundUp = false;\n         for (int i = 0; i < fields.length; i++) {\n             for (int j = 0; j < fields[i].length; j++) {\n                 if (fields[i][j] == field) {\n                     //This is our field... we stop looping\n                     if (round && roundUp) {\n                         if (field == DateUtils.SEMI_MONTH) {\n                             //This is a special case that's hard to generalize\n                             //If the date is 1, we round up to 16, otherwise\n                             //  we subtract 15 days and add 1 month\n                             if (val.get(Calendar.DATE) == 1) {\n                                 val.add(Calendar.DATE, 15);\n                             } else {\n                                 val.add(Calendar.DATE, -15);\n                                 val.add(Calendar.MONTH, 1);\n                             }\n+// ----------------- Fix for LANG-440 ---------------------- START ---------------\n+                        } else if (field == Calendar.AM_PM) {\n+                            // This is a special case\n+                            // If the time is 0, we round up to 12, otherwise\n+                            //  we subtract 12 hours and add 1 day\n+                            if (val.get(Calendar.HOUR_OF_DAY) == 0) {\n+                                val.add(Calendar.HOUR_OF_DAY, 12);\n+                            } else {\n+                                val.add(Calendar.HOUR_OF_DAY, -12);\n+                                val.add(Calendar.DATE, 1);\n+                            }\n+// ----------------- Fix for LANG-440 ---------------------- END ---------------\n                         } else {\n                             //We need at add one to this field since the\n                             //  last number causes us to round up\n                             val.add(fields[i][0], 1);\n                         }\n                     }\n                     return;\n                 }\n             }\n             //We have various fields that are not easy roundings\n             int offset = 0;\n             boolean offsetSet = false;\n             //These are special types of fields that require different rounding rules\n             switch (field) {\n                 case DateUtils.SEMI_MONTH:\n                     if (fields[i][0] == Calendar.DATE) {\n                         //If we're going to drop the DATE field's value,\n                         //  we want to do this our own way.\n                         //We need to subtrace 1 since the date has a minimum of 1\n                         offset = val.get(Calendar.DATE) - 1;\n                         //If we're above 15 days adjustment, that means we're in the\n                         //  bottom half of the month and should stay accordingly.\n                         if (offset >= 15) {\n                             offset -= 15;\n                         }\n                         //Record whether we're in the top or bottom half of that range\n                         roundUp = offset > 7;\n                         offsetSet = true;\n                     }\n                     break;\n                 case Calendar.AM_PM:\n                     if (fields[i][0] == Calendar.HOUR_OF_DAY) {\n                         //If we're going to drop the HOUR field's value,\n                         //  we want to do this our own way.\n                         offset = val.get(Calendar.HOUR_OF_DAY);\n                         if (offset >= 12) {\n                             offset -= 12;\n                         }\n                         roundUp = offset > 6;\n                         offsetSet = true;\n                     }\n                     break;\n             }\n             if (!offsetSet) {\n                 int min = val.getActualMinimum(fields[i][0]);\n                 int max = val.getActualMaximum(fields[i][0]);\n                 //Calculate the offset from the minimum allowed value\n                 offset = val.get(fields[i][0]) - min;\n                 //Set roundUp if this is more than half way between the minimum and maximum\n                 roundUp = offset > ((max - min) / 2);\n             }\n             //We need to remove this field\n             if (offset != 0) {\n                 val.set(fields[i][0], val.get(fields[i][0]) - offset);\n             }\n         }\n         throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n \n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"050fe8e916507c9716983868284d64e58c1b56d2": {
			"type": "Ybodychange",
			"commitMessage": "Applying the fix and the test patches from LANG-346 - fixes bugs in DateUtils.round() for minutes and seconds. Patch from Dave Meikle\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@564053 13f79535-47bb-0310-9956-ffa450edef68\n",
			"commitDate": "2007-08-08, 6:24 PM",
			"commitName": "050fe8e916507c9716983868284d64e58c1b56d2",
			"commitAuthor": "Henri Yandell",
			"commitDateOld": "2006-08-28, 12:21 AM",
			"commitNameOld": "a5a4f9067a0b22e629463b1ef059818ccda6f37e",
			"commitAuthorOld": "Henri Yandell",
			"daysBetweenCommits": 345.75,
			"commitsBetweenForRepo": 180,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,125 +1,125 @@\n     private static void modify(Calendar val, int field, boolean round) {\n         if (val.get(Calendar.YEAR) > 280000000) {\n             throw new ArithmeticException(\"Calendar value too large for accurate calculations\");\n         }\n         \n         if (field == Calendar.MILLISECOND) {\n             return;\n         }\n \n         // ----------------- Fix for LANG-59 ---------------------- START ---------------\n         // see http://issues.apache.org/jira/browse/LANG-59\n         //\n         // Manually truncate milliseconds, seconds and minutes, rather than using\n         // Calendar methods.\n \n         Date date = val.getTime();\n         long time = date.getTime();\n         boolean done = false;\n \n         // truncate milliseconds\n         int millisecs = val.get(Calendar.MILLISECOND);\n         if (!round || millisecs < 500) {\n             time = time - millisecs;\n-            if (field == Calendar.SECOND) {\n-                done = true;\n-            }\n+        }\n+        if (field == Calendar.SECOND) {\n+            done = true;\n         }\n \n         // truncate seconds\n         int seconds = val.get(Calendar.SECOND);\n         if (!done && (!round || seconds < 30)) {\n             time = time - (seconds * 1000L);\n-            if (field == Calendar.MINUTE) {\n-                done = true;\n-            }\n+        }\n+        if (field == Calendar.MINUTE) {\n+            done = true;\n         }\n \n         // truncate minutes\n         int minutes = val.get(Calendar.MINUTE);\n         if (!done && (!round || minutes < 30)) {\n             time = time - (minutes * 60000L);\n         }\n \n         // reset time\n         if (date.getTime() != time) {\n             date.setTime(time);\n             val.setTime(date);\n         }\n         // ----------------- Fix for LANG-59 ----------------------- END ----------------\n \n         boolean roundUp = false;\n         for (int i = 0; i < fields.length; i++) {\n             for (int j = 0; j < fields[i].length; j++) {\n                 if (fields[i][j] == field) {\n                     //This is our field... we stop looping\n                     if (round && roundUp) {\n                         if (field == DateUtils.SEMI_MONTH) {\n                             //This is a special case that's hard to generalize\n                             //If the date is 1, we round up to 16, otherwise\n                             //  we subtract 15 days and add 1 month\n                             if (val.get(Calendar.DATE) == 1) {\n                                 val.add(Calendar.DATE, 15);\n                             } else {\n                                 val.add(Calendar.DATE, -15);\n                                 val.add(Calendar.MONTH, 1);\n                             }\n                         } else {\n                             //We need at add one to this field since the\n                             //  last number causes us to round up\n                             val.add(fields[i][0], 1);\n                         }\n                     }\n                     return;\n                 }\n             }\n             //We have various fields that are not easy roundings\n             int offset = 0;\n             boolean offsetSet = false;\n             //These are special types of fields that require different rounding rules\n             switch (field) {\n                 case DateUtils.SEMI_MONTH:\n                     if (fields[i][0] == Calendar.DATE) {\n                         //If we're going to drop the DATE field's value,\n                         //  we want to do this our own way.\n                         //We need to subtrace 1 since the date has a minimum of 1\n                         offset = val.get(Calendar.DATE) - 1;\n                         //If we're above 15 days adjustment, that means we're in the\n                         //  bottom half of the month and should stay accordingly.\n                         if (offset >= 15) {\n                             offset -= 15;\n                         }\n                         //Record whether we're in the top or bottom half of that range\n                         roundUp = offset > 7;\n                         offsetSet = true;\n                     }\n                     break;\n                 case Calendar.AM_PM:\n                     if (fields[i][0] == Calendar.HOUR_OF_DAY) {\n                         //If we're going to drop the HOUR field's value,\n                         //  we want to do this our own way.\n                         offset = val.get(Calendar.HOUR_OF_DAY);\n                         if (offset >= 12) {\n                             offset -= 12;\n                         }\n                         roundUp = offset > 6;\n                         offsetSet = true;\n                     }\n                     break;\n             }\n             if (!offsetSet) {\n                 int min = val.getActualMinimum(fields[i][0]);\n                 int max = val.getActualMaximum(fields[i][0]);\n                 //Calculate the offset from the minimum allowed value\n                 offset = val.get(fields[i][0]) - min;\n                 //Set roundUp if this is more than half way between the minimum and maximum\n                 roundUp = offset > ((max - min) / 2);\n             }\n             //We need to remove this field\n             if (offset != 0) {\n                 val.set(fields[i][0], val.get(fields[i][0]) - offset);\n             }\n         }\n         throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n \n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"9cbf70d82285d7ebdd190f7cd59f2a9d82a09c61": {
			"type": "Ybodychange",
			"commitMessage": "Adding Niall's fix for LANG-59 - an edge case in date truncation - and his enhancement \nfor the unit test that was there. \n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/lang/trunk@424192 13f79535-47bb-0310-9956-ffa450edef68\n",
			"commitDate": "2006-07-20, 11:47 PM",
			"commitName": "9cbf70d82285d7ebdd190f7cd59f2a9d82a09c61",
			"commitAuthor": "Henri Yandell",
			"commitDateOld": "2006-07-05, 5:49 PM",
			"commitNameOld": "3a48c43f4d467bc05a5cac77c2405e8a13b8a87d",
			"commitAuthorOld": "Stephen Colebourne",
			"daysBetweenCommits": 15.25,
			"commitsBetweenForRepo": 11,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,78 +1,125 @@\n     private static void modify(Calendar val, int field, boolean round) {\n         if (val.get(Calendar.YEAR) > 280000000) {\n             throw new ArithmeticException(\"Calendar value too large for accurate calculations\");\n         }\n         \n+        if (field == Calendar.MILLISECOND) {\n+            return;\n+        }\n+\n+        // ----------------- Fix for LANG-59 ---------------------- START ---------------\n+        // see http://issues.apache.org/jira/browse/LANG-59\n+        //\n+        // Manually truncate milliseconds, seconds and minutes, rather than using\n+        // Calendar methods.\n+\n+        Date date = val.getTime();\n+        long time = date.getTime();\n+        boolean done = false;\n+\n+        // truncate milliseconds\n+        int millisecs = val.get(Calendar.MILLISECOND);\n+        if (!round || millisecs < 500) {\n+            time = time - millisecs;\n+            if (field == Calendar.SECOND) {\n+                done = true;\n+            }\n+        }\n+\n+        // truncate seconds\n+        int seconds = val.get(Calendar.SECOND);\n+        if (!done && (!round || seconds < 30)) {\n+            time = time - (seconds * 1000L);\n+            if (field == Calendar.MINUTE) {\n+                done = true;\n+            }\n+        }\n+\n+        // truncate minutes\n+        int minutes = val.get(Calendar.MINUTE);\n+        if (!done && (!round || minutes < 30)) {\n+            time = time - (minutes * 60000L);\n+        }\n+\n+        // reset time\n+        if (date.getTime() != time) {\n+            date.setTime(time);\n+            val.setTime(date);\n+        }\n+        // ----------------- Fix for LANG-59 ----------------------- END ----------------\n+\n         boolean roundUp = false;\n         for (int i = 0; i < fields.length; i++) {\n             for (int j = 0; j < fields[i].length; j++) {\n                 if (fields[i][j] == field) {\n                     //This is our field... we stop looping\n                     if (round && roundUp) {\n                         if (field == DateUtils.SEMI_MONTH) {\n                             //This is a special case that's hard to generalize\n                             //If the date is 1, we round up to 16, otherwise\n                             //  we subtract 15 days and add 1 month\n                             if (val.get(Calendar.DATE) == 1) {\n                                 val.add(Calendar.DATE, 15);\n                             } else {\n                                 val.add(Calendar.DATE, -15);\n                                 val.add(Calendar.MONTH, 1);\n                             }\n                         } else {\n                             //We need at add one to this field since the\n                             //  last number causes us to round up\n                             val.add(fields[i][0], 1);\n                         }\n                     }\n                     return;\n                 }\n             }\n             //We have various fields that are not easy roundings\n             int offset = 0;\n             boolean offsetSet = false;\n             //These are special types of fields that require different rounding rules\n             switch (field) {\n                 case DateUtils.SEMI_MONTH:\n                     if (fields[i][0] == Calendar.DATE) {\n                         //If we're going to drop the DATE field's value,\n                         //  we want to do this our own way.\n                         //We need to subtrace 1 since the date has a minimum of 1\n                         offset = val.get(Calendar.DATE) - 1;\n                         //If we're above 15 days adjustment, that means we're in the\n                         //  bottom half of the month and should stay accordingly.\n                         if (offset >= 15) {\n                             offset -= 15;\n                         }\n                         //Record whether we're in the top or bottom half of that range\n                         roundUp = offset > 7;\n                         offsetSet = true;\n                     }\n                     break;\n                 case Calendar.AM_PM:\n                     if (fields[i][0] == Calendar.HOUR_OF_DAY) {\n                         //If we're going to drop the HOUR field's value,\n                         //  we want to do this our own way.\n                         offset = val.get(Calendar.HOUR_OF_DAY);\n                         if (offset >= 12) {\n                             offset -= 12;\n                         }\n                         roundUp = offset > 6;\n                         offsetSet = true;\n                     }\n                     break;\n             }\n             if (!offsetSet) {\n                 int min = val.getActualMinimum(fields[i][0]);\n                 int max = val.getActualMaximum(fields[i][0]);\n                 //Calculate the offset from the minimum allowed value\n                 offset = val.get(fields[i][0]) - min;\n                 //Set roundUp if this is more than half way between the minimum and maximum\n                 roundUp = offset > ((max - min) / 2);\n             }\n             //We need to remove this field\n-            val.set(fields[i][0], val.get(fields[i][0]) - offset);\n+            if (offset != 0) {\n+                val.set(fields[i][0], val.get(fields[i][0]) - offset);\n+            }\n         }\n         throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n \n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"3a48c43f4d467bc05a5cac77c2405e8a13b8a87d": {
			"type": "Ybodychange",
			"commitMessage": "Remove debugging code\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/lang/trunk@419387 13f79535-47bb-0310-9956-ffa450edef68\n",
			"commitDate": "2006-07-05, 5:49 PM",
			"commitName": "3a48c43f4d467bc05a5cac77c2405e8a13b8a87d",
			"commitAuthor": "Stephen Colebourne",
			"commitDateOld": "2006-07-05, 12:14 AM",
			"commitNameOld": "4a453bd132aa147607c14a036d23fc1fe524006f",
			"commitAuthorOld": "Henri Yandell",
			"daysBetweenCommits": 0.73,
			"commitsBetweenForRepo": 4,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,79 +1,78 @@\n     private static void modify(Calendar val, int field, boolean round) {\n         if (val.get(Calendar.YEAR) > 280000000) {\n             throw new ArithmeticException(\"Calendar value too large for accurate calculations\");\n         }\n         \n         boolean roundUp = false;\n         for (int i = 0; i < fields.length; i++) {\n             for (int j = 0; j < fields[i].length; j++) {\n                 if (fields[i][j] == field) {\n                     //This is our field... we stop looping\n                     if (round && roundUp) {\n                         if (field == DateUtils.SEMI_MONTH) {\n                             //This is a special case that's hard to generalize\n                             //If the date is 1, we round up to 16, otherwise\n                             //  we subtract 15 days and add 1 month\n                             if (val.get(Calendar.DATE) == 1) {\n                                 val.add(Calendar.DATE, 15);\n                             } else {\n                                 val.add(Calendar.DATE, -15);\n                                 val.add(Calendar.MONTH, 1);\n                             }\n                         } else {\n                             //We need at add one to this field since the\n                             //  last number causes us to round up\n                             val.add(fields[i][0], 1);\n                         }\n                     }\n                     return;\n                 }\n             }\n             //We have various fields that are not easy roundings\n             int offset = 0;\n             boolean offsetSet = false;\n             //These are special types of fields that require different rounding rules\n             switch (field) {\n                 case DateUtils.SEMI_MONTH:\n                     if (fields[i][0] == Calendar.DATE) {\n                         //If we're going to drop the DATE field's value,\n                         //  we want to do this our own way.\n                         //We need to subtrace 1 since the date has a minimum of 1\n                         offset = val.get(Calendar.DATE) - 1;\n                         //If we're above 15 days adjustment, that means we're in the\n                         //  bottom half of the month and should stay accordingly.\n                         if (offset >= 15) {\n                             offset -= 15;\n                         }\n                         //Record whether we're in the top or bottom half of that range\n                         roundUp = offset > 7;\n                         offsetSet = true;\n                     }\n                     break;\n                 case Calendar.AM_PM:\n                     if (fields[i][0] == Calendar.HOUR_OF_DAY) {\n                         //If we're going to drop the HOUR field's value,\n                         //  we want to do this our own way.\n                         offset = val.get(Calendar.HOUR_OF_DAY);\n                         if (offset >= 12) {\n                             offset -= 12;\n                         }\n                         roundUp = offset > 6;\n                         offsetSet = true;\n                     }\n                     break;\n             }\n             if (!offsetSet) {\n                 int min = val.getActualMinimum(fields[i][0]);\n                 int max = val.getActualMaximum(fields[i][0]);\n                 //Calculate the offset from the minimum allowed value\n                 offset = val.get(fields[i][0]) - min;\n                 //Set roundUp if this is more than half way between the minimum and maximum\n                 roundUp = offset > ((max - min) / 2);\n             }\n-System.err.println(\"DST: \" + val.get(Calendar.DST_OFFSET));\n             //We need to remove this field\n             val.set(fields[i][0], val.get(fields[i][0]) - offset);\n         }\n         throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n \n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"4a453bd132aa147607c14a036d23fc1fe524006f": {
			"type": "Ybodychange",
			"commitMessage": "Minor style fixes suggested by checkstyle\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/lang/trunk@419174 13f79535-47bb-0310-9956-ffa450edef68\n",
			"commitDate": "2006-07-05, 12:14 AM",
			"commitName": "4a453bd132aa147607c14a036d23fc1fe524006f",
			"commitAuthor": "Henri Yandell",
			"commitDateOld": "2006-04-16, 2:55 PM",
			"commitNameOld": "12491a6801249b2a582a231b1a40e17b401cc413",
			"commitAuthorOld": "Stephen Colebourne",
			"daysBetweenCommits": 79.39,
			"commitsBetweenForRepo": 50,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,78 +1,79 @@\n     private static void modify(Calendar val, int field, boolean round) {\n         if (val.get(Calendar.YEAR) > 280000000) {\n             throw new ArithmeticException(\"Calendar value too large for accurate calculations\");\n         }\n         \n         boolean roundUp = false;\n         for (int i = 0; i < fields.length; i++) {\n             for (int j = 0; j < fields[i].length; j++) {\n                 if (fields[i][j] == field) {\n                     //This is our field... we stop looping\n                     if (round && roundUp) {\n                         if (field == DateUtils.SEMI_MONTH) {\n                             //This is a special case that's hard to generalize\n                             //If the date is 1, we round up to 16, otherwise\n                             //  we subtract 15 days and add 1 month\n                             if (val.get(Calendar.DATE) == 1) {\n                                 val.add(Calendar.DATE, 15);\n                             } else {\n                                 val.add(Calendar.DATE, -15);\n                                 val.add(Calendar.MONTH, 1);\n                             }\n                         } else {\n                             //We need at add one to this field since the\n                             //  last number causes us to round up\n                             val.add(fields[i][0], 1);\n                         }\n                     }\n                     return;\n                 }\n             }\n             //We have various fields that are not easy roundings\n             int offset = 0;\n             boolean offsetSet = false;\n             //These are special types of fields that require different rounding rules\n             switch (field) {\n                 case DateUtils.SEMI_MONTH:\n                     if (fields[i][0] == Calendar.DATE) {\n                         //If we're going to drop the DATE field's value,\n                         //  we want to do this our own way.\n                         //We need to subtrace 1 since the date has a minimum of 1\n                         offset = val.get(Calendar.DATE) - 1;\n                         //If we're above 15 days adjustment, that means we're in the\n                         //  bottom half of the month and should stay accordingly.\n                         if (offset >= 15) {\n                             offset -= 15;\n                         }\n                         //Record whether we're in the top or bottom half of that range\n                         roundUp = offset > 7;\n                         offsetSet = true;\n                     }\n                     break;\n                 case Calendar.AM_PM:\n                     if (fields[i][0] == Calendar.HOUR_OF_DAY) {\n                         //If we're going to drop the HOUR field's value,\n                         //  we want to do this our own way.\n                         offset = val.get(Calendar.HOUR_OF_DAY);\n                         if (offset >= 12) {\n                             offset -= 12;\n                         }\n                         roundUp = offset > 6;\n                         offsetSet = true;\n                     }\n                     break;\n             }\n             if (!offsetSet) {\n                 int min = val.getActualMinimum(fields[i][0]);\n                 int max = val.getActualMaximum(fields[i][0]);\n                 //Calculate the offset from the minimum allowed value\n                 offset = val.get(fields[i][0]) - min;\n                 //Set roundUp if this is more than half way between the minimum and maximum\n                 roundUp = offset > ((max - min) / 2);\n             }\n+System.err.println(\"DST: \" + val.get(Calendar.DST_OFFSET));\n             //We need to remove this field\n             val.set(fields[i][0], val.get(fields[i][0]) - offset);\n         }\n         throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n \n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"d19d4a852154ef1d38a842d88c34cac6505e5f01": {
			"type": "Ybodychange",
			"commitMessage": "Fix DateUtils.truncate oddity at the far end of the Date spectrum\nbug 31395, from Marc Portier\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/lang/trunk@137984 13f79535-47bb-0310-9956-ffa450edef68\n",
			"commitDate": "2004-10-16, 11:43 AM",
			"commitName": "d19d4a852154ef1d38a842d88c34cac6505e5f01",
			"commitAuthor": "Stephen Colebourne",
			"commitDateOld": "2004-10-16, 11:08 AM",
			"commitNameOld": "61cccd3e0a4cc51c0956ca90310c8b76d4f6fdeb",
			"commitAuthorOld": "Stephen Colebourne",
			"daysBetweenCommits": 0.02,
			"commitsBetweenForRepo": 2,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,74 +1,78 @@\n     private static void modify(Calendar val, int field, boolean round) {\n+        if (val.get(Calendar.YEAR) > 280000000) {\n+            throw new ArithmeticException(\"Calendar value too large for accurate calculations\");\n+        }\n+        \n         boolean roundUp = false;\n         for (int i = 0; i < fields.length; i++) {\n             for (int j = 0; j < fields[i].length; j++) {\n                 if (fields[i][j] == field) {\n                     //This is our field... we stop looping\n                     if (round && roundUp) {\n                         if (field == DateUtils.SEMI_MONTH) {\n                             //This is a special case that's hard to generalize\n                             //If the date is 1, we round up to 16, otherwise\n                             //  we subtract 15 days and add 1 month\n                             if (val.get(Calendar.DATE) == 1) {\n                                 val.add(Calendar.DATE, 15);\n                             } else {\n                                 val.add(Calendar.DATE, -15);\n                                 val.add(Calendar.MONTH, 1);\n                             }\n                         } else {\n                             //We need at add one to this field since the\n                             //  last number causes us to round up\n                             val.add(fields[i][0], 1);\n                         }\n                     }\n                     return;\n                 }\n             }\n             //We have various fields that are not easy roundings\n             int offset = 0;\n             boolean offsetSet = false;\n             //These are special types of fields that require different rounding rules\n             switch (field) {\n                 case DateUtils.SEMI_MONTH:\n                     if (fields[i][0] == Calendar.DATE) {\n                         //If we're going to drop the DATE field's value,\n                         //  we want to do this our own way.\n                         //We need to subtrace 1 since the date has a minimum of 1\n                         offset = val.get(Calendar.DATE) - 1;\n                         //If we're above 15 days adjustment, that means we're in the\n                         //  bottom half of the month and should stay accordingly.\n                         if (offset >= 15) {\n                             offset -= 15;\n                         }\n                         //Record whether we're in the top or bottom half of that range\n                         roundUp = offset > 7;\n                         offsetSet = true;\n                     }\n                     break;\n                 case Calendar.AM_PM:\n                     if (fields[i][0] == Calendar.HOUR_OF_DAY) {\n                         //If we're going to drop the HOUR field's value,\n                         //  we want to do this our own way.\n                         offset = val.get(Calendar.HOUR_OF_DAY);\n                         if (offset >= 12) {\n                             offset -= 12;\n                         }\n                         roundUp = offset > 6;\n                         offsetSet = true;\n                     }\n                     break;\n             }\n             if (!offsetSet) {\n                 int min = val.getActualMinimum(fields[i][0]);\n                 int max = val.getActualMaximum(fields[i][0]);\n                 //Calculate the offset from the minimum allowed value\n                 offset = val.get(fields[i][0]) - min;\n                 //Set roundUp if this is more than half way between the minimum and maximum\n                 roundUp = offset > ((max - min) / 2);\n             }\n             //We need to remove this field\n             val.set(fields[i][0], val.get(fields[i][0]) - offset);\n         }\n         throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n \n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"0c40162c2feef6cd17a553a5506666e1f43a7380": {
			"type": "Ybodychange",
			"commitMessage": "corrected calendar field used to calculate the offset when modifying the hour for a round or truncated based on AM_PM\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/lang/trunk@137881 13f79535-47bb-0310-9956-ffa450edef68\n",
			"commitDate": "2004-07-11, 6:04 PM",
			"commitName": "0c40162c2feef6cd17a553a5506666e1f43a7380",
			"commitAuthor": "Steven Caswell",
			"commitDateOld": "2004-07-11, 12:40 PM",
			"commitNameOld": "946ba1293b91a73461d7f3db02a99881bed2147b",
			"commitAuthorOld": "Steven Caswell",
			"daysBetweenCommits": 0.23,
			"commitsBetweenForRepo": 4,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,74 +1,74 @@\n     private static void modify(Calendar val, int field, boolean round) {\n         boolean roundUp = false;\n         for (int i = 0; i < fields.length; i++) {\n             for (int j = 0; j < fields[i].length; j++) {\n                 if (fields[i][j] == field) {\n                     //This is our field... we stop looping\n                     if (round && roundUp) {\n                         if (field == DateUtils.SEMI_MONTH) {\n                             //This is a special case that's hard to generalize\n                             //If the date is 1, we round up to 16, otherwise\n                             //  we subtract 15 days and add 1 month\n                             if (val.get(Calendar.DATE) == 1) {\n                                 val.add(Calendar.DATE, 15);\n                             } else {\n                                 val.add(Calendar.DATE, -15);\n                                 val.add(Calendar.MONTH, 1);\n                             }\n                         } else {\n                             //We need at add one to this field since the\n                             //  last number causes us to round up\n                             val.add(fields[i][0], 1);\n                         }\n                     }\n                     return;\n                 }\n             }\n             //We have various fields that are not easy roundings\n             int offset = 0;\n             boolean offsetSet = false;\n             //These are special types of fields that require different rounding rules\n             switch (field) {\n                 case DateUtils.SEMI_MONTH:\n                     if (fields[i][0] == Calendar.DATE) {\n                         //If we're going to drop the DATE field's value,\n                         //  we want to do this our own way.\n                         //We need to subtrace 1 since the date has a minimum of 1\n                         offset = val.get(Calendar.DATE) - 1;\n                         //If we're above 15 days adjustment, that means we're in the\n                         //  bottom half of the month and should stay accordingly.\n                         if (offset >= 15) {\n                             offset -= 15;\n                         }\n                         //Record whether we're in the top or bottom half of that range\n                         roundUp = offset > 7;\n                         offsetSet = true;\n                     }\n                     break;\n                 case Calendar.AM_PM:\n-                    if (fields[i][0] == Calendar.HOUR) {\n+                    if (fields[i][0] == Calendar.HOUR_OF_DAY) {\n                         //If we're going to drop the HOUR field's value,\n                         //  we want to do this our own way.\n-                        offset = val.get(Calendar.HOUR);\n+                        offset = val.get(Calendar.HOUR_OF_DAY);\n                         if (offset >= 12) {\n                             offset -= 12;\n                         }\n                         roundUp = offset > 6;\n                         offsetSet = true;\n                     }\n                     break;\n             }\n             if (!offsetSet) {\n                 int min = val.getActualMinimum(fields[i][0]);\n                 int max = val.getActualMaximum(fields[i][0]);\n                 //Calculate the offset from the minimum allowed value\n                 offset = val.get(fields[i][0]) - min;\n                 //Set roundUp if this is more than half way between the minimum and maximum\n                 roundUp = offset > ((max - min) / 2);\n             }\n             //We need to remove this field\n             val.set(fields[i][0], val.get(fields[i][0]) - offset);\n         }\n         throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n \n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"c4df48e565253ed75b1a3070b1f01f1d58087a1f": {
			"type": "Ybodychange",
			"commitMessage": "changed modify method to calculate the field offset and use the set method, rather than adding the offset and letting Calendar perform the calculation - this fixes http://issues.apache.org/bugzilla/show_bug.cgi?id=25560;\nupdated javadocs on round method to explain how rounding across daylight saving time is handled\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/lang/trunk@137866 13f79535-47bb-0310-9956-ffa450edef68\n",
			"commitDate": "2004-07-05, 11:54 AM",
			"commitName": "c4df48e565253ed75b1a3070b1f01f1d58087a1f",
			"commitAuthor": "Steven Caswell",
			"commitDateOld": "2004-06-27, 12:29 AM",
			"commitNameOld": "5f7e26a978322dd6d09459ecdbefb7a389a86652",
			"commitAuthorOld": "Henri Yandell",
			"daysBetweenCommits": 8.48,
			"commitsBetweenForRepo": 11,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,74 +1,74 @@\n     private static void modify(Calendar val, int field, boolean round) {\n         boolean roundUp = false;\n         for (int i = 0; i < fields.length; i++) {\n             for (int j = 0; j < fields[i].length; j++) {\n                 if (fields[i][j] == field) {\n                     //This is our field... we stop looping\n                     if (round && roundUp) {\n                         if (field == DateUtils.SEMI_MONTH) {\n                             //This is a special case that's hard to generalize\n                             //If the date is 1, we round up to 16, otherwise\n                             //  we subtract 15 days and add 1 month\n                             if (val.get(Calendar.DATE) == 1) {\n                                 val.add(Calendar.DATE, 15);\n                             } else {\n                                 val.add(Calendar.DATE, -15);\n                                 val.add(Calendar.MONTH, 1);\n                             }\n                         } else {\n                             //We need at add one to this field since the\n                             //  last number causes us to round up\n                             val.add(fields[i][0], 1);\n                         }\n                     }\n                     return;\n                 }\n             }\n             //We have various fields that are not easy roundings\n             int offset = 0;\n             boolean offsetSet = false;\n             //These are special types of fields that require different rounding rules\n             switch (field) {\n                 case DateUtils.SEMI_MONTH:\n                     if (fields[i][0] == Calendar.DATE) {\n                         //If we're going to drop the DATE field's value,\n                         //  we want to do this our own way.\n                         //We need to subtrace 1 since the date has a minimum of 1\n                         offset = val.get(Calendar.DATE) - 1;\n                         //If we're above 15 days adjustment, that means we're in the\n                         //  bottom half of the month and should stay accordingly.\n                         if (offset >= 15) {\n                             offset -= 15;\n                         }\n                         //Record whether we're in the top or bottom half of that range\n                         roundUp = offset > 7;\n                         offsetSet = true;\n                     }\n                     break;\n                 case Calendar.AM_PM:\n                     if (fields[i][0] == Calendar.HOUR) {\n                         //If we're going to drop the HOUR field's value,\n                         //  we want to do this our own way.\n                         offset = val.get(Calendar.HOUR);\n                         if (offset >= 12) {\n                             offset -= 12;\n                         }\n                         roundUp = offset > 6;\n                         offsetSet = true;\n                     }\n                     break;\n             }\n             if (!offsetSet) {\n                 int min = val.getActualMinimum(fields[i][0]);\n                 int max = val.getActualMaximum(fields[i][0]);\n                 //Calculate the offset from the minimum allowed value\n                 offset = val.get(fields[i][0]) - min;\n                 //Set roundUp if this is more than half way between the minimum and maximum\n                 roundUp = offset > ((max - min) / 2);\n             }\n             //We need to remove this field\n-            val.add(fields[i][0], -offset);\n+            val.set(fields[i][0], val.get(fields[i][0]) - offset);\n         }\n         throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n \n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"402c8e0846d5ad865226a7488c4bbc803e685719": {
			"type": "Ybodychange",
			"commitMessage": "Prepare DateUtils for 2.0 release\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/lang/trunk@137375 13f79535-47bb-0310-9956-ffa450edef68\n",
			"commitDate": "2003-06-23, 5:41 PM",
			"commitName": "402c8e0846d5ad865226a7488c4bbc803e685719",
			"commitAuthor": "Stephen Colebourne",
			"commitDateOld": "2003-06-08, 5:14 PM",
			"commitNameOld": "73ee6c3d270a91bd447f732b24c4d65169b0c8d6",
			"commitAuthorOld": "Stephen Colebourne",
			"daysBetweenCommits": 15.02,
			"commitsBetweenForRepo": 14,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,74 +1,74 @@\n     private static void modify(Calendar val, int field, boolean round) {\n         boolean roundUp = false;\n         for (int i = 0; i < fields.length; i++) {\n             for (int j = 0; j < fields[i].length; j++) {\n                 if (fields[i][j] == field) {\n                     //This is our field... we stop looping\n                     if (round && roundUp) {\n                         if (field == DateUtils.SEMI_MONTH) {\n                             //This is a special case that's hard to generalize\n                             //If the date is 1, we round up to 16, otherwise\n                             //  we subtract 15 days and add 1 month\n                             if (val.get(Calendar.DATE) == 1) {\n                                 val.add(Calendar.DATE, 15);\n                             } else {\n                                 val.add(Calendar.DATE, -15);\n                                 val.add(Calendar.MONTH, 1);\n                             }\n                         } else {\n                             //We need at add one to this field since the\n                             //  last number causes us to round up\n                             val.add(fields[i][0], 1);\n                         }\n                     }\n                     return;\n                 }\n             }\n             //We have various fields that are not easy roundings\n             int offset = 0;\n             boolean offsetSet = false;\n             //These are special types of fields that require different rounding rules\n             switch (field) {\n                 case DateUtils.SEMI_MONTH:\n                     if (fields[i][0] == Calendar.DATE) {\n                         //If we're going to drop the DATE field's value,\n                         //  we want to do this our own way.\n                         //We need to subtrace 1 since the date has a minimum of 1\n                         offset = val.get(Calendar.DATE) - 1;\n                         //If we're above 15 days adjustment, that means we're in the\n                         //  bottom half of the month and should stay accordingly.\n                         if (offset >= 15) {\n                             offset -= 15;\n                         }\n                         //Record whether we're in the top or bottom half of that range\n                         roundUp = offset > 7;\n                         offsetSet = true;\n                     }\n                     break;\n                 case Calendar.AM_PM:\n                     if (fields[i][0] == Calendar.HOUR) {\n                         //If we're going to drop the HOUR field's value,\n                         //  we want to do this our own way.\n                         offset = val.get(Calendar.HOUR);\n                         if (offset >= 12) {\n                             offset -= 12;\n                         }\n                         roundUp = offset > 6;\n                         offsetSet = true;\n                     }\n                     break;\n             }\n             if (!offsetSet) {\n                 int min = val.getActualMinimum(fields[i][0]);\n                 int max = val.getActualMaximum(fields[i][0]);\n                 //Calculate the offset from the minimum allowed value\n                 offset = val.get(fields[i][0]) - min;\n                 //Set roundUp if this is more than half way between the minimum and maximum\n                 roundUp = offset > ((max - min) / 2);\n             }\n             //We need to remove this field\n             val.add(fields[i][0], -offset);\n         }\n-        throw new RuntimeException(\"We do not support that field.\");\n+        throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n \n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"73ee6c3d270a91bd447f732b24c4d65169b0c8d6": {
			"type": "Ymultichange(Ymovefromfile,Ybodychange)",
			"commitMessage": "Rework time package in preparation for 2.0 release\nDateUtils split to DateFormatUtils and DurationFormatUtils\nCalendarUtils renamed to DateUtils\nStopWatch time format method moved to DurationFormatUtils\nTests updated and pass\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/lang/trunk@137361 13f79535-47bb-0310-9956-ffa450edef68\n",
			"commitDate": "2003-06-08, 5:14 PM",
			"commitName": "73ee6c3d270a91bd447f732b24c4d65169b0c8d6",
			"commitAuthor": "Stephen Colebourne",
			"subchanges": [
				{
					"type": "Ymovefromfile",
					"commitMessage": "Rework time package in preparation for 2.0 release\nDateUtils split to DateFormatUtils and DurationFormatUtils\nCalendarUtils renamed to DateUtils\nStopWatch time format method moved to DurationFormatUtils\nTests updated and pass\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/lang/trunk@137361 13f79535-47bb-0310-9956-ffa450edef68\n",
					"commitDate": "2003-06-08, 5:14 PM",
					"commitName": "73ee6c3d270a91bd447f732b24c4d65169b0c8d6",
					"commitAuthor": "Stephen Colebourne",
					"commitDateOld": "2003-06-08, 8:19 AM",
					"commitNameOld": "9bb3f9b9a3e513cbac7f02d6ee97995d741d09de",
					"commitAuthorOld": "Stephen Colebourne",
					"daysBetweenCommits": 0.37,
					"commitsBetweenForRepo": 1,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,74 +1,74 @@\n     private static void modify(Calendar val, int field, boolean round) {\n         boolean roundUp = false;\n         for (int i = 0; i < fields.length; i++) {\n             for (int j = 0; j < fields[i].length; j++) {\n                 if (fields[i][j] == field) {\n                     //This is our field... we stop looping\n                     if (round && roundUp) {\n-                        if (field == CalendarUtils.SEMI_MONTH) {\n+                        if (field == DateUtils.SEMI_MONTH) {\n                             //This is a special case that's hard to generalize\n                             //If the date is 1, we round up to 16, otherwise\n                             //  we subtract 15 days and add 1 month\n                             if (val.get(Calendar.DATE) == 1) {\n                                 val.add(Calendar.DATE, 15);\n                             } else {\n                                 val.add(Calendar.DATE, -15);\n                                 val.add(Calendar.MONTH, 1);\n                             }\n                         } else {\n                             //We need at add one to this field since the\n                             //  last number causes us to round up\n                             val.add(fields[i][0], 1);\n                         }\n                     }\n                     return;\n                 }\n             }\n             //We have various fields that are not easy roundings\n             int offset = 0;\n             boolean offsetSet = false;\n             //These are special types of fields that require different rounding rules\n             switch (field) {\n-                case CalendarUtils.SEMI_MONTH:\n+                case DateUtils.SEMI_MONTH:\n                     if (fields[i][0] == Calendar.DATE) {\n                         //If we're going to drop the DATE field's value,\n                         //  we want to do this our own way.\n                         //We need to subtrace 1 since the date has a minimum of 1\n                         offset = val.get(Calendar.DATE) - 1;\n                         //If we're above 15 days adjustment, that means we're in the\n                         //  bottom half of the month and should stay accordingly.\n                         if (offset >= 15) {\n                             offset -= 15;\n                         }\n                         //Record whether we're in the top or bottom half of that range\n                         roundUp = offset > 7;\n                         offsetSet = true;\n                     }\n                     break;\n                 case Calendar.AM_PM:\n                     if (fields[i][0] == Calendar.HOUR) {\n                         //If we're going to drop the HOUR field's value,\n                         //  we want to do this our own way.\n                         offset = val.get(Calendar.HOUR);\n                         if (offset >= 12) {\n                             offset -= 12;\n                         }\n                         roundUp = offset > 6;\n                         offsetSet = true;\n                     }\n                     break;\n             }\n             if (!offsetSet) {\n                 int min = val.getActualMinimum(fields[i][0]);\n                 int max = val.getActualMaximum(fields[i][0]);\n                 //Calculate the offset from the minimum allowed value\n                 offset = val.get(fields[i][0]) - min;\n                 //Set roundUp if this is more than half way between the minimum and maximum\n                 roundUp = offset > ((max - min) / 2);\n             }\n             //We need to remove this field\n             val.add(fields[i][0], -offset);\n         }\n         throw new RuntimeException(\"We do not support that field.\");\n \n     }\n\\ No newline at end of file\n",
					"extendedDetails": {
						"oldPath": "src/java/org/apache/commons/lang/time/CalendarUtils.java",
						"newPath": "src/java/org/apache/commons/lang/time/DateUtils.java",
						"oldMethodName": "modify",
						"newMethodName": "modify"
					}
				},
				{
					"type": "Ybodychange",
					"commitMessage": "Rework time package in preparation for 2.0 release\nDateUtils split to DateFormatUtils and DurationFormatUtils\nCalendarUtils renamed to DateUtils\nStopWatch time format method moved to DurationFormatUtils\nTests updated and pass\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/lang/trunk@137361 13f79535-47bb-0310-9956-ffa450edef68\n",
					"commitDate": "2003-06-08, 5:14 PM",
					"commitName": "73ee6c3d270a91bd447f732b24c4d65169b0c8d6",
					"commitAuthor": "Stephen Colebourne",
					"commitDateOld": "2003-06-08, 8:19 AM",
					"commitNameOld": "9bb3f9b9a3e513cbac7f02d6ee97995d741d09de",
					"commitAuthorOld": "Stephen Colebourne",
					"daysBetweenCommits": 0.37,
					"commitsBetweenForRepo": 1,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,74 +1,74 @@\n     private static void modify(Calendar val, int field, boolean round) {\n         boolean roundUp = false;\n         for (int i = 0; i < fields.length; i++) {\n             for (int j = 0; j < fields[i].length; j++) {\n                 if (fields[i][j] == field) {\n                     //This is our field... we stop looping\n                     if (round && roundUp) {\n-                        if (field == CalendarUtils.SEMI_MONTH) {\n+                        if (field == DateUtils.SEMI_MONTH) {\n                             //This is a special case that's hard to generalize\n                             //If the date is 1, we round up to 16, otherwise\n                             //  we subtract 15 days and add 1 month\n                             if (val.get(Calendar.DATE) == 1) {\n                                 val.add(Calendar.DATE, 15);\n                             } else {\n                                 val.add(Calendar.DATE, -15);\n                                 val.add(Calendar.MONTH, 1);\n                             }\n                         } else {\n                             //We need at add one to this field since the\n                             //  last number causes us to round up\n                             val.add(fields[i][0], 1);\n                         }\n                     }\n                     return;\n                 }\n             }\n             //We have various fields that are not easy roundings\n             int offset = 0;\n             boolean offsetSet = false;\n             //These are special types of fields that require different rounding rules\n             switch (field) {\n-                case CalendarUtils.SEMI_MONTH:\n+                case DateUtils.SEMI_MONTH:\n                     if (fields[i][0] == Calendar.DATE) {\n                         //If we're going to drop the DATE field's value,\n                         //  we want to do this our own way.\n                         //We need to subtrace 1 since the date has a minimum of 1\n                         offset = val.get(Calendar.DATE) - 1;\n                         //If we're above 15 days adjustment, that means we're in the\n                         //  bottom half of the month and should stay accordingly.\n                         if (offset >= 15) {\n                             offset -= 15;\n                         }\n                         //Record whether we're in the top or bottom half of that range\n                         roundUp = offset > 7;\n                         offsetSet = true;\n                     }\n                     break;\n                 case Calendar.AM_PM:\n                     if (fields[i][0] == Calendar.HOUR) {\n                         //If we're going to drop the HOUR field's value,\n                         //  we want to do this our own way.\n                         offset = val.get(Calendar.HOUR);\n                         if (offset >= 12) {\n                             offset -= 12;\n                         }\n                         roundUp = offset > 6;\n                         offsetSet = true;\n                     }\n                     break;\n             }\n             if (!offsetSet) {\n                 int min = val.getActualMinimum(fields[i][0]);\n                 int max = val.getActualMaximum(fields[i][0]);\n                 //Calculate the offset from the minimum allowed value\n                 offset = val.get(fields[i][0]) - min;\n                 //Set roundUp if this is more than half way between the minimum and maximum\n                 roundUp = offset > ((max - min) / 2);\n             }\n             //We need to remove this field\n             val.add(fields[i][0], -offset);\n         }\n         throw new RuntimeException(\"We do not support that field.\");\n \n     }\n\\ No newline at end of file\n",
					"extendedDetails": {}
				}
			]
		},
		"9c4166dbb25e1a0b53e0d776cddc9feececccc78": {
			"type": "Yfilerename",
			"commitMessage": "Create time subpackage\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/lang/trunk@137194 13f79535-47bb-0310-9956-ffa450edef68\n",
			"commitDate": "2002-12-18, 4:30 PM",
			"commitName": "9c4166dbb25e1a0b53e0d776cddc9feececccc78",
			"commitAuthor": "Stephen Colebourne",
			"commitDateOld": "2002-12-18, 4:28 PM",
			"commitNameOld": "55feeb72b96de4da9cc3535762ddf6b9d04209f7",
			"commitAuthorOld": "Stephen Colebourne",
			"daysBetweenCommits": 0,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "",
			"extendedDetails": {
				"oldPath": "src/java/org/apache/commons/lang/CalendarUtils.java",
				"newPath": "src/java/org/apache/commons/lang/time/CalendarUtils.java"
			}
		},
		"3d82f12dbdc8fbf971b61a360f2cd13c0a4fd8d5": {
			"type": "Yintroduced",
			"commitMessage": "CalendarUtils from the sandbox, for merger with DateUtils. Or parallel living.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/lang/trunk@137190 13f79535-47bb-0310-9956-ffa450edef68\n",
			"commitDate": "2002-12-16, 2:55 PM",
			"commitName": "3d82f12dbdc8fbf971b61a360f2cd13c0a4fd8d5",
			"commitAuthor": "Henri Yandell"
		}
	},
	"sha": "a36c903d4f1065bc59f5e6d2bb0f9d92a5e71d83"
}