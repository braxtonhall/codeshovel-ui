{
	"repo": "https://github.com/spring-projects/spring-framework.git",
	"file": "spring-webflux/src/main/java/org/springframework/web/reactive/result/method/annotation/ResponseBodyResultHandler.java",
	"method": {
		"longName": "ResponseBodyResultHandler::handleResult(ServerWebExchange exchange, HandlerResult result)",
		"startLine": 83,
		"methodName": "handleResult",
		"isStatic": false,
		"isAbstract": false,
		"visibility": "public"
	},
	"history": {
		"db69a082d9449ecb13f615316a382c100cab1f23": {
			"type": "Ybodychange",
			"commitMessage": "Avoid java.util.Optional signatures for simple field access\n\nIssue: SPR-15576\n",
			"commitDate": "2017-05-23, 2:05 PM",
			"commitName": "db69a082d9449ecb13f615316a382c100cab1f23",
			"commitAuthor": "Juergen Hoeller",
			"commitDateOld": "2017-03-24, 3:48 PM",
			"commitNameOld": "5414cd0cf8228d4cd1a3873ae18b4fcb91b6e556",
			"commitAuthorOld": "Rossen Stoyanchev",
			"daysBetweenCommits": 59.93,
			"commitsBetweenForRepo": 333,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,5 +1,5 @@\n \tpublic Mono<Void> handleResult(ServerWebExchange exchange, HandlerResult result) {\n-\t\tObject body = result.getReturnValue().orElse(null);\n+\t\tObject body = result.getReturnValue();\n \t\tMethodParameter bodyTypeParameter = result.getReturnTypeSource();\n \t\treturn writeBody(body, bodyTypeParameter, exchange);\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"fafd2d20e177d56b5d08dfa630b920d7095877da": {
			"type": "Yfilerename",
			"commitMessage": "Rename spring-web-reactive to spring-webflux\n\nIssue: SPR-15190\n",
			"commitDate": "2017-02-01, 3:02 PM",
			"commitName": "fafd2d20e177d56b5d08dfa630b920d7095877da",
			"commitAuthor": "Rossen Stoyanchev",
			"commitDateOld": "2017-02-01, 1:29 PM",
			"commitNameOld": "81d121797645c65cbfc5a85b73b3540e1ab0ea92",
			"commitAuthorOld": "Rossen Stoyanchev",
			"daysBetweenCommits": 0.06,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "",
			"extendedDetails": {
				"oldPath": "spring-web-reactive/src/main/java/org/springframework/web/reactive/result/method/annotation/ResponseBodyResultHandler.java",
				"newPath": "spring-webflux/src/main/java/org/springframework/web/reactive/result/method/annotation/ResponseBodyResultHandler.java"
			}
		},
		"101220bad1ac3b4082a08aff4e9c8254e71febaf": {
			"type": "Ybodychange",
			"commitMessage": "Add ReactiveAdapterRegistry\n\nIssue: SPR-14159\n",
			"commitDate": "2016-07-22, 10:21 AM",
			"commitName": "101220bad1ac3b4082a08aff4e9c8254e71febaf",
			"commitAuthor": "Rossen Stoyanchev",
			"commitDateOld": "2016-07-18, 8:16 PM",
			"commitNameOld": "4b92bf2af121075eae7ee55399841aff91984294",
			"commitAuthorOld": "Rossen Stoyanchev",
			"daysBetweenCommits": 3.59,
			"commitsBetweenForRepo": 38,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,6 +1,5 @@\n \tpublic Mono<Void> handleResult(ServerWebExchange exchange, HandlerResult result) {\n \t\tObject body = result.getReturnValue().orElse(null);\n-\t\tResolvableType bodyType = result.getReturnType();\n \t\tMethodParameter bodyTypeParameter = result.getReturnTypeSource();\n-\t\treturn writeBody(exchange, body, bodyType, bodyTypeParameter);\n+\t\treturn writeBody(body, bodyTypeParameter, exchange);\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"8c7658144284f2f47124c6ac8131f53320091551": {
			"type": "Ybodychange",
			"commitMessage": "Provide rich type information to ConversionService\n\nWhen using the ConversionService to check and bridge to and from\nreactive types we now generallly provide the full type information\navailable from method signatures. However that full type information\nis not always necessary such as when we perform additional checks on\nthe generics of the reactive type (e.g. Mono<ResponseEntity>).\n\nThis allows us to switch to use DefaultFormattingConversionService\ninstead of GenericConversionService while also ensuring that the\nCollectionToObjectConverter doesn't think it can convert List<?> to\nany reactive type.\n\nThe ObjectToObjectConverter can also interfere because it is smart\nenough to find the \"from(Publisher<?>)\" method on Flux and Mono.\nTo make up for that on the response side we now check if a type\nis assignable to Publisher first in which case it is a simple cast.\n\nIn turn that means we don't need a PublisherToFluxConverter which can\nbe problematic in its own right because it can convert from Mono to\nFlux which technically doesn't lose data but switches stream semantics.\n\nIssue: #124, #128\n",
			"commitDate": "2016-07-03, 7:55 PM",
			"commitName": "8c7658144284f2f47124c6ac8131f53320091551",
			"commitAuthor": "Rossen Stoyanchev",
			"commitDateOld": "2016-07-03, 7:54 PM",
			"commitNameOld": "fb2e79604859a5b6fbc9b1c491caee8c3a9dbdcc",
			"commitAuthorOld": "Rossen Stoyanchev",
			"daysBetweenCommits": 0,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,5 +1,6 @@\n \tpublic Mono<Void> handleResult(ServerWebExchange exchange, HandlerResult result) {\n \t\tObject body = result.getReturnValue().orElse(null);\n \t\tResolvableType bodyType = result.getReturnType();\n-\t\treturn writeBody(exchange, body, bodyType);\n+\t\tMethodParameter bodyTypeParameter = result.getReturnTypeSource();\n+\t\treturn writeBody(exchange, body, bodyType, bodyTypeParameter);\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"dffd6d674ab9415caed1b82755634f52383cd7ba": {
			"type": "Ybodychange",
			"commitMessage": "Shorten returnValueType name in HandlerResult\n",
			"commitDate": "2016-07-01, 4:00 PM",
			"commitName": "dffd6d674ab9415caed1b82755634f52383cd7ba",
			"commitAuthor": "Rossen Stoyanchev",
			"commitDateOld": "2016-06-27, 7:00 AM",
			"commitNameOld": "699b0571267e5a27897f6d6d6304d18006ceed85",
			"commitAuthorOld": "Rossen Stoyanchev",
			"daysBetweenCommits": 4.37,
			"commitsBetweenForRepo": 27,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,5 +1,5 @@\n \tpublic Mono<Void> handleResult(ServerWebExchange exchange, HandlerResult result) {\n \t\tObject body = result.getReturnValue().orElse(null);\n-\t\tResolvableType bodyType = result.getReturnValueType();\n+\t\tResolvableType bodyType = result.getReturnType();\n \t\treturn writeBody(exchange, body, bodyType);\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"9aa6f5caacac316c74e374550a387f222e7e1921": {
			"type": "Ybodychange",
			"commitMessage": "Add support for ResponseEntity result handling\n",
			"commitDate": "2016-06-21, 3:27 PM",
			"commitName": "9aa6f5caacac316c74e374550a387f222e7e1921",
			"commitAuthor": "Rossen Stoyanchev",
			"commitDateOld": "2016-06-06, 3:43 PM",
			"commitNameOld": "0a88d5983aedfaa7165d332d415df5e0341c4128",
			"commitAuthorOld": "Rossen Stoyanchev",
			"daysBetweenCommits": 14.99,
			"commitsBetweenForRepo": 19,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,38 +1,5 @@\n \tpublic Mono<Void> handleResult(ServerWebExchange exchange, HandlerResult result) {\n-\n-\t\tPublisher<?> publisher;\n-\t\tResolvableType elementType;\n-\t\tResolvableType returnType = result.getReturnValueType();\n-\n-\t\tif (getConversionService().canConvert(returnType.getRawClass(), Publisher.class)) {\n-\t\t\tOptional<Object> optionalValue = result.getReturnValue();\n-\t\t\tif (optionalValue.isPresent()) {\n-\t\t\t\tpublisher = getConversionService().convert(optionalValue.get(), Publisher.class);\n-\t\t\t}\n-\t\t\telse {\n-\t\t\t\tpublisher = Mono.empty();\n-\t\t\t}\n-\t\t\telementType = returnType.getGeneric(0);\n-\t\t\tif (Void.class.equals(elementType.getRawClass())) {\n-\t\t\t\treturn Mono.from((Publisher<Void>)publisher);\n-\t\t\t}\n-\t\t}\n-\t\telse {\n-\t\t\tpublisher = Mono.justOrEmpty(result.getReturnValue());\n-\t\t\telementType = returnType;\n-\t\t}\n-\n-\t\tList<MediaType> producibleTypes = getProducibleMediaTypes(elementType);\n-\t\tMediaType bestMediaType = selectMediaType(exchange, producibleTypes);\n-\n-\t\tif (bestMediaType != null) {\n-\t\t\tfor (HttpMessageConverter<?> converter : this.messageConverters) {\n-\t\t\t\tif (converter.canWrite(elementType, bestMediaType)) {\n-\t\t\t\t\tServerHttpResponse response = exchange.getResponse();\n-\t\t\t\t\treturn converter.write((Publisher) publisher, elementType, bestMediaType, response);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\n-\t\treturn Mono.error(new NotAcceptableStatusException(producibleTypes));\n+\t\tObject body = result.getReturnValue().orElse(null);\n+\t\tResolvableType bodyType = result.getReturnValueType();\n+\t\treturn writeBody(exchange, body, bodyType);\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"1b308cffbf5a6d6b4e71b8b991ae698f822ab5f1": {
			"type": "Ybodychange",
			"commitMessage": "Introduce base class for ResponseBodyResultHandler\n\nThe ContentNegotiatingResultHandlerSupport base class encapsulates the\nlogic for content negotiation needed for both @ResponseBody and view\nresolution result handling.\n",
			"commitDate": "2016-05-31, 2:33 PM",
			"commitName": "1b308cffbf5a6d6b4e71b8b991ae698f822ab5f1",
			"commitAuthor": "Rossen Stoyanchev",
			"commitDateOld": "2016-05-26, 3:48 PM",
			"commitNameOld": "793638e610fa01cfffa53e1edcab56c98b2d5751",
			"commitAuthorOld": "Rossen Stoyanchev",
			"daysBetweenCommits": 4.95,
			"commitsBetweenForRepo": 15,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,45 +1,38 @@\n \tpublic Mono<Void> handleResult(ServerWebExchange exchange, HandlerResult result) {\n \n \t\tPublisher<?> publisher;\n \t\tResolvableType elementType;\n \t\tResolvableType returnType = result.getReturnValueType();\n \n-\t\tif (this.conversionService.canConvert(returnType.getRawClass(), Publisher.class)) {\n+\t\tif (getConversionService().canConvert(returnType.getRawClass(), Publisher.class)) {\n \t\t\tOptional<Object> optionalValue = result.getReturnValue();\n \t\t\tif (optionalValue.isPresent()) {\n-\t\t\t\tpublisher = this.conversionService.convert(optionalValue.get(), Publisher.class);\n+\t\t\t\tpublisher = getConversionService().convert(optionalValue.get(), Publisher.class);\n \t\t\t}\n \t\t\telse {\n \t\t\t\tpublisher = Mono.empty();\n \t\t\t}\n \t\t\telementType = returnType.getGeneric(0);\n \t\t\tif (Void.class.equals(elementType.getRawClass())) {\n \t\t\t\treturn Mono.from((Publisher<Void>)publisher);\n \t\t\t}\n \t\t}\n \t\telse {\n \t\t\tpublisher = Mono.justOrEmpty(result.getReturnValue());\n \t\t\telementType = returnType;\n \t\t}\n \n-\t\tList<MediaType> compatibleMediaTypes = getCompatibleMediaTypes(exchange, elementType);\n-\t\tif (compatibleMediaTypes.isEmpty()) {\n-\t\t\tif (result.getReturnValue().isPresent()) {\n-\t\t\t\tList<MediaType> mediaTypes = getProducibleMediaTypes(exchange, elementType);\n-\t\t\t\treturn Mono.error(new NotAcceptableStatusException(mediaTypes));\n-\t\t\t}\n-\t\t\treturn Mono.empty();\n-\t\t}\n+\t\tList<MediaType> producibleTypes = getProducibleMediaTypes(elementType);\n+\t\tMediaType bestMediaType = selectMediaType(exchange, producibleTypes);\n \n-\t\tMediaType bestMediaType = selectBestMediaType(compatibleMediaTypes);\n \t\tif (bestMediaType != null) {\n \t\t\tfor (HttpMessageConverter<?> converter : this.messageConverters) {\n \t\t\t\tif (converter.canWrite(elementType, bestMediaType)) {\n \t\t\t\t\tServerHttpResponse response = exchange.getResponse();\n \t\t\t\t\treturn converter.write((Publisher) publisher, elementType, bestMediaType, response);\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n-\t\treturn Mono.error(new NotAcceptableStatusException(this.supportedMediaTypes));\n+\t\treturn Mono.error(new NotAcceptableStatusException(producibleTypes));\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"318b15c321963ad772ae9e4762c25b205047a463": {
			"type": "Ybodychange",
			"commitMessage": "Polish\n",
			"commitDate": "2016-05-26, 11:39 AM",
			"commitName": "318b15c321963ad772ae9e4762c25b205047a463",
			"commitAuthor": "Rossen Stoyanchev",
			"commitDateOld": "2016-05-26, 11:34 AM",
			"commitNameOld": "2263954ad7d760c145eeaf4b02c2e9a68f118ad1",
			"commitAuthorOld": "Rossen Stoyanchev",
			"daysBetweenCommits": 0,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,44 +1,45 @@\n \tpublic Mono<Void> handleResult(ServerWebExchange exchange, HandlerResult result) {\n \n \t\tPublisher<?> publisher;\n \t\tResolvableType elementType;\n \t\tResolvableType returnType = result.getReturnValueType();\n \n \t\tif (this.conversionService.canConvert(returnType.getRawClass(), Publisher.class)) {\n \t\t\tOptional<Object> optionalValue = result.getReturnValue();\n \t\t\tif (optionalValue.isPresent()) {\n \t\t\t\tpublisher = this.conversionService.convert(optionalValue.get(), Publisher.class);\n \t\t\t}\n \t\t\telse {\n \t\t\t\tpublisher = Mono.empty();\n \t\t\t}\n \t\t\telementType = returnType.getGeneric(0);\n \t\t\tif (Void.class.equals(elementType.getRawClass())) {\n \t\t\t\treturn Mono.from((Publisher<Void>)publisher);\n \t\t\t}\n \t\t}\n \t\telse {\n \t\t\tpublisher = Mono.justOrEmpty(result.getReturnValue());\n \t\t\telementType = returnType;\n \t\t}\n \n \t\tList<MediaType> compatibleMediaTypes = getCompatibleMediaTypes(exchange, elementType);\n \t\tif (compatibleMediaTypes.isEmpty()) {\n \t\t\tif (result.getReturnValue().isPresent()) {\n \t\t\t\tList<MediaType> mediaTypes = getProducibleMediaTypes(exchange, elementType);\n \t\t\t\treturn Mono.error(new NotAcceptableStatusException(mediaTypes));\n \t\t\t}\n \t\t\treturn Mono.empty();\n \t\t}\n \n \t\tMediaType bestMediaType = selectBestMediaType(compatibleMediaTypes);\n \t\tif (bestMediaType != null) {\n-\t\t\tHttpMessageConverter<?> converter = resolveEncoder(elementType, bestMediaType);\n-\t\t\tif (converter != null) {\n-\t\t\t\tServerHttpResponse response = exchange.getResponse();\n-\t\t\t\treturn converter.write((Publisher) publisher, elementType, bestMediaType, response);\n+\t\t\tfor (HttpMessageConverter<?> converter : this.messageConverters) {\n+\t\t\t\tif (converter.canWrite(elementType, bestMediaType)) {\n+\t\t\t\t\tServerHttpResponse response = exchange.getResponse();\n+\t\t\t\t\treturn converter.write((Publisher) publisher, elementType, bestMediaType, response);\n+\t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\treturn Mono.error(new NotAcceptableStatusException(this.supportedMediaTypes));\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"2263954ad7d760c145eeaf4b02c2e9a68f118ad1": {
			"type": "Ybodychange",
			"commitMessage": "Respect produces condition in @ResponseBody algorithm\n",
			"commitDate": "2016-05-26, 11:34 AM",
			"commitName": "2263954ad7d760c145eeaf4b02c2e9a68f118ad1",
			"commitAuthor": "Rossen Stoyanchev",
			"commitDateOld": "2016-05-26, 9:05 AM",
			"commitNameOld": "a017e2848a792038b10eec635ab10e4809a2883b",
			"commitAuthorOld": "Rossen Stoyanchev",
			"daysBetweenCommits": 0.1,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,45 +1,44 @@\n \tpublic Mono<Void> handleResult(ServerWebExchange exchange, HandlerResult result) {\n \n \t\tPublisher<?> publisher;\n \t\tResolvableType elementType;\n \t\tResolvableType returnType = result.getReturnValueType();\n \n \t\tif (this.conversionService.canConvert(returnType.getRawClass(), Publisher.class)) {\n \t\t\tOptional<Object> optionalValue = result.getReturnValue();\n \t\t\tif (optionalValue.isPresent()) {\n \t\t\t\tpublisher = this.conversionService.convert(optionalValue.get(), Publisher.class);\n \t\t\t}\n \t\t\telse {\n \t\t\t\tpublisher = Mono.empty();\n \t\t\t}\n \t\t\telementType = returnType.getGeneric(0);\n \t\t\tif (Void.class.equals(elementType.getRawClass())) {\n \t\t\t\treturn Mono.from((Publisher<Void>)publisher);\n \t\t\t}\n \t\t}\n \t\telse {\n \t\t\tpublisher = Mono.justOrEmpty(result.getReturnValue());\n \t\t\telementType = returnType;\n \t\t}\n \n-\t\tServerHttpRequest request = exchange.getRequest();\n \t\tList<MediaType> compatibleMediaTypes = getCompatibleMediaTypes(exchange, elementType);\n \t\tif (compatibleMediaTypes.isEmpty()) {\n \t\t\tif (result.getReturnValue().isPresent()) {\n-\t\t\t\tList<MediaType> mediaTypes = getProducibleMediaTypes(elementType);\n+\t\t\t\tList<MediaType> mediaTypes = getProducibleMediaTypes(exchange, elementType);\n \t\t\t\treturn Mono.error(new NotAcceptableStatusException(mediaTypes));\n \t\t\t}\n \t\t\treturn Mono.empty();\n \t\t}\n \n \t\tMediaType bestMediaType = selectBestMediaType(compatibleMediaTypes);\n \t\tif (bestMediaType != null) {\n \t\t\tHttpMessageConverter<?> converter = resolveEncoder(elementType, bestMediaType);\n \t\t\tif (converter != null) {\n \t\t\t\tServerHttpResponse response = exchange.getResponse();\n \t\t\t\treturn converter.write((Publisher) publisher, elementType, bestMediaType, response);\n \t\t\t}\n \t\t}\n \n \t\treturn Mono.error(new NotAcceptableStatusException(this.supportedMediaTypes));\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"37404d081e807c1f4926590a78f1d4da266fb5c3": {
			"type": "Ybodychange",
			"commitMessage": "Use ContentTypeResolver for content negotiation\n",
			"commitDate": "2016-05-26, 8:52 AM",
			"commitName": "37404d081e807c1f4926590a78f1d4da266fb5c3",
			"commitAuthor": "Rossen Stoyanchev",
			"commitDateOld": "2016-05-25, 3:35 PM",
			"commitNameOld": "2292e46b04c65d4f3f8193b0eab249a8058e59a8",
			"commitAuthorOld": "Rossen Stoyanchev",
			"daysBetweenCommits": 0.72,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,42 +1,45 @@\n \tpublic Mono<Void> handleResult(ServerWebExchange exchange, HandlerResult result) {\n \n \t\tPublisher<?> publisher;\n \t\tResolvableType elementType;\n \t\tResolvableType returnType = result.getReturnValueType();\n \n \t\tif (this.conversionService.canConvert(returnType.getRawClass(), Publisher.class)) {\n \t\t\tOptional<Object> optionalValue = result.getReturnValue();\n \t\t\tif (optionalValue.isPresent()) {\n \t\t\t\tpublisher = this.conversionService.convert(optionalValue.get(), Publisher.class);\n \t\t\t}\n \t\t\telse {\n \t\t\t\tpublisher = Mono.empty();\n \t\t\t}\n \t\t\telementType = returnType.getGeneric(0);\n \t\t\tif (Void.class.equals(elementType.getRawClass())) {\n \t\t\t\treturn Mono.from((Publisher<Void>)publisher);\n \t\t\t}\n \t\t}\n \t\telse {\n \t\t\tpublisher = Mono.justOrEmpty(result.getReturnValue());\n \t\t\telementType = returnType;\n \t\t}\n \n \t\tServerHttpRequest request = exchange.getRequest();\n-\t\tList<MediaType> compatibleMediaTypes = getCompatibleMediaTypes(request, elementType);\n+\t\tList<MediaType> compatibleMediaTypes = getCompatibleMediaTypes(exchange, elementType);\n \t\tif (compatibleMediaTypes.isEmpty()) {\n-\t\t\tList<MediaType> supported = getProducibleMediaTypes(elementType);\n-\t\t\treturn Mono.error(new NotAcceptableStatusException(supported));\n+\t\t\tif (result.getReturnValue().isPresent()) {\n+\t\t\t\tList<MediaType> mediaTypes = getProducibleMediaTypes(elementType);\n+\t\t\t\treturn Mono.error(new NotAcceptableStatusException(mediaTypes));\n+\t\t\t}\n+\t\t\treturn Mono.empty();\n \t\t}\n \n \t\tMediaType bestMediaType = selectBestMediaType(compatibleMediaTypes);\n \t\tif (bestMediaType != null) {\n \t\t\tHttpMessageConverter<?> converter = resolveEncoder(elementType, bestMediaType);\n \t\t\tif (converter != null) {\n \t\t\t\tServerHttpResponse response = exchange.getResponse();\n \t\t\t\treturn converter.write((Publisher) publisher, elementType, bestMediaType, response);\n \t\t\t}\n \t\t}\n \n \t\treturn Mono.error(new NotAcceptableStatusException(this.supportedMediaTypes));\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"2292e46b04c65d4f3f8193b0eab249a8058e59a8": {
			"type": "Ybodychange",
			"commitMessage": "Update empty return value ResponseBody handling\n\nWhen a null is returned from an @ResponseBody method, rather than\nreturning Mono.empty() immediately, convert it to Mono.empty() and\napply the same processing.\n\nCurrently that doesn't make a practical difference but it's more\naccurate to do it this way. Eventually it may mean the possibility\nto turn empty values into something through an extension point\nas we do with ResponseBodyAdvice in Spring MVC today.\n",
			"commitDate": "2016-05-25, 3:35 PM",
			"commitName": "2292e46b04c65d4f3f8193b0eab249a8058e59a8",
			"commitAuthor": "Rossen Stoyanchev",
			"commitDateOld": "2016-05-25, 3:34 PM",
			"commitNameOld": "91d063899bd816cc57815ac0b2317b3ab674868e",
			"commitAuthorOld": "Rossen Stoyanchev",
			"daysBetweenCommits": 0,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,40 +1,42 @@\n \tpublic Mono<Void> handleResult(ServerWebExchange exchange, HandlerResult result) {\n \n-\t\tOptional<Object> value = result.getReturnValue();\n-\t\tif (!value.isPresent()) {\n-\t\t\treturn Mono.empty();\n-\t\t}\n-\n \t\tPublisher<?> publisher;\n \t\tResolvableType elementType;\n \t\tResolvableType returnType = result.getReturnValueType();\n+\n \t\tif (this.conversionService.canConvert(returnType.getRawClass(), Publisher.class)) {\n-\t\t\tpublisher = this.conversionService.convert(value.get(), Publisher.class);\n+\t\t\tOptional<Object> optionalValue = result.getReturnValue();\n+\t\t\tif (optionalValue.isPresent()) {\n+\t\t\t\tpublisher = this.conversionService.convert(optionalValue.get(), Publisher.class);\n+\t\t\t}\n+\t\t\telse {\n+\t\t\t\tpublisher = Mono.empty();\n+\t\t\t}\n \t\t\telementType = returnType.getGeneric(0);\n \t\t\tif (Void.class.equals(elementType.getRawClass())) {\n \t\t\t\treturn Mono.from((Publisher<Void>)publisher);\n \t\t\t}\n \t\t}\n \t\telse {\n-\t\t\tpublisher = Mono.just(value.get());\n+\t\t\tpublisher = Mono.justOrEmpty(result.getReturnValue());\n \t\t\telementType = returnType;\n \t\t}\n \n \t\tServerHttpRequest request = exchange.getRequest();\n \t\tList<MediaType> compatibleMediaTypes = getCompatibleMediaTypes(request, elementType);\n \t\tif (compatibleMediaTypes.isEmpty()) {\n \t\t\tList<MediaType> supported = getProducibleMediaTypes(elementType);\n \t\t\treturn Mono.error(new NotAcceptableStatusException(supported));\n \t\t}\n \n \t\tMediaType bestMediaType = selectBestMediaType(compatibleMediaTypes);\n \t\tif (bestMediaType != null) {\n \t\t\tHttpMessageConverter<?> converter = resolveEncoder(elementType, bestMediaType);\n \t\t\tif (converter != null) {\n \t\t\t\tServerHttpResponse response = exchange.getResponse();\n \t\t\t\treturn converter.write((Publisher) publisher, elementType, bestMediaType, response);\n \t\t\t}\n \t\t}\n \n \t\treturn Mono.error(new NotAcceptableStatusException(this.supportedMediaTypes));\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"91d063899bd816cc57815ac0b2317b3ab674868e": {
			"type": "Ybodychange",
			"commitMessage": "Polish ResponseBody result handling\n",
			"commitDate": "2016-05-25, 3:34 PM",
			"commitName": "91d063899bd816cc57815ac0b2317b3ab674868e",
			"commitAuthor": "Rossen Stoyanchev",
			"commitDateOld": "2016-04-20, 8:27 AM",
			"commitNameOld": "804f69c8b6e8156462449a310a1e0865eb329b61",
			"commitAuthorOld": "Arjen Poutsma",
			"daysBetweenCommits": 35.3,
			"commitsBetweenForRepo": 28,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,44 +1,40 @@\n \tpublic Mono<Void> handleResult(ServerWebExchange exchange, HandlerResult result) {\n \n \t\tOptional<Object> value = result.getReturnValue();\n \t\tif (!value.isPresent()) {\n \t\t\treturn Mono.empty();\n \t\t}\n \n \t\tPublisher<?> publisher;\n \t\tResolvableType elementType;\n \t\tResolvableType returnType = result.getReturnValueType();\n \t\tif (this.conversionService.canConvert(returnType.getRawClass(), Publisher.class)) {\n \t\t\tpublisher = this.conversionService.convert(value.get(), Publisher.class);\n \t\t\telementType = returnType.getGeneric(0);\n \t\t\tif (Void.class.equals(elementType.getRawClass())) {\n \t\t\t\treturn Mono.from((Publisher<Void>)publisher);\n \t\t\t}\n \t\t}\n \t\telse {\n \t\t\tpublisher = Mono.just(value.get());\n \t\t\telementType = returnType;\n \t\t}\n \n-\t\tList<MediaType> compatibleMediaTypes =\n-\t\t\t\tgetCompatibleMediaTypes(exchange.getRequest(), elementType);\n+\t\tServerHttpRequest request = exchange.getRequest();\n+\t\tList<MediaType> compatibleMediaTypes = getCompatibleMediaTypes(request, elementType);\n \t\tif (compatibleMediaTypes.isEmpty()) {\n-\t\t\treturn Mono.error(new NotAcceptableStatusException(\n-\t\t\t\t\tgetProducibleMediaTypes(elementType)));\n+\t\t\tList<MediaType> supported = getProducibleMediaTypes(elementType);\n+\t\t\treturn Mono.error(new NotAcceptableStatusException(supported));\n \t\t}\n \n-\t\tOptional<MediaType> selectedMediaType = selectBestMediaType(compatibleMediaTypes);\n-\n-\t\tif (selectedMediaType.isPresent()) {\n-\t\t\tHttpMessageConverter<?> converter =\n-\t\t\t\t\tresolveEncoder(elementType, selectedMediaType.get());\n+\t\tMediaType bestMediaType = selectBestMediaType(compatibleMediaTypes);\n+\t\tif (bestMediaType != null) {\n+\t\t\tHttpMessageConverter<?> converter = resolveEncoder(elementType, bestMediaType);\n \t\t\tif (converter != null) {\n \t\t\t\tServerHttpResponse response = exchange.getResponse();\n-\t\t\t\treturn converter.write((Publisher) publisher, elementType,\n-\t\t\t\t\t\tselectedMediaType.get(),\n-\t\t\t\t\t\t\t\tresponse);\n+\t\t\t\treturn converter.write((Publisher) publisher, elementType, bestMediaType, response);\n \t\t\t}\n \t\t}\n \n-\t\treturn Mono.error(new NotAcceptableStatusException(this.allMediaTypes));\n+\t\treturn Mono.error(new NotAcceptableStatusException(this.supportedMediaTypes));\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"804f69c8b6e8156462449a310a1e0865eb329b61": {
			"type": "Ybodychange",
			"commitMessage": "Wrapping up zero-copy support\n\nThis commit wraps up the previous commits:\n\n - It uses HttpMessageConverter in the web.reactive.server package instead of Encoder/Decoder.\n - It introduces tests for the Resource @ResponseBodies.\n",
			"commitDate": "2016-04-20, 8:27 AM",
			"commitName": "804f69c8b6e8156462449a310a1e0865eb329b61",
			"commitAuthor": "Arjen Poutsma",
			"commitDateOld": "2016-04-19, 2:02 PM",
			"commitNameOld": "6b7360fed1741bd9f7208f993f1df0036e2137d6",
			"commitAuthorOld": "Rossen Stoyanchev",
			"daysBetweenCommits": 0.77,
			"commitsBetweenForRepo": 9,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,70 +1,44 @@\n \tpublic Mono<Void> handleResult(ServerWebExchange exchange, HandlerResult result) {\n \n \t\tOptional<Object> value = result.getReturnValue();\n \t\tif (!value.isPresent()) {\n \t\t\treturn Mono.empty();\n \t\t}\n \n \t\tPublisher<?> publisher;\n \t\tResolvableType elementType;\n \t\tResolvableType returnType = result.getReturnValueType();\n \t\tif (this.conversionService.canConvert(returnType.getRawClass(), Publisher.class)) {\n \t\t\tpublisher = this.conversionService.convert(value.get(), Publisher.class);\n \t\t\telementType = returnType.getGeneric(0);\n \t\t\tif (Void.class.equals(elementType.getRawClass())) {\n \t\t\t\treturn Mono.from((Publisher<Void>)publisher);\n \t\t\t}\n \t\t}\n \t\telse {\n \t\t\tpublisher = Mono.just(value.get());\n \t\t\telementType = returnType;\n \t\t}\n \n-\t\tList<MediaType> requestedMediaTypes = getAcceptableMediaTypes(exchange.getRequest());\n-\t\tList<MediaType> producibleMediaTypes = getProducibleMediaTypes(elementType);\n-\n-\t\tif (producibleMediaTypes.isEmpty()) {\n-\t\t\tproducibleMediaTypes.add(MediaType.ALL);\n-\t\t}\n-\n-\t\tSet<MediaType> compatibleMediaTypes = new LinkedHashSet<>();\n-\t\tfor (MediaType requestedType : requestedMediaTypes) {\n-\t\t\tfor (MediaType producibleType : producibleMediaTypes) {\n-\t\t\t\tif (requestedType.isCompatibleWith(producibleType)) {\n-\t\t\t\t\tcompatibleMediaTypes.add(getMostSpecificMediaType(requestedType, producibleType));\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n+\t\tList<MediaType> compatibleMediaTypes =\n+\t\t\t\tgetCompatibleMediaTypes(exchange.getRequest(), elementType);\n \t\tif (compatibleMediaTypes.isEmpty()) {\n-\t\t\treturn Mono.error(new NotAcceptableStatusException(producibleMediaTypes));\n+\t\t\treturn Mono.error(new NotAcceptableStatusException(\n+\t\t\t\t\tgetProducibleMediaTypes(elementType)));\n \t\t}\n \n-\t\tList<MediaType> mediaTypes = new ArrayList<>(compatibleMediaTypes);\n-\t\tMediaType.sortBySpecificityAndQuality(mediaTypes);\n+\t\tOptional<MediaType> selectedMediaType = selectBestMediaType(compatibleMediaTypes);\n \n-\t\tMediaType selectedMediaType = null;\n-\t\tfor (MediaType mediaType : mediaTypes) {\n-\t\t\tif (mediaType.isConcrete()) {\n-\t\t\t\tselectedMediaType = mediaType;\n-\t\t\t\tbreak;\n-\t\t\t}\n-\t\t\telse if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n-\t\t\t\tselectedMediaType = MediaType.APPLICATION_OCTET_STREAM;\n-\t\t\t\tbreak;\n-\t\t\t}\n-\t\t}\n-\n-\t\tif (selectedMediaType != null) {\n-\t\t\tEncoder<?> encoder = resolveEncoder(elementType, selectedMediaType);\n-\t\t\tif (encoder != null) {\n+\t\tif (selectedMediaType.isPresent()) {\n+\t\t\tHttpMessageConverter<?> converter =\n+\t\t\t\t\tresolveEncoder(elementType, selectedMediaType.get());\n+\t\t\tif (converter != null) {\n \t\t\t\tServerHttpResponse response = exchange.getResponse();\n-\t\t\t\tresponse.getHeaders().setContentType(selectedMediaType);\n-\t\t\t\tDataBufferAllocator allocator = response.allocator();\n-\t\t\t\treturn response.setBody(\n-\t\t\t\t\t\tencoder.encode((Publisher) publisher, allocator, elementType,\n-\t\t\t\t\t\t\t\tselectedMediaType));\n+\t\t\t\treturn converter.write((Publisher) publisher, elementType,\n+\t\t\t\t\t\tselectedMediaType.get(),\n+\t\t\t\t\t\t\t\tresponse);\n \t\t\t}\n \t\t}\n \n \t\treturn Mono.error(new NotAcceptableStatusException(this.allMediaTypes));\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"6b7360fed1741bd9f7208f993f1df0036e2137d6": {
			"type": "Ybodychange",
			"commitMessage": "Apply new ResponseStatusException hierarchy\n\nThis commit replaces use of the existing ServletException-based\nexceptions with the new ones from ~.web.server.\n",
			"commitDate": "2016-04-19, 2:02 PM",
			"commitName": "6b7360fed1741bd9f7208f993f1df0036e2137d6",
			"commitAuthor": "Rossen Stoyanchev",
			"commitDateOld": "2016-04-14, 2:15 PM",
			"commitNameOld": "341f23e0e666ce0a00090fe1cad91caa7cb5e97c",
			"commitAuthorOld": "Rossen Stoyanchev",
			"daysBetweenCommits": 4.99,
			"commitsBetweenForRepo": 24,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,70 +1,70 @@\n \tpublic Mono<Void> handleResult(ServerWebExchange exchange, HandlerResult result) {\n \n \t\tOptional<Object> value = result.getReturnValue();\n \t\tif (!value.isPresent()) {\n \t\t\treturn Mono.empty();\n \t\t}\n \n \t\tPublisher<?> publisher;\n \t\tResolvableType elementType;\n \t\tResolvableType returnType = result.getReturnValueType();\n \t\tif (this.conversionService.canConvert(returnType.getRawClass(), Publisher.class)) {\n \t\t\tpublisher = this.conversionService.convert(value.get(), Publisher.class);\n \t\t\telementType = returnType.getGeneric(0);\n \t\t\tif (Void.class.equals(elementType.getRawClass())) {\n \t\t\t\treturn Mono.from((Publisher<Void>)publisher);\n \t\t\t}\n \t\t}\n \t\telse {\n \t\t\tpublisher = Mono.just(value.get());\n \t\t\telementType = returnType;\n \t\t}\n \n \t\tList<MediaType> requestedMediaTypes = getAcceptableMediaTypes(exchange.getRequest());\n \t\tList<MediaType> producibleMediaTypes = getProducibleMediaTypes(elementType);\n \n \t\tif (producibleMediaTypes.isEmpty()) {\n \t\t\tproducibleMediaTypes.add(MediaType.ALL);\n \t\t}\n \n \t\tSet<MediaType> compatibleMediaTypes = new LinkedHashSet<>();\n \t\tfor (MediaType requestedType : requestedMediaTypes) {\n \t\t\tfor (MediaType producibleType : producibleMediaTypes) {\n \t\t\t\tif (requestedType.isCompatibleWith(producibleType)) {\n \t\t\t\t\tcompatibleMediaTypes.add(getMostSpecificMediaType(requestedType, producibleType));\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\tif (compatibleMediaTypes.isEmpty()) {\n-\t\t\treturn Mono.error(new HttpMediaTypeNotAcceptableException(producibleMediaTypes));\n+\t\t\treturn Mono.error(new NotAcceptableStatusException(producibleMediaTypes));\n \t\t}\n \n \t\tList<MediaType> mediaTypes = new ArrayList<>(compatibleMediaTypes);\n \t\tMediaType.sortBySpecificityAndQuality(mediaTypes);\n \n \t\tMediaType selectedMediaType = null;\n \t\tfor (MediaType mediaType : mediaTypes) {\n \t\t\tif (mediaType.isConcrete()) {\n \t\t\t\tselectedMediaType = mediaType;\n \t\t\t\tbreak;\n \t\t\t}\n \t\t\telse if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n \t\t\t\tselectedMediaType = MediaType.APPLICATION_OCTET_STREAM;\n \t\t\t\tbreak;\n \t\t\t}\n \t\t}\n \n \t\tif (selectedMediaType != null) {\n \t\t\tEncoder<?> encoder = resolveEncoder(elementType, selectedMediaType);\n \t\t\tif (encoder != null) {\n \t\t\t\tServerHttpResponse response = exchange.getResponse();\n \t\t\t\tresponse.getHeaders().setContentType(selectedMediaType);\n \t\t\t\tDataBufferAllocator allocator = response.allocator();\n \t\t\t\treturn response.setBody(\n \t\t\t\t\t\tencoder.encode((Publisher) publisher, allocator, elementType,\n \t\t\t\t\t\t\t\tselectedMediaType));\n \t\t\t}\n \t\t}\n \n-\t\treturn Mono.error(new HttpMediaTypeNotAcceptableException(this.allMediaTypes));\n+\t\treturn Mono.error(new NotAcceptableStatusException(this.allMediaTypes));\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"341f23e0e666ce0a00090fe1cad91caa7cb5e97c": {
			"type": "Yfilerename",
			"commitMessage": "Add \"result\" package under ~.web.reactive\n\nThe new package is parallel to the \"mvc\" package under spring-webmvc\nand a place to hold the various programming model styles.\n",
			"commitDate": "2016-04-14, 2:15 PM",
			"commitName": "341f23e0e666ce0a00090fe1cad91caa7cb5e97c",
			"commitAuthor": "Rossen Stoyanchev",
			"commitDateOld": "2016-04-14, 1:17 PM",
			"commitNameOld": "3460e577ad86c6d660bab066e751911b16182f73",
			"commitAuthorOld": "Rossen Stoyanchev",
			"daysBetweenCommits": 0.04,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "",
			"extendedDetails": {
				"oldPath": "spring-web-reactive/src/main/java/org/springframework/web/reactive/method/annotation/ResponseBodyResultHandler.java",
				"newPath": "spring-web-reactive/src/main/java/org/springframework/web/reactive/result/method/annotation/ResponseBodyResultHandler.java"
			}
		},
		"7f786ce4d7a8b51a02133d7db404d9f038d5a927": {
			"type": "Ybodychange",
			"commitMessage": "Added DataBufferAllocator property to ReactiveHttpOutputMessage, and use that to pass on to Encoder.encode().\n",
			"commitDate": "2016-03-18, 9:14 AM",
			"commitName": "7f786ce4d7a8b51a02133d7db404d9f038d5a927",
			"commitAuthor": "Arjen Poutsma",
			"commitDateOld": "2016-02-28, 4:49 AM",
			"commitNameOld": "4197f002d87c1c02455cc640e20f89b28b10d271",
			"commitAuthorOld": "Stephane Maldini",
			"daysBetweenCommits": 19.14,
			"commitsBetweenForRepo": 25,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,67 +1,70 @@\n \tpublic Mono<Void> handleResult(ServerWebExchange exchange, HandlerResult result) {\n \n \t\tOptional<Object> value = result.getReturnValue();\n \t\tif (!value.isPresent()) {\n \t\t\treturn Mono.empty();\n \t\t}\n \n \t\tPublisher<?> publisher;\n \t\tResolvableType elementType;\n \t\tResolvableType returnType = result.getReturnValueType();\n \t\tif (this.conversionService.canConvert(returnType.getRawClass(), Publisher.class)) {\n \t\t\tpublisher = this.conversionService.convert(value.get(), Publisher.class);\n \t\t\telementType = returnType.getGeneric(0);\n \t\t\tif (Void.class.equals(elementType.getRawClass())) {\n \t\t\t\treturn Mono.from((Publisher<Void>)publisher);\n \t\t\t}\n \t\t}\n \t\telse {\n \t\t\tpublisher = Mono.just(value.get());\n \t\t\telementType = returnType;\n \t\t}\n \n \t\tList<MediaType> requestedMediaTypes = getAcceptableMediaTypes(exchange.getRequest());\n \t\tList<MediaType> producibleMediaTypes = getProducibleMediaTypes(elementType);\n \n \t\tif (producibleMediaTypes.isEmpty()) {\n \t\t\tproducibleMediaTypes.add(MediaType.ALL);\n \t\t}\n \n \t\tSet<MediaType> compatibleMediaTypes = new LinkedHashSet<>();\n \t\tfor (MediaType requestedType : requestedMediaTypes) {\n \t\t\tfor (MediaType producibleType : producibleMediaTypes) {\n \t\t\t\tif (requestedType.isCompatibleWith(producibleType)) {\n \t\t\t\t\tcompatibleMediaTypes.add(getMostSpecificMediaType(requestedType, producibleType));\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\tif (compatibleMediaTypes.isEmpty()) {\n \t\t\treturn Mono.error(new HttpMediaTypeNotAcceptableException(producibleMediaTypes));\n \t\t}\n \n \t\tList<MediaType> mediaTypes = new ArrayList<>(compatibleMediaTypes);\n \t\tMediaType.sortBySpecificityAndQuality(mediaTypes);\n \n \t\tMediaType selectedMediaType = null;\n \t\tfor (MediaType mediaType : mediaTypes) {\n \t\t\tif (mediaType.isConcrete()) {\n \t\t\t\tselectedMediaType = mediaType;\n \t\t\t\tbreak;\n \t\t\t}\n \t\t\telse if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n \t\t\t\tselectedMediaType = MediaType.APPLICATION_OCTET_STREAM;\n \t\t\t\tbreak;\n \t\t\t}\n \t\t}\n \n \t\tif (selectedMediaType != null) {\n \t\t\tEncoder<?> encoder = resolveEncoder(elementType, selectedMediaType);\n \t\t\tif (encoder != null) {\n \t\t\t\tServerHttpResponse response = exchange.getResponse();\n \t\t\t\tresponse.getHeaders().setContentType(selectedMediaType);\n-\t\t\t\treturn response.setBody(encoder.encode((Publisher) publisher, elementType, selectedMediaType));\n+\t\t\t\tDataBufferAllocator allocator = response.allocator();\n+\t\t\t\treturn response.setBody(\n+\t\t\t\t\t\tencoder.encode((Publisher) publisher, allocator, elementType,\n+\t\t\t\t\t\t\t\tselectedMediaType));\n \t\t\t}\n \t\t}\n \n \t\treturn Mono.error(new HttpMediaTypeNotAcceptableException(this.allMediaTypes));\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"4197f002d87c1c02455cc640e20f89b28b10d271": {
			"type": "Ybodychange",
			"commitMessage": "Arrange WriteWithOperator to save some allocation cost with the same technique used by RSC and Reactor\n",
			"commitDate": "2016-02-28, 4:49 AM",
			"commitName": "4197f002d87c1c02455cc640e20f89b28b10d271",
			"commitAuthor": "Stephane Maldini",
			"commitDateOld": "2016-02-08, 4:13 PM",
			"commitNameOld": "29db80c3e8f1d61ef97129ff9e139b24d9de93ba",
			"commitAuthorOld": "Rossen Stoyanchev",
			"daysBetweenCommits": 19.52,
			"commitsBetweenForRepo": 17,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,67 +1,67 @@\n \tpublic Mono<Void> handleResult(ServerWebExchange exchange, HandlerResult result) {\n \n \t\tOptional<Object> value = result.getReturnValue();\n \t\tif (!value.isPresent()) {\n \t\t\treturn Mono.empty();\n \t\t}\n \n \t\tPublisher<?> publisher;\n \t\tResolvableType elementType;\n \t\tResolvableType returnType = result.getReturnValueType();\n \t\tif (this.conversionService.canConvert(returnType.getRawClass(), Publisher.class)) {\n \t\t\tpublisher = this.conversionService.convert(value.get(), Publisher.class);\n \t\t\telementType = returnType.getGeneric(0);\n \t\t\tif (Void.class.equals(elementType.getRawClass())) {\n-\t\t\t\treturn (Mono<Void>)Mono.from(publisher);\n+\t\t\t\treturn Mono.from((Publisher<Void>)publisher);\n \t\t\t}\n \t\t}\n \t\telse {\n \t\t\tpublisher = Mono.just(value.get());\n \t\t\telementType = returnType;\n \t\t}\n \n \t\tList<MediaType> requestedMediaTypes = getAcceptableMediaTypes(exchange.getRequest());\n \t\tList<MediaType> producibleMediaTypes = getProducibleMediaTypes(elementType);\n \n \t\tif (producibleMediaTypes.isEmpty()) {\n \t\t\tproducibleMediaTypes.add(MediaType.ALL);\n \t\t}\n \n \t\tSet<MediaType> compatibleMediaTypes = new LinkedHashSet<>();\n \t\tfor (MediaType requestedType : requestedMediaTypes) {\n \t\t\tfor (MediaType producibleType : producibleMediaTypes) {\n \t\t\t\tif (requestedType.isCompatibleWith(producibleType)) {\n \t\t\t\t\tcompatibleMediaTypes.add(getMostSpecificMediaType(requestedType, producibleType));\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\tif (compatibleMediaTypes.isEmpty()) {\n \t\t\treturn Mono.error(new HttpMediaTypeNotAcceptableException(producibleMediaTypes));\n \t\t}\n \n \t\tList<MediaType> mediaTypes = new ArrayList<>(compatibleMediaTypes);\n \t\tMediaType.sortBySpecificityAndQuality(mediaTypes);\n \n \t\tMediaType selectedMediaType = null;\n \t\tfor (MediaType mediaType : mediaTypes) {\n \t\t\tif (mediaType.isConcrete()) {\n \t\t\t\tselectedMediaType = mediaType;\n \t\t\t\tbreak;\n \t\t\t}\n \t\t\telse if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n \t\t\t\tselectedMediaType = MediaType.APPLICATION_OCTET_STREAM;\n \t\t\t\tbreak;\n \t\t\t}\n \t\t}\n \n \t\tif (selectedMediaType != null) {\n \t\t\tEncoder<?> encoder = resolveEncoder(elementType, selectedMediaType);\n \t\t\tif (encoder != null) {\n \t\t\t\tServerHttpResponse response = exchange.getResponse();\n \t\t\t\tresponse.getHeaders().setContentType(selectedMediaType);\n \t\t\t\treturn response.setBody(encoder.encode((Publisher) publisher, elementType, selectedMediaType));\n \t\t\t}\n \t\t}\n \n \t\treturn Mono.error(new HttpMediaTypeNotAcceptableException(this.allMediaTypes));\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"e92174c772c0d787be7721ae00c7189f16b05fb5": {
			"type": "Ybodychange",
			"commitMessage": "Update HandlerResult\n\nRename result to returnValue and resultType to returnValueType to\nreflect what they represent.\n\nThe returnValue getter is also wrapped as Optional since the value\nreturned from a handler may be null (e.g. void method, null value).\n",
			"commitDate": "2016-02-07, 7:50 PM",
			"commitName": "e92174c772c0d787be7721ae00c7189f16b05fb5",
			"commitAuthor": "Rossen Stoyanchev",
			"commitDateOld": "2016-01-27, 3:05 PM",
			"commitNameOld": "381855aaf315adfd44e22797bbf14f07d08155d9",
			"commitAuthorOld": "Rossen Stoyanchev",
			"daysBetweenCommits": 11.2,
			"commitsBetweenForRepo": 17,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,67 +1,67 @@\n \tpublic Mono<Void> handleResult(ServerWebExchange exchange, HandlerResult result) {\n \n-\t\tObject value = result.getResult();\n-\t\tif (value == null) {\n+\t\tOptional<Object> value = result.getReturnValue();\n+\t\tif (!value.isPresent()) {\n \t\t\treturn Mono.empty();\n \t\t}\n \n \t\tPublisher<?> publisher;\n \t\tResolvableType elementType;\n-\t\tResolvableType returnType = result.getResultType();\n+\t\tResolvableType returnType = result.getReturnValueType();\n \t\tif (this.conversionService.canConvert(returnType.getRawClass(), Publisher.class)) {\n-\t\t\tpublisher = this.conversionService.convert(value, Publisher.class);\n+\t\t\tpublisher = this.conversionService.convert(value.get(), Publisher.class);\n \t\t\telementType = returnType.getGeneric(0);\n \t\t\tif (Void.class.equals(elementType.getRawClass())) {\n \t\t\t\treturn (Mono<Void>)Mono.from(publisher);\n \t\t\t}\n \t\t}\n \t\telse {\n-\t\t\tpublisher = Mono.just(value);\n+\t\t\tpublisher = Mono.just(value.get());\n \t\t\telementType = returnType;\n \t\t}\n \n \t\tList<MediaType> requestedMediaTypes = getAcceptableMediaTypes(exchange.getRequest());\n \t\tList<MediaType> producibleMediaTypes = getProducibleMediaTypes(elementType);\n \n \t\tif (producibleMediaTypes.isEmpty()) {\n \t\t\tproducibleMediaTypes.add(MediaType.ALL);\n \t\t}\n \n \t\tSet<MediaType> compatibleMediaTypes = new LinkedHashSet<>();\n \t\tfor (MediaType requestedType : requestedMediaTypes) {\n \t\t\tfor (MediaType producibleType : producibleMediaTypes) {\n \t\t\t\tif (requestedType.isCompatibleWith(producibleType)) {\n \t\t\t\t\tcompatibleMediaTypes.add(getMostSpecificMediaType(requestedType, producibleType));\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\tif (compatibleMediaTypes.isEmpty()) {\n \t\t\treturn Mono.error(new HttpMediaTypeNotAcceptableException(producibleMediaTypes));\n \t\t}\n \n \t\tList<MediaType> mediaTypes = new ArrayList<>(compatibleMediaTypes);\n \t\tMediaType.sortBySpecificityAndQuality(mediaTypes);\n \n \t\tMediaType selectedMediaType = null;\n \t\tfor (MediaType mediaType : mediaTypes) {\n \t\t\tif (mediaType.isConcrete()) {\n \t\t\t\tselectedMediaType = mediaType;\n \t\t\t\tbreak;\n \t\t\t}\n \t\t\telse if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n \t\t\t\tselectedMediaType = MediaType.APPLICATION_OCTET_STREAM;\n \t\t\t\tbreak;\n \t\t\t}\n \t\t}\n \n \t\tif (selectedMediaType != null) {\n \t\t\tEncoder<?> encoder = resolveEncoder(elementType, selectedMediaType);\n \t\t\tif (encoder != null) {\n \t\t\t\tServerHttpResponse response = exchange.getResponse();\n \t\t\t\tresponse.getHeaders().setContentType(selectedMediaType);\n \t\t\t\treturn response.setBody(encoder.encode((Publisher) publisher, elementType, selectedMediaType));\n \t\t\t}\n \t\t}\n \n \t\treturn Mono.error(new HttpMediaTypeNotAcceptableException(this.allMediaTypes));\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"381855aaf315adfd44e22797bbf14f07d08155d9": {
			"type": "Yparameterchange",
			"commitMessage": "Refine names in web.server and polish Javadoc\n\nWebServerExchange -> ServerWebExchange\n\nFollows the same convention as in the http package also better allowing\nthe possibility for a client equivalent in the future.\n\nWebToHttpHandlerBuilder -> WebHttpHandlerBuilder\nWebToHttpHandlerAdapter -> WebHttpHandlerAdapter\n\nMore consistent with Spring conventions.\n",
			"commitDate": "2016-01-27, 3:05 PM",
			"commitName": "381855aaf315adfd44e22797bbf14f07d08155d9",
			"commitAuthor": "Rossen Stoyanchev",
			"commitDateOld": "2016-01-19, 1:18 PM",
			"commitNameOld": "198e31641247061d0e02f8103b6d5b4583b1c619",
			"commitAuthorOld": "Stephane Maldini",
			"daysBetweenCommits": 8.07,
			"commitsBetweenForRepo": 25,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,67 +1,67 @@\n-\tpublic Mono<Void> handleResult(WebServerExchange exchange, HandlerResult result) {\n+\tpublic Mono<Void> handleResult(ServerWebExchange exchange, HandlerResult result) {\n \n \t\tObject value = result.getResult();\n \t\tif (value == null) {\n \t\t\treturn Mono.empty();\n \t\t}\n \n \t\tPublisher<?> publisher;\n \t\tResolvableType elementType;\n \t\tResolvableType returnType = result.getResultType();\n \t\tif (this.conversionService.canConvert(returnType.getRawClass(), Publisher.class)) {\n \t\t\tpublisher = this.conversionService.convert(value, Publisher.class);\n \t\t\telementType = returnType.getGeneric(0);\n \t\t\tif (Void.class.equals(elementType.getRawClass())) {\n \t\t\t\treturn (Mono<Void>)Mono.from(publisher);\n \t\t\t}\n \t\t}\n \t\telse {\n \t\t\tpublisher = Mono.just(value);\n \t\t\telementType = returnType;\n \t\t}\n \n \t\tList<MediaType> requestedMediaTypes = getAcceptableMediaTypes(exchange.getRequest());\n \t\tList<MediaType> producibleMediaTypes = getProducibleMediaTypes(elementType);\n \n \t\tif (producibleMediaTypes.isEmpty()) {\n \t\t\tproducibleMediaTypes.add(MediaType.ALL);\n \t\t}\n \n \t\tSet<MediaType> compatibleMediaTypes = new LinkedHashSet<>();\n \t\tfor (MediaType requestedType : requestedMediaTypes) {\n \t\t\tfor (MediaType producibleType : producibleMediaTypes) {\n \t\t\t\tif (requestedType.isCompatibleWith(producibleType)) {\n \t\t\t\t\tcompatibleMediaTypes.add(getMostSpecificMediaType(requestedType, producibleType));\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\tif (compatibleMediaTypes.isEmpty()) {\n \t\t\treturn Mono.error(new HttpMediaTypeNotAcceptableException(producibleMediaTypes));\n \t\t}\n \n \t\tList<MediaType> mediaTypes = new ArrayList<>(compatibleMediaTypes);\n \t\tMediaType.sortBySpecificityAndQuality(mediaTypes);\n \n \t\tMediaType selectedMediaType = null;\n \t\tfor (MediaType mediaType : mediaTypes) {\n \t\t\tif (mediaType.isConcrete()) {\n \t\t\t\tselectedMediaType = mediaType;\n \t\t\t\tbreak;\n \t\t\t}\n \t\t\telse if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n \t\t\t\tselectedMediaType = MediaType.APPLICATION_OCTET_STREAM;\n \t\t\t\tbreak;\n \t\t\t}\n \t\t}\n \n \t\tif (selectedMediaType != null) {\n \t\t\tEncoder<?> encoder = resolveEncoder(elementType, selectedMediaType);\n \t\t\tif (encoder != null) {\n \t\t\t\tServerHttpResponse response = exchange.getResponse();\n \t\t\t\tresponse.getHeaders().setContentType(selectedMediaType);\n \t\t\t\treturn response.setBody(encoder.encode((Publisher) publisher, elementType, selectedMediaType));\n \t\t\t}\n \t\t}\n \n \t\treturn Mono.error(new HttpMediaTypeNotAcceptableException(this.allMediaTypes));\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {
				"oldValue": "[exchange-WebServerExchange, result-HandlerResult]",
				"newValue": "[exchange-ServerWebExchange, result-HandlerResult]"
			}
		},
		"72e5aa39ec6c2f5d773a1ff1a67cb00fb2b8277a": {
			"type": "Ybodychange",
			"commitMessage": "Polish @RestController support\n",
			"commitDate": "2016-01-14, 3:06 AM",
			"commitName": "72e5aa39ec6c2f5d773a1ff1a67cb00fb2b8277a",
			"commitAuthor": "Sebastien Deleuze",
			"commitDateOld": "2016-01-13, 4:12 PM",
			"commitNameOld": "da90f03f4c7e192a23aaf64680cccf1c51c2b0f5",
			"commitAuthorOld": "Rossen Stoyanchev",
			"daysBetweenCommits": 0.45,
			"commitsBetweenForRepo": 3,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,64 +1,67 @@\n \tpublic Mono<Void> handleResult(WebServerExchange exchange, HandlerResult result) {\n \n \t\tObject value = result.getResult();\n \t\tif (value == null) {\n \t\t\treturn Mono.empty();\n \t\t}\n \n \t\tPublisher<?> publisher;\n \t\tResolvableType elementType;\n \t\tResolvableType returnType = result.getResultType();\n \t\tif (this.conversionService.canConvert(returnType.getRawClass(), Publisher.class)) {\n \t\t\tpublisher = this.conversionService.convert(value, Publisher.class);\n \t\t\telementType = returnType.getGeneric(0);\n+\t\t\tif (Void.class.equals(elementType.getRawClass())) {\n+\t\t\t\treturn (Mono<Void>)Mono.from(publisher);\n+\t\t\t}\n \t\t}\n \t\telse {\n \t\t\tpublisher = Mono.just(value);\n \t\t\telementType = returnType;\n \t\t}\n \n \t\tList<MediaType> requestedMediaTypes = getAcceptableMediaTypes(exchange.getRequest());\n \t\tList<MediaType> producibleMediaTypes = getProducibleMediaTypes(elementType);\n \n \t\tif (producibleMediaTypes.isEmpty()) {\n \t\t\tproducibleMediaTypes.add(MediaType.ALL);\n \t\t}\n \n \t\tSet<MediaType> compatibleMediaTypes = new LinkedHashSet<>();\n \t\tfor (MediaType requestedType : requestedMediaTypes) {\n \t\t\tfor (MediaType producibleType : producibleMediaTypes) {\n \t\t\t\tif (requestedType.isCompatibleWith(producibleType)) {\n \t\t\t\t\tcompatibleMediaTypes.add(getMostSpecificMediaType(requestedType, producibleType));\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\tif (compatibleMediaTypes.isEmpty()) {\n \t\t\treturn Mono.error(new HttpMediaTypeNotAcceptableException(producibleMediaTypes));\n \t\t}\n \n \t\tList<MediaType> mediaTypes = new ArrayList<>(compatibleMediaTypes);\n \t\tMediaType.sortBySpecificityAndQuality(mediaTypes);\n \n \t\tMediaType selectedMediaType = null;\n \t\tfor (MediaType mediaType : mediaTypes) {\n \t\t\tif (mediaType.isConcrete()) {\n \t\t\t\tselectedMediaType = mediaType;\n \t\t\t\tbreak;\n \t\t\t}\n \t\t\telse if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n \t\t\t\tselectedMediaType = MediaType.APPLICATION_OCTET_STREAM;\n \t\t\t\tbreak;\n \t\t\t}\n \t\t}\n \n \t\tif (selectedMediaType != null) {\n \t\t\tEncoder<?> encoder = resolveEncoder(elementType, selectedMediaType);\n \t\t\tif (encoder != null) {\n \t\t\t\tServerHttpResponse response = exchange.getResponse();\n \t\t\t\tresponse.getHeaders().setContentType(selectedMediaType);\n \t\t\t\treturn response.setBody(encoder.encode((Publisher) publisher, elementType, selectedMediaType));\n \t\t\t}\n \t\t}\n \n \t\treturn Mono.error(new HttpMediaTypeNotAcceptableException(this.allMediaTypes));\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"4f614fa0fd74ce29c5822e70f4815cc40745a2be": {
			"type": "Ymultichange(Yparameterchange,Ybodychange)",
			"commitMessage": "Add WebServerExchange\n\nThis change adds a WebServerExchange and updates all contracts at the\nthe same level (i.e. org.springframework.web.server) as well as the\norg.springframework.web.reactive level to use it so that all\nframework-related code will have access to server-side processing\nfeatures such as request attributes (and others to come).\n",
			"commitDate": "2016-01-08, 10:30 AM",
			"commitName": "4f614fa0fd74ce29c5822e70f4815cc40745a2be",
			"commitAuthor": "Rossen Stoyanchev",
			"subchanges": [
				{
					"type": "Yparameterchange",
					"commitMessage": "Add WebServerExchange\n\nThis change adds a WebServerExchange and updates all contracts at the\nthe same level (i.e. org.springframework.web.server) as well as the\norg.springframework.web.reactive level to use it so that all\nframework-related code will have access to server-side processing\nfeatures such as request attributes (and others to come).\n",
					"commitDate": "2016-01-08, 10:30 AM",
					"commitName": "4f614fa0fd74ce29c5822e70f4815cc40745a2be",
					"commitAuthor": "Rossen Stoyanchev",
					"commitDateOld": "2016-01-07, 3:14 AM",
					"commitNameOld": "8ef7e2ff77f913773e30b1463d4657368db700e5",
					"commitAuthorOld": "Sebastien Deleuze",
					"daysBetweenCommits": 1.3,
					"commitsBetweenForRepo": 11,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,64 +1,64 @@\n-\tpublic Mono<Void> handleResult(ServerHttpRequest request,\n-\t\t\tServerHttpResponse response, HandlerResult result) {\n+\tpublic Mono<Void> handleResult(WebServerExchange exchange, HandlerResult result) {\n \n \t\tObject value = result.getResult();\n \t\tif (value == null) {\n \t\t\treturn Mono.empty();\n \t\t}\n \n \t\tPublisher<?> publisher;\n \t\tResolvableType elementType;\n \t\tResolvableType returnType = result.getResultType();\n \t\tif (this.conversionService.canConvert(returnType.getRawClass(), Publisher.class)) {\n \t\t\tpublisher = this.conversionService.convert(value, Publisher.class);\n \t\t\telementType = returnType.getGeneric(0);\n \t\t}\n \t\telse {\n \t\t\tpublisher = Mono.just(value);\n \t\t\telementType = returnType;\n \t\t}\n \n-\t\tList<MediaType> requestedMediaTypes = getAcceptableMediaTypes(request);\n+\t\tList<MediaType> requestedMediaTypes = getAcceptableMediaTypes(exchange.getRequest());\n \t\tList<MediaType> producibleMediaTypes = getProducibleMediaTypes(elementType);\n \n \t\tif (producibleMediaTypes.isEmpty()) {\n \t\t\tproducibleMediaTypes.add(MediaType.ALL);\n \t\t}\n \n \t\tSet<MediaType> compatibleMediaTypes = new LinkedHashSet<>();\n \t\tfor (MediaType requestedType : requestedMediaTypes) {\n \t\t\tfor (MediaType producibleType : producibleMediaTypes) {\n \t\t\t\tif (requestedType.isCompatibleWith(producibleType)) {\n \t\t\t\t\tcompatibleMediaTypes.add(getMostSpecificMediaType(requestedType, producibleType));\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\tif (compatibleMediaTypes.isEmpty()) {\n \t\t\treturn Mono.error(new HttpMediaTypeNotAcceptableException(producibleMediaTypes));\n \t\t}\n \n \t\tList<MediaType> mediaTypes = new ArrayList<>(compatibleMediaTypes);\n \t\tMediaType.sortBySpecificityAndQuality(mediaTypes);\n \n \t\tMediaType selectedMediaType = null;\n \t\tfor (MediaType mediaType : mediaTypes) {\n \t\t\tif (mediaType.isConcrete()) {\n \t\t\t\tselectedMediaType = mediaType;\n \t\t\t\tbreak;\n \t\t\t}\n \t\t\telse if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n \t\t\t\tselectedMediaType = MediaType.APPLICATION_OCTET_STREAM;\n \t\t\t\tbreak;\n \t\t\t}\n \t\t}\n \n \t\tif (selectedMediaType != null) {\n \t\t\tEncoder<?> encoder = resolveEncoder(elementType, selectedMediaType);\n \t\t\tif (encoder != null) {\n+\t\t\t\tServerHttpResponse response = exchange.getResponse();\n \t\t\t\tresponse.getHeaders().setContentType(selectedMediaType);\n \t\t\t\treturn response.setBody(encoder.encode((Publisher) publisher, elementType, selectedMediaType));\n \t\t\t}\n \t\t}\n \n \t\treturn Mono.error(new HttpMediaTypeNotAcceptableException(this.allMediaTypes));\n \t}\n\\ No newline at end of file\n",
					"extendedDetails": {
						"oldValue": "[request-ServerHttpRequest, response-ServerHttpResponse, result-HandlerResult]",
						"newValue": "[exchange-WebServerExchange, result-HandlerResult]"
					}
				},
				{
					"type": "Ybodychange",
					"commitMessage": "Add WebServerExchange\n\nThis change adds a WebServerExchange and updates all contracts at the\nthe same level (i.e. org.springframework.web.server) as well as the\norg.springframework.web.reactive level to use it so that all\nframework-related code will have access to server-side processing\nfeatures such as request attributes (and others to come).\n",
					"commitDate": "2016-01-08, 10:30 AM",
					"commitName": "4f614fa0fd74ce29c5822e70f4815cc40745a2be",
					"commitAuthor": "Rossen Stoyanchev",
					"commitDateOld": "2016-01-07, 3:14 AM",
					"commitNameOld": "8ef7e2ff77f913773e30b1463d4657368db700e5",
					"commitAuthorOld": "Sebastien Deleuze",
					"daysBetweenCommits": 1.3,
					"commitsBetweenForRepo": 11,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,64 +1,64 @@\n-\tpublic Mono<Void> handleResult(ServerHttpRequest request,\n-\t\t\tServerHttpResponse response, HandlerResult result) {\n+\tpublic Mono<Void> handleResult(WebServerExchange exchange, HandlerResult result) {\n \n \t\tObject value = result.getResult();\n \t\tif (value == null) {\n \t\t\treturn Mono.empty();\n \t\t}\n \n \t\tPublisher<?> publisher;\n \t\tResolvableType elementType;\n \t\tResolvableType returnType = result.getResultType();\n \t\tif (this.conversionService.canConvert(returnType.getRawClass(), Publisher.class)) {\n \t\t\tpublisher = this.conversionService.convert(value, Publisher.class);\n \t\t\telementType = returnType.getGeneric(0);\n \t\t}\n \t\telse {\n \t\t\tpublisher = Mono.just(value);\n \t\t\telementType = returnType;\n \t\t}\n \n-\t\tList<MediaType> requestedMediaTypes = getAcceptableMediaTypes(request);\n+\t\tList<MediaType> requestedMediaTypes = getAcceptableMediaTypes(exchange.getRequest());\n \t\tList<MediaType> producibleMediaTypes = getProducibleMediaTypes(elementType);\n \n \t\tif (producibleMediaTypes.isEmpty()) {\n \t\t\tproducibleMediaTypes.add(MediaType.ALL);\n \t\t}\n \n \t\tSet<MediaType> compatibleMediaTypes = new LinkedHashSet<>();\n \t\tfor (MediaType requestedType : requestedMediaTypes) {\n \t\t\tfor (MediaType producibleType : producibleMediaTypes) {\n \t\t\t\tif (requestedType.isCompatibleWith(producibleType)) {\n \t\t\t\t\tcompatibleMediaTypes.add(getMostSpecificMediaType(requestedType, producibleType));\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\tif (compatibleMediaTypes.isEmpty()) {\n \t\t\treturn Mono.error(new HttpMediaTypeNotAcceptableException(producibleMediaTypes));\n \t\t}\n \n \t\tList<MediaType> mediaTypes = new ArrayList<>(compatibleMediaTypes);\n \t\tMediaType.sortBySpecificityAndQuality(mediaTypes);\n \n \t\tMediaType selectedMediaType = null;\n \t\tfor (MediaType mediaType : mediaTypes) {\n \t\t\tif (mediaType.isConcrete()) {\n \t\t\t\tselectedMediaType = mediaType;\n \t\t\t\tbreak;\n \t\t\t}\n \t\t\telse if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n \t\t\t\tselectedMediaType = MediaType.APPLICATION_OCTET_STREAM;\n \t\t\t\tbreak;\n \t\t\t}\n \t\t}\n \n \t\tif (selectedMediaType != null) {\n \t\t\tEncoder<?> encoder = resolveEncoder(elementType, selectedMediaType);\n \t\t\tif (encoder != null) {\n+\t\t\t\tServerHttpResponse response = exchange.getResponse();\n \t\t\t\tresponse.getHeaders().setContentType(selectedMediaType);\n \t\t\t\treturn response.setBody(encoder.encode((Publisher) publisher, elementType, selectedMediaType));\n \t\t\t}\n \t\t}\n \n \t\treturn Mono.error(new HttpMediaTypeNotAcceptableException(this.allMediaTypes));\n \t}\n\\ No newline at end of file\n",
					"extendedDetails": {}
				}
			]
		},
		"8ef7e2ff77f913773e30b1463d4657368db700e5": {
			"type": "Ymultichange(Yreturntypechange,Ybodychange)",
			"commitMessage": "Use Reactor 2.5 Flux and Mono Rx light API\n\nFlux and Mono are used both for implementation and exposed at API\nlevel to express 1 versus N semantic and to provide default Rx\noperators:\n- Flux<T> for multiple values Publisher (issue #48)\n- Mono<T> for single value Publisher (issue #50)\n- Mono<Void> for Publisher with no value (issue #49)\n",
			"commitDate": "2016-01-07, 3:14 AM",
			"commitName": "8ef7e2ff77f913773e30b1463d4657368db700e5",
			"commitAuthor": "Sebastien Deleuze",
			"subchanges": [
				{
					"type": "Yreturntypechange",
					"commitMessage": "Use Reactor 2.5 Flux and Mono Rx light API\n\nFlux and Mono are used both for implementation and exposed at API\nlevel to express 1 versus N semantic and to provide default Rx\noperators:\n- Flux<T> for multiple values Publisher (issue #48)\n- Mono<T> for single value Publisher (issue #50)\n- Mono<Void> for Publisher with no value (issue #49)\n",
					"commitDate": "2016-01-07, 3:14 AM",
					"commitName": "8ef7e2ff77f913773e30b1463d4657368db700e5",
					"commitAuthor": "Sebastien Deleuze",
					"commitDateOld": "2015-12-29, 9:13 PM",
					"commitNameOld": "9789db23d2973d8f0156d2b6c6027d9fb67ab844",
					"commitAuthorOld": "Rossen Stoyanchev",
					"daysBetweenCommits": 8.25,
					"commitsBetweenForRepo": 7,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,64 +1,64 @@\n-\tpublic Publisher<Void> handleResult(ServerHttpRequest request,\n+\tpublic Mono<Void> handleResult(ServerHttpRequest request,\n \t\t\tServerHttpResponse response, HandlerResult result) {\n \n \t\tObject value = result.getResult();\n \t\tif (value == null) {\n-\t\t\treturn Publishers.empty();\n+\t\t\treturn Mono.empty();\n \t\t}\n \n \t\tPublisher<?> publisher;\n \t\tResolvableType elementType;\n \t\tResolvableType returnType = result.getResultType();\n \t\tif (this.conversionService.canConvert(returnType.getRawClass(), Publisher.class)) {\n \t\t\tpublisher = this.conversionService.convert(value, Publisher.class);\n \t\t\telementType = returnType.getGeneric(0);\n \t\t}\n \t\telse {\n-\t\t\tpublisher = Publishers.just(value);\n+\t\t\tpublisher = Mono.just(value);\n \t\t\telementType = returnType;\n \t\t}\n \n \t\tList<MediaType> requestedMediaTypes = getAcceptableMediaTypes(request);\n \t\tList<MediaType> producibleMediaTypes = getProducibleMediaTypes(elementType);\n \n \t\tif (producibleMediaTypes.isEmpty()) {\n \t\t\tproducibleMediaTypes.add(MediaType.ALL);\n \t\t}\n \n \t\tSet<MediaType> compatibleMediaTypes = new LinkedHashSet<>();\n \t\tfor (MediaType requestedType : requestedMediaTypes) {\n \t\t\tfor (MediaType producibleType : producibleMediaTypes) {\n \t\t\t\tif (requestedType.isCompatibleWith(producibleType)) {\n \t\t\t\t\tcompatibleMediaTypes.add(getMostSpecificMediaType(requestedType, producibleType));\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\tif (compatibleMediaTypes.isEmpty()) {\n-\t\t\treturn Publishers.error(new HttpMediaTypeNotAcceptableException(producibleMediaTypes));\n+\t\t\treturn Mono.error(new HttpMediaTypeNotAcceptableException(producibleMediaTypes));\n \t\t}\n \n \t\tList<MediaType> mediaTypes = new ArrayList<>(compatibleMediaTypes);\n \t\tMediaType.sortBySpecificityAndQuality(mediaTypes);\n \n \t\tMediaType selectedMediaType = null;\n \t\tfor (MediaType mediaType : mediaTypes) {\n \t\t\tif (mediaType.isConcrete()) {\n \t\t\t\tselectedMediaType = mediaType;\n \t\t\t\tbreak;\n \t\t\t}\n \t\t\telse if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n \t\t\t\tselectedMediaType = MediaType.APPLICATION_OCTET_STREAM;\n \t\t\t\tbreak;\n \t\t\t}\n \t\t}\n \n \t\tif (selectedMediaType != null) {\n \t\t\tEncoder<?> encoder = resolveEncoder(elementType, selectedMediaType);\n \t\t\tif (encoder != null) {\n \t\t\t\tresponse.getHeaders().setContentType(selectedMediaType);\n \t\t\t\treturn response.setBody(encoder.encode((Publisher) publisher, elementType, selectedMediaType));\n \t\t\t}\n \t\t}\n \n-\t\treturn Publishers.error(new HttpMediaTypeNotAcceptableException(this.allMediaTypes));\n+\t\treturn Mono.error(new HttpMediaTypeNotAcceptableException(this.allMediaTypes));\n \t}\n\\ No newline at end of file\n",
					"extendedDetails": {
						"oldValue": "Publisher<Void>",
						"newValue": "Mono<Void>"
					}
				},
				{
					"type": "Ybodychange",
					"commitMessage": "Use Reactor 2.5 Flux and Mono Rx light API\n\nFlux and Mono are used both for implementation and exposed at API\nlevel to express 1 versus N semantic and to provide default Rx\noperators:\n- Flux<T> for multiple values Publisher (issue #48)\n- Mono<T> for single value Publisher (issue #50)\n- Mono<Void> for Publisher with no value (issue #49)\n",
					"commitDate": "2016-01-07, 3:14 AM",
					"commitName": "8ef7e2ff77f913773e30b1463d4657368db700e5",
					"commitAuthor": "Sebastien Deleuze",
					"commitDateOld": "2015-12-29, 9:13 PM",
					"commitNameOld": "9789db23d2973d8f0156d2b6c6027d9fb67ab844",
					"commitAuthorOld": "Rossen Stoyanchev",
					"daysBetweenCommits": 8.25,
					"commitsBetweenForRepo": 7,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,64 +1,64 @@\n-\tpublic Publisher<Void> handleResult(ServerHttpRequest request,\n+\tpublic Mono<Void> handleResult(ServerHttpRequest request,\n \t\t\tServerHttpResponse response, HandlerResult result) {\n \n \t\tObject value = result.getResult();\n \t\tif (value == null) {\n-\t\t\treturn Publishers.empty();\n+\t\t\treturn Mono.empty();\n \t\t}\n \n \t\tPublisher<?> publisher;\n \t\tResolvableType elementType;\n \t\tResolvableType returnType = result.getResultType();\n \t\tif (this.conversionService.canConvert(returnType.getRawClass(), Publisher.class)) {\n \t\t\tpublisher = this.conversionService.convert(value, Publisher.class);\n \t\t\telementType = returnType.getGeneric(0);\n \t\t}\n \t\telse {\n-\t\t\tpublisher = Publishers.just(value);\n+\t\t\tpublisher = Mono.just(value);\n \t\t\telementType = returnType;\n \t\t}\n \n \t\tList<MediaType> requestedMediaTypes = getAcceptableMediaTypes(request);\n \t\tList<MediaType> producibleMediaTypes = getProducibleMediaTypes(elementType);\n \n \t\tif (producibleMediaTypes.isEmpty()) {\n \t\t\tproducibleMediaTypes.add(MediaType.ALL);\n \t\t}\n \n \t\tSet<MediaType> compatibleMediaTypes = new LinkedHashSet<>();\n \t\tfor (MediaType requestedType : requestedMediaTypes) {\n \t\t\tfor (MediaType producibleType : producibleMediaTypes) {\n \t\t\t\tif (requestedType.isCompatibleWith(producibleType)) {\n \t\t\t\t\tcompatibleMediaTypes.add(getMostSpecificMediaType(requestedType, producibleType));\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\tif (compatibleMediaTypes.isEmpty()) {\n-\t\t\treturn Publishers.error(new HttpMediaTypeNotAcceptableException(producibleMediaTypes));\n+\t\t\treturn Mono.error(new HttpMediaTypeNotAcceptableException(producibleMediaTypes));\n \t\t}\n \n \t\tList<MediaType> mediaTypes = new ArrayList<>(compatibleMediaTypes);\n \t\tMediaType.sortBySpecificityAndQuality(mediaTypes);\n \n \t\tMediaType selectedMediaType = null;\n \t\tfor (MediaType mediaType : mediaTypes) {\n \t\t\tif (mediaType.isConcrete()) {\n \t\t\t\tselectedMediaType = mediaType;\n \t\t\t\tbreak;\n \t\t\t}\n \t\t\telse if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n \t\t\t\tselectedMediaType = MediaType.APPLICATION_OCTET_STREAM;\n \t\t\t\tbreak;\n \t\t\t}\n \t\t}\n \n \t\tif (selectedMediaType != null) {\n \t\t\tEncoder<?> encoder = resolveEncoder(elementType, selectedMediaType);\n \t\t\tif (encoder != null) {\n \t\t\t\tresponse.getHeaders().setContentType(selectedMediaType);\n \t\t\t\treturn response.setBody(encoder.encode((Publisher) publisher, elementType, selectedMediaType));\n \t\t\t}\n \t\t}\n \n-\t\treturn Publishers.error(new HttpMediaTypeNotAcceptableException(this.allMediaTypes));\n+\t\treturn Mono.error(new HttpMediaTypeNotAcceptableException(this.allMediaTypes));\n \t}\n\\ No newline at end of file\n",
					"extendedDetails": {}
				}
			]
		},
		"9789db23d2973d8f0156d2b6c6027d9fb67ab844": {
			"type": "Ybodychange",
			"commitMessage": "Rename HandlerResult fields from value to result\n",
			"commitDate": "2015-12-29, 9:13 PM",
			"commitName": "9789db23d2973d8f0156d2b6c6027d9fb67ab844",
			"commitAuthor": "Rossen Stoyanchev",
			"commitDateOld": "2015-12-10, 2:35 PM",
			"commitNameOld": "a0018d13e19f7fe7ef7a98979476d9cd2851a10c",
			"commitAuthorOld": "Rossen Stoyanchev",
			"daysBetweenCommits": 19.28,
			"commitsBetweenForRepo": 13,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,64 +1,64 @@\n \tpublic Publisher<Void> handleResult(ServerHttpRequest request,\n \t\t\tServerHttpResponse response, HandlerResult result) {\n \n-\t\tObject value = result.getValue();\n+\t\tObject value = result.getResult();\n \t\tif (value == null) {\n \t\t\treturn Publishers.empty();\n \t\t}\n \n \t\tPublisher<?> publisher;\n \t\tResolvableType elementType;\n-\t\tResolvableType returnType = result.getValueType();\n+\t\tResolvableType returnType = result.getResultType();\n \t\tif (this.conversionService.canConvert(returnType.getRawClass(), Publisher.class)) {\n \t\t\tpublisher = this.conversionService.convert(value, Publisher.class);\n \t\t\telementType = returnType.getGeneric(0);\n \t\t}\n \t\telse {\n \t\t\tpublisher = Publishers.just(value);\n \t\t\telementType = returnType;\n \t\t}\n \n \t\tList<MediaType> requestedMediaTypes = getAcceptableMediaTypes(request);\n \t\tList<MediaType> producibleMediaTypes = getProducibleMediaTypes(elementType);\n \n \t\tif (producibleMediaTypes.isEmpty()) {\n \t\t\tproducibleMediaTypes.add(MediaType.ALL);\n \t\t}\n \n \t\tSet<MediaType> compatibleMediaTypes = new LinkedHashSet<>();\n \t\tfor (MediaType requestedType : requestedMediaTypes) {\n \t\t\tfor (MediaType producibleType : producibleMediaTypes) {\n \t\t\t\tif (requestedType.isCompatibleWith(producibleType)) {\n \t\t\t\t\tcompatibleMediaTypes.add(getMostSpecificMediaType(requestedType, producibleType));\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\tif (compatibleMediaTypes.isEmpty()) {\n \t\t\treturn Publishers.error(new HttpMediaTypeNotAcceptableException(producibleMediaTypes));\n \t\t}\n \n \t\tList<MediaType> mediaTypes = new ArrayList<>(compatibleMediaTypes);\n \t\tMediaType.sortBySpecificityAndQuality(mediaTypes);\n \n \t\tMediaType selectedMediaType = null;\n \t\tfor (MediaType mediaType : mediaTypes) {\n \t\t\tif (mediaType.isConcrete()) {\n \t\t\t\tselectedMediaType = mediaType;\n \t\t\t\tbreak;\n \t\t\t}\n \t\t\telse if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n \t\t\t\tselectedMediaType = MediaType.APPLICATION_OCTET_STREAM;\n \t\t\t\tbreak;\n \t\t\t}\n \t\t}\n \n \t\tif (selectedMediaType != null) {\n \t\t\tEncoder<?> encoder = resolveEncoder(elementType, selectedMediaType);\n \t\t\tif (encoder != null) {\n \t\t\t\tresponse.getHeaders().setContentType(selectedMediaType);\n \t\t\t\treturn response.setBody(encoder.encode((Publisher) publisher, elementType, selectedMediaType));\n \t\t\t}\n \t\t}\n \n \t\treturn Publishers.error(new HttpMediaTypeNotAcceptableException(this.allMediaTypes));\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"a0018d13e19f7fe7ef7a98979476d9cd2851a10c": {
			"type": "Ybodychange",
			"commitMessage": "Add DispatcherHandlerErrorTests\n\nThe tests demonstrate failures at various phases of request processing\nand the resulting error signals.\n",
			"commitDate": "2015-12-10, 2:35 PM",
			"commitName": "a0018d13e19f7fe7ef7a98979476d9cd2851a10c",
			"commitAuthor": "Rossen Stoyanchev",
			"commitDateOld": "2015-12-02, 3:46 PM",
			"commitNameOld": "da98becf72fbeef836dba366431be2a652e5e001",
			"commitAuthorOld": "Rossen Stoyanchev",
			"daysBetweenCommits": 7.95,
			"commitsBetweenForRepo": 11,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,64 +1,64 @@\n \tpublic Publisher<Void> handleResult(ServerHttpRequest request,\n \t\t\tServerHttpResponse response, HandlerResult result) {\n \n \t\tObject value = result.getValue();\n \t\tif (value == null) {\n \t\t\treturn Publishers.empty();\n \t\t}\n \n+\t\tPublisher<?> publisher;\n+\t\tResolvableType elementType;\n \t\tResolvableType returnType = result.getValueType();\n+\t\tif (this.conversionService.canConvert(returnType.getRawClass(), Publisher.class)) {\n+\t\t\tpublisher = this.conversionService.convert(value, Publisher.class);\n+\t\t\telementType = returnType.getGeneric(0);\n+\t\t}\n+\t\telse {\n+\t\t\tpublisher = Publishers.just(value);\n+\t\t\telementType = returnType;\n+\t\t}\n \n \t\tList<MediaType> requestedMediaTypes = getAcceptableMediaTypes(request);\n-\t\tList<MediaType> producibleMediaTypes = getProducibleMediaTypes(returnType);\n+\t\tList<MediaType> producibleMediaTypes = getProducibleMediaTypes(elementType);\n \n \t\tif (producibleMediaTypes.isEmpty()) {\n \t\t\tproducibleMediaTypes.add(MediaType.ALL);\n \t\t}\n \n \t\tSet<MediaType> compatibleMediaTypes = new LinkedHashSet<>();\n \t\tfor (MediaType requestedType : requestedMediaTypes) {\n \t\t\tfor (MediaType producibleType : producibleMediaTypes) {\n \t\t\t\tif (requestedType.isCompatibleWith(producibleType)) {\n \t\t\t\t\tcompatibleMediaTypes.add(getMostSpecificMediaType(requestedType, producibleType));\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\tif (compatibleMediaTypes.isEmpty()) {\n \t\t\treturn Publishers.error(new HttpMediaTypeNotAcceptableException(producibleMediaTypes));\n \t\t}\n \n \t\tList<MediaType> mediaTypes = new ArrayList<>(compatibleMediaTypes);\n \t\tMediaType.sortBySpecificityAndQuality(mediaTypes);\n \n \t\tMediaType selectedMediaType = null;\n \t\tfor (MediaType mediaType : mediaTypes) {\n \t\t\tif (mediaType.isConcrete()) {\n \t\t\t\tselectedMediaType = mediaType;\n \t\t\t\tbreak;\n \t\t\t}\n \t\t\telse if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n \t\t\t\tselectedMediaType = MediaType.APPLICATION_OCTET_STREAM;\n \t\t\t\tbreak;\n \t\t\t}\n \t\t}\n \n \t\tif (selectedMediaType != null) {\n-\t\t\tPublisher<?> publisher;\n-\t\t\tResolvableType elementType;\n-\t\t\tif (this.conversionService.canConvert(returnType.getRawClass(), Publisher.class)) {\n-\t\t\t\tpublisher = this.conversionService.convert(value, Publisher.class);\n-\t\t\t\telementType = returnType.getGeneric(0);\n-\t\t\t}\n-\t\t\telse {\n-\t\t\t\tpublisher = Publishers.just(value);\n-\t\t\t\telementType = returnType;\n-\t\t\t}\n \t\t\tEncoder<?> encoder = resolveEncoder(elementType, selectedMediaType);\n \t\t\tif (encoder != null) {\n \t\t\t\tresponse.getHeaders().setContentType(selectedMediaType);\n \t\t\t\treturn response.setBody(encoder.encode((Publisher) publisher, elementType, selectedMediaType));\n \t\t\t}\n \t\t}\n \n \t\treturn Publishers.error(new HttpMediaTypeNotAcceptableException(this.allMediaTypes));\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"da98becf72fbeef836dba366431be2a652e5e001": {
			"type": "Yparameterchange",
			"commitMessage": "Move http.server to http.server.reactive\n",
			"commitDate": "2015-12-02, 3:46 PM",
			"commitName": "da98becf72fbeef836dba366431be2a652e5e001",
			"commitAuthor": "Rossen Stoyanchev",
			"commitDateOld": "2015-11-22, 1:02 PM",
			"commitNameOld": "4a3c0bc3b615df84afd7deb18bc102f5d363076e",
			"commitAuthorOld": "Rossen Stoyanchev",
			"daysBetweenCommits": 10.11,
			"commitsBetweenForRepo": 13,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,64 +1,64 @@\n-\tpublic Publisher<Void> handleResult(ReactiveServerHttpRequest request,\n-\t\t\tReactiveServerHttpResponse response, HandlerResult result) {\n+\tpublic Publisher<Void> handleResult(ServerHttpRequest request,\n+\t\t\tServerHttpResponse response, HandlerResult result) {\n \n \t\tObject value = result.getValue();\n \t\tif (value == null) {\n \t\t\treturn Publishers.empty();\n \t\t}\n \n \t\tResolvableType returnType = result.getValueType();\n \n \t\tList<MediaType> requestedMediaTypes = getAcceptableMediaTypes(request);\n \t\tList<MediaType> producibleMediaTypes = getProducibleMediaTypes(returnType);\n \n \t\tif (producibleMediaTypes.isEmpty()) {\n \t\t\tproducibleMediaTypes.add(MediaType.ALL);\n \t\t}\n \n \t\tSet<MediaType> compatibleMediaTypes = new LinkedHashSet<>();\n \t\tfor (MediaType requestedType : requestedMediaTypes) {\n \t\t\tfor (MediaType producibleType : producibleMediaTypes) {\n \t\t\t\tif (requestedType.isCompatibleWith(producibleType)) {\n \t\t\t\t\tcompatibleMediaTypes.add(getMostSpecificMediaType(requestedType, producibleType));\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\tif (compatibleMediaTypes.isEmpty()) {\n \t\t\treturn Publishers.error(new HttpMediaTypeNotAcceptableException(producibleMediaTypes));\n \t\t}\n \n \t\tList<MediaType> mediaTypes = new ArrayList<>(compatibleMediaTypes);\n \t\tMediaType.sortBySpecificityAndQuality(mediaTypes);\n \n \t\tMediaType selectedMediaType = null;\n \t\tfor (MediaType mediaType : mediaTypes) {\n \t\t\tif (mediaType.isConcrete()) {\n \t\t\t\tselectedMediaType = mediaType;\n \t\t\t\tbreak;\n \t\t\t}\n \t\t\telse if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n \t\t\t\tselectedMediaType = MediaType.APPLICATION_OCTET_STREAM;\n \t\t\t\tbreak;\n \t\t\t}\n \t\t}\n \n \t\tif (selectedMediaType != null) {\n \t\t\tPublisher<?> publisher;\n \t\t\tResolvableType elementType;\n \t\t\tif (this.conversionService.canConvert(returnType.getRawClass(), Publisher.class)) {\n \t\t\t\tpublisher = this.conversionService.convert(value, Publisher.class);\n \t\t\t\telementType = returnType.getGeneric(0);\n \t\t\t}\n \t\t\telse {\n \t\t\t\tpublisher = Publishers.just(value);\n \t\t\t\telementType = returnType;\n \t\t\t}\n \t\t\tEncoder<?> encoder = resolveEncoder(elementType, selectedMediaType);\n \t\t\tif (encoder != null) {\n \t\t\t\tresponse.getHeaders().setContentType(selectedMediaType);\n \t\t\t\treturn response.setBody(encoder.encode((Publisher) publisher, elementType, selectedMediaType));\n \t\t\t}\n \t\t}\n \n \t\treturn Publishers.error(new HttpMediaTypeNotAcceptableException(this.allMediaTypes));\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {
				"oldValue": "[request-ReactiveServerHttpRequest, response-ReactiveServerHttpResponse, result-HandlerResult]",
				"newValue": "[request-ServerHttpRequest, response-ServerHttpResponse, result-HandlerResult]"
			}
		},
		"911d3769224d009fb9fe08c6cb5489686bbc5713": {
			"type": "Ybodychange",
			"commitMessage": "Improve MimeType -> MediaType handling\n\nThis change adds an Encoder-to-MediaType lookup in\nResponseBodyResultHandler to avoid MimeType to MediaType creation at\nruntime.\n",
			"commitDate": "2015-11-22, 12:41 PM",
			"commitName": "911d3769224d009fb9fe08c6cb5489686bbc5713",
			"commitAuthor": "Rossen Stoyanchev",
			"commitDateOld": "2015-11-13, 3:49 PM",
			"commitNameOld": "81867fa4237643ca3eae24a8f085bc4b5f9443b3",
			"commitAuthorOld": "Rossen Stoyanchev",
			"daysBetweenCommits": 8.87,
			"commitsBetweenForRepo": 3,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,65 +1,64 @@\n \tpublic Publisher<Void> handleResult(ReactiveServerHttpRequest request,\n \t\t\tReactiveServerHttpResponse response, HandlerResult result) {\n \n \t\tObject value = result.getValue();\n \t\tif (value == null) {\n \t\t\treturn Publishers.empty();\n \t\t}\n \n \t\tResolvableType returnType = result.getValueType();\n \n \t\tList<MediaType> requestedMediaTypes = getAcceptableMediaTypes(request);\n \t\tList<MediaType> producibleMediaTypes = getProducibleMediaTypes(returnType);\n \n \t\tif (producibleMediaTypes.isEmpty()) {\n-\t\t\tPublishers.error(new IllegalArgumentException(\n-\t\t\t\t\t\"No encoder found for return value of type: \" + returnType));\n+\t\t\tproducibleMediaTypes.add(MediaType.ALL);\n \t\t}\n \n \t\tSet<MediaType> compatibleMediaTypes = new LinkedHashSet<>();\n \t\tfor (MediaType requestedType : requestedMediaTypes) {\n \t\t\tfor (MediaType producibleType : producibleMediaTypes) {\n \t\t\t\tif (requestedType.isCompatibleWith(producibleType)) {\n \t\t\t\t\tcompatibleMediaTypes.add(getMostSpecificMediaType(requestedType, producibleType));\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\tif (compatibleMediaTypes.isEmpty()) {\n \t\t\treturn Publishers.error(new HttpMediaTypeNotAcceptableException(producibleMediaTypes));\n \t\t}\n \n \t\tList<MediaType> mediaTypes = new ArrayList<>(compatibleMediaTypes);\n \t\tMediaType.sortBySpecificityAndQuality(mediaTypes);\n \n \t\tMediaType selectedMediaType = null;\n \t\tfor (MediaType mediaType : mediaTypes) {\n \t\t\tif (mediaType.isConcrete()) {\n \t\t\t\tselectedMediaType = mediaType;\n \t\t\t\tbreak;\n \t\t\t}\n \t\t\telse if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n \t\t\t\tselectedMediaType = MediaType.APPLICATION_OCTET_STREAM;\n \t\t\t\tbreak;\n \t\t\t}\n \t\t}\n \n \t\tif (selectedMediaType != null) {\n \t\t\tPublisher<?> publisher;\n \t\t\tResolvableType elementType;\n \t\t\tif (this.conversionService.canConvert(returnType.getRawClass(), Publisher.class)) {\n \t\t\t\tpublisher = this.conversionService.convert(value, Publisher.class);\n \t\t\t\telementType = returnType.getGeneric(0);\n \t\t\t}\n \t\t\telse {\n \t\t\t\tpublisher = Publishers.just(value);\n \t\t\t\telementType = returnType;\n \t\t\t}\n \t\t\tEncoder<?> encoder = resolveEncoder(elementType, selectedMediaType);\n \t\t\tif (encoder != null) {\n \t\t\t\tresponse.getHeaders().setContentType(selectedMediaType);\n \t\t\t\treturn response.setBody(encoder.encode((Publisher) publisher, elementType, selectedMediaType));\n \t\t\t}\n \t\t}\n \n-\t\treturn Publishers.error(new HttpMediaTypeNotAcceptableException(this.allSupportedMediaTypes));\n+\t\treturn Publishers.error(new HttpMediaTypeNotAcceptableException(this.allMediaTypes));\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"81867fa4237643ca3eae24a8f085bc4b5f9443b3": {
			"type": "Yfilerename",
			"commitMessage": "Refactor package structure for web\n\nThe web related code is now under org.springframework.web.reactive.\nThis is parallel to org.springframework.web (the top-level package of\nspring-webmvc).\n",
			"commitDate": "2015-11-13, 3:49 PM",
			"commitName": "81867fa4237643ca3eae24a8f085bc4b5f9443b3",
			"commitAuthor": "Rossen Stoyanchev",
			"commitDateOld": "2015-11-13, 3:23 PM",
			"commitNameOld": "54ce20a5e04275835b40f2cd1453db778264191e",
			"commitAuthorOld": "Rossen Stoyanchev",
			"daysBetweenCommits": 0.02,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "",
			"extendedDetails": {
				"oldPath": "spring-web-reactive/src/main/java/org/springframework/reactive/web/dispatch/method/annotation/ResponseBodyResultHandler.java",
				"newPath": "spring-web-reactive/src/main/java/org/springframework/web/reactive/method/annotation/ResponseBodyResultHandler.java"
			}
		},
		"54ce20a5e04275835b40f2cd1453db778264191e": {
			"type": "Ybodychange",
			"commitMessage": "Rename field in HandlerResult\n",
			"commitDate": "2015-11-13, 3:23 PM",
			"commitName": "54ce20a5e04275835b40f2cd1453db778264191e",
			"commitAuthor": "Rossen Stoyanchev",
			"commitDateOld": "2015-11-13, 3:09 PM",
			"commitNameOld": "c6713c23e327961d021706e5b1e4d5ebe8e2f458",
			"commitAuthorOld": "Sebastien Deleuze",
			"daysBetweenCommits": 0.01,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,65 +1,65 @@\n \tpublic Publisher<Void> handleResult(ReactiveServerHttpRequest request,\n \t\t\tReactiveServerHttpResponse response, HandlerResult result) {\n \n \t\tObject value = result.getValue();\n \t\tif (value == null) {\n \t\t\treturn Publishers.empty();\n \t\t}\n \n-\t\tResolvableType returnType = result.getType();\n+\t\tResolvableType returnType = result.getValueType();\n \n \t\tList<MediaType> requestedMediaTypes = getAcceptableMediaTypes(request);\n \t\tList<MediaType> producibleMediaTypes = getProducibleMediaTypes(returnType);\n \n \t\tif (producibleMediaTypes.isEmpty()) {\n \t\t\tPublishers.error(new IllegalArgumentException(\n \t\t\t\t\t\"No encoder found for return value of type: \" + returnType));\n \t\t}\n \n \t\tSet<MediaType> compatibleMediaTypes = new LinkedHashSet<>();\n \t\tfor (MediaType requestedType : requestedMediaTypes) {\n \t\t\tfor (MediaType producibleType : producibleMediaTypes) {\n \t\t\t\tif (requestedType.isCompatibleWith(producibleType)) {\n \t\t\t\t\tcompatibleMediaTypes.add(getMostSpecificMediaType(requestedType, producibleType));\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\tif (compatibleMediaTypes.isEmpty()) {\n \t\t\treturn Publishers.error(new HttpMediaTypeNotAcceptableException(producibleMediaTypes));\n \t\t}\n \n \t\tList<MediaType> mediaTypes = new ArrayList<>(compatibleMediaTypes);\n \t\tMediaType.sortBySpecificityAndQuality(mediaTypes);\n \n \t\tMediaType selectedMediaType = null;\n \t\tfor (MediaType mediaType : mediaTypes) {\n \t\t\tif (mediaType.isConcrete()) {\n \t\t\t\tselectedMediaType = mediaType;\n \t\t\t\tbreak;\n \t\t\t}\n \t\t\telse if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n \t\t\t\tselectedMediaType = MediaType.APPLICATION_OCTET_STREAM;\n \t\t\t\tbreak;\n \t\t\t}\n \t\t}\n \n \t\tif (selectedMediaType != null) {\n \t\t\tPublisher<?> publisher;\n \t\t\tResolvableType elementType;\n \t\t\tif (this.conversionService.canConvert(returnType.getRawClass(), Publisher.class)) {\n \t\t\t\tpublisher = this.conversionService.convert(value, Publisher.class);\n \t\t\t\telementType = returnType.getGeneric(0);\n \t\t\t}\n \t\t\telse {\n \t\t\t\tpublisher = Publishers.just(value);\n \t\t\t\telementType = returnType;\n \t\t\t}\n \t\t\tEncoder<?> encoder = resolveEncoder(elementType, selectedMediaType);\n \t\t\tif (encoder != null) {\n \t\t\t\tresponse.getHeaders().setContentType(selectedMediaType);\n \t\t\t\treturn response.setBody(encoder.encode((Publisher) publisher, elementType, selectedMediaType));\n \t\t\t}\n \t\t}\n \n \t\treturn Publishers.error(new HttpMediaTypeNotAcceptableException(this.allSupportedMediaTypes));\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"c6713c23e327961d021706e5b1e4d5ebe8e2f458": {
			"type": "Ybodychange",
			"commitMessage": "Add a ResolvableType field to HandlerResult\n\nThis change allows to be able to check generic type on the return value\nat HandlerAdapter and ResultHandler level. For example, it allows to do\na Publisher<Void> check in SimpleHandlerResultHandler.\n",
			"commitDate": "2015-11-13, 3:09 PM",
			"commitName": "c6713c23e327961d021706e5b1e4d5ebe8e2f458",
			"commitAuthor": "Sebastien Deleuze",
			"commitDateOld": "2015-11-13, 2:47 PM",
			"commitNameOld": "5d4201d50079fc36fee21617ece1bfbbcf194120",
			"commitAuthorOld": "Rossen Stoyanchev",
			"daysBetweenCommits": 0.01,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,66 +1,65 @@\n \tpublic Publisher<Void> handleResult(ReactiveServerHttpRequest request,\n \t\t\tReactiveServerHttpResponse response, HandlerResult result) {\n \n \t\tObject value = result.getValue();\n \t\tif (value == null) {\n \t\t\treturn Publishers.empty();\n \t\t}\n \n-\t\tHandlerMethod hm = (HandlerMethod) result.getHandler();\n-\t\tResolvableType returnType = ResolvableType.forMethodParameter(hm.getReturnValueType(value));\n+\t\tResolvableType returnType = result.getType();\n \n \t\tList<MediaType> requestedMediaTypes = getAcceptableMediaTypes(request);\n \t\tList<MediaType> producibleMediaTypes = getProducibleMediaTypes(returnType);\n \n \t\tif (producibleMediaTypes.isEmpty()) {\n \t\t\tPublishers.error(new IllegalArgumentException(\n \t\t\t\t\t\"No encoder found for return value of type: \" + returnType));\n \t\t}\n \n \t\tSet<MediaType> compatibleMediaTypes = new LinkedHashSet<>();\n \t\tfor (MediaType requestedType : requestedMediaTypes) {\n \t\t\tfor (MediaType producibleType : producibleMediaTypes) {\n \t\t\t\tif (requestedType.isCompatibleWith(producibleType)) {\n \t\t\t\t\tcompatibleMediaTypes.add(getMostSpecificMediaType(requestedType, producibleType));\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\tif (compatibleMediaTypes.isEmpty()) {\n \t\t\treturn Publishers.error(new HttpMediaTypeNotAcceptableException(producibleMediaTypes));\n \t\t}\n \n \t\tList<MediaType> mediaTypes = new ArrayList<>(compatibleMediaTypes);\n \t\tMediaType.sortBySpecificityAndQuality(mediaTypes);\n \n \t\tMediaType selectedMediaType = null;\n \t\tfor (MediaType mediaType : mediaTypes) {\n \t\t\tif (mediaType.isConcrete()) {\n \t\t\t\tselectedMediaType = mediaType;\n \t\t\t\tbreak;\n \t\t\t}\n \t\t\telse if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n \t\t\t\tselectedMediaType = MediaType.APPLICATION_OCTET_STREAM;\n \t\t\t\tbreak;\n \t\t\t}\n \t\t}\n \n \t\tif (selectedMediaType != null) {\n \t\t\tPublisher<?> publisher;\n \t\t\tResolvableType elementType;\n \t\t\tif (this.conversionService.canConvert(returnType.getRawClass(), Publisher.class)) {\n \t\t\t\tpublisher = this.conversionService.convert(value, Publisher.class);\n \t\t\t\telementType = returnType.getGeneric(0);\n \t\t\t}\n \t\t\telse {\n \t\t\t\tpublisher = Publishers.just(value);\n \t\t\t\telementType = returnType;\n \t\t\t}\n \t\t\tEncoder<?> encoder = resolveEncoder(elementType, selectedMediaType);\n \t\t\tif (encoder != null) {\n \t\t\t\tresponse.getHeaders().setContentType(selectedMediaType);\n \t\t\t\treturn response.setBody(encoder.encode((Publisher) publisher, elementType, selectedMediaType));\n \t\t\t}\n \t\t}\n \n \t\treturn Publishers.error(new HttpMediaTypeNotAcceptableException(this.allSupportedMediaTypes));\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"5d4201d50079fc36fee21617ece1bfbbcf194120": {
			"type": "Ybodychange",
			"commitMessage": "Fix \"Content-Type\" and \"Accept\" header processing\n\n\"Content-Type\" is just a single MediaType.\n\nFor the response, the MediaType must be fully selected before\nselecting and encoder.\n\nThe ResponseBodyResultHandler now includes actual content negotiation\nwith a potential 406 response.\n",
			"commitDate": "2015-11-13, 2:47 PM",
			"commitName": "5d4201d50079fc36fee21617ece1bfbbcf194120",
			"commitAuthor": "Rossen Stoyanchev",
			"commitDateOld": "2015-11-13, 1:55 PM",
			"commitNameOld": "2de127ad4ad8dcb81521039749308de58ac81420",
			"commitAuthorOld": "Rossen Stoyanchev",
			"daysBetweenCommits": 0.04,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,45 +1,66 @@\n \tpublic Publisher<Void> handleResult(ReactiveServerHttpRequest request,\n \t\t\tReactiveServerHttpResponse response, HandlerResult result) {\n \n \t\tObject value = result.getValue();\n \t\tif (value == null) {\n \t\t\treturn Publishers.empty();\n \t\t}\n \n \t\tHandlerMethod hm = (HandlerMethod) result.getHandler();\n \t\tResolvableType returnType = ResolvableType.forMethodParameter(hm.getReturnValueType(value));\n \n-\t\tPublisher<?> elementStream;\n-\t\tResolvableType elementType;\n-\t\tif (this.conversionService.canConvert(returnType.getRawClass(), Publisher.class)) {\n-\t\t\telementStream = this.conversionService.convert(value, Publisher.class);\n-\t\t\telementType = returnType.getGeneric(0);\n-\t\t}\n-\t\telse {\n-\t\t\telementStream = Publishers.just(value);\n-\t\t\telementType = returnType;\n+\t\tList<MediaType> requestedMediaTypes = getAcceptableMediaTypes(request);\n+\t\tList<MediaType> producibleMediaTypes = getProducibleMediaTypes(returnType);\n+\n+\t\tif (producibleMediaTypes.isEmpty()) {\n+\t\t\tPublishers.error(new IllegalArgumentException(\n+\t\t\t\t\t\"No encoder found for return value of type: \" + returnType));\n \t\t}\n \n-\t\tMediaType mediaType = resolveMediaType(request);\n-\t\tEncoder<?> encoder = resolveEncoder(elementType, mediaType);\n-\t\tif (encoder == null) {\n-\t\t\treturn Publishers.error(new IllegalStateException(\n-\t\t\t\t\t\"Return value type '\" + returnType +\n-\t\t\t\t\t\t\t\"' with media type '\" + mediaType + \"' not supported\"));\n+\t\tSet<MediaType> compatibleMediaTypes = new LinkedHashSet<>();\n+\t\tfor (MediaType requestedType : requestedMediaTypes) {\n+\t\t\tfor (MediaType producibleType : producibleMediaTypes) {\n+\t\t\t\tif (requestedType.isCompatibleWith(producibleType)) {\n+\t\t\t\t\tcompatibleMediaTypes.add(getMostSpecificMediaType(requestedType, producibleType));\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\tif (compatibleMediaTypes.isEmpty()) {\n+\t\t\treturn Publishers.error(new HttpMediaTypeNotAcceptableException(producibleMediaTypes));\n \t\t}\n \n-\t\tPublisher<ByteBuffer> outputStream = encoder.encode((Publisher) elementStream, returnType, mediaType);\n-\t\tif (mediaType == null || mediaType.isWildcardType() || mediaType.isWildcardSubtype()) {\n-\t\t\tList<MimeType> mimeTypes = encoder.getSupportedMimeTypes();\n-\t\t\tif (!mimeTypes.isEmpty()) {\n-\t\t\t\tMimeType mimeType = mimeTypes.get(0);\n-\t\t\t\tmediaType = new MediaType(mimeType.getType(), mimeType.getSubtype(), mimeType.getParameters());\n+\t\tList<MediaType> mediaTypes = new ArrayList<>(compatibleMediaTypes);\n+\t\tMediaType.sortBySpecificityAndQuality(mediaTypes);\n+\n+\t\tMediaType selectedMediaType = null;\n+\t\tfor (MediaType mediaType : mediaTypes) {\n+\t\t\tif (mediaType.isConcrete()) {\n+\t\t\t\tselectedMediaType = mediaType;\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t\telse if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n+\t\t\t\tselectedMediaType = MediaType.APPLICATION_OCTET_STREAM;\n+\t\t\t\tbreak;\n \t\t\t}\n \t\t}\n \n-\t\tif (mediaType != null && !mediaType.equals(MediaType.ALL)) {\n-\t\t\tresponse.getHeaders().setContentType(mediaType);\n+\t\tif (selectedMediaType != null) {\n+\t\t\tPublisher<?> publisher;\n+\t\t\tResolvableType elementType;\n+\t\t\tif (this.conversionService.canConvert(returnType.getRawClass(), Publisher.class)) {\n+\t\t\t\tpublisher = this.conversionService.convert(value, Publisher.class);\n+\t\t\t\telementType = returnType.getGeneric(0);\n+\t\t\t}\n+\t\t\telse {\n+\t\t\t\tpublisher = Publishers.just(value);\n+\t\t\t\telementType = returnType;\n+\t\t\t}\n+\t\t\tEncoder<?> encoder = resolveEncoder(elementType, selectedMediaType);\n+\t\t\tif (encoder != null) {\n+\t\t\t\tresponse.getHeaders().setContentType(selectedMediaType);\n+\t\t\t\treturn response.setBody(encoder.encode((Publisher) publisher, elementType, selectedMediaType));\n+\t\t\t}\n \t\t}\n \n-\t\treturn response.setBody(outputStream);\n+\t\treturn Publishers.error(new HttpMediaTypeNotAcceptableException(this.allSupportedMediaTypes));\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"2de127ad4ad8dcb81521039749308de58ac81420": {
			"type": "Ybodychange",
			"commitMessage": "Polish\n",
			"commitDate": "2015-11-13, 1:55 PM",
			"commitName": "2de127ad4ad8dcb81521039749308de58ac81420",
			"commitAuthor": "Rossen Stoyanchev",
			"commitDateOld": "2015-11-13, 1:01 PM",
			"commitNameOld": "bdc5b38cb12d26605a968845338bef5bad22816d",
			"commitAuthorOld": "Sebastien Deleuze",
			"daysBetweenCommits": 0.04,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,44 +1,45 @@\n \tpublic Publisher<Void> handleResult(ReactiveServerHttpRequest request,\n \t\t\tReactiveServerHttpResponse response, HandlerResult result) {\n \n \t\tObject value = result.getValue();\n-\t\tHandlerMethod handlerMethod = (HandlerMethod) result.getHandler();\n-\t\tMethodParameter returnType = handlerMethod.getReturnValueType(value);\n-\n \t\tif (value == null) {\n \t\t\treturn Publishers.empty();\n \t\t}\n \n-\t\tResolvableType type = ResolvableType.forMethodParameter(returnType);\n-\t\tMediaType mediaType = resolveMediaType(request);\n+\t\tHandlerMethod hm = (HandlerMethod) result.getHandler();\n+\t\tResolvableType returnType = ResolvableType.forMethodParameter(hm.getReturnValueType(value));\n+\n \t\tPublisher<?> elementStream;\n \t\tResolvableType elementType;\n-\t\tif (conversionService.canConvert(type.getRawClass(), Publisher.class)) {\n-\t\t\telementStream = conversionService.convert(value, Publisher.class);\n-\t\t\telementType = type.getGeneric(0);\n+\t\tif (this.conversionService.canConvert(returnType.getRawClass(), Publisher.class)) {\n+\t\t\telementStream = this.conversionService.convert(value, Publisher.class);\n+\t\t\telementType = returnType.getGeneric(0);\n \t\t}\n \t\telse {\n \t\t\telementStream = Publishers.just(value);\n-\t\t\telementType = type;\n+\t\t\telementType = returnType;\n \t\t}\n \n-\t\tEncoder<?> serializer = resolveSerializer(elementType, mediaType);\n-\n-\t\tif (serializer != null) {\n-\t\t\tPublisher<ByteBuffer> outputStream = serializer.encode((Publisher)elementStream, type, mediaType);\n-\t\t\tif (mediaType == null || mediaType.isWildcardType() || mediaType.isWildcardSubtype()) {\n-\t\t\t\tList<MimeType> mimeTypes = serializer.getSupportedMimeTypes();\n-\t\t\t\tif (!mimeTypes.isEmpty()) {\n-\t\t\t\t\tMimeType mimeType = mimeTypes.get(0);\n-\t\t\t\t\tmediaType = new MediaType(mimeType.getType(), mimeType.getSubtype(), mimeType.getParameters());\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\tif (mediaType != null && !mediaType.equals(MediaType.ALL)) {\n-\t\t\t\tresponse.getHeaders().setContentType(mediaType);\n-\t\t\t}\n-\t\t\treturn response.setBody(outputStream);\n+\t\tMediaType mediaType = resolveMediaType(request);\n+\t\tEncoder<?> encoder = resolveEncoder(elementType, mediaType);\n+\t\tif (encoder == null) {\n+\t\t\treturn Publishers.error(new IllegalStateException(\n+\t\t\t\t\t\"Return value type '\" + returnType +\n+\t\t\t\t\t\t\t\"' with media type '\" + mediaType + \"' not supported\"));\n \t\t}\n-\t\tString returnTypeName = returnType.getParameterType().getName();\n-\t\treturn Publishers.error(new IllegalStateException(\"Return value type '\" + returnTypeName +\n-\t\t\t\t\"' with media type '\" + mediaType + \"' not supported\"));\n+\n+\t\tPublisher<ByteBuffer> outputStream = encoder.encode((Publisher) elementStream, returnType, mediaType);\n+\t\tif (mediaType == null || mediaType.isWildcardType() || mediaType.isWildcardSubtype()) {\n+\t\t\tList<MimeType> mimeTypes = encoder.getSupportedMimeTypes();\n+\t\t\tif (!mimeTypes.isEmpty()) {\n+\t\t\t\tMimeType mimeType = mimeTypes.get(0);\n+\t\t\t\tmediaType = new MediaType(mimeType.getType(), mimeType.getSubtype(), mimeType.getParameters());\n+\t\t\t}\n+\t\t}\n+\n+\t\tif (mediaType != null && !mediaType.equals(MediaType.ALL)) {\n+\t\t\tresponse.getHeaders().setContentType(mediaType);\n+\t\t}\n+\n+\t\treturn response.setBody(outputStream);\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"bdc5b38cb12d26605a968845338bef5bad22816d": {
			"type": "Ybodychange",
			"commitMessage": "Refactor codecs\n\nThis commit introduces the following changes:\n - MessageToByteEncoder/Decoder renamed to Encoder/Decoder\n - JsonObjectEncoder/Decoder are now used directly in\n   JacksonJsonEncoder/Decoder\n - Codec uses MimeType instead of MediaType since they\n   are not specific to HTTP\n - Default MimeType are now managed thanks to\n   Encoder/Decoder#getSupportedMimeTypes()\n - AbstractEncoder/Decoder takes care of generic MimeType related behavior\n",
			"commitDate": "2015-11-13, 1:01 PM",
			"commitName": "bdc5b38cb12d26605a968845338bef5bad22816d",
			"commitAuthor": "Sebastien Deleuze",
			"commitDateOld": "2015-10-30, 3:58 PM",
			"commitNameOld": "a48c9b6305a9aab74168b5c5455f8b5ef9eb466b",
			"commitAuthorOld": "Rossen Stoyanchev",
			"daysBetweenCommits": 13.92,
			"commitsBetweenForRepo": 5,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,43 +1,44 @@\n \tpublic Publisher<Void> handleResult(ReactiveServerHttpRequest request,\n \t\t\tReactiveServerHttpResponse response, HandlerResult result) {\n \n \t\tObject value = result.getValue();\n \t\tHandlerMethod handlerMethod = (HandlerMethod) result.getHandler();\n \t\tMethodParameter returnType = handlerMethod.getReturnValueType(value);\n \n \t\tif (value == null) {\n \t\t\treturn Publishers.empty();\n \t\t}\n \n \t\tResolvableType type = ResolvableType.forMethodParameter(returnType);\n \t\tMediaType mediaType = resolveMediaType(request);\n-\t\tList<Object> hints = new ArrayList<>();\n-\t\thints.add(UTF_8);\n-\t\tPublisher<Object> elementStream;\n+\t\tPublisher<?> elementStream;\n \t\tResolvableType elementType;\n \t\tif (conversionService.canConvert(type.getRawClass(), Publisher.class)) {\n \t\t\telementStream = conversionService.convert(value, Publisher.class);\n \t\t\telementType = type.getGeneric(0);\n \t\t}\n \t\telse {\n \t\t\telementStream = Publishers.just(value);\n \t\t\telementType = type;\n \t\t}\n \n-\t\tMessageToByteEncoder<Object> encoder = (MessageToByteEncoder<Object>) resolveEncoder(\n-\t\t\t\telementType, mediaType, hints.toArray());\n+\t\tEncoder<?> serializer = resolveSerializer(elementType, mediaType);\n \n-\t\tif (encoder != null) {\n-\t\t\tPublisher<ByteBuffer> outputStream = encoder.encode(elementStream, type, mediaType, hints.toArray());\n-\t\t\tList<MessageToByteEncoder<ByteBuffer>> postProcessors = resolvePostProcessors(\n-\t\t\t\t\telementType, mediaType, hints.toArray());\n-\t\t\tfor (MessageToByteEncoder<ByteBuffer> postProcessor : postProcessors) {\n-\t\t\t\toutputStream = postProcessor.encode(outputStream, elementType, mediaType, hints.toArray());\n+\t\tif (serializer != null) {\n+\t\t\tPublisher<ByteBuffer> outputStream = serializer.encode((Publisher)elementStream, type, mediaType);\n+\t\t\tif (mediaType == null || mediaType.isWildcardType() || mediaType.isWildcardSubtype()) {\n+\t\t\t\tList<MimeType> mimeTypes = serializer.getSupportedMimeTypes();\n+\t\t\t\tif (!mimeTypes.isEmpty()) {\n+\t\t\t\t\tMimeType mimeType = mimeTypes.get(0);\n+\t\t\t\t\tmediaType = new MediaType(mimeType.getType(), mimeType.getSubtype(), mimeType.getParameters());\n+\t\t\t\t}\n \t\t\t}\n-\t\t\tresponse.getHeaders().setContentType(mediaType);\n+\t\t\tif (mediaType != null && !mediaType.equals(MediaType.ALL)) {\n+\t\t\t\tresponse.getHeaders().setContentType(mediaType);\n+\t\t\t}\n \t\t\treturn response.setBody(outputStream);\n \t\t}\n \t\tString returnTypeName = returnType.getParameterType().getName();\n \t\treturn Publishers.error(new IllegalStateException(\"Return value type '\" + returnTypeName +\n \t\t\t\t\"' with media type '\" + mediaType + \"' not supported\"));\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"a48c9b6305a9aab74168b5c5455f8b5ef9eb466b": {
			"type": "Ybodychange",
			"commitMessage": "Replace DefaultConversionService in spring-reactive\n",
			"commitDate": "2015-10-30, 3:58 PM",
			"commitName": "a48c9b6305a9aab74168b5c5455f8b5ef9eb466b",
			"commitAuthor": "Rossen Stoyanchev",
			"commitDateOld": "2015-10-30, 3:22 PM",
			"commitNameOld": "c0dff3d2bb2277429f4e387d18deb75b0797a375",
			"commitAuthorOld": "Rossen Stoyanchev",
			"daysBetweenCommits": 0.03,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,43 +1,43 @@\n \tpublic Publisher<Void> handleResult(ReactiveServerHttpRequest request,\n \t\t\tReactiveServerHttpResponse response, HandlerResult result) {\n \n \t\tObject value = result.getValue();\n \t\tHandlerMethod handlerMethod = (HandlerMethod) result.getHandler();\n \t\tMethodParameter returnType = handlerMethod.getReturnValueType(value);\n \n \t\tif (value == null) {\n \t\t\treturn Publishers.empty();\n \t\t}\n \n \t\tResolvableType type = ResolvableType.forMethodParameter(returnType);\n \t\tMediaType mediaType = resolveMediaType(request);\n \t\tList<Object> hints = new ArrayList<>();\n \t\thints.add(UTF_8);\n \t\tPublisher<Object> elementStream;\n \t\tResolvableType elementType;\n \t\tif (conversionService.canConvert(type.getRawClass(), Publisher.class)) {\n \t\t\telementStream = conversionService.convert(value, Publisher.class);\n \t\t\telementType = type.getGeneric(0);\n \t\t}\n \t\telse {\n \t\t\telementStream = Publishers.just(value);\n \t\t\telementType = type;\n \t\t}\n \n \t\tMessageToByteEncoder<Object> encoder = (MessageToByteEncoder<Object>) resolveEncoder(\n-\t\t\t\trequest, elementType, mediaType, hints.toArray());\n+\t\t\t\telementType, mediaType, hints.toArray());\n \n \t\tif (encoder != null) {\n \t\t\tPublisher<ByteBuffer> outputStream = encoder.encode(elementStream, type, mediaType, hints.toArray());\n-\t\t\tList<MessageToByteEncoder<ByteBuffer>> postProcessors = resolvePostProcessors(request,\n+\t\t\tList<MessageToByteEncoder<ByteBuffer>> postProcessors = resolvePostProcessors(\n \t\t\t\t\telementType, mediaType, hints.toArray());\n \t\t\tfor (MessageToByteEncoder<ByteBuffer> postProcessor : postProcessors) {\n \t\t\t\toutputStream = postProcessor.encode(outputStream, elementType, mediaType, hints.toArray());\n \t\t\t}\n \t\t\tresponse.getHeaders().setContentType(mediaType);\n \t\t\treturn response.setBody(outputStream);\n \t\t}\n \t\tString returnTypeName = returnType.getParameterType().getName();\n \t\treturn Publishers.error(new IllegalStateException(\"Return value type '\" + returnTypeName +\n \t\t\t\t\"' with media type '\" + mediaType + \"' not supported\"));\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"c0dff3d2bb2277429f4e387d18deb75b0797a375": {
			"type": "Ybodychange",
			"commitMessage": "Comply with Spring Framework code style\n\nhttps://github.com/spring-projects/spring-framework/wiki/Spring-Framework-Code-Style\n",
			"commitDate": "2015-10-30, 3:22 PM",
			"commitName": "c0dff3d2bb2277429f4e387d18deb75b0797a375",
			"commitAuthor": "Rossen Stoyanchev",
			"commitDateOld": "2015-10-30, 4:03 AM",
			"commitNameOld": "01ae961820768bfe9c1f948a74a37104dcdef992",
			"commitAuthorOld": "Sebastien Deleuze",
			"daysBetweenCommits": 0.47,
			"commitsBetweenForRepo": 3,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,41 +1,43 @@\n \tpublic Publisher<Void> handleResult(ReactiveServerHttpRequest request,\n-\t\t\tReactiveServerHttpResponse response,\n-\t\t\tHandlerResult result) {\n+\t\t\tReactiveServerHttpResponse response, HandlerResult result) {\n \n \t\tObject value = result.getValue();\n \t\tHandlerMethod handlerMethod = (HandlerMethod) result.getHandler();\n \t\tMethodParameter returnType = handlerMethod.getReturnValueType(value);\n \n \t\tif (value == null) {\n \t\t\treturn Publishers.empty();\n \t\t}\n \n \t\tResolvableType type = ResolvableType.forMethodParameter(returnType);\n \t\tMediaType mediaType = resolveMediaType(request);\n \t\tList<Object> hints = new ArrayList<>();\n \t\thints.add(UTF_8);\n \t\tPublisher<Object> elementStream;\n \t\tResolvableType elementType;\n \t\tif (conversionService.canConvert(type.getRawClass(), Publisher.class)) {\n \t\t\telementStream = conversionService.convert(value, Publisher.class);\n \t\t\telementType = type.getGeneric(0);\n \t\t}\n \t\telse {\n \t\t\telementStream = Publishers.just(value);\n \t\t\telementType = type;\n \t\t}\n \n-\t\tMessageToByteEncoder<Object> serializer = (MessageToByteEncoder<Object>) resolveSerializer(request, elementType, mediaType, hints.toArray());\n-\t\tif (serializer != null) {\n-\t\t\tPublisher<ByteBuffer> outputStream = serializer.encode(elementStream, type, mediaType, hints.toArray());\n-\t\t\tList<MessageToByteEncoder<ByteBuffer>> postProcessors = resolvePostProcessors(request, elementType, mediaType, hints.toArray());\n+\t\tMessageToByteEncoder<Object> encoder = (MessageToByteEncoder<Object>) resolveEncoder(\n+\t\t\t\trequest, elementType, mediaType, hints.toArray());\n+\n+\t\tif (encoder != null) {\n+\t\t\tPublisher<ByteBuffer> outputStream = encoder.encode(elementStream, type, mediaType, hints.toArray());\n+\t\t\tList<MessageToByteEncoder<ByteBuffer>> postProcessors = resolvePostProcessors(request,\n+\t\t\t\t\telementType, mediaType, hints.toArray());\n \t\t\tfor (MessageToByteEncoder<ByteBuffer> postProcessor : postProcessors) {\n \t\t\t\toutputStream = postProcessor.encode(outputStream, elementType, mediaType, hints.toArray());\n \t\t\t}\n \t\t\tresponse.getHeaders().setContentType(mediaType);\n \t\t\treturn response.setBody(outputStream);\n \t\t}\n-\t\treturn Publishers.error(new IllegalStateException(\n-\t\t\t\t\"Return value type '\" + returnType.getParameterType().getName() +\n-\t\t\t\t\t\t\"' with media type '\" + mediaType + \"' not supported\"));\n+\t\tString returnTypeName = returnType.getParameterType().getName();\n+\t\treturn Publishers.error(new IllegalStateException(\"Return value type '\" + returnTypeName +\n+\t\t\t\t\"' with media type '\" + mediaType + \"' not supported\"));\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"45a88974bc9545eff6c7de07d054a2836dcbdfca": {
			"type": "Ybodychange",
			"commitMessage": "Changed addBody() to setBody()\n",
			"commitDate": "2015-10-29, 9:28 AM",
			"commitName": "45a88974bc9545eff6c7de07d054a2836dcbdfca",
			"commitAuthor": "Arjen Poutsma",
			"commitDateOld": "2015-10-29, 8:45 AM",
			"commitNameOld": "bab3b6fd1c4946cdba59aca365aba1a7f4ca6033",
			"commitAuthorOld": "Arjen Poutsma",
			"daysBetweenCommits": 0.03,
			"commitsBetweenForRepo": 2,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,40 +1,41 @@\n \tpublic Publisher<Void> handleResult(ReactiveServerHttpRequest request,\n \t\t\tReactiveServerHttpResponse response,\n \t\t\tHandlerResult result) {\n \n \t\tObject value = result.getValue();\n \t\tHandlerMethod handlerMethod = (HandlerMethod) result.getHandler();\n \t\tMethodParameter returnType = handlerMethod.getReturnValueType(value);\n \n \t\tif (value == null) {\n \t\t\treturn Publishers.empty();\n \t\t}\n \n \t\tResolvableType type = ResolvableType.forMethodParameter(returnType);\n \t\tMediaType mediaType = resolveMediaType(request);\n \t\tList<Object> hints = new ArrayList<>();\n \t\thints.add(UTF_8);\n \t\tPublisher<Object> elementStream;\n \t\tResolvableType elementType;\n \t\tif (conversionService.canConvert(type.getRawClass(), Publisher.class)) {\n \t\t\telementStream = conversionService.convert(value, Publisher.class);\n \t\t\telementType = type.getGeneric(0);\n \t\t}\n \t\telse {\n \t\t\telementStream = Publishers.just(value);\n \t\t\telementType = type;\n \t\t}\n \n \t\tMessageToByteEncoder<Object> serializer = (MessageToByteEncoder<Object>) resolveSerializer(request, elementType, mediaType, hints.toArray());\n \t\tif (serializer != null) {\n \t\t\tPublisher<ByteBuffer> outputStream = serializer.encode(elementStream, type, mediaType, hints.toArray());\n \t\t\tList<MessageToByteEncoder<ByteBuffer>> postProcessors = resolvePostProcessors(request, elementType, mediaType, hints.toArray());\n \t\t\tfor (MessageToByteEncoder<ByteBuffer> postProcessor : postProcessors) {\n \t\t\t\toutputStream = postProcessor.encode(outputStream, elementType, mediaType, hints.toArray());\n \t\t\t}\n \t\t\tresponse.getHeaders().setContentType(mediaType);\n-\t\t\treturn response.addBody(outputStream);\n+\t\t\treturn response.setBody(outputStream);\n \t\t}\n \t\treturn Publishers.error(new IllegalStateException(\n-\t\t  \"Return value type '\" + returnType.getParameterType().getName() + \"' with media type '\" + mediaType + \"' not supported\"  ));\n+\t\t\t\t\"Return value type '\" + returnType.getParameterType().getName() +\n+\t\t\t\t\t\t\"' with media type '\" + mediaType + \"' not supported\"));\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"bab3b6fd1c4946cdba59aca365aba1a7f4ca6033": {
			"type": "Ymultichange(Yparameterchange,Ybodychange)",
			"commitMessage": "Introduce HttpMessage hierarchy\n\nThis commit introduces \"reactive\" sub-interfaces of the HttpMessage\ninterface found in the Spring Framework.\n",
			"commitDate": "2015-10-29, 8:45 AM",
			"commitName": "bab3b6fd1c4946cdba59aca365aba1a7f4ca6033",
			"commitAuthor": "Arjen Poutsma",
			"subchanges": [
				{
					"type": "Yparameterchange",
					"commitMessage": "Introduce HttpMessage hierarchy\n\nThis commit introduces \"reactive\" sub-interfaces of the HttpMessage\ninterface found in the Spring Framework.\n",
					"commitDate": "2015-10-29, 8:45 AM",
					"commitName": "bab3b6fd1c4946cdba59aca365aba1a7f4ca6033",
					"commitAuthor": "Arjen Poutsma",
					"commitDateOld": "2015-10-29, 3:50 AM",
					"commitNameOld": "adc50bbfb9e95e742c36ee3e99c1550e6638bcfa",
					"commitAuthorOld": "Sebastien Deleuze",
					"daysBetweenCommits": 0.21,
					"commitsBetweenForRepo": 3,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,39 +1,40 @@\n-\tpublic Publisher<Void> handleResult(ServerHttpRequest request, ServerHttpResponse response,\n+\tpublic Publisher<Void> handleResult(ReactiveServerHttpRequest request,\n+\t\t\tReactiveServerHttpResponse response,\n \t\t\tHandlerResult result) {\n \n \t\tObject value = result.getValue();\n \t\tHandlerMethod handlerMethod = (HandlerMethod) result.getHandler();\n \t\tMethodParameter returnType = handlerMethod.getReturnValueType(value);\n \n \t\tif (value == null) {\n \t\t\treturn Publishers.empty();\n \t\t}\n \n \t\tResolvableType type = ResolvableType.forMethodParameter(returnType);\n \t\tMediaType mediaType = resolveMediaType(request);\n \t\tList<Object> hints = new ArrayList<>();\n \t\thints.add(UTF_8);\n \t\tPublisher<Object> elementStream;\n \t\tResolvableType elementType;\n \t\tif (conversionService.canConvert(type.getRawClass(), Publisher.class)) {\n \t\t\telementStream = conversionService.convert(value, Publisher.class);\n \t\t\telementType = type.getGeneric(0);\n \t\t}\n \t\telse {\n \t\t\telementStream = Publishers.just(value);\n \t\t\telementType = type;\n \t\t}\n \n \t\tMessageToByteEncoder<Object> serializer = (MessageToByteEncoder<Object>) resolveSerializer(request, elementType, mediaType, hints.toArray());\n \t\tif (serializer != null) {\n \t\t\tPublisher<ByteBuffer> outputStream = serializer.encode(elementStream, type, mediaType, hints.toArray());\n \t\t\tList<MessageToByteEncoder<ByteBuffer>> postProcessors = resolvePostProcessors(request, elementType, mediaType, hints.toArray());\n \t\t\tfor (MessageToByteEncoder<ByteBuffer> postProcessor : postProcessors) {\n \t\t\t\toutputStream = postProcessor.encode(outputStream, elementType, mediaType, hints.toArray());\n \t\t\t}\n \t\t\tresponse.getHeaders().setContentType(mediaType);\n-\t\t\treturn response.writeWith(outputStream);\n+\t\t\treturn response.addBody(outputStream);\n \t\t}\n \t\treturn Publishers.error(new IllegalStateException(\n \t\t  \"Return value type '\" + returnType.getParameterType().getName() + \"' with media type '\" + mediaType + \"' not supported\"  ));\n \t}\n\\ No newline at end of file\n",
					"extendedDetails": {
						"oldValue": "[request-ServerHttpRequest, response-ServerHttpResponse, result-HandlerResult]",
						"newValue": "[request-ReactiveServerHttpRequest, response-ReactiveServerHttpResponse, result-HandlerResult]"
					}
				},
				{
					"type": "Ybodychange",
					"commitMessage": "Introduce HttpMessage hierarchy\n\nThis commit introduces \"reactive\" sub-interfaces of the HttpMessage\ninterface found in the Spring Framework.\n",
					"commitDate": "2015-10-29, 8:45 AM",
					"commitName": "bab3b6fd1c4946cdba59aca365aba1a7f4ca6033",
					"commitAuthor": "Arjen Poutsma",
					"commitDateOld": "2015-10-29, 3:50 AM",
					"commitNameOld": "adc50bbfb9e95e742c36ee3e99c1550e6638bcfa",
					"commitAuthorOld": "Sebastien Deleuze",
					"daysBetweenCommits": 0.21,
					"commitsBetweenForRepo": 3,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,39 +1,40 @@\n-\tpublic Publisher<Void> handleResult(ServerHttpRequest request, ServerHttpResponse response,\n+\tpublic Publisher<Void> handleResult(ReactiveServerHttpRequest request,\n+\t\t\tReactiveServerHttpResponse response,\n \t\t\tHandlerResult result) {\n \n \t\tObject value = result.getValue();\n \t\tHandlerMethod handlerMethod = (HandlerMethod) result.getHandler();\n \t\tMethodParameter returnType = handlerMethod.getReturnValueType(value);\n \n \t\tif (value == null) {\n \t\t\treturn Publishers.empty();\n \t\t}\n \n \t\tResolvableType type = ResolvableType.forMethodParameter(returnType);\n \t\tMediaType mediaType = resolveMediaType(request);\n \t\tList<Object> hints = new ArrayList<>();\n \t\thints.add(UTF_8);\n \t\tPublisher<Object> elementStream;\n \t\tResolvableType elementType;\n \t\tif (conversionService.canConvert(type.getRawClass(), Publisher.class)) {\n \t\t\telementStream = conversionService.convert(value, Publisher.class);\n \t\t\telementType = type.getGeneric(0);\n \t\t}\n \t\telse {\n \t\t\telementStream = Publishers.just(value);\n \t\t\telementType = type;\n \t\t}\n \n \t\tMessageToByteEncoder<Object> serializer = (MessageToByteEncoder<Object>) resolveSerializer(request, elementType, mediaType, hints.toArray());\n \t\tif (serializer != null) {\n \t\t\tPublisher<ByteBuffer> outputStream = serializer.encode(elementStream, type, mediaType, hints.toArray());\n \t\t\tList<MessageToByteEncoder<ByteBuffer>> postProcessors = resolvePostProcessors(request, elementType, mediaType, hints.toArray());\n \t\t\tfor (MessageToByteEncoder<ByteBuffer> postProcessor : postProcessors) {\n \t\t\t\toutputStream = postProcessor.encode(outputStream, elementType, mediaType, hints.toArray());\n \t\t\t}\n \t\t\tresponse.getHeaders().setContentType(mediaType);\n-\t\t\treturn response.writeWith(outputStream);\n+\t\t\treturn response.addBody(outputStream);\n \t\t}\n \t\treturn Publishers.error(new IllegalStateException(\n \t\t  \"Return value type '\" + returnType.getParameterType().getName() + \"' with media type '\" + mediaType + \"' not supported\"  ));\n \t}\n\\ No newline at end of file\n",
					"extendedDetails": {}
				}
			]
		},
		"adc50bbfb9e95e742c36ee3e99c1550e6638bcfa": {
			"type": "Ybodychange",
			"commitMessage": "Add handler method parameter and result converters\n\nThis commit introduces the following changes:\n - Publisher -> Observable/Stream/etc. conversion is now managed\n    in a dedicated ConversionService instead of directly in\n    RequestBodyArgumentResolver and ResponseBodyResultHandler\n - More isolated logic that decides if the stream should be\n    serialized as a JSON array or not\n - Publisher<ByteBuffer> are now handled by regular\n   ByteBufferEncoder and ByteBufferDecoder\n - Handle Publisher<Void> return value properly\n - Ensure that the headers are properly written even for response\n   without body\n - Improve JsonObjectEncoder to autodetect JSON arrays\n",
			"commitDate": "2015-10-29, 3:50 AM",
			"commitName": "adc50bbfb9e95e742c36ee3e99c1550e6638bcfa",
			"commitAuthor": "Sebastien Deleuze",
			"commitDateOld": "2015-10-19, 3:15 AM",
			"commitNameOld": "cf2c1514af43bc955571ede20876d6cda1779f11",
			"commitAuthorOld": "Sebastien Deleuze",
			"daysBetweenCommits": 10.02,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,50 +1,39 @@\n \tpublic Publisher<Void> handleResult(ServerHttpRequest request, ServerHttpResponse response,\n \t\t\tHandlerResult result) {\n \n \t\tObject value = result.getValue();\n \t\tHandlerMethod handlerMethod = (HandlerMethod) result.getHandler();\n \t\tMethodParameter returnType = handlerMethod.getReturnValueType(value);\n \n \t\tif (value == null) {\n \t\t\treturn Publishers.empty();\n \t\t}\n \n-\t\tMediaType mediaType = resolveMediaType(request);\n \t\tResolvableType type = ResolvableType.forMethodParameter(returnType);\n+\t\tMediaType mediaType = resolveMediaType(request);\n \t\tList<Object> hints = new ArrayList<>();\n \t\thints.add(UTF_8);\n-\t\tMessageToByteEncoder<Object> serializer = (MessageToByteEncoder<Object>)resolveSerializer(request, type, mediaType, hints.toArray());\n+\t\tPublisher<Object> elementStream;\n+\t\tResolvableType elementType;\n+\t\tif (conversionService.canConvert(type.getRawClass(), Publisher.class)) {\n+\t\t\telementStream = conversionService.convert(value, Publisher.class);\n+\t\t\telementType = type.getGeneric(0);\n+\t\t}\n+\t\telse {\n+\t\t\telementStream = Publishers.just(value);\n+\t\t\telementType = type;\n+\t\t}\n+\n+\t\tMessageToByteEncoder<Object> serializer = (MessageToByteEncoder<Object>) resolveSerializer(request, elementType, mediaType, hints.toArray());\n \t\tif (serializer != null) {\n-\t\t\tPublisher<Object> elementStream;\n-\n-\t\t\t// TODO: Refactor type conversion\n-\t\t\tif (Promise.class.isAssignableFrom(type.getRawClass())) {\n-\t\t\t\telementStream = ((Promise)value).stream();\n-\t\t\t}\n-\t\t\telse if (Observable.class.isAssignableFrom(type.getRawClass())) {\n-\t\t\t\telementStream = RxJava1Converter.from((Observable) value);\n-\t\t\t}\n-\t\t\telse if (Single.class.isAssignableFrom(type.getRawClass())) {\n-\t\t\t\telementStream = RxJava1SingleConverter.from((Single)value);\n-\t\t\t}\n-\t\t\telse if (CompletableFuture.class.isAssignableFrom(type.getRawClass())) {\n-\t\t\t\telementStream = CompletableFutureConverter.from((CompletableFuture) value);\n-\t\t\t}\n-\t\t\telse if (Publisher.class.isAssignableFrom(type.getRawClass())) {\n-\t\t\t\telementStream = (Publisher)value;\n-\t\t\t}\n-\t\t\telse {\n-\t\t\t\telementStream = Publishers.just(value);\n-\t\t\t}\n-\n \t\t\tPublisher<ByteBuffer> outputStream = serializer.encode(elementStream, type, mediaType, hints.toArray());\n-\t\t\tList<MessageToByteEncoder<ByteBuffer>> postProcessors = resolvePostProcessors(request, type, mediaType, hints.toArray());\n+\t\t\tList<MessageToByteEncoder<ByteBuffer>> postProcessors = resolvePostProcessors(request, elementType, mediaType, hints.toArray());\n \t\t\tfor (MessageToByteEncoder<ByteBuffer> postProcessor : postProcessors) {\n-\t\t\t\toutputStream = postProcessor.encode(outputStream, type, mediaType, hints.toArray());\n+\t\t\t\toutputStream = postProcessor.encode(outputStream, elementType, mediaType, hints.toArray());\n \t\t\t}\n \t\t\tresponse.getHeaders().setContentType(mediaType);\n \t\t\treturn response.writeWith(outputStream);\n \t\t}\n \t\treturn Publishers.error(new IllegalStateException(\n \t\t  \"Return value type '\" + returnType.getParameterType().getName() + \"' with media type '\" + mediaType + \"' not supported\"  ));\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"cf2c1514af43bc955571ede20876d6cda1779f11": {
			"type": "Ybodychange",
			"commitMessage": "Use latest Reactor core capabilities\n\n No need for rxjava-reactive-streams dependency and\n CompletableFutureUtils anymore.\n",
			"commitDate": "2015-10-19, 3:15 AM",
			"commitName": "cf2c1514af43bc955571ede20876d6cda1779f11",
			"commitAuthor": "Sebastien Deleuze",
			"commitDateOld": "2015-10-16, 1:13 AM",
			"commitNameOld": "8ca04b84259f1840db7e1037828f7120427eb7b1",
			"commitAuthorOld": "Sebastien Deleuze",
			"daysBetweenCommits": 3.08,
			"commitsBetweenForRepo": 3,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,50 +1,50 @@\n \tpublic Publisher<Void> handleResult(ServerHttpRequest request, ServerHttpResponse response,\n \t\t\tHandlerResult result) {\n \n \t\tObject value = result.getValue();\n \t\tHandlerMethod handlerMethod = (HandlerMethod) result.getHandler();\n \t\tMethodParameter returnType = handlerMethod.getReturnValueType(value);\n \n \t\tif (value == null) {\n \t\t\treturn Publishers.empty();\n \t\t}\n \n \t\tMediaType mediaType = resolveMediaType(request);\n \t\tResolvableType type = ResolvableType.forMethodParameter(returnType);\n \t\tList<Object> hints = new ArrayList<>();\n \t\thints.add(UTF_8);\n \t\tMessageToByteEncoder<Object> serializer = (MessageToByteEncoder<Object>)resolveSerializer(request, type, mediaType, hints.toArray());\n \t\tif (serializer != null) {\n \t\t\tPublisher<Object> elementStream;\n \n \t\t\t// TODO: Refactor type conversion\n \t\t\tif (Promise.class.isAssignableFrom(type.getRawClass())) {\n \t\t\t\telementStream = ((Promise)value).stream();\n \t\t\t}\n \t\t\telse if (Observable.class.isAssignableFrom(type.getRawClass())) {\n-\t\t\t\telementStream = RxReactiveStreams.toPublisher((Observable) value);\n+\t\t\t\telementStream = RxJava1Converter.from((Observable) value);\n \t\t\t}\n \t\t\telse if (Single.class.isAssignableFrom(type.getRawClass())) {\n-\t\t\t\telementStream = RxReactiveStreams.toPublisher(((Single)value).toObservable());\n+\t\t\t\telementStream = RxJava1SingleConverter.from((Single)value);\n \t\t\t}\n \t\t\telse if (CompletableFuture.class.isAssignableFrom(type.getRawClass())) {\n-\t\t\t\telementStream = CompletableFutureUtils.toPublisher((CompletableFuture) value);\n+\t\t\t\telementStream = CompletableFutureConverter.from((CompletableFuture) value);\n \t\t\t}\n \t\t\telse if (Publisher.class.isAssignableFrom(type.getRawClass())) {\n \t\t\t\telementStream = (Publisher)value;\n \t\t\t}\n \t\t\telse {\n \t\t\t\telementStream = Publishers.just(value);\n \t\t\t}\n \n \t\t\tPublisher<ByteBuffer> outputStream = serializer.encode(elementStream, type, mediaType, hints.toArray());\n \t\t\tList<MessageToByteEncoder<ByteBuffer>> postProcessors = resolvePostProcessors(request, type, mediaType, hints.toArray());\n \t\t\tfor (MessageToByteEncoder<ByteBuffer> postProcessor : postProcessors) {\n \t\t\t\toutputStream = postProcessor.encode(outputStream, type, mediaType, hints.toArray());\n \t\t\t}\n \t\t\tresponse.getHeaders().setContentType(mediaType);\n \t\t\treturn response.writeWith(outputStream);\n \t\t}\n \t\treturn Publishers.error(new IllegalStateException(\n \t\t  \"Return value type '\" + returnType.getParameterType().getName() + \"' with media type '\" + mediaType + \"' not supported\"  ));\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"8ca04b84259f1840db7e1037828f7120427eb7b1": {
			"type": "Ybodychange",
			"commitMessage": "More accurate ResponseBodyResultHandler error message\n",
			"commitDate": "2015-10-16, 1:13 AM",
			"commitName": "8ca04b84259f1840db7e1037828f7120427eb7b1",
			"commitAuthor": "Sebastien Deleuze",
			"commitDateOld": "2015-10-07, 5:24 AM",
			"commitNameOld": "464ff1d9606a3189a41bae80e504929dec091d33",
			"commitAuthorOld": "Stephane Maldini",
			"daysBetweenCommits": 8.83,
			"commitsBetweenForRepo": 7,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,50 +1,50 @@\n \tpublic Publisher<Void> handleResult(ServerHttpRequest request, ServerHttpResponse response,\n \t\t\tHandlerResult result) {\n \n \t\tObject value = result.getValue();\n \t\tHandlerMethod handlerMethod = (HandlerMethod) result.getHandler();\n \t\tMethodParameter returnType = handlerMethod.getReturnValueType(value);\n \n \t\tif (value == null) {\n \t\t\treturn Publishers.empty();\n \t\t}\n \n \t\tMediaType mediaType = resolveMediaType(request);\n \t\tResolvableType type = ResolvableType.forMethodParameter(returnType);\n \t\tList<Object> hints = new ArrayList<>();\n \t\thints.add(UTF_8);\n \t\tMessageToByteEncoder<Object> serializer = (MessageToByteEncoder<Object>)resolveSerializer(request, type, mediaType, hints.toArray());\n \t\tif (serializer != null) {\n \t\t\tPublisher<Object> elementStream;\n \n \t\t\t// TODO: Refactor type conversion\n \t\t\tif (Promise.class.isAssignableFrom(type.getRawClass())) {\n \t\t\t\telementStream = ((Promise)value).stream();\n \t\t\t}\n \t\t\telse if (Observable.class.isAssignableFrom(type.getRawClass())) {\n \t\t\t\telementStream = RxReactiveStreams.toPublisher((Observable) value);\n \t\t\t}\n \t\t\telse if (Single.class.isAssignableFrom(type.getRawClass())) {\n \t\t\t\telementStream = RxReactiveStreams.toPublisher(((Single)value).toObservable());\n \t\t\t}\n \t\t\telse if (CompletableFuture.class.isAssignableFrom(type.getRawClass())) {\n \t\t\t\telementStream = CompletableFutureUtils.toPublisher((CompletableFuture) value);\n \t\t\t}\n \t\t\telse if (Publisher.class.isAssignableFrom(type.getRawClass())) {\n \t\t\t\telementStream = (Publisher)value;\n \t\t\t}\n \t\t\telse {\n \t\t\t\telementStream = Publishers.just(value);\n \t\t\t}\n \n \t\t\tPublisher<ByteBuffer> outputStream = serializer.encode(elementStream, type, mediaType, hints.toArray());\n \t\t\tList<MessageToByteEncoder<ByteBuffer>> postProcessors = resolvePostProcessors(request, type, mediaType, hints.toArray());\n \t\t\tfor (MessageToByteEncoder<ByteBuffer> postProcessor : postProcessors) {\n \t\t\t\toutputStream = postProcessor.encode(outputStream, type, mediaType, hints.toArray());\n \t\t\t}\n \t\t\tresponse.getHeaders().setContentType(mediaType);\n \t\t\treturn response.writeWith(outputStream);\n \t\t}\n \t\treturn Publishers.error(new IllegalStateException(\n-\t\t  \"Return value type not supported: \" + returnType));\n+\t\t  \"Return value type '\" + returnType.getParameterType().getName() + \"' with media type '\" + mediaType + \"' not supported\"  ));\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"464ff1d9606a3189a41bae80e504929dec091d33": {
			"type": "Ybodychange",
			"commitMessage": "Progress #24\nReplace Streams fail, empty and Stream map with Publishers.error, empty and map.\nReplace Streams calls by Publishers.flatMap, just and Publishers.from\nPrecise cancel and size to toReadQueue to simulate Promise\nUpdate build\n",
			"commitDate": "2015-10-07, 5:24 AM",
			"commitName": "464ff1d9606a3189a41bae80e504929dec091d33",
			"commitAuthor": "Stephane Maldini",
			"commitDateOld": "2015-10-02, 12:09 PM",
			"commitNameOld": "9516c9992f4ed53bbb0be801bed31b6280eaff8c",
			"commitAuthorOld": "Sebastien Deleuze",
			"daysBetweenCommits": 4.72,
			"commitsBetweenForRepo": 5,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,50 +1,50 @@\n \tpublic Publisher<Void> handleResult(ServerHttpRequest request, ServerHttpResponse response,\n \t\t\tHandlerResult result) {\n \n \t\tObject value = result.getValue();\n \t\tHandlerMethod handlerMethod = (HandlerMethod) result.getHandler();\n \t\tMethodParameter returnType = handlerMethod.getReturnValueType(value);\n \n \t\tif (value == null) {\n-\t\t\treturn Streams.empty();\n+\t\t\treturn Publishers.empty();\n \t\t}\n \n \t\tMediaType mediaType = resolveMediaType(request);\n \t\tResolvableType type = ResolvableType.forMethodParameter(returnType);\n \t\tList<Object> hints = new ArrayList<>();\n \t\thints.add(UTF_8);\n \t\tMessageToByteEncoder<Object> serializer = (MessageToByteEncoder<Object>)resolveSerializer(request, type, mediaType, hints.toArray());\n \t\tif (serializer != null) {\n \t\t\tPublisher<Object> elementStream;\n \n \t\t\t// TODO: Refactor type conversion\n \t\t\tif (Promise.class.isAssignableFrom(type.getRawClass())) {\n \t\t\t\telementStream = ((Promise)value).stream();\n \t\t\t}\n \t\t\telse if (Observable.class.isAssignableFrom(type.getRawClass())) {\n \t\t\t\telementStream = RxReactiveStreams.toPublisher((Observable) value);\n \t\t\t}\n \t\t\telse if (Single.class.isAssignableFrom(type.getRawClass())) {\n \t\t\t\telementStream = RxReactiveStreams.toPublisher(((Single)value).toObservable());\n \t\t\t}\n \t\t\telse if (CompletableFuture.class.isAssignableFrom(type.getRawClass())) {\n \t\t\t\telementStream = CompletableFutureUtils.toPublisher((CompletableFuture) value);\n \t\t\t}\n \t\t\telse if (Publisher.class.isAssignableFrom(type.getRawClass())) {\n \t\t\t\telementStream = (Publisher)value;\n \t\t\t}\n \t\t\telse {\n-\t\t\t\telementStream = Streams.just(value);\n+\t\t\t\telementStream = Publishers.just(value);\n \t\t\t}\n \n \t\t\tPublisher<ByteBuffer> outputStream = serializer.encode(elementStream, type, mediaType, hints.toArray());\n \t\t\tList<MessageToByteEncoder<ByteBuffer>> postProcessors = resolvePostProcessors(request, type, mediaType, hints.toArray());\n \t\t\tfor (MessageToByteEncoder<ByteBuffer> postProcessor : postProcessors) {\n \t\t\t\toutputStream = postProcessor.encode(outputStream, type, mediaType, hints.toArray());\n \t\t\t}\n \t\t\tresponse.getHeaders().setContentType(mediaType);\n-\t\t\treturn response.writeWith(Streams.wrap(outputStream));\n+\t\t\treturn response.writeWith(outputStream);\n \t\t}\n-\t\treturn Streams.fail(new IllegalStateException(\n-\t\t\t\t\"Return value type not supported: \" + returnType));\n+\t\treturn Publishers.error(new IllegalStateException(\n+\t\t  \"Return value type not supported: \" + returnType));\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"f816cc6a516c324875fa409a33d288447c6996f7": {
			"type": "Ybodychange",
			"commitMessage": "Add CompletableFuture/Single/Promise support\n",
			"commitDate": "2015-09-24, 3:02 PM",
			"commitName": "f816cc6a516c324875fa409a33d288447c6996f7",
			"commitAuthor": "Sebastien Deleuze",
			"commitDateOld": "2015-09-22, 12:02 AM",
			"commitNameOld": "110d9d7cd906c524af5053329a65ef4e1bd9f7eb",
			"commitAuthorOld": "Sebastien Deleuze",
			"daysBetweenCommits": 2.62,
			"commitsBetweenForRepo": 4,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,41 +1,50 @@\n \tpublic Publisher<Void> handleResult(ServerHttpRequest request, ServerHttpResponse response,\n \t\t\tHandlerResult result) {\n \n \t\tObject value = result.getValue();\n \t\tHandlerMethod handlerMethod = (HandlerMethod) result.getHandler();\n \t\tMethodParameter returnType = handlerMethod.getReturnValueType(value);\n \n \t\tif (value == null) {\n \t\t\treturn Streams.empty();\n \t\t}\n \n \t\tMediaType mediaType = resolveMediaType(request);\n \t\tResolvableType type = ResolvableType.forMethodParameter(returnType);\n \t\tList<Object> hints = new ArrayList<>();\n \t\thints.add(UTF_8);\n \t\tMessageToByteEncoder<Object> serializer = (MessageToByteEncoder<Object>)resolveSerializer(request, type, mediaType, hints.toArray());\n \t\tif (serializer != null) {\n \t\t\tPublisher<Object> elementStream;\n \n \t\t\t// TODO: Refactor type conversion\n-\t\t\tif (Observable.class.isAssignableFrom(type.getRawClass())) {\n+\t\t\tif (Promise.class.isAssignableFrom(type.getRawClass())) {\n+\t\t\t\telementStream = ((Promise)value).stream();\n+\t\t\t}\n+\t\t\telse if (Observable.class.isAssignableFrom(type.getRawClass())) {\n \t\t\t\telementStream = RxReactiveStreams.toPublisher((Observable) value);\n \t\t\t}\n+\t\t\telse if (Single.class.isAssignableFrom(type.getRawClass())) {\n+\t\t\t\telementStream = RxReactiveStreams.toPublisher(((Single)value).toObservable());\n+\t\t\t}\n+\t\t\telse if (CompletableFuture.class.isAssignableFrom(type.getRawClass())) {\n+\t\t\t\telementStream = CompletableFutureUtils.toPublisher((CompletableFuture) value);\n+\t\t\t}\n \t\t\telse if (Publisher.class.isAssignableFrom(type.getRawClass())) {\n \t\t\t\telementStream = (Publisher)value;\n \t\t\t}\n \t\t\telse {\n \t\t\t\telementStream = Streams.just(value);\n \t\t\t}\n \n \t\t\tPublisher<ByteBuffer> outputStream = serializer.encode(elementStream, type, mediaType, hints.toArray());\n \t\t\tList<MessageToByteEncoder<ByteBuffer>> postProcessors = resolvePostProcessors(request, type, mediaType, hints.toArray());\n \t\t\tfor (MessageToByteEncoder<ByteBuffer> postProcessor : postProcessors) {\n \t\t\t\toutputStream = postProcessor.encode(outputStream, type, mediaType, hints.toArray());\n \t\t\t}\n \t\t\tresponse.getHeaders().setContentType(mediaType);\n \t\t\treturn response.writeWith(Streams.wrap(outputStream));\n \t\t}\n \t\treturn Streams.fail(new IllegalStateException(\n \t\t\t\t\"Return value type not supported: \" + returnType));\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"110d9d7cd906c524af5053329a65ef4e1bd9f7eb": {
			"type": "Ybodychange",
			"commitMessage": "Use ByteBuffer instead of byte[]\n",
			"commitDate": "2015-09-22, 12:02 AM",
			"commitName": "110d9d7cd906c524af5053329a65ef4e1bd9f7eb",
			"commitAuthor": "Sebastien Deleuze",
			"commitDateOld": "2015-09-10, 5:47 AM",
			"commitNameOld": "881db0688b5448768e1b3196fe5365a3d41d9342",
			"commitAuthorOld": "Sebastien Deleuze",
			"daysBetweenCommits": 11.76,
			"commitsBetweenForRepo": 9,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,41 +1,41 @@\n \tpublic Publisher<Void> handleResult(ServerHttpRequest request, ServerHttpResponse response,\n \t\t\tHandlerResult result) {\n \n \t\tObject value = result.getValue();\n \t\tHandlerMethod handlerMethod = (HandlerMethod) result.getHandler();\n \t\tMethodParameter returnType = handlerMethod.getReturnValueType(value);\n \n \t\tif (value == null) {\n \t\t\treturn Streams.empty();\n \t\t}\n \n \t\tMediaType mediaType = resolveMediaType(request);\n \t\tResolvableType type = ResolvableType.forMethodParameter(returnType);\n \t\tList<Object> hints = new ArrayList<>();\n \t\thints.add(UTF_8);\n \t\tMessageToByteEncoder<Object> serializer = (MessageToByteEncoder<Object>)resolveSerializer(request, type, mediaType, hints.toArray());\n \t\tif (serializer != null) {\n \t\t\tPublisher<Object> elementStream;\n \n \t\t\t// TODO: Refactor type conversion\n \t\t\tif (Observable.class.isAssignableFrom(type.getRawClass())) {\n \t\t\t\telementStream = RxReactiveStreams.toPublisher((Observable) value);\n \t\t\t}\n \t\t\telse if (Publisher.class.isAssignableFrom(type.getRawClass())) {\n \t\t\t\telementStream = (Publisher)value;\n \t\t\t}\n \t\t\telse {\n \t\t\t\telementStream = Streams.just(value);\n \t\t\t}\n \n \t\t\tPublisher<ByteBuffer> outputStream = serializer.encode(elementStream, type, mediaType, hints.toArray());\n \t\t\tList<MessageToByteEncoder<ByteBuffer>> postProcessors = resolvePostProcessors(request, type, mediaType, hints.toArray());\n \t\t\tfor (MessageToByteEncoder<ByteBuffer> postProcessor : postProcessors) {\n \t\t\t\toutputStream = postProcessor.encode(outputStream, type, mediaType, hints.toArray());\n \t\t\t}\n \t\t\tresponse.getHeaders().setContentType(mediaType);\n-\t\t\treturn response.writeWith(Streams.wrap(outputStream).map(buffer -> new Buffer(buffer).asBytes()));\n+\t\t\treturn response.writeWith(Streams.wrap(outputStream));\n \t\t}\n \t\treturn Streams.fail(new IllegalStateException(\n \t\t\t\t\"Return value type not supported: \" + returnType));\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"881db0688b5448768e1b3196fe5365a3d41d9342": {
			"type": "Ybodychange",
			"commitMessage": "Add Codec support\n\nThis commit adds support for Publisher based codecs that allows to convert\nbyte stream to object stream and vice & versa.\n\nJackson, JAXB2 and String codec implementations are provided.\n",
			"commitDate": "2015-09-10, 5:47 AM",
			"commitName": "881db0688b5448768e1b3196fe5365a3d41d9342",
			"commitAuthor": "Sebastien Deleuze",
			"commitDateOld": "2015-08-25, 10:45 AM",
			"commitNameOld": "202825554c022e4262fe3bd20a34faf01ab9d620",
			"commitAuthorOld": "Rossen Stoyanchev",
			"daysBetweenCommits": 15.79,
			"commitsBetweenForRepo": 10,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,26 +1,41 @@\n \tpublic Publisher<Void> handleResult(ServerHttpRequest request, ServerHttpResponse response,\n \t\t\tHandlerResult result) {\n \n \t\tObject value = result.getValue();\n \t\tHandlerMethod handlerMethod = (HandlerMethod) result.getHandler();\n \t\tMethodParameter returnType = handlerMethod.getReturnValueType(value);\n \n \t\tif (value == null) {\n \t\t\treturn Streams.empty();\n \t\t}\n \n-\t\tif (value instanceof String) {\n-\t\t\tresponse.getHeaders().setContentType(new MediaType(\"text\", \"plain\", UTF_8));\n-\t\t\treturn response.writeWith(Streams.just(((String) value).getBytes(UTF_8)));\n-\t\t}\n-\t\telse if (value instanceof Publisher) {\n-\t\t\tClass<?> type = ResolvableType.forMethodParameter(returnType).resolveGeneric(0);\n-\t\t\tif (String.class.equals(type)) {\n-\t\t\t\t@SuppressWarnings(\"unchecked\")\n-\t\t\t\tPublisher<String> content = (Publisher<String>) value;\n-\t\t\t\treturn response.writeWith(Streams.wrap(content).map(value1 -> value1.getBytes(UTF_8)));\n-\t\t\t}\n-\t\t}\n+\t\tMediaType mediaType = resolveMediaType(request);\n+\t\tResolvableType type = ResolvableType.forMethodParameter(returnType);\n+\t\tList<Object> hints = new ArrayList<>();\n+\t\thints.add(UTF_8);\n+\t\tMessageToByteEncoder<Object> serializer = (MessageToByteEncoder<Object>)resolveSerializer(request, type, mediaType, hints.toArray());\n+\t\tif (serializer != null) {\n+\t\t\tPublisher<Object> elementStream;\n \n-\t\treturn Streams.fail(new IllegalStateException(\"Return value type not supported: \" + returnType));\n+\t\t\t// TODO: Refactor type conversion\n+\t\t\tif (Observable.class.isAssignableFrom(type.getRawClass())) {\n+\t\t\t\telementStream = RxReactiveStreams.toPublisher((Observable) value);\n+\t\t\t}\n+\t\t\telse if (Publisher.class.isAssignableFrom(type.getRawClass())) {\n+\t\t\t\telementStream = (Publisher)value;\n+\t\t\t}\n+\t\t\telse {\n+\t\t\t\telementStream = Streams.just(value);\n+\t\t\t}\n+\n+\t\t\tPublisher<ByteBuffer> outputStream = serializer.encode(elementStream, type, mediaType, hints.toArray());\n+\t\t\tList<MessageToByteEncoder<ByteBuffer>> postProcessors = resolvePostProcessors(request, type, mediaType, hints.toArray());\n+\t\t\tfor (MessageToByteEncoder<ByteBuffer> postProcessor : postProcessors) {\n+\t\t\t\toutputStream = postProcessor.encode(outputStream, type, mediaType, hints.toArray());\n+\t\t\t}\n+\t\t\tresponse.getHeaders().setContentType(mediaType);\n+\t\t\treturn response.writeWith(Streams.wrap(outputStream).map(buffer -> new Buffer(buffer).asBytes()));\n+\t\t}\n+\t\treturn Streams.fail(new IllegalStateException(\n+\t\t\t\t\"Return value type not supported: \" + returnType));\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"202825554c022e4262fe3bd20a34faf01ab9d620": {
			"type": "Yintroduced",
			"commitMessage": "Add basic support for @RequestMapping\n\nJust enough for a test with an @ResponseBody method that accepts an\n@RequestParam String arg and returning Publisher<String> or String.\n\nSee RequestMappingIntegrationTests.\n",
			"commitDate": "2015-08-25, 10:45 AM",
			"commitName": "202825554c022e4262fe3bd20a34faf01ab9d620",
			"commitAuthor": "Rossen Stoyanchev"
		}
	},
	"sha": "b325c74216fd9564a36602158fa1269e2e832874"
}