{
	"repo": "https://github.com/apache/hadoop.git",
	"file": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fifo/FifoScheduler.java",
	"method": {
		"longName": "public Allocation allocate(ApplicationAttemptId applicationAttemptId, List<ResourceRequest> ask, List<SchedulingRequest> schedulingRequests, List<ContainerId> release, List<String> blacklistAdditions, List<String> blacklistRemovals, ContainerUpdates updateRequests);",
		"startLine": 323,
		"methodName": "allocate",
		"isStatic": false,
		"isAbstract": false,
		"visibility": "public"
	},
	"history": {
		"38af23796971193fa529c3d08ffde8fcd6e607b6": {
			"type": "Ymultichange(Yparameterchange,Ybodychange)",
			"commitMessage": "YARN-6599. Support anti-affinity constraint via AppPlacementAllocator. (Wangda Tan via asuresh)\n",
			"commitDate": "2018-01-31, 1:30 AM",
			"commitName": "38af23796971193fa529c3d08ffde8fcd6e607b6",
			"commitAuthor": "Arun Suresh",
			"subchanges": [
				{
					"type": "Yparameterchange",
					"commitMessage": "YARN-6599. Support anti-affinity constraint via AppPlacementAllocator. (Wangda Tan via asuresh)\n",
					"commitDate": "2018-01-31, 1:30 AM",
					"commitName": "38af23796971193fa529c3d08ffde8fcd6e607b6",
					"commitAuthor": "Arun Suresh",
					"commitDateOld": "2018-01-09, 4:59 PM",
					"commitNameOld": "55066cc53dc22b68f9ca55a0029741d6c846be0a",
					"commitAuthorOld": "Miklos Szegedi",
					"daysBetweenCommits": 21.35,
					"commitsBetweenForRepo": 132,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,65 +1,65 @@\n   public Allocation allocate(ApplicationAttemptId applicationAttemptId,\n-      List<ResourceRequest> ask, List<ContainerId> release,\n-      List<String> blacklistAdditions, List<String> blacklistRemovals,\n+      List<ResourceRequest> ask, List<SchedulingRequest> schedulingRequests,\n+      List<ContainerId> release, List<String> blacklistAdditions, List<String> blacklistRemovals,\n       ContainerUpdates updateRequests) {\n     FifoAppAttempt application = getApplicationAttempt(applicationAttemptId);\n     if (application == null) {\n       LOG.error(\"Calling allocate on removed or non existent application \" +\n           applicationAttemptId.getApplicationId());\n       return EMPTY_ALLOCATION;\n     }\n \n     // The allocate may be the leftover from previous attempt, and it will\n     // impact current attempt, such as confuse the request and allocation for\n     // current attempt's AM container.\n     // Note outside precondition check for the attempt id may be\n     // outdated here, so double check it here is necessary.\n     if (!application.getApplicationAttemptId().equals(applicationAttemptId)) {\n       LOG.error(\"Calling allocate on previous or removed \" +\n           \"or non existent application attempt \" + applicationAttemptId);\n       return EMPTY_ALLOCATION;\n     }\n \n     // Sanity check\n-    normalizeRequests(ask);\n+    normalizeResourceRequests(ask);\n \n     // Release containers\n     releaseContainers(release, application);\n \n     synchronized (application) {\n \n       // make sure we aren't stopping/removing the application\n       // when the allocate comes in\n       if (application.isStopped()) {\n         LOG.info(\"Calling allocate on a stopped \" +\n             \"application \" + applicationAttemptId);\n         return EMPTY_ALLOCATION;\n       }\n \n       if (!ask.isEmpty()) {\n         LOG.debug(\"allocate: pre-update\" +\n             \" applicationId=\" + applicationAttemptId + \n             \" application=\" + application);\n         application.showRequests();\n \n         // Update application requests\n         application.updateResourceRequests(ask);\n \n         LOG.debug(\"allocate: post-update\" +\n             \" applicationId=\" + applicationAttemptId + \n             \" application=\" + application);\n         application.showRequests();\n \n         LOG.debug(\"allocate:\" +\n             \" applicationId=\" + applicationAttemptId +\n             \" #ask=\" + ask.size());\n       }\n \n       application.updateBlacklist(blacklistAdditions, blacklistRemovals);\n \n       Resource headroom = application.getHeadroom();\n       application.setApplicationHeadroomForMetrics(headroom);\n       return new Allocation(application.pullNewlyAllocatedContainers(),\n           headroom, null, null, null, application.pullUpdatedNMTokens());\n     }\n   }\n\\ No newline at end of file\n",
					"extendedDetails": {
						"oldValue": "[applicationAttemptId-ApplicationAttemptId, ask-List<ResourceRequest>, release-List<ContainerId>, blacklistAdditions-List<String>, blacklistRemovals-List<String>, updateRequests-ContainerUpdates]",
						"newValue": "[applicationAttemptId-ApplicationAttemptId, ask-List<ResourceRequest>, schedulingRequests-List<SchedulingRequest>, release-List<ContainerId>, blacklistAdditions-List<String>, blacklistRemovals-List<String>, updateRequests-ContainerUpdates]"
					}
				},
				{
					"type": "Ybodychange",
					"commitMessage": "YARN-6599. Support anti-affinity constraint via AppPlacementAllocator. (Wangda Tan via asuresh)\n",
					"commitDate": "2018-01-31, 1:30 AM",
					"commitName": "38af23796971193fa529c3d08ffde8fcd6e607b6",
					"commitAuthor": "Arun Suresh",
					"commitDateOld": "2018-01-09, 4:59 PM",
					"commitNameOld": "55066cc53dc22b68f9ca55a0029741d6c846be0a",
					"commitAuthorOld": "Miklos Szegedi",
					"daysBetweenCommits": 21.35,
					"commitsBetweenForRepo": 132,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,65 +1,65 @@\n   public Allocation allocate(ApplicationAttemptId applicationAttemptId,\n-      List<ResourceRequest> ask, List<ContainerId> release,\n-      List<String> blacklistAdditions, List<String> blacklistRemovals,\n+      List<ResourceRequest> ask, List<SchedulingRequest> schedulingRequests,\n+      List<ContainerId> release, List<String> blacklistAdditions, List<String> blacklistRemovals,\n       ContainerUpdates updateRequests) {\n     FifoAppAttempt application = getApplicationAttempt(applicationAttemptId);\n     if (application == null) {\n       LOG.error(\"Calling allocate on removed or non existent application \" +\n           applicationAttemptId.getApplicationId());\n       return EMPTY_ALLOCATION;\n     }\n \n     // The allocate may be the leftover from previous attempt, and it will\n     // impact current attempt, such as confuse the request and allocation for\n     // current attempt's AM container.\n     // Note outside precondition check for the attempt id may be\n     // outdated here, so double check it here is necessary.\n     if (!application.getApplicationAttemptId().equals(applicationAttemptId)) {\n       LOG.error(\"Calling allocate on previous or removed \" +\n           \"or non existent application attempt \" + applicationAttemptId);\n       return EMPTY_ALLOCATION;\n     }\n \n     // Sanity check\n-    normalizeRequests(ask);\n+    normalizeResourceRequests(ask);\n \n     // Release containers\n     releaseContainers(release, application);\n \n     synchronized (application) {\n \n       // make sure we aren't stopping/removing the application\n       // when the allocate comes in\n       if (application.isStopped()) {\n         LOG.info(\"Calling allocate on a stopped \" +\n             \"application \" + applicationAttemptId);\n         return EMPTY_ALLOCATION;\n       }\n \n       if (!ask.isEmpty()) {\n         LOG.debug(\"allocate: pre-update\" +\n             \" applicationId=\" + applicationAttemptId + \n             \" application=\" + application);\n         application.showRequests();\n \n         // Update application requests\n         application.updateResourceRequests(ask);\n \n         LOG.debug(\"allocate: post-update\" +\n             \" applicationId=\" + applicationAttemptId + \n             \" application=\" + application);\n         application.showRequests();\n \n         LOG.debug(\"allocate:\" +\n             \" applicationId=\" + applicationAttemptId +\n             \" #ask=\" + ask.size());\n       }\n \n       application.updateBlacklist(blacklistAdditions, blacklistRemovals);\n \n       Resource headroom = application.getHeadroom();\n       application.setApplicationHeadroomForMetrics(headroom);\n       return new Allocation(application.pullNewlyAllocatedContainers(),\n           headroom, null, null, null, application.pullUpdatedNMTokens());\n     }\n   }\n\\ No newline at end of file\n",
					"extendedDetails": {}
				}
			]
		},
		"e2f6299f6f580d7a03f2377d19ac85f55fd4e73b": {
			"type": "Ybodychange",
			"commitMessage": "YARN-6959. RM may allocate wrong AM Container for new attempt. Contributed by Yuqi Wang\n",
			"commitDate": "2017-08-14, 10:51 AM",
			"commitName": "e2f6299f6f580d7a03f2377d19ac85f55fd4e73b",
			"commitAuthor": "Jian He",
			"commitDateOld": "2017-02-28, 10:35 AM",
			"commitNameOld": "eac6b4c35c50e555c2f1b5f913bb2c4d839f1ff4",
			"commitAuthorOld": "Wangda Tan",
			"daysBetweenCommits": 166.97,
			"commitsBetweenForRepo": 959,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,54 +1,65 @@\n   public Allocation allocate(ApplicationAttemptId applicationAttemptId,\n       List<ResourceRequest> ask, List<ContainerId> release,\n       List<String> blacklistAdditions, List<String> blacklistRemovals,\n       ContainerUpdates updateRequests) {\n     FifoAppAttempt application = getApplicationAttempt(applicationAttemptId);\n     if (application == null) {\n-      LOG.error(\"Calling allocate on removed \" +\n-          \"or non-existent application \" + applicationAttemptId);\n+      LOG.error(\"Calling allocate on removed or non existent application \" +\n+          applicationAttemptId.getApplicationId());\n+      return EMPTY_ALLOCATION;\n+    }\n+\n+    // The allocate may be the leftover from previous attempt, and it will\n+    // impact current attempt, such as confuse the request and allocation for\n+    // current attempt's AM container.\n+    // Note outside precondition check for the attempt id may be\n+    // outdated here, so double check it here is necessary.\n+    if (!application.getApplicationAttemptId().equals(applicationAttemptId)) {\n+      LOG.error(\"Calling allocate on previous or removed \" +\n+          \"or non existent application attempt \" + applicationAttemptId);\n       return EMPTY_ALLOCATION;\n     }\n \n     // Sanity check\n     normalizeRequests(ask);\n \n     // Release containers\n     releaseContainers(release, application);\n \n     synchronized (application) {\n \n       // make sure we aren't stopping/removing the application\n       // when the allocate comes in\n       if (application.isStopped()) {\n         LOG.info(\"Calling allocate on a stopped \" +\n             \"application \" + applicationAttemptId);\n         return EMPTY_ALLOCATION;\n       }\n \n       if (!ask.isEmpty()) {\n         LOG.debug(\"allocate: pre-update\" +\n             \" applicationId=\" + applicationAttemptId + \n             \" application=\" + application);\n         application.showRequests();\n \n         // Update application requests\n         application.updateResourceRequests(ask);\n \n         LOG.debug(\"allocate: post-update\" +\n             \" applicationId=\" + applicationAttemptId + \n             \" application=\" + application);\n         application.showRequests();\n \n         LOG.debug(\"allocate:\" +\n             \" applicationId=\" + applicationAttemptId +\n             \" #ask=\" + ask.size());\n       }\n \n       application.updateBlacklist(blacklistAdditions, blacklistRemovals);\n \n       Resource headroom = application.getHeadroom();\n       application.setApplicationHeadroomForMetrics(headroom);\n       return new Allocation(application.pullNewlyAllocatedContainers(),\n           headroom, null, null, null, application.pullUpdatedNMTokens());\n     }\n   }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"0a55bd841ec0f2eb89a0383f4c589526e8b138d4": {
			"type": "Yparameterchange",
			"commitMessage": "YARN-5959. RM changes to support change of container ExecutionType. (Arun Suresh via wangda)\n",
			"commitDate": "2017-01-05, 10:31 AM",
			"commitName": "0a55bd841ec0f2eb89a0383f4c589526e8b138d4",
			"commitAuthor": "Wangda Tan",
			"commitDateOld": "2017-01-03, 2:53 PM",
			"commitNameOld": "f69a107aeccc68ca1085a7be8093d36b2f45eaa1",
			"commitAuthorOld": "Wangda Tan",
			"daysBetweenCommits": 1.82,
			"commitsBetweenForRepo": 8,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,55 +1,54 @@\n   public Allocation allocate(ApplicationAttemptId applicationAttemptId,\n       List<ResourceRequest> ask, List<ContainerId> release,\n       List<String> blacklistAdditions, List<String> blacklistRemovals,\n-      List<UpdateContainerRequest> increaseRequests,\n-      List<UpdateContainerRequest> decreaseRequests) {\n+      ContainerUpdates updateRequests) {\n     FifoAppAttempt application = getApplicationAttempt(applicationAttemptId);\n     if (application == null) {\n       LOG.error(\"Calling allocate on removed \" +\n           \"or non-existent application \" + applicationAttemptId);\n       return EMPTY_ALLOCATION;\n     }\n \n     // Sanity check\n     normalizeRequests(ask);\n \n     // Release containers\n     releaseContainers(release, application);\n \n     synchronized (application) {\n \n       // make sure we aren't stopping/removing the application\n       // when the allocate comes in\n       if (application.isStopped()) {\n         LOG.info(\"Calling allocate on a stopped \" +\n             \"application \" + applicationAttemptId);\n         return EMPTY_ALLOCATION;\n       }\n \n       if (!ask.isEmpty()) {\n         LOG.debug(\"allocate: pre-update\" +\n             \" applicationId=\" + applicationAttemptId + \n             \" application=\" + application);\n         application.showRequests();\n \n         // Update application requests\n         application.updateResourceRequests(ask);\n \n         LOG.debug(\"allocate: post-update\" +\n             \" applicationId=\" + applicationAttemptId + \n             \" application=\" + application);\n         application.showRequests();\n \n         LOG.debug(\"allocate:\" +\n             \" applicationId=\" + applicationAttemptId +\n             \" #ask=\" + ask.size());\n       }\n \n       application.updateBlacklist(blacklistAdditions, blacklistRemovals);\n \n       Resource headroom = application.getHeadroom();\n       application.setApplicationHeadroomForMetrics(headroom);\n       return new Allocation(application.pullNewlyAllocatedContainers(),\n           headroom, null, null, null, application.pullUpdatedNMTokens());\n     }\n   }\n\\ No newline at end of file\n",
			"extendedDetails": {
				"oldValue": "[applicationAttemptId-ApplicationAttemptId, ask-List<ResourceRequest>, release-List<ContainerId>, blacklistAdditions-List<String>, blacklistRemovals-List<String>, increaseRequests-List<UpdateContainerRequest>, decreaseRequests-List<UpdateContainerRequest>]",
				"newValue": "[applicationAttemptId-ApplicationAttemptId, ask-List<ResourceRequest>, release-List<ContainerId>, blacklistAdditions-List<String>, blacklistRemovals-List<String>, updateRequests-ContainerUpdates]"
			}
		},
		"1bbd023275db535ab80fcb60e022151e9679d468": {
			"type": "Ybodychange",
			"commitMessage": "YARN-5962. Spelling errors in logging and exceptions for resource manager code (gsohn via rkanter)\n",
			"commitDate": "2016-12-27, 1:35 PM",
			"commitName": "1bbd023275db535ab80fcb60e022151e9679d468",
			"commitAuthor": "Robert Kanter",
			"commitDateOld": "2016-12-27, 12:40 PM",
			"commitNameOld": "ac1e5d4f77e3b9df8dcacb0b1f72eecc27931eb8",
			"commitAuthorOld": "Arun Suresh",
			"daysBetweenCommits": 0.04,
			"commitsBetweenForRepo": 2,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,55 +1,55 @@\n   public Allocation allocate(ApplicationAttemptId applicationAttemptId,\n       List<ResourceRequest> ask, List<ContainerId> release,\n       List<String> blacklistAdditions, List<String> blacklistRemovals,\n       List<UpdateContainerRequest> increaseRequests,\n       List<UpdateContainerRequest> decreaseRequests) {\n     FifoAppAttempt application = getApplicationAttempt(applicationAttemptId);\n     if (application == null) {\n       LOG.error(\"Calling allocate on removed \" +\n-          \"or non existant application \" + applicationAttemptId);\n+          \"or non-existent application \" + applicationAttemptId);\n       return EMPTY_ALLOCATION;\n     }\n \n     // Sanity check\n     normalizeRequests(ask);\n \n     // Release containers\n     releaseContainers(release, application);\n \n     synchronized (application) {\n \n       // make sure we aren't stopping/removing the application\n       // when the allocate comes in\n       if (application.isStopped()) {\n         LOG.info(\"Calling allocate on a stopped \" +\n             \"application \" + applicationAttemptId);\n         return EMPTY_ALLOCATION;\n       }\n \n       if (!ask.isEmpty()) {\n         LOG.debug(\"allocate: pre-update\" +\n             \" applicationId=\" + applicationAttemptId + \n             \" application=\" + application);\n         application.showRequests();\n \n         // Update application requests\n         application.updateResourceRequests(ask);\n \n         LOG.debug(\"allocate: post-update\" +\n             \" applicationId=\" + applicationAttemptId + \n             \" application=\" + application);\n         application.showRequests();\n \n         LOG.debug(\"allocate:\" +\n             \" applicationId=\" + applicationAttemptId +\n             \" #ask=\" + ask.size());\n       }\n \n       application.updateBlacklist(blacklistAdditions, blacklistRemovals);\n \n       Resource headroom = application.getHeadroom();\n       application.setApplicationHeadroomForMetrics(headroom);\n       return new Allocation(application.pullNewlyAllocatedContainers(),\n           headroom, null, null, null, application.pullUpdatedNMTokens());\n     }\n   }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"25f9872be63423ada6a18481eaad2888e731fdac": {
			"type": "Ybodychange",
			"commitMessage": "YARN-5774. MR Job stuck in ACCEPTED status without any progress in Fair Scheduler\nif set yarn.scheduler.minimum-allocation-mb to 0. (Contributed by Yufei Gu via Daniel Templeton)\n",
			"commitDate": "2016-11-29, 9:40 AM",
			"commitName": "25f9872be63423ada6a18481eaad2888e731fdac",
			"commitAuthor": "Daniel Templeton",
			"commitDateOld": "2016-11-07, 10:14 AM",
			"commitNameOld": "de3b4aac561258ad242a3c5ed1c919428893fd4c",
			"commitAuthorOld": "Jian He",
			"daysBetweenCommits": 21.98,
			"commitsBetweenForRepo": 134,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,57 +1,55 @@\n   public Allocation allocate(ApplicationAttemptId applicationAttemptId,\n       List<ResourceRequest> ask, List<ContainerId> release,\n       List<String> blacklistAdditions, List<String> blacklistRemovals,\n       List<UpdateContainerRequest> increaseRequests,\n       List<UpdateContainerRequest> decreaseRequests) {\n     FifoAppAttempt application = getApplicationAttempt(applicationAttemptId);\n     if (application == null) {\n       LOG.error(\"Calling allocate on removed \" +\n           \"or non existant application \" + applicationAttemptId);\n       return EMPTY_ALLOCATION;\n     }\n \n     // Sanity check\n-    SchedulerUtils.normalizeRequests(ask, resourceCalculator, \n-        getClusterResource(), minimumAllocation,\n-        getMaximumResourceCapability());\n+    normalizeRequests(ask);\n \n     // Release containers\n     releaseContainers(release, application);\n \n     synchronized (application) {\n \n       // make sure we aren't stopping/removing the application\n       // when the allocate comes in\n       if (application.isStopped()) {\n         LOG.info(\"Calling allocate on a stopped \" +\n             \"application \" + applicationAttemptId);\n         return EMPTY_ALLOCATION;\n       }\n \n       if (!ask.isEmpty()) {\n         LOG.debug(\"allocate: pre-update\" +\n             \" applicationId=\" + applicationAttemptId + \n             \" application=\" + application);\n         application.showRequests();\n \n         // Update application requests\n         application.updateResourceRequests(ask);\n \n         LOG.debug(\"allocate: post-update\" +\n             \" applicationId=\" + applicationAttemptId + \n             \" application=\" + application);\n         application.showRequests();\n \n         LOG.debug(\"allocate:\" +\n             \" applicationId=\" + applicationAttemptId +\n             \" #ask=\" + ask.size());\n       }\n \n       application.updateBlacklist(blacklistAdditions, blacklistRemovals);\n \n       Resource headroom = application.getHeadroom();\n       application.setApplicationHeadroomForMetrics(headroom);\n       return new Allocation(application.pullNewlyAllocatedContainers(),\n           headroom, null, null, null, application.pullUpdatedNMTokens());\n     }\n   }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"de3b4aac561258ad242a3c5ed1c919428893fd4c": {
			"type": "Ybodychange",
			"commitMessage": "YARN-5716. Add global scheduler interface definition and update CapacityScheduler to use it. Contributed by Wangda Tan\n",
			"commitDate": "2016-11-07, 10:14 AM",
			"commitName": "de3b4aac561258ad242a3c5ed1c919428893fd4c",
			"commitAuthor": "Jian He",
			"commitDateOld": "2016-10-20, 9:17 PM",
			"commitNameOld": "754cb4e30fac1c5fe8d44626968c0ddbfe459335",
			"commitAuthorOld": "Karthik Kambatla",
			"daysBetweenCommits": 17.58,
			"commitsBetweenForRepo": 196,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,57 +1,57 @@\n   public Allocation allocate(ApplicationAttemptId applicationAttemptId,\n       List<ResourceRequest> ask, List<ContainerId> release,\n       List<String> blacklistAdditions, List<String> blacklistRemovals,\n       List<UpdateContainerRequest> increaseRequests,\n       List<UpdateContainerRequest> decreaseRequests) {\n-    FiCaSchedulerApp application = getApplicationAttempt(applicationAttemptId);\n+    FifoAppAttempt application = getApplicationAttempt(applicationAttemptId);\n     if (application == null) {\n       LOG.error(\"Calling allocate on removed \" +\n           \"or non existant application \" + applicationAttemptId);\n       return EMPTY_ALLOCATION;\n     }\n \n     // Sanity check\n     SchedulerUtils.normalizeRequests(ask, resourceCalculator, \n         getClusterResource(), minimumAllocation,\n         getMaximumResourceCapability());\n \n     // Release containers\n     releaseContainers(release, application);\n \n     synchronized (application) {\n \n       // make sure we aren't stopping/removing the application\n       // when the allocate comes in\n       if (application.isStopped()) {\n         LOG.info(\"Calling allocate on a stopped \" +\n             \"application \" + applicationAttemptId);\n         return EMPTY_ALLOCATION;\n       }\n \n       if (!ask.isEmpty()) {\n         LOG.debug(\"allocate: pre-update\" +\n             \" applicationId=\" + applicationAttemptId + \n             \" application=\" + application);\n         application.showRequests();\n \n         // Update application requests\n         application.updateResourceRequests(ask);\n \n         LOG.debug(\"allocate: post-update\" +\n             \" applicationId=\" + applicationAttemptId + \n             \" application=\" + application);\n         application.showRequests();\n \n         LOG.debug(\"allocate:\" +\n             \" applicationId=\" + applicationAttemptId +\n             \" #ask=\" + ask.size());\n       }\n \n       application.updateBlacklist(blacklistAdditions, blacklistRemovals);\n \n       Resource headroom = application.getHeadroom();\n       application.setApplicationHeadroomForMetrics(headroom);\n       return new Allocation(application.pullNewlyAllocatedContainers(),\n           headroom, null, null, null, application.pullUpdatedNMTokens());\n     }\n   }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"d6d9cff21b7b6141ed88359652cf22e8973c0661": {
			"type": "Yparameterchange",
			"commitMessage": "YARN-5221. Expose UpdateResourceRequest API to allow AM to request for change in container properties. (asuresh)\n",
			"commitDate": "2016-08-30, 3:52 PM",
			"commitName": "d6d9cff21b7b6141ed88359652cf22e8973c0661",
			"commitAuthor": "Arun Suresh",
			"commitDateOld": "2016-08-05, 10:43 AM",
			"commitNameOld": "3f100d76ff5df020dbb8ecd4f5b4f9736a0a8270",
			"commitAuthorOld": "Wangda Tan",
			"daysBetweenCommits": 25.21,
			"commitsBetweenForRepo": 173,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,57 +1,57 @@\n   public Allocation allocate(ApplicationAttemptId applicationAttemptId,\n       List<ResourceRequest> ask, List<ContainerId> release,\n       List<String> blacklistAdditions, List<String> blacklistRemovals,\n-      List<ContainerResourceChangeRequest> increaseRequests,\n-      List<ContainerResourceChangeRequest> decreaseRequests) {\n+      List<UpdateContainerRequest> increaseRequests,\n+      List<UpdateContainerRequest> decreaseRequests) {\n     FiCaSchedulerApp application = getApplicationAttempt(applicationAttemptId);\n     if (application == null) {\n       LOG.error(\"Calling allocate on removed \" +\n           \"or non existant application \" + applicationAttemptId);\n       return EMPTY_ALLOCATION;\n     }\n \n     // Sanity check\n     SchedulerUtils.normalizeRequests(ask, resourceCalculator, \n         getClusterResource(), minimumAllocation,\n         getMaximumResourceCapability());\n \n     // Release containers\n     releaseContainers(release, application);\n \n     synchronized (application) {\n \n       // make sure we aren't stopping/removing the application\n       // when the allocate comes in\n       if (application.isStopped()) {\n         LOG.info(\"Calling allocate on a stopped \" +\n             \"application \" + applicationAttemptId);\n         return EMPTY_ALLOCATION;\n       }\n \n       if (!ask.isEmpty()) {\n         LOG.debug(\"allocate: pre-update\" +\n             \" applicationId=\" + applicationAttemptId + \n             \" application=\" + application);\n         application.showRequests();\n \n         // Update application requests\n         application.updateResourceRequests(ask);\n \n         LOG.debug(\"allocate: post-update\" +\n             \" applicationId=\" + applicationAttemptId + \n             \" application=\" + application);\n         application.showRequests();\n \n         LOG.debug(\"allocate:\" +\n             \" applicationId=\" + applicationAttemptId +\n             \" #ask=\" + ask.size());\n       }\n \n       application.updateBlacklist(blacklistAdditions, blacklistRemovals);\n \n       Resource headroom = application.getHeadroom();\n       application.setApplicationHeadroomForMetrics(headroom);\n       return new Allocation(application.pullNewlyAllocatedContainers(),\n           headroom, null, null, null, application.pullUpdatedNMTokens());\n     }\n   }\n\\ No newline at end of file\n",
			"extendedDetails": {
				"oldValue": "[applicationAttemptId-ApplicationAttemptId, ask-List<ResourceRequest>, release-List<ContainerId>, blacklistAdditions-List<String>, blacklistRemovals-List<String>, increaseRequests-List<ContainerResourceChangeRequest>, decreaseRequests-List<ContainerResourceChangeRequest>]",
				"newValue": "[applicationAttemptId-ApplicationAttemptId, ask-List<ResourceRequest>, release-List<ContainerId>, blacklistAdditions-List<String>, blacklistRemovals-List<String>, increaseRequests-List<UpdateContainerRequest>, decreaseRequests-List<UpdateContainerRequest>]"
			}
		},
		"620325e81696fca140195b74929ed9eda2d5eb16": {
			"type": "Ybodychange",
			"commitMessage": "YARN-4837. User facing aspects of 'AM blacklisting' feature need fixing. (vinodkv via wangda)\n",
			"commitDate": "2016-06-07, 3:06 PM",
			"commitName": "620325e81696fca140195b74929ed9eda2d5eb16",
			"commitAuthor": "Wangda Tan",
			"commitDateOld": "2016-05-29, 8:54 AM",
			"commitNameOld": "42f90ab885d9693fcc1e52f9637f7de4111110ae",
			"commitAuthorOld": "Varun Vasudev",
			"daysBetweenCommits": 9.26,
			"commitsBetweenForRepo": 57,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,63 +1,57 @@\n   public Allocation allocate(ApplicationAttemptId applicationAttemptId,\n       List<ResourceRequest> ask, List<ContainerId> release,\n       List<String> blacklistAdditions, List<String> blacklistRemovals,\n       List<ContainerResourceChangeRequest> increaseRequests,\n       List<ContainerResourceChangeRequest> decreaseRequests) {\n     FiCaSchedulerApp application = getApplicationAttempt(applicationAttemptId);\n     if (application == null) {\n       LOG.error(\"Calling allocate on removed \" +\n           \"or non existant application \" + applicationAttemptId);\n       return EMPTY_ALLOCATION;\n     }\n \n     // Sanity check\n     SchedulerUtils.normalizeRequests(ask, resourceCalculator, \n         getClusterResource(), minimumAllocation,\n         getMaximumResourceCapability());\n \n     // Release containers\n     releaseContainers(release, application);\n \n     synchronized (application) {\n \n       // make sure we aren't stopping/removing the application\n       // when the allocate comes in\n       if (application.isStopped()) {\n         LOG.info(\"Calling allocate on a stopped \" +\n             \"application \" + applicationAttemptId);\n         return EMPTY_ALLOCATION;\n       }\n \n       if (!ask.isEmpty()) {\n         LOG.debug(\"allocate: pre-update\" +\n             \" applicationId=\" + applicationAttemptId + \n             \" application=\" + application);\n         application.showRequests();\n \n         // Update application requests\n         application.updateResourceRequests(ask);\n \n         LOG.debug(\"allocate: post-update\" +\n             \" applicationId=\" + applicationAttemptId + \n             \" application=\" + application);\n         application.showRequests();\n \n         LOG.debug(\"allocate:\" +\n             \" applicationId=\" + applicationAttemptId +\n             \" #ask=\" + ask.size());\n       }\n \n-      if (application.isWaitingForAMContainer()) {\n-        // Allocate is for AM and update AM blacklist for this\n-        application.updateAMBlacklist(\n-            blacklistAdditions, blacklistRemovals);\n-      } else {\n-        application.updateBlacklist(blacklistAdditions, blacklistRemovals);\n-      }\n+      application.updateBlacklist(blacklistAdditions, blacklistRemovals);\n \n       Resource headroom = application.getHeadroom();\n       application.setApplicationHeadroomForMetrics(headroom);\n       return new Allocation(application.pullNewlyAllocatedContainers(),\n           headroom, null, null, null, application.pullUpdatedNMTokens());\n     }\n   }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"20d389ce61eaacb5ddfb329015f50e96ad894f8d": {
			"type": "Ybodychange",
			"commitMessage": "YARN-4719. Add a helper library to maintain node state and allows common queries. (kasha)\n",
			"commitDate": "2016-03-14, 2:19 PM",
			"commitName": "20d389ce61eaacb5ddfb329015f50e96ad894f8d",
			"commitAuthor": "Karthik Kambatla",
			"commitDateOld": "2016-02-28, 9:35 AM",
			"commitNameOld": "f9692770a58af0ab082eb7f15da9cbdcd177605b",
			"commitAuthorOld": "Karthik Kambatla",
			"daysBetweenCommits": 15.15,
			"commitsBetweenForRepo": 90,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,62 +1,63 @@\n   public Allocation allocate(ApplicationAttemptId applicationAttemptId,\n       List<ResourceRequest> ask, List<ContainerId> release,\n       List<String> blacklistAdditions, List<String> blacklistRemovals,\n       List<ContainerResourceChangeRequest> increaseRequests,\n       List<ContainerResourceChangeRequest> decreaseRequests) {\n     FiCaSchedulerApp application = getApplicationAttempt(applicationAttemptId);\n     if (application == null) {\n       LOG.error(\"Calling allocate on removed \" +\n           \"or non existant application \" + applicationAttemptId);\n       return EMPTY_ALLOCATION;\n     }\n \n     // Sanity check\n     SchedulerUtils.normalizeRequests(ask, resourceCalculator, \n-        clusterResource, minimumAllocation, getMaximumResourceCapability());\n+        getClusterResource(), minimumAllocation,\n+        getMaximumResourceCapability());\n \n     // Release containers\n     releaseContainers(release, application);\n \n     synchronized (application) {\n \n       // make sure we aren't stopping/removing the application\n       // when the allocate comes in\n       if (application.isStopped()) {\n         LOG.info(\"Calling allocate on a stopped \" +\n             \"application \" + applicationAttemptId);\n         return EMPTY_ALLOCATION;\n       }\n \n       if (!ask.isEmpty()) {\n         LOG.debug(\"allocate: pre-update\" +\n             \" applicationId=\" + applicationAttemptId + \n             \" application=\" + application);\n         application.showRequests();\n \n         // Update application requests\n         application.updateResourceRequests(ask);\n \n         LOG.debug(\"allocate: post-update\" +\n             \" applicationId=\" + applicationAttemptId + \n             \" application=\" + application);\n         application.showRequests();\n \n         LOG.debug(\"allocate:\" +\n             \" applicationId=\" + applicationAttemptId +\n             \" #ask=\" + ask.size());\n       }\n \n       if (application.isWaitingForAMContainer()) {\n         // Allocate is for AM and update AM blacklist for this\n         application.updateAMBlacklist(\n             blacklistAdditions, blacklistRemovals);\n       } else {\n         application.updateBlacklist(blacklistAdditions, blacklistRemovals);\n       }\n \n       Resource headroom = application.getHeadroom();\n       application.setApplicationHeadroomForMetrics(headroom);\n       return new Allocation(application.pullNewlyAllocatedContainers(),\n           headroom, null, null, null, application.pullUpdatedNMTokens());\n     }\n   }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"6cb0af3c39a5d49cb2f7911ee21363a9542ca2d7": {
			"type": "Ybodychange",
			"commitMessage": "YARN-3946. Update exact reason as to why a submitted app is in ACCEPTED state to app's diagnostic message. (Naganarasimha G R via wangda)\n",
			"commitDate": "2015-12-14, 10:52 AM",
			"commitName": "6cb0af3c39a5d49cb2f7911ee21363a9542ca2d7",
			"commitAuthor": "Wangda Tan",
			"commitDateOld": "2015-11-24, 12:17 AM",
			"commitNameOld": "52948bb20bd1446164df1d3920c46c96dad750ae",
			"commitAuthorOld": "Karthik Kambatla",
			"daysBetweenCommits": 20.44,
			"commitsBetweenForRepo": 110,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,62 +1,62 @@\n   public Allocation allocate(ApplicationAttemptId applicationAttemptId,\n       List<ResourceRequest> ask, List<ContainerId> release,\n       List<String> blacklistAdditions, List<String> blacklistRemovals,\n       List<ContainerResourceChangeRequest> increaseRequests,\n       List<ContainerResourceChangeRequest> decreaseRequests) {\n     FiCaSchedulerApp application = getApplicationAttempt(applicationAttemptId);\n     if (application == null) {\n       LOG.error(\"Calling allocate on removed \" +\n           \"or non existant application \" + applicationAttemptId);\n       return EMPTY_ALLOCATION;\n     }\n \n     // Sanity check\n     SchedulerUtils.normalizeRequests(ask, resourceCalculator, \n         clusterResource, minimumAllocation, getMaximumResourceCapability());\n \n     // Release containers\n     releaseContainers(release, application);\n \n     synchronized (application) {\n \n       // make sure we aren't stopping/removing the application\n       // when the allocate comes in\n       if (application.isStopped()) {\n         LOG.info(\"Calling allocate on a stopped \" +\n             \"application \" + applicationAttemptId);\n         return EMPTY_ALLOCATION;\n       }\n \n       if (!ask.isEmpty()) {\n         LOG.debug(\"allocate: pre-update\" +\n             \" applicationId=\" + applicationAttemptId + \n             \" application=\" + application);\n         application.showRequests();\n \n         // Update application requests\n         application.updateResourceRequests(ask);\n \n         LOG.debug(\"allocate: post-update\" +\n             \" applicationId=\" + applicationAttemptId + \n             \" application=\" + application);\n         application.showRequests();\n \n         LOG.debug(\"allocate:\" +\n             \" applicationId=\" + applicationAttemptId +\n             \" #ask=\" + ask.size());\n       }\n \n-      if (application.isWaitingForAMContainer(application.getApplicationId())) {\n+      if (application.isWaitingForAMContainer()) {\n         // Allocate is for AM and update AM blacklist for this\n         application.updateAMBlacklist(\n             blacklistAdditions, blacklistRemovals);\n       } else {\n         application.updateBlacklist(blacklistAdditions, blacklistRemovals);\n       }\n \n       Resource headroom = application.getHeadroom();\n       application.setApplicationHeadroomForMetrics(headroom);\n       return new Allocation(application.pullNewlyAllocatedContainers(),\n           headroom, null, null, null, application.pullUpdatedNMTokens());\n     }\n   }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"89cab1ba5f0671f8ef30dbe7432079c18362b434": {
			"type": "Ymultichange(Yparameterchange,Ybodychange)",
			"commitMessage": "YARN-1651. CapacityScheduler side changes to support container resize. Contributed by Wangda Tan\n",
			"commitDate": "2015-09-23, 1:29 PM",
			"commitName": "89cab1ba5f0671f8ef30dbe7432079c18362b434",
			"commitAuthor": "Jian He",
			"subchanges": [
				{
					"type": "Yparameterchange",
					"commitMessage": "YARN-1651. CapacityScheduler side changes to support container resize. Contributed by Wangda Tan\n",
					"commitDate": "2015-09-23, 1:29 PM",
					"commitName": "89cab1ba5f0671f8ef30dbe7432079c18362b434",
					"commitAuthor": "Jian He",
					"commitDateOld": "2015-09-13, 5:03 PM",
					"commitNameOld": "81df7b586a16f8226c7b01c139c1c70c060399c3",
					"commitAuthorOld": "Karthik Kambatla",
					"daysBetweenCommits": 9.85,
					"commitsBetweenForRepo": 74,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,62 +1,62 @@\n-  public Allocation allocate(\n-      ApplicationAttemptId applicationAttemptId, List<ResourceRequest> ask,\n-      List<ContainerId> release, List<String> blacklistAdditions, List<String> blacklistRemovals) {\n+  public Allocation allocate(ApplicationAttemptId applicationAttemptId,\n+      List<ResourceRequest> ask, List<ContainerId> release,\n+      List<String> blacklistAdditions, List<String> blacklistRemovals,\n+      List<ContainerResourceChangeRequest> increaseRequests,\n+      List<ContainerResourceChangeRequest> decreaseRequests) {\n     FiCaSchedulerApp application = getApplicationAttempt(applicationAttemptId);\n     if (application == null) {\n       LOG.error(\"Calling allocate on removed \" +\n           \"or non existant application \" + applicationAttemptId);\n       return EMPTY_ALLOCATION;\n     }\n \n     // Sanity check\n     SchedulerUtils.normalizeRequests(ask, resourceCalculator, \n         clusterResource, minimumAllocation, getMaximumResourceCapability());\n \n     // Release containers\n     releaseContainers(release, application);\n \n     synchronized (application) {\n \n       // make sure we aren't stopping/removing the application\n       // when the allocate comes in\n       if (application.isStopped()) {\n         LOG.info(\"Calling allocate on a stopped \" +\n             \"application \" + applicationAttemptId);\n         return EMPTY_ALLOCATION;\n       }\n \n       if (!ask.isEmpty()) {\n         LOG.debug(\"allocate: pre-update\" +\n             \" applicationId=\" + applicationAttemptId + \n             \" application=\" + application);\n         application.showRequests();\n \n         // Update application requests\n         application.updateResourceRequests(ask);\n \n         LOG.debug(\"allocate: post-update\" +\n             \" applicationId=\" + applicationAttemptId + \n             \" application=\" + application);\n         application.showRequests();\n \n         LOG.debug(\"allocate:\" +\n             \" applicationId=\" + applicationAttemptId +\n             \" #ask=\" + ask.size());\n       }\n \n       if (application.isWaitingForAMContainer(application.getApplicationId())) {\n         // Allocate is for AM and update AM blacklist for this\n         application.updateAMBlacklist(\n             blacklistAdditions, blacklistRemovals);\n       } else {\n         application.updateBlacklist(blacklistAdditions, blacklistRemovals);\n       }\n \n-      ContainersAndNMTokensAllocation allocation =\n-          application.pullNewlyAllocatedContainersAndNMTokens();\n       Resource headroom = application.getHeadroom();\n       application.setApplicationHeadroomForMetrics(headroom);\n-      return new Allocation(allocation.getContainerList(), headroom, null,\n-          null, null, allocation.getNMTokenList());\n+      return new Allocation(application.pullNewlyAllocatedContainers(),\n+          headroom, null, null, null, application.pullUpdatedNMTokens());\n     }\n   }\n\\ No newline at end of file\n",
					"extendedDetails": {
						"oldValue": "[applicationAttemptId-ApplicationAttemptId, ask-List<ResourceRequest>, release-List<ContainerId>, blacklistAdditions-List<String>, blacklistRemovals-List<String>]",
						"newValue": "[applicationAttemptId-ApplicationAttemptId, ask-List<ResourceRequest>, release-List<ContainerId>, blacklistAdditions-List<String>, blacklistRemovals-List<String>, increaseRequests-List<ContainerResourceChangeRequest>, decreaseRequests-List<ContainerResourceChangeRequest>]"
					}
				},
				{
					"type": "Ybodychange",
					"commitMessage": "YARN-1651. CapacityScheduler side changes to support container resize. Contributed by Wangda Tan\n",
					"commitDate": "2015-09-23, 1:29 PM",
					"commitName": "89cab1ba5f0671f8ef30dbe7432079c18362b434",
					"commitAuthor": "Jian He",
					"commitDateOld": "2015-09-13, 5:03 PM",
					"commitNameOld": "81df7b586a16f8226c7b01c139c1c70c060399c3",
					"commitAuthorOld": "Karthik Kambatla",
					"daysBetweenCommits": 9.85,
					"commitsBetweenForRepo": 74,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,62 +1,62 @@\n-  public Allocation allocate(\n-      ApplicationAttemptId applicationAttemptId, List<ResourceRequest> ask,\n-      List<ContainerId> release, List<String> blacklistAdditions, List<String> blacklistRemovals) {\n+  public Allocation allocate(ApplicationAttemptId applicationAttemptId,\n+      List<ResourceRequest> ask, List<ContainerId> release,\n+      List<String> blacklistAdditions, List<String> blacklistRemovals,\n+      List<ContainerResourceChangeRequest> increaseRequests,\n+      List<ContainerResourceChangeRequest> decreaseRequests) {\n     FiCaSchedulerApp application = getApplicationAttempt(applicationAttemptId);\n     if (application == null) {\n       LOG.error(\"Calling allocate on removed \" +\n           \"or non existant application \" + applicationAttemptId);\n       return EMPTY_ALLOCATION;\n     }\n \n     // Sanity check\n     SchedulerUtils.normalizeRequests(ask, resourceCalculator, \n         clusterResource, minimumAllocation, getMaximumResourceCapability());\n \n     // Release containers\n     releaseContainers(release, application);\n \n     synchronized (application) {\n \n       // make sure we aren't stopping/removing the application\n       // when the allocate comes in\n       if (application.isStopped()) {\n         LOG.info(\"Calling allocate on a stopped \" +\n             \"application \" + applicationAttemptId);\n         return EMPTY_ALLOCATION;\n       }\n \n       if (!ask.isEmpty()) {\n         LOG.debug(\"allocate: pre-update\" +\n             \" applicationId=\" + applicationAttemptId + \n             \" application=\" + application);\n         application.showRequests();\n \n         // Update application requests\n         application.updateResourceRequests(ask);\n \n         LOG.debug(\"allocate: post-update\" +\n             \" applicationId=\" + applicationAttemptId + \n             \" application=\" + application);\n         application.showRequests();\n \n         LOG.debug(\"allocate:\" +\n             \" applicationId=\" + applicationAttemptId +\n             \" #ask=\" + ask.size());\n       }\n \n       if (application.isWaitingForAMContainer(application.getApplicationId())) {\n         // Allocate is for AM and update AM blacklist for this\n         application.updateAMBlacklist(\n             blacklistAdditions, blacklistRemovals);\n       } else {\n         application.updateBlacklist(blacklistAdditions, blacklistRemovals);\n       }\n \n-      ContainersAndNMTokensAllocation allocation =\n-          application.pullNewlyAllocatedContainersAndNMTokens();\n       Resource headroom = application.getHeadroom();\n       application.setApplicationHeadroomForMetrics(headroom);\n-      return new Allocation(allocation.getContainerList(), headroom, null,\n-          null, null, allocation.getNMTokenList());\n+      return new Allocation(application.pullNewlyAllocatedContainers(),\n+          headroom, null, null, null, application.pullUpdatedNMTokens());\n     }\n   }\n\\ No newline at end of file\n",
					"extendedDetails": {}
				}
			]
		},
		"81df7b586a16f8226c7b01c139c1c70c060399c3": {
			"type": "Ybodychange",
			"commitMessage": "YARN-2005. Blacklisting support for scheduling AMs. (Anubhav Dhoot via kasha)\n",
			"commitDate": "2015-09-13, 5:03 PM",
			"commitName": "81df7b586a16f8226c7b01c139c1c70c060399c3",
			"commitAuthor": "Karthik Kambatla",
			"commitDateOld": "2015-07-21, 9:57 AM",
			"commitNameOld": "c39ca541f498712133890961598bbff50d89d68b",
			"commitAuthorOld": "Wangda Tan",
			"daysBetweenCommits": 54.3,
			"commitsBetweenForRepo": 301,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,55 +1,62 @@\n   public Allocation allocate(\n       ApplicationAttemptId applicationAttemptId, List<ResourceRequest> ask,\n       List<ContainerId> release, List<String> blacklistAdditions, List<String> blacklistRemovals) {\n     FiCaSchedulerApp application = getApplicationAttempt(applicationAttemptId);\n     if (application == null) {\n       LOG.error(\"Calling allocate on removed \" +\n           \"or non existant application \" + applicationAttemptId);\n       return EMPTY_ALLOCATION;\n     }\n \n     // Sanity check\n     SchedulerUtils.normalizeRequests(ask, resourceCalculator, \n         clusterResource, minimumAllocation, getMaximumResourceCapability());\n \n     // Release containers\n     releaseContainers(release, application);\n \n     synchronized (application) {\n \n       // make sure we aren't stopping/removing the application\n       // when the allocate comes in\n       if (application.isStopped()) {\n         LOG.info(\"Calling allocate on a stopped \" +\n             \"application \" + applicationAttemptId);\n         return EMPTY_ALLOCATION;\n       }\n \n       if (!ask.isEmpty()) {\n         LOG.debug(\"allocate: pre-update\" +\n             \" applicationId=\" + applicationAttemptId + \n             \" application=\" + application);\n         application.showRequests();\n \n         // Update application requests\n         application.updateResourceRequests(ask);\n \n         LOG.debug(\"allocate: post-update\" +\n             \" applicationId=\" + applicationAttemptId + \n             \" application=\" + application);\n         application.showRequests();\n \n         LOG.debug(\"allocate:\" +\n-            \" applicationId=\" + applicationAttemptId + \n+            \" applicationId=\" + applicationAttemptId +\n             \" #ask=\" + ask.size());\n       }\n \n-      application.updateBlacklist(blacklistAdditions, blacklistRemovals);\n+      if (application.isWaitingForAMContainer(application.getApplicationId())) {\n+        // Allocate is for AM and update AM blacklist for this\n+        application.updateAMBlacklist(\n+            blacklistAdditions, blacklistRemovals);\n+      } else {\n+        application.updateBlacklist(blacklistAdditions, blacklistRemovals);\n+      }\n+\n       ContainersAndNMTokensAllocation allocation =\n           application.pullNewlyAllocatedContainersAndNMTokens();\n       Resource headroom = application.getHeadroom();\n       application.setApplicationHeadroomForMetrics(headroom);\n       return new Allocation(allocation.getContainerList(), headroom, null,\n           null, null, allocation.getNMTokenList());\n     }\n   }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"658097d6da1b1aac8e01db459f0c3b456e99652f": {
			"type": "Ybodychange",
			"commitMessage": "YARN-3273. Improve scheduler UI to facilitate scheduling analysis and debugging. Contributed Rohith Sharmaks\n",
			"commitDate": "2015-03-17, 9:30 PM",
			"commitName": "658097d6da1b1aac8e01db459f0c3b456e99652f",
			"commitAuthor": "Jian He",
			"commitDateOld": "2014-12-30, 7:55 PM",
			"commitNameOld": "e7257acd8a7adb74d81cd1d009d4a99f023ed844",
			"commitAuthorOld": "Karthik Kambatla",
			"daysBetweenCommits": 77.02,
			"commitsBetweenForRepo": 628,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,54 +1,55 @@\n   public Allocation allocate(\n       ApplicationAttemptId applicationAttemptId, List<ResourceRequest> ask,\n       List<ContainerId> release, List<String> blacklistAdditions, List<String> blacklistRemovals) {\n     FiCaSchedulerApp application = getApplicationAttempt(applicationAttemptId);\n     if (application == null) {\n       LOG.error(\"Calling allocate on removed \" +\n           \"or non existant application \" + applicationAttemptId);\n       return EMPTY_ALLOCATION;\n     }\n \n     // Sanity check\n     SchedulerUtils.normalizeRequests(ask, resourceCalculator, \n         clusterResource, minimumAllocation, getMaximumResourceCapability());\n \n     // Release containers\n     releaseContainers(release, application);\n \n     synchronized (application) {\n \n       // make sure we aren't stopping/removing the application\n       // when the allocate comes in\n       if (application.isStopped()) {\n         LOG.info(\"Calling allocate on a stopped \" +\n             \"application \" + applicationAttemptId);\n         return EMPTY_ALLOCATION;\n       }\n \n       if (!ask.isEmpty()) {\n         LOG.debug(\"allocate: pre-update\" +\n             \" applicationId=\" + applicationAttemptId + \n             \" application=\" + application);\n         application.showRequests();\n \n         // Update application requests\n         application.updateResourceRequests(ask);\n \n         LOG.debug(\"allocate: post-update\" +\n             \" applicationId=\" + applicationAttemptId + \n             \" application=\" + application);\n         application.showRequests();\n \n         LOG.debug(\"allocate:\" +\n             \" applicationId=\" + applicationAttemptId + \n             \" #ask=\" + ask.size());\n       }\n \n       application.updateBlacklist(blacklistAdditions, blacklistRemovals);\n       ContainersAndNMTokensAllocation allocation =\n           application.pullNewlyAllocatedContainersAndNMTokens();\n-      return new Allocation(allocation.getContainerList(),\n-        application.getHeadroom(), null, null, null,\n-        allocation.getNMTokenList());\n+      Resource headroom = application.getHeadroom();\n+      application.setApplicationHeadroomForMetrics(headroom);\n+      return new Allocation(allocation.getContainerList(), headroom, null,\n+          null, null, allocation.getNMTokenList());\n     }\n   }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"3114d4731dcca7cb6c16aaa7c7a6550b7dd7dccb": {
			"type": "Ybodychange",
			"commitMessage": "YARN-2604. Scheduler should consider max-allocation-* in conjunction with the largest node. (Robert Kanter via kasha)\n",
			"commitDate": "2014-11-21, 10:32 AM",
			"commitName": "3114d4731dcca7cb6c16aaa7c7a6550b7dd7dccb",
			"commitAuthor": "Karthik Kambatla",
			"commitDateOld": "2014-10-15, 6:33 PM",
			"commitNameOld": "f2ea555ac6c06a3f2f6559731f48711fff05d3f1",
			"commitAuthorOld": "Vinod Kumar Vavilapalli",
			"daysBetweenCommits": 36.71,
			"commitsBetweenForRepo": 344,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,54 +1,54 @@\n   public Allocation allocate(\n       ApplicationAttemptId applicationAttemptId, List<ResourceRequest> ask,\n       List<ContainerId> release, List<String> blacklistAdditions, List<String> blacklistRemovals) {\n     FiCaSchedulerApp application = getApplicationAttempt(applicationAttemptId);\n     if (application == null) {\n       LOG.error(\"Calling allocate on removed \" +\n           \"or non existant application \" + applicationAttemptId);\n       return EMPTY_ALLOCATION;\n     }\n \n     // Sanity check\n     SchedulerUtils.normalizeRequests(ask, resourceCalculator, \n-        clusterResource, minimumAllocation, maximumAllocation);\n+        clusterResource, minimumAllocation, getMaximumResourceCapability());\n \n     // Release containers\n     releaseContainers(release, application);\n \n     synchronized (application) {\n \n       // make sure we aren't stopping/removing the application\n       // when the allocate comes in\n       if (application.isStopped()) {\n         LOG.info(\"Calling allocate on a stopped \" +\n             \"application \" + applicationAttemptId);\n         return EMPTY_ALLOCATION;\n       }\n \n       if (!ask.isEmpty()) {\n         LOG.debug(\"allocate: pre-update\" +\n             \" applicationId=\" + applicationAttemptId + \n             \" application=\" + application);\n         application.showRequests();\n \n         // Update application requests\n         application.updateResourceRequests(ask);\n \n         LOG.debug(\"allocate: post-update\" +\n             \" applicationId=\" + applicationAttemptId + \n             \" application=\" + application);\n         application.showRequests();\n \n         LOG.debug(\"allocate:\" +\n             \" applicationId=\" + applicationAttemptId + \n             \" #ask=\" + ask.size());\n       }\n \n       application.updateBlacklist(blacklistAdditions, blacklistRemovals);\n       ContainersAndNMTokensAllocation allocation =\n           application.pullNewlyAllocatedContainersAndNMTokens();\n       return new Allocation(allocation.getContainerList(),\n         application.getHeadroom(), null, null, null,\n         allocation.getNMTokenList());\n     }\n   }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"f6a778c3725bcdaba1e1de43786af17dd44deb78": {
			"type": "Ybodychange",
			"commitMessage": "YARN-2249. Avoided AM release requests being lost on work preserving RM restart. Contributed by Jian He.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1618972 13f79535-47bb-0310-9956-ffa450edef68\n",
			"commitDate": "2014-08-19, 1:33 PM",
			"commitName": "f6a778c3725bcdaba1e1de43786af17dd44deb78",
			"commitAuthor": "Zhijie Shen",
			"commitDateOld": "2014-07-18, 5:12 PM",
			"commitNameOld": "8871d8ed9fb1e4b21943477dcbaa13ef22ea7b8e",
			"commitAuthorOld": "Karthik Kambatla",
			"daysBetweenCommits": 31.85,
			"commitsBetweenForRepo": 243,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,68 +1,54 @@\n   public Allocation allocate(\n       ApplicationAttemptId applicationAttemptId, List<ResourceRequest> ask,\n       List<ContainerId> release, List<String> blacklistAdditions, List<String> blacklistRemovals) {\n     FiCaSchedulerApp application = getApplicationAttempt(applicationAttemptId);\n     if (application == null) {\n       LOG.error(\"Calling allocate on removed \" +\n           \"or non existant application \" + applicationAttemptId);\n       return EMPTY_ALLOCATION;\n     }\n \n     // Sanity check\n     SchedulerUtils.normalizeRequests(ask, resourceCalculator, \n         clusterResource, minimumAllocation, maximumAllocation);\n \n     // Release containers\n-    for (ContainerId releasedContainer : release) {\n-      RMContainer rmContainer = getRMContainer(releasedContainer);\n-      if (rmContainer == null) {\n-         RMAuditLogger.logFailure(application.getUser(),\n-             AuditConstants.RELEASE_CONTAINER, \n-             \"Unauthorized access or invalid container\", \"FifoScheduler\", \n-             \"Trying to release container not owned by app or with invalid id\",\n-             application.getApplicationId(), releasedContainer);\n-      }\n-      containerCompleted(rmContainer,\n-          SchedulerUtils.createAbnormalContainerStatus(\n-              releasedContainer, \n-              SchedulerUtils.RELEASED_CONTAINER),\n-          RMContainerEventType.RELEASED);\n-    }\n+    releaseContainers(release, application);\n \n     synchronized (application) {\n \n       // make sure we aren't stopping/removing the application\n       // when the allocate comes in\n       if (application.isStopped()) {\n         LOG.info(\"Calling allocate on a stopped \" +\n             \"application \" + applicationAttemptId);\n         return EMPTY_ALLOCATION;\n       }\n \n       if (!ask.isEmpty()) {\n         LOG.debug(\"allocate: pre-update\" +\n             \" applicationId=\" + applicationAttemptId + \n             \" application=\" + application);\n         application.showRequests();\n \n         // Update application requests\n         application.updateResourceRequests(ask);\n \n         LOG.debug(\"allocate: post-update\" +\n             \" applicationId=\" + applicationAttemptId + \n             \" application=\" + application);\n         application.showRequests();\n \n         LOG.debug(\"allocate:\" +\n             \" applicationId=\" + applicationAttemptId + \n             \" #ask=\" + ask.size());\n       }\n \n       application.updateBlacklist(blacklistAdditions, blacklistRemovals);\n       ContainersAndNMTokensAllocation allocation =\n           application.pullNewlyAllocatedContainersAndNMTokens();\n       return new Allocation(allocation.getContainerList(),\n         application.getHeadroom(), null, null, null,\n         allocation.getNMTokenList());\n     }\n   }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"5fd5c9900cfd299428acbc8dff767273e44647c0": {
			"type": "Ybodychange",
			"commitMessage": "YARN-713. Fixed ResourceManager to not crash while building tokens when DNS issues happen transmittently. Contributed by Jian He.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1569979 13f79535-47bb-0310-9956-ffa450edef68\n",
			"commitDate": "2014-02-19, 3:39 PM",
			"commitName": "5fd5c9900cfd299428acbc8dff767273e44647c0",
			"commitAuthor": "Vinod Kumar Vavilapalli",
			"commitDateOld": "2014-02-13, 2:02 PM",
			"commitNameOld": "d0a5e43de73119e57d12f2ec89a9d1a192cde204",
			"commitAuthorOld": "Vinod Kumar Vavilapalli",
			"daysBetweenCommits": 6.07,
			"commitsBetweenForRepo": 44,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,67 +1,68 @@\n   public Allocation allocate(\n       ApplicationAttemptId applicationAttemptId, List<ResourceRequest> ask,\n       List<ContainerId> release, List<String> blacklistAdditions, List<String> blacklistRemovals) {\n     FiCaSchedulerApp application = getApplicationAttempt(applicationAttemptId);\n     if (application == null) {\n       LOG.error(\"Calling allocate on removed \" +\n           \"or non existant application \" + applicationAttemptId);\n       return EMPTY_ALLOCATION;\n     }\n \n     // Sanity check\n     SchedulerUtils.normalizeRequests(ask, resourceCalculator, \n         clusterResource, minimumAllocation, maximumAllocation);\n \n     // Release containers\n     for (ContainerId releasedContainer : release) {\n       RMContainer rmContainer = getRMContainer(releasedContainer);\n       if (rmContainer == null) {\n          RMAuditLogger.logFailure(application.getUser(),\n              AuditConstants.RELEASE_CONTAINER, \n              \"Unauthorized access or invalid container\", \"FifoScheduler\", \n              \"Trying to release container not owned by app or with invalid id\",\n              application.getApplicationId(), releasedContainer);\n       }\n       containerCompleted(rmContainer,\n           SchedulerUtils.createAbnormalContainerStatus(\n               releasedContainer, \n               SchedulerUtils.RELEASED_CONTAINER),\n           RMContainerEventType.RELEASED);\n     }\n \n     synchronized (application) {\n \n       // make sure we aren't stopping/removing the application\n       // when the allocate comes in\n       if (application.isStopped()) {\n         LOG.info(\"Calling allocate on a stopped \" +\n             \"application \" + applicationAttemptId);\n         return EMPTY_ALLOCATION;\n       }\n \n       if (!ask.isEmpty()) {\n         LOG.debug(\"allocate: pre-update\" +\n             \" applicationId=\" + applicationAttemptId + \n             \" application=\" + application);\n         application.showRequests();\n \n         // Update application requests\n         application.updateResourceRequests(ask);\n \n         LOG.debug(\"allocate: post-update\" +\n             \" applicationId=\" + applicationAttemptId + \n             \" application=\" + application);\n         application.showRequests();\n \n         LOG.debug(\"allocate:\" +\n             \" applicationId=\" + applicationAttemptId + \n             \" #ask=\" + ask.size());\n       }\n \n       application.updateBlacklist(blacklistAdditions, blacklistRemovals);\n-\n-      return new Allocation(\n-          application.pullNewlyAllocatedContainers(), \n-          application.getHeadroom());\n+      ContainersAndNMTokensAllocation allocation =\n+          application.pullNewlyAllocatedContainersAndNMTokens();\n+      return new Allocation(allocation.getContainerList(),\n+        application.getHeadroom(), null, null, null,\n+        allocation.getNMTokenList());\n     }\n   }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"1393581bceda234c88cafec00dbfc0ef2a402e83": {
			"type": "Ybodychange",
			"commitMessage": "YARN-1490. Introduced the ability to make ResourceManager optionally not kill all containers when an ApplicationMaster exits. Contributed by Jian He.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1557143 13f79535-47bb-0310-9956-ffa450edef68\n",
			"commitDate": "2014-01-10, 7:04 AM",
			"commitName": "1393581bceda234c88cafec00dbfc0ef2a402e83",
			"commitAuthor": "Vinod Kumar Vavilapalli",
			"commitDateOld": "2014-01-02, 12:19 PM",
			"commitNameOld": "a45017a5f17ec11814db7e206d1e80aaa4dd8d8f",
			"commitAuthorOld": "Vinod Kumar Vavilapalli",
			"daysBetweenCommits": 7.78,
			"commitsBetweenForRepo": 34,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,67 +1,67 @@\n   public Allocation allocate(\n       ApplicationAttemptId applicationAttemptId, List<ResourceRequest> ask,\n       List<ContainerId> release, List<String> blacklistAdditions, List<String> blacklistRemovals) {\n-    FiCaSchedulerApp application = getApplication(applicationAttemptId);\n+    FiCaSchedulerApp application = getApplicationAttempt(applicationAttemptId);\n     if (application == null) {\n       LOG.error(\"Calling allocate on removed \" +\n           \"or non existant application \" + applicationAttemptId);\n       return EMPTY_ALLOCATION;\n     }\n \n     // Sanity check\n     SchedulerUtils.normalizeRequests(ask, resourceCalculator, \n         clusterResource, minimumAllocation, maximumAllocation);\n \n     // Release containers\n     for (ContainerId releasedContainer : release) {\n       RMContainer rmContainer = getRMContainer(releasedContainer);\n       if (rmContainer == null) {\n          RMAuditLogger.logFailure(application.getUser(),\n              AuditConstants.RELEASE_CONTAINER, \n              \"Unauthorized access or invalid container\", \"FifoScheduler\", \n              \"Trying to release container not owned by app or with invalid id\",\n              application.getApplicationId(), releasedContainer);\n       }\n       containerCompleted(rmContainer,\n           SchedulerUtils.createAbnormalContainerStatus(\n               releasedContainer, \n               SchedulerUtils.RELEASED_CONTAINER),\n           RMContainerEventType.RELEASED);\n     }\n \n     synchronized (application) {\n \n       // make sure we aren't stopping/removing the application\n       // when the allocate comes in\n       if (application.isStopped()) {\n         LOG.info(\"Calling allocate on a stopped \" +\n             \"application \" + applicationAttemptId);\n         return EMPTY_ALLOCATION;\n       }\n \n       if (!ask.isEmpty()) {\n         LOG.debug(\"allocate: pre-update\" +\n             \" applicationId=\" + applicationAttemptId + \n             \" application=\" + application);\n         application.showRequests();\n \n         // Update application requests\n         application.updateResourceRequests(ask);\n \n         LOG.debug(\"allocate: post-update\" +\n             \" applicationId=\" + applicationAttemptId + \n             \" application=\" + application);\n         application.showRequests();\n \n         LOG.debug(\"allocate:\" +\n             \" applicationId=\" + applicationAttemptId + \n             \" #ask=\" + ask.size());\n       }\n \n       application.updateBlacklist(blacklistAdditions, blacklistRemovals);\n \n       return new Allocation(\n           application.pullNewlyAllocatedContainers(), \n           application.getHeadroom());\n     }\n   }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"0a6e275ee3360719290ad666629624450d4f0a6f": {
			"type": "Ybodychange",
			"commitMessage": "YARN-1141. Updating resource requests should be decoupled with updating blacklist (Zhijie Shen via bikas)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1528632 13f79535-47bb-0310-9956-ffa450edef68\n",
			"commitDate": "2013-10-02, 2:31 PM",
			"commitName": "0a6e275ee3360719290ad666629624450d4f0a6f",
			"commitAuthor": "Bikas Saha",
			"commitDateOld": "2013-09-29, 1:21 AM",
			"commitNameOld": "1c5b49eeafc2253d4fa92456e6ccf0f35290c889",
			"commitAuthorOld": "Vinod Kumar Vavilapalli",
			"daysBetweenCommits": 3.55,
			"commitsBetweenForRepo": 30,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,65 +1,67 @@\n   public Allocation allocate(\n       ApplicationAttemptId applicationAttemptId, List<ResourceRequest> ask,\n       List<ContainerId> release, List<String> blacklistAdditions, List<String> blacklistRemovals) {\n     FiCaSchedulerApp application = getApplication(applicationAttemptId);\n     if (application == null) {\n       LOG.error(\"Calling allocate on removed \" +\n           \"or non existant application \" + applicationAttemptId);\n       return EMPTY_ALLOCATION;\n     }\n \n     // Sanity check\n     SchedulerUtils.normalizeRequests(ask, resourceCalculator, \n         clusterResource, minimumAllocation, maximumAllocation);\n \n     // Release containers\n     for (ContainerId releasedContainer : release) {\n       RMContainer rmContainer = getRMContainer(releasedContainer);\n       if (rmContainer == null) {\n          RMAuditLogger.logFailure(application.getUser(),\n              AuditConstants.RELEASE_CONTAINER, \n              \"Unauthorized access or invalid container\", \"FifoScheduler\", \n              \"Trying to release container not owned by app or with invalid id\",\n              application.getApplicationId(), releasedContainer);\n       }\n       containerCompleted(rmContainer,\n           SchedulerUtils.createAbnormalContainerStatus(\n               releasedContainer, \n               SchedulerUtils.RELEASED_CONTAINER),\n           RMContainerEventType.RELEASED);\n     }\n \n     synchronized (application) {\n \n       // make sure we aren't stopping/removing the application\n       // when the allocate comes in\n       if (application.isStopped()) {\n         LOG.info(\"Calling allocate on a stopped \" +\n             \"application \" + applicationAttemptId);\n         return EMPTY_ALLOCATION;\n       }\n \n       if (!ask.isEmpty()) {\n         LOG.debug(\"allocate: pre-update\" +\n             \" applicationId=\" + applicationAttemptId + \n             \" application=\" + application);\n         application.showRequests();\n \n         // Update application requests\n-        application.updateResourceRequests(ask, blacklistAdditions, blacklistRemovals);\n+        application.updateResourceRequests(ask);\n \n         LOG.debug(\"allocate: post-update\" +\n             \" applicationId=\" + applicationAttemptId + \n             \" application=\" + application);\n         application.showRequests();\n \n         LOG.debug(\"allocate:\" +\n             \" applicationId=\" + applicationAttemptId + \n             \" #ask=\" + ask.size());\n       }\n \n+      application.updateBlacklist(blacklistAdditions, blacklistRemovals);\n+\n       return new Allocation(\n           application.pullNewlyAllocatedContainers(), \n           application.getHeadroom());\n     }\n   }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"8eb3be63f598daae01f0a0c09eab5086881f153d": {
			"type": "Ybodychange",
			"commitMessage": "YARN-877. Support resource blacklisting for FifoScheduler. (Junping Du via llu)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1498021 13f79535-47bb-0310-9956-ffa450edef68\n",
			"commitDate": "2013-06-29, 1:18 PM",
			"commitName": "8eb3be63f598daae01f0a0c09eab5086881f153d",
			"commitAuthor": "Luke Lu",
			"commitDateOld": "2013-06-21, 11:28 AM",
			"commitNameOld": "37d7935a9d7b86635c9c1ffc03f88b49857f88a0",
			"commitAuthorOld": "Bikas Saha",
			"daysBetweenCommits": 8.08,
			"commitsBetweenForRepo": 25,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,65 +1,65 @@\n   public Allocation allocate(\n       ApplicationAttemptId applicationAttemptId, List<ResourceRequest> ask,\n       List<ContainerId> release, List<String> blacklistAdditions, List<String> blacklistRemovals) {\n     FiCaSchedulerApp application = getApplication(applicationAttemptId);\n     if (application == null) {\n       LOG.error(\"Calling allocate on removed \" +\n           \"or non existant application \" + applicationAttemptId);\n       return EMPTY_ALLOCATION;\n     }\n \n     // Sanity check\n     SchedulerUtils.normalizeRequests(ask, resourceCalculator, \n         clusterResource, minimumAllocation, maximumAllocation);\n \n     // Release containers\n     for (ContainerId releasedContainer : release) {\n       RMContainer rmContainer = getRMContainer(releasedContainer);\n       if (rmContainer == null) {\n          RMAuditLogger.logFailure(application.getUser(),\n              AuditConstants.RELEASE_CONTAINER, \n              \"Unauthorized access or invalid container\", \"FifoScheduler\", \n              \"Trying to release container not owned by app or with invalid id\",\n              application.getApplicationId(), releasedContainer);\n       }\n       containerCompleted(rmContainer,\n           SchedulerUtils.createAbnormalContainerStatus(\n               releasedContainer, \n               SchedulerUtils.RELEASED_CONTAINER),\n           RMContainerEventType.RELEASED);\n     }\n \n     synchronized (application) {\n \n       // make sure we aren't stopping/removing the application\n       // when the allocate comes in\n       if (application.isStopped()) {\n         LOG.info(\"Calling allocate on a stopped \" +\n             \"application \" + applicationAttemptId);\n         return EMPTY_ALLOCATION;\n       }\n \n       if (!ask.isEmpty()) {\n         LOG.debug(\"allocate: pre-update\" +\n             \" applicationId=\" + applicationAttemptId + \n             \" application=\" + application);\n         application.showRequests();\n \n         // Update application requests\n-        application.updateResourceRequests(ask, null, null);\n+        application.updateResourceRequests(ask, blacklistAdditions, blacklistRemovals);\n \n         LOG.debug(\"allocate: post-update\" +\n             \" applicationId=\" + applicationAttemptId + \n             \" application=\" + application);\n         application.showRequests();\n \n         LOG.debug(\"allocate:\" +\n             \" applicationId=\" + applicationAttemptId + \n             \" #ask=\" + ask.size());\n       }\n \n       return new Allocation(\n           application.pullNewlyAllocatedContainers(), \n           application.getHeadroom());\n     }\n   }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"2051fd5ee29e99df6fe79c70b0c7c8c0c1cc131f": {
			"type": "Ymultichange(Yparameterchange,Ybodychange)",
			"commitMessage": "YARN-750. Allow for black-listing resources in YARN API and Impl in CS (acmurthy via bikas)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1490392 13f79535-47bb-0310-9956-ffa450edef68\n",
			"commitDate": "2013-06-06, 11:46 AM",
			"commitName": "2051fd5ee29e99df6fe79c70b0c7c8c0c1cc131f",
			"commitAuthor": "Bikas Saha",
			"subchanges": [
				{
					"type": "Yparameterchange",
					"commitMessage": "YARN-750. Allow for black-listing resources in YARN API and Impl in CS (acmurthy via bikas)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1490392 13f79535-47bb-0310-9956-ffa450edef68\n",
					"commitDate": "2013-06-06, 11:46 AM",
					"commitName": "2051fd5ee29e99df6fe79c70b0c7c8c0c1cc131f",
					"commitAuthor": "Bikas Saha",
					"commitDateOld": "2013-06-03, 5:34 PM",
					"commitNameOld": "d33534c4fb35cb82ff8d56abeeb63a949e72a031",
					"commitAuthorOld": "Vinod Kumar Vavilapalli",
					"daysBetweenCommits": 2.76,
					"commitsBetweenForRepo": 24,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,65 +1,65 @@\n   public Allocation allocate(\n       ApplicationAttemptId applicationAttemptId, List<ResourceRequest> ask,\n-      List<ContainerId> release) {\n+      List<ContainerId> release, List<String> blacklistAdditions, List<String> blacklistRemovals) {\n     FiCaSchedulerApp application = getApplication(applicationAttemptId);\n     if (application == null) {\n       LOG.error(\"Calling allocate on removed \" +\n           \"or non existant application \" + applicationAttemptId);\n       return EMPTY_ALLOCATION;\n     }\n \n     // Sanity check\n     SchedulerUtils.normalizeRequests(ask, resourceCalculator, \n         clusterResource, minimumAllocation, maximumAllocation);\n \n     // Release containers\n     for (ContainerId releasedContainer : release) {\n       RMContainer rmContainer = getRMContainer(releasedContainer);\n       if (rmContainer == null) {\n          RMAuditLogger.logFailure(application.getUser(),\n              AuditConstants.RELEASE_CONTAINER, \n              \"Unauthorized access or invalid container\", \"FifoScheduler\", \n              \"Trying to release container not owned by app or with invalid id\",\n              application.getApplicationId(), releasedContainer);\n       }\n       containerCompleted(rmContainer,\n           SchedulerUtils.createAbnormalContainerStatus(\n               releasedContainer, \n               SchedulerUtils.RELEASED_CONTAINER),\n           RMContainerEventType.RELEASED);\n     }\n \n     synchronized (application) {\n \n       // make sure we aren't stopping/removing the application\n       // when the allocate comes in\n       if (application.isStopped()) {\n         LOG.info(\"Calling allocate on a stopped \" +\n             \"application \" + applicationAttemptId);\n         return EMPTY_ALLOCATION;\n       }\n \n       if (!ask.isEmpty()) {\n         LOG.debug(\"allocate: pre-update\" +\n             \" applicationId=\" + applicationAttemptId + \n             \" application=\" + application);\n         application.showRequests();\n \n         // Update application requests\n-        application.updateResourceRequests(ask);\n+        application.updateResourceRequests(ask, null, null);\n \n         LOG.debug(\"allocate: post-update\" +\n             \" applicationId=\" + applicationAttemptId + \n             \" application=\" + application);\n         application.showRequests();\n \n         LOG.debug(\"allocate:\" +\n             \" applicationId=\" + applicationAttemptId + \n             \" #ask=\" + ask.size());\n       }\n \n       return new Allocation(\n           application.pullNewlyAllocatedContainers(), \n           application.getHeadroom());\n     }\n   }\n\\ No newline at end of file\n",
					"extendedDetails": {
						"oldValue": "[applicationAttemptId-ApplicationAttemptId, ask-List<ResourceRequest>, release-List<ContainerId>]",
						"newValue": "[applicationAttemptId-ApplicationAttemptId, ask-List<ResourceRequest>, release-List<ContainerId>, blacklistAdditions-List<String>, blacklistRemovals-List<String>]"
					}
				},
				{
					"type": "Ybodychange",
					"commitMessage": "YARN-750. Allow for black-listing resources in YARN API and Impl in CS (acmurthy via bikas)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1490392 13f79535-47bb-0310-9956-ffa450edef68\n",
					"commitDate": "2013-06-06, 11:46 AM",
					"commitName": "2051fd5ee29e99df6fe79c70b0c7c8c0c1cc131f",
					"commitAuthor": "Bikas Saha",
					"commitDateOld": "2013-06-03, 5:34 PM",
					"commitNameOld": "d33534c4fb35cb82ff8d56abeeb63a949e72a031",
					"commitAuthorOld": "Vinod Kumar Vavilapalli",
					"daysBetweenCommits": 2.76,
					"commitsBetweenForRepo": 24,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,65 +1,65 @@\n   public Allocation allocate(\n       ApplicationAttemptId applicationAttemptId, List<ResourceRequest> ask,\n-      List<ContainerId> release) {\n+      List<ContainerId> release, List<String> blacklistAdditions, List<String> blacklistRemovals) {\n     FiCaSchedulerApp application = getApplication(applicationAttemptId);\n     if (application == null) {\n       LOG.error(\"Calling allocate on removed \" +\n           \"or non existant application \" + applicationAttemptId);\n       return EMPTY_ALLOCATION;\n     }\n \n     // Sanity check\n     SchedulerUtils.normalizeRequests(ask, resourceCalculator, \n         clusterResource, minimumAllocation, maximumAllocation);\n \n     // Release containers\n     for (ContainerId releasedContainer : release) {\n       RMContainer rmContainer = getRMContainer(releasedContainer);\n       if (rmContainer == null) {\n          RMAuditLogger.logFailure(application.getUser(),\n              AuditConstants.RELEASE_CONTAINER, \n              \"Unauthorized access or invalid container\", \"FifoScheduler\", \n              \"Trying to release container not owned by app or with invalid id\",\n              application.getApplicationId(), releasedContainer);\n       }\n       containerCompleted(rmContainer,\n           SchedulerUtils.createAbnormalContainerStatus(\n               releasedContainer, \n               SchedulerUtils.RELEASED_CONTAINER),\n           RMContainerEventType.RELEASED);\n     }\n \n     synchronized (application) {\n \n       // make sure we aren't stopping/removing the application\n       // when the allocate comes in\n       if (application.isStopped()) {\n         LOG.info(\"Calling allocate on a stopped \" +\n             \"application \" + applicationAttemptId);\n         return EMPTY_ALLOCATION;\n       }\n \n       if (!ask.isEmpty()) {\n         LOG.debug(\"allocate: pre-update\" +\n             \" applicationId=\" + applicationAttemptId + \n             \" application=\" + application);\n         application.showRequests();\n \n         // Update application requests\n-        application.updateResourceRequests(ask);\n+        application.updateResourceRequests(ask, null, null);\n \n         LOG.debug(\"allocate: post-update\" +\n             \" applicationId=\" + applicationAttemptId + \n             \" application=\" + application);\n         application.showRequests();\n \n         LOG.debug(\"allocate:\" +\n             \" applicationId=\" + applicationAttemptId + \n             \" #ask=\" + ask.size());\n       }\n \n       return new Allocation(\n           application.pullNewlyAllocatedContainers(), \n           application.getHeadroom());\n     }\n   }\n\\ No newline at end of file\n",
					"extendedDetails": {}
				}
			]
		},
		"bc6777dd5bdcbaef09897b506bc6511ae456033d": {
			"type": "Ybodychange",
			"commitMessage": "YARN-193. Scheduler.normalizeRequest does not account for allocation requests that exceed maximumAllocation limits (Zhijie Shen via bikas)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1465067 13f79535-47bb-0310-9956-ffa450edef68\n",
			"commitDate": "2013-04-05, 10:45 AM",
			"commitName": "bc6777dd5bdcbaef09897b506bc6511ae456033d",
			"commitAuthor": "Bikas Saha",
			"commitDateOld": "2013-03-29, 7:36 AM",
			"commitNameOld": "01aabf73639785a29d1651f2e268cec04a8b9b94",
			"commitAuthorOld": "Thomas Graves",
			"daysBetweenCommits": 7.13,
			"commitsBetweenForRepo": 38,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,65 +1,65 @@\n   public Allocation allocate(\n       ApplicationAttemptId applicationAttemptId, List<ResourceRequest> ask,\n       List<ContainerId> release) {\n     FiCaSchedulerApp application = getApplication(applicationAttemptId);\n     if (application == null) {\n       LOG.error(\"Calling allocate on removed \" +\n           \"or non existant application \" + applicationAttemptId);\n       return EMPTY_ALLOCATION;\n     }\n \n     // Sanity check\n     SchedulerUtils.normalizeRequests(ask, resourceCalculator, \n-        clusterResource, minimumAllocation);\n+        clusterResource, minimumAllocation, maximumAllocation);\n \n     // Release containers\n     for (ContainerId releasedContainer : release) {\n       RMContainer rmContainer = getRMContainer(releasedContainer);\n       if (rmContainer == null) {\n          RMAuditLogger.logFailure(application.getUser(),\n              AuditConstants.RELEASE_CONTAINER, \n              \"Unauthorized access or invalid container\", \"FifoScheduler\", \n              \"Trying to release container not owned by app or with invalid id\",\n              application.getApplicationId(), releasedContainer);\n       }\n       containerCompleted(rmContainer,\n           SchedulerUtils.createAbnormalContainerStatus(\n               releasedContainer, \n               SchedulerUtils.RELEASED_CONTAINER),\n           RMContainerEventType.RELEASED);\n     }\n \n     synchronized (application) {\n \n       // make sure we aren't stopping/removing the application\n       // when the allocate comes in\n       if (application.isStopped()) {\n         LOG.info(\"Calling allocate on a stopped \" +\n             \"application \" + applicationAttemptId);\n         return EMPTY_ALLOCATION;\n       }\n \n       if (!ask.isEmpty()) {\n         LOG.debug(\"allocate: pre-update\" +\n             \" applicationId=\" + applicationAttemptId + \n             \" application=\" + application);\n         application.showRequests();\n \n         // Update application requests\n         application.updateResourceRequests(ask);\n \n         LOG.debug(\"allocate: post-update\" +\n             \" applicationId=\" + applicationAttemptId + \n             \" application=\" + application);\n         application.showRequests();\n \n         LOG.debug(\"allocate:\" +\n             \" applicationId=\" + applicationAttemptId + \n             \" #ask=\" + ask.size());\n       }\n \n       return new Allocation(\n           application.pullNewlyAllocatedContainers(), \n           application.getHeadroom());\n     }\n   }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"01aabf73639785a29d1651f2e268cec04a8b9b94": {
			"type": "Ybodychange",
			"commitMessage": "YARN-460. CS user left in list of active users for the queue even when application finished (tgraves)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1462486 13f79535-47bb-0310-9956-ffa450edef68\n",
			"commitDate": "2013-03-29, 7:36 AM",
			"commitName": "01aabf73639785a29d1651f2e268cec04a8b9b94",
			"commitAuthor": "Thomas Graves",
			"commitDateOld": "2013-03-28, 12:44 PM",
			"commitNameOld": "520033b1cd81c76b38fcdcfcfeed16158db4bbba",
			"commitAuthorOld": "Bikas Saha",
			"daysBetweenCommits": 0.79,
			"commitsBetweenForRepo": 3,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,56 +1,65 @@\n   public Allocation allocate(\n       ApplicationAttemptId applicationAttemptId, List<ResourceRequest> ask,\n       List<ContainerId> release) {\n     FiCaSchedulerApp application = getApplication(applicationAttemptId);\n     if (application == null) {\n       LOG.error(\"Calling allocate on removed \" +\n           \"or non existant application \" + applicationAttemptId);\n       return EMPTY_ALLOCATION;\n     }\n \n     // Sanity check\n     SchedulerUtils.normalizeRequests(ask, resourceCalculator, \n         clusterResource, minimumAllocation);\n \n     // Release containers\n     for (ContainerId releasedContainer : release) {\n       RMContainer rmContainer = getRMContainer(releasedContainer);\n       if (rmContainer == null) {\n          RMAuditLogger.logFailure(application.getUser(),\n              AuditConstants.RELEASE_CONTAINER, \n              \"Unauthorized access or invalid container\", \"FifoScheduler\", \n              \"Trying to release container not owned by app or with invalid id\",\n              application.getApplicationId(), releasedContainer);\n       }\n       containerCompleted(rmContainer,\n           SchedulerUtils.createAbnormalContainerStatus(\n               releasedContainer, \n               SchedulerUtils.RELEASED_CONTAINER),\n           RMContainerEventType.RELEASED);\n     }\n \n     synchronized (application) {\n+\n+      // make sure we aren't stopping/removing the application\n+      // when the allocate comes in\n+      if (application.isStopped()) {\n+        LOG.info(\"Calling allocate on a stopped \" +\n+            \"application \" + applicationAttemptId);\n+        return EMPTY_ALLOCATION;\n+      }\n+\n       if (!ask.isEmpty()) {\n         LOG.debug(\"allocate: pre-update\" +\n             \" applicationId=\" + applicationAttemptId + \n             \" application=\" + application);\n         application.showRequests();\n \n         // Update application requests\n         application.updateResourceRequests(ask);\n \n         LOG.debug(\"allocate: post-update\" +\n             \" applicationId=\" + applicationAttemptId + \n             \" application=\" + application);\n         application.showRequests();\n \n         LOG.debug(\"allocate:\" +\n             \" applicationId=\" + applicationAttemptId + \n             \" #ask=\" + ask.size());\n       }\n \n       return new Allocation(\n           application.pullNewlyAllocatedContainers(), \n           application.getHeadroom());\n     }\n   }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"453926397182078c65a4428eb5de5a90d6af6448": {
			"type": "Ybodychange",
			"commitMessage": "YARN-2. Enhanced CapacityScheduler to account for CPU alongwith memory for multi-dimensional resource scheduling. Contributed by Arun C. Murthy.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1430682 13f79535-47bb-0310-9956-ffa450edef68\n",
			"commitDate": "2013-01-08, 9:08 PM",
			"commitName": "453926397182078c65a4428eb5de5a90d6af6448",
			"commitAuthor": "Arun Murthy",
			"commitDateOld": "2012-11-28, 5:56 PM",
			"commitNameOld": "1943fdbec613715f3cdc3ca60cbd273115f28299",
			"commitAuthorOld": "Arun Murthy",
			"daysBetweenCommits": 41.13,
			"commitsBetweenForRepo": 152,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,55 +1,56 @@\n   public Allocation allocate(\n       ApplicationAttemptId applicationAttemptId, List<ResourceRequest> ask,\n       List<ContainerId> release) {\n     FiCaSchedulerApp application = getApplication(applicationAttemptId);\n     if (application == null) {\n       LOG.error(\"Calling allocate on removed \" +\n           \"or non existant application \" + applicationAttemptId);\n       return EMPTY_ALLOCATION;\n     }\n \n     // Sanity check\n-    SchedulerUtils.normalizeRequests(ask, minimumAllocation.getMemory());\n+    SchedulerUtils.normalizeRequests(ask, resourceCalculator, \n+        clusterResource, minimumAllocation);\n \n     // Release containers\n     for (ContainerId releasedContainer : release) {\n       RMContainer rmContainer = getRMContainer(releasedContainer);\n       if (rmContainer == null) {\n          RMAuditLogger.logFailure(application.getUser(),\n              AuditConstants.RELEASE_CONTAINER, \n              \"Unauthorized access or invalid container\", \"FifoScheduler\", \n              \"Trying to release container not owned by app or with invalid id\",\n              application.getApplicationId(), releasedContainer);\n       }\n       containerCompleted(rmContainer,\n           SchedulerUtils.createAbnormalContainerStatus(\n               releasedContainer, \n               SchedulerUtils.RELEASED_CONTAINER),\n           RMContainerEventType.RELEASED);\n     }\n \n     synchronized (application) {\n       if (!ask.isEmpty()) {\n         LOG.debug(\"allocate: pre-update\" +\n             \" applicationId=\" + applicationAttemptId + \n             \" application=\" + application);\n         application.showRequests();\n \n         // Update application requests\n         application.updateResourceRequests(ask);\n \n         LOG.debug(\"allocate: post-update\" +\n             \" applicationId=\" + applicationAttemptId + \n             \" application=\" + application);\n         application.showRequests();\n \n         LOG.debug(\"allocate:\" +\n             \" applicationId=\" + applicationAttemptId + \n             \" #ask=\" + ask.size());\n       }\n \n       return new Allocation(\n           application.pullNewlyAllocatedContainers(), \n           application.getHeadroom());\n     }\n   }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"e1fdf62123625e4ba399af02f8aad500637d29d1": {
			"type": "Yfilerename",
			"commitMessage": "YARN-1. Promote YARN to be a sub-project of Apache Hadoop.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1370666 13f79535-47bb-0310-9956-ffa450edef68\n",
			"commitDate": "2012-08-07, 10:22 PM",
			"commitName": "e1fdf62123625e4ba399af02f8aad500637d29d1",
			"commitAuthor": "Arun Murthy",
			"commitDateOld": "2012-08-07, 7:53 PM",
			"commitNameOld": "34554d1e11ee1d5b564d7d9ed3e6d55931d72749",
			"commitAuthorOld": "Aaron Myers",
			"daysBetweenCommits": 0.1,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "",
			"extendedDetails": {
				"oldPath": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fifo/FifoScheduler.java",
				"newPath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fifo/FifoScheduler.java"
			}
		},
		"7f2b1eadc1b0807ec1302a0c3488bf6e7a59bc76": {
			"type": "Ybodychange",
			"commitMessage": "MAPREDUCE-4440. Changed SchedulerApp and SchedulerNode to be a minimal interface to allow schedulers to maintain their own.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1362332 13f79535-47bb-0310-9956-ffa450edef68\n",
			"commitDate": "2012-07-16, 6:43 PM",
			"commitName": "7f2b1eadc1b0807ec1302a0c3488bf6e7a59bc76",
			"commitAuthor": "Arun Murthy",
			"commitDateOld": "2012-07-13, 1:53 PM",
			"commitNameOld": "17de78a43e8d010f3df91dc5a1a40d74b60dfb8c",
			"commitAuthorOld": "Robert Joseph Evans",
			"daysBetweenCommits": 3.2,
			"commitsBetweenForRepo": 28,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,55 +1,55 @@\n   public Allocation allocate(\n       ApplicationAttemptId applicationAttemptId, List<ResourceRequest> ask,\n       List<ContainerId> release) {\n-    SchedulerApp application = getApplication(applicationAttemptId);\n+    FiCaSchedulerApp application = getApplication(applicationAttemptId);\n     if (application == null) {\n       LOG.error(\"Calling allocate on removed \" +\n           \"or non existant application \" + applicationAttemptId);\n       return EMPTY_ALLOCATION;\n     }\n \n     // Sanity check\n     SchedulerUtils.normalizeRequests(ask, minimumAllocation.getMemory());\n \n     // Release containers\n     for (ContainerId releasedContainer : release) {\n       RMContainer rmContainer = getRMContainer(releasedContainer);\n       if (rmContainer == null) {\n          RMAuditLogger.logFailure(application.getUser(),\n              AuditConstants.RELEASE_CONTAINER, \n              \"Unauthorized access or invalid container\", \"FifoScheduler\", \n              \"Trying to release container not owned by app or with invalid id\",\n              application.getApplicationId(), releasedContainer);\n       }\n       containerCompleted(rmContainer,\n           SchedulerUtils.createAbnormalContainerStatus(\n               releasedContainer, \n               SchedulerUtils.RELEASED_CONTAINER),\n           RMContainerEventType.RELEASED);\n     }\n \n     synchronized (application) {\n       if (!ask.isEmpty()) {\n         LOG.debug(\"allocate: pre-update\" +\n             \" applicationId=\" + applicationAttemptId + \n             \" application=\" + application);\n         application.showRequests();\n \n         // Update application requests\n         application.updateResourceRequests(ask);\n \n         LOG.debug(\"allocate: post-update\" +\n             \" applicationId=\" + applicationAttemptId + \n             \" application=\" + application);\n         application.showRequests();\n \n         LOG.debug(\"allocate:\" +\n             \" applicationId=\" + applicationAttemptId + \n             \" #ask=\" + ask.size());\n       }\n \n       return new Allocation(\n           application.pullNewlyAllocatedContainers(), \n           application.getHeadroom());\n     }\n   }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"23e336a0ed314ac7f1b47649d1a688e8de6b6e94": {
			"type": "Ybodychange",
			"commitMessage": "MAPREDUCE-3765. FifoScheduler does not respect yarn.scheduler.fifo.minimum-allocation-mb setting (Hitesh Shah via mahadev)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1240634 13f79535-47bb-0310-9956-ffa450edef68\n",
			"commitDate": "2012-02-04, 2:44 PM",
			"commitName": "23e336a0ed314ac7f1b47649d1a688e8de6b6e94",
			"commitAuthor": "Mahadev Konar",
			"commitDateOld": "2012-02-02, 4:33 PM",
			"commitNameOld": "72d34e6594371112bb4e9835817b382bd4161a6d",
			"commitAuthorOld": "Mahadev Konar",
			"daysBetweenCommits": 1.92,
			"commitsBetweenForRepo": 18,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,55 +1,55 @@\n   public Allocation allocate(\n       ApplicationAttemptId applicationAttemptId, List<ResourceRequest> ask,\n       List<ContainerId> release) {\n     SchedulerApp application = getApplication(applicationAttemptId);\n     if (application == null) {\n       LOG.error(\"Calling allocate on removed \" +\n           \"or non existant application \" + applicationAttemptId);\n       return EMPTY_ALLOCATION;\n     }\n \n     // Sanity check\n-    SchedulerUtils.normalizeRequests(ask, MINIMUM_MEMORY);\n+    SchedulerUtils.normalizeRequests(ask, minimumAllocation.getMemory());\n \n     // Release containers\n     for (ContainerId releasedContainer : release) {\n       RMContainer rmContainer = getRMContainer(releasedContainer);\n       if (rmContainer == null) {\n          RMAuditLogger.logFailure(application.getUser(),\n              AuditConstants.RELEASE_CONTAINER, \n              \"Unauthorized access or invalid container\", \"FifoScheduler\", \n              \"Trying to release container not owned by app or with invalid id\",\n              application.getApplicationId(), releasedContainer);\n       }\n       containerCompleted(rmContainer,\n           SchedulerUtils.createAbnormalContainerStatus(\n               releasedContainer, \n               SchedulerUtils.RELEASED_CONTAINER),\n           RMContainerEventType.RELEASED);\n     }\n \n     synchronized (application) {\n       if (!ask.isEmpty()) {\n         LOG.debug(\"allocate: pre-update\" +\n             \" applicationId=\" + applicationAttemptId + \n             \" application=\" + application);\n         application.showRequests();\n \n         // Update application requests\n         application.updateResourceRequests(ask);\n \n         LOG.debug(\"allocate: post-update\" +\n             \" applicationId=\" + applicationAttemptId + \n             \" application=\" + application);\n         application.showRequests();\n \n         LOG.debug(\"allocate:\" +\n             \" applicationId=\" + applicationAttemptId + \n             \" #ask=\" + ask.size());\n       }\n \n       return new Allocation(\n           application.pullNewlyAllocatedContainers(), \n           application.getHeadroom());\n     }\n   }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"80cc8e94861e2b0fc423b77fa8ce0f174c3a91fd": {
			"type": "Ybodychange",
			"commitMessage": "MAPREDUCE-3345. Fixed a race condition in ResourceManager that was causing TestContainerManagerSecurity to fail sometimes. Contributed by Hitesh Shah.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1199144 13f79535-47bb-0310-9956-ffa450edef68\n",
			"commitDate": "2011-11-07, 11:55 PM",
			"commitName": "80cc8e94861e2b0fc423b77fa8ce0f174c3a91fd",
			"commitAuthor": "Vinod Kumar Vavilapalli",
			"commitDateOld": "2011-10-20, 4:45 AM",
			"commitNameOld": "df2991c0cbc3f35c2640b93680667507c4f810dd",
			"commitAuthorOld": "Vinod Kumar Vavilapalli",
			"daysBetweenCommits": 18.84,
			"commitsBetweenForRepo": 177,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,53 +1,55 @@\n   public Allocation allocate(\n       ApplicationAttemptId applicationAttemptId, List<ResourceRequest> ask,\n       List<ContainerId> release) {\n     SchedulerApp application = getApplication(applicationAttemptId);\n     if (application == null) {\n       LOG.error(\"Calling allocate on removed \" +\n           \"or non existant application \" + applicationAttemptId);\n       return EMPTY_ALLOCATION;\n     }\n \n     // Sanity check\n     SchedulerUtils.normalizeRequests(ask, MINIMUM_MEMORY);\n \n     // Release containers\n     for (ContainerId releasedContainer : release) {\n       RMContainer rmContainer = getRMContainer(releasedContainer);\n       if (rmContainer == null) {\n          RMAuditLogger.logFailure(application.getUser(),\n              AuditConstants.RELEASE_CONTAINER, \n              \"Unauthorized access or invalid container\", \"FifoScheduler\", \n              \"Trying to release container not owned by app or with invalid id\",\n              application.getApplicationId(), releasedContainer);\n       }\n       containerCompleted(rmContainer,\n           SchedulerUtils.createAbnormalContainerStatus(\n               releasedContainer, \n               SchedulerUtils.RELEASED_CONTAINER),\n           RMContainerEventType.RELEASED);\n     }\n \n-    if (!ask.isEmpty()) {\n-      LOG.debug(\"allocate: pre-update\" +\n-          \" applicationId=\" + applicationAttemptId + \n-          \" application=\" + application);\n-      application.showRequests();\n+    synchronized (application) {\n+      if (!ask.isEmpty()) {\n+        LOG.debug(\"allocate: pre-update\" +\n+            \" applicationId=\" + applicationAttemptId + \n+            \" application=\" + application);\n+        application.showRequests();\n \n-      // Update application requests\n-      application.updateResourceRequests(ask);\n+        // Update application requests\n+        application.updateResourceRequests(ask);\n \n-      LOG.debug(\"allocate: post-update\" +\n-          \" applicationId=\" + applicationAttemptId + \n-          \" application=\" + application);\n-      application.showRequests();\n+        LOG.debug(\"allocate: post-update\" +\n+            \" applicationId=\" + applicationAttemptId + \n+            \" application=\" + application);\n+        application.showRequests();\n \n-      LOG.debug(\"allocate:\" +\n-          \" applicationId=\" + applicationAttemptId + \n-          \" #ask=\" + ask.size());\n+        LOG.debug(\"allocate:\" +\n+            \" applicationId=\" + applicationAttemptId + \n+            \" #ask=\" + ask.size());\n+      }\n+\n+      return new Allocation(\n+          application.pullNewlyAllocatedContainers(), \n+          application.getHeadroom());\n     }\n-\n-    return new Allocation(\n-        application.pullNewlyAllocatedContainers(), \n-        application.getHeadroom());\n   }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"e549ac93694f768f2e26706a54a1b45dea6d2844": {
			"type": "Ybodychange",
			"commitMessage": "MAPREDUCE-2788. Normalize resource requests in FifoScheduler appropriately. Contributed by Ahmed Radwan. \n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1186467 13f79535-47bb-0310-9956-ffa450edef68\n",
			"commitDate": "2011-10-19, 1:37 PM",
			"commitName": "e549ac93694f768f2e26706a54a1b45dea6d2844",
			"commitAuthor": "Arun Murthy",
			"commitDateOld": "2011-10-05, 7:01 AM",
			"commitNameOld": "9a4e890f4aadc921fa468fd1292d215704429b61",
			"commitAuthorOld": "Vinod Kumar Vavilapalli",
			"daysBetweenCommits": 14.27,
			"commitsBetweenForRepo": 108,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,53 +1,53 @@\n   public Allocation allocate(\n       ApplicationAttemptId applicationAttemptId, List<ResourceRequest> ask,\n       List<ContainerId> release) {\n     SchedulerApp application = getApplication(applicationAttemptId);\n     if (application == null) {\n       LOG.error(\"Calling allocate on removed \" +\n           \"or non existant application \" + applicationAttemptId);\n       return EMPTY_ALLOCATION;\n     }\n \n     // Sanity check\n-    normalizeRequests(ask);\n+    SchedulerUtils.normalizeRequests(ask, MINIMUM_MEMORY);\n \n     // Release containers\n     for (ContainerId releasedContainer : release) {\n       RMContainer rmContainer = getRMContainer(releasedContainer);\n       if (rmContainer == null) {\n          RMAuditLogger.logFailure(application.getUser(),\n              AuditConstants.RELEASE_CONTAINER, \n              \"Unauthorized access or invalid container\", \"FifoScheduler\", \n              \"Trying to release container not owned by app or with invalid id\",\n              application.getApplicationId(), releasedContainer);\n       }\n       containerCompleted(rmContainer,\n           SchedulerUtils.createAbnormalContainerStatus(\n               releasedContainer, \n               SchedulerUtils.RELEASED_CONTAINER),\n           RMContainerEventType.RELEASED);\n     }\n \n     if (!ask.isEmpty()) {\n       LOG.debug(\"allocate: pre-update\" +\n           \" applicationId=\" + applicationAttemptId + \n           \" application=\" + application);\n       application.showRequests();\n \n       // Update application requests\n       application.updateResourceRequests(ask);\n \n       LOG.debug(\"allocate: post-update\" +\n           \" applicationId=\" + applicationAttemptId + \n           \" application=\" + application);\n       application.showRequests();\n \n       LOG.debug(\"allocate:\" +\n           \" applicationId=\" + applicationAttemptId + \n           \" #ask=\" + ask.size());\n     }\n \n     return new Allocation(\n         application.pullNewlyAllocatedContainers(), \n         application.getHeadroom());\n   }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"817ead65b99f465fc2dfa18072cf23cadf5f05d0": {
			"type": "Ybodychange",
			"commitMessage": "MAPREDUCE-2933. Change allocate call to return ContainerStatus for completed containers rather than Container.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1169484 13f79535-47bb-0310-9956-ffa450edef68\n",
			"commitDate": "2011-09-11, 10:26 AM",
			"commitName": "817ead65b99f465fc2dfa18072cf23cadf5f05d0",
			"commitAuthor": "Arun Murthy",
			"commitDateOld": "2011-09-08, 7:04 PM",
			"commitNameOld": "035937bee8ef57bc24b08068e7375ac45413a349",
			"commitAuthorOld": "Arun Murthy",
			"daysBetweenCommits": 2.64,
			"commitsBetweenForRepo": 15,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,49 +1,53 @@\n   public Allocation allocate(\n       ApplicationAttemptId applicationAttemptId, List<ResourceRequest> ask,\n       List<ContainerId> release) {\n     SchedulerApp application = getApplication(applicationAttemptId);\n     if (application == null) {\n       LOG.error(\"Calling allocate on removed \" +\n           \"or non existant application \" + applicationAttemptId);\n       return EMPTY_ALLOCATION;\n     }\n \n     // Sanity check\n     normalizeRequests(ask);\n \n     // Release containers\n     for (ContainerId releasedContainer : release) {\n       RMContainer rmContainer = getRMContainer(releasedContainer);\n       if (rmContainer == null) {\n          RMAuditLogger.logFailure(application.getUser(),\n              AuditConstants.RELEASE_CONTAINER, \n              \"Unauthorized access or invalid container\", \"FifoScheduler\", \n              \"Trying to release container not owned by app or with invalid id\",\n              application.getApplicationId(), releasedContainer);\n       }\n-      containerCompleted(rmContainer, RMContainerEventType.RELEASED);\n+      containerCompleted(rmContainer,\n+          SchedulerUtils.createAbnormalContainerStatus(\n+              releasedContainer, \n+              SchedulerUtils.RELEASED_CONTAINER),\n+          RMContainerEventType.RELEASED);\n     }\n \n     if (!ask.isEmpty()) {\n       LOG.debug(\"allocate: pre-update\" +\n           \" applicationId=\" + applicationAttemptId + \n           \" application=\" + application);\n       application.showRequests();\n \n       // Update application requests\n       application.updateResourceRequests(ask);\n \n       LOG.debug(\"allocate: post-update\" +\n           \" applicationId=\" + applicationAttemptId + \n           \" application=\" + application);\n       application.showRequests();\n \n       LOG.debug(\"allocate:\" +\n           \" applicationId=\" + applicationAttemptId + \n           \" #ask=\" + ask.size());\n     }\n \n     return new Allocation(\n         application.pullNewlyAllocatedContainers(), \n         application.getHeadroom());\n   }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"cdfabf5ae289836968b3d296668593b9500b6f26": {
			"type": "Ybodychange",
			"commitMessage": "MAPREDUCE-2655. Add audit logs to ResourceManager and NodeManager. Contributed by Thomas Graves.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1165949 13f79535-47bb-0310-9956-ffa450edef68\n",
			"commitDate": "2011-09-06, 6:24 PM",
			"commitName": "cdfabf5ae289836968b3d296668593b9500b6f26",
			"commitAuthor": "Arun Murthy",
			"commitDateOld": "2011-08-24, 5:14 PM",
			"commitNameOld": "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
			"commitAuthorOld": "Arun Murthy",
			"daysBetweenCommits": 13.05,
			"commitsBetweenForRepo": 69,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,42 +1,49 @@\n   public Allocation allocate(\n       ApplicationAttemptId applicationAttemptId, List<ResourceRequest> ask,\n       List<ContainerId> release) {\n     SchedulerApp application = getApplication(applicationAttemptId);\n     if (application == null) {\n       LOG.error(\"Calling allocate on removed \" +\n           \"or non existant application \" + applicationAttemptId);\n       return EMPTY_ALLOCATION;\n     }\n \n     // Sanity check\n     normalizeRequests(ask);\n \n     // Release containers\n     for (ContainerId releasedContainer : release) {\n-      containerCompleted(getRMContainer(releasedContainer), \n-          RMContainerEventType.RELEASED);\n+      RMContainer rmContainer = getRMContainer(releasedContainer);\n+      if (rmContainer == null) {\n+         RMAuditLogger.logFailure(application.getUser(),\n+             AuditConstants.RELEASE_CONTAINER, \n+             \"Unauthorized access or invalid container\", \"FifoScheduler\", \n+             \"Trying to release container not owned by app or with invalid id\",\n+             application.getApplicationId(), releasedContainer);\n+      }\n+      containerCompleted(rmContainer, RMContainerEventType.RELEASED);\n     }\n \n     if (!ask.isEmpty()) {\n       LOG.debug(\"allocate: pre-update\" +\n           \" applicationId=\" + applicationAttemptId + \n           \" application=\" + application);\n       application.showRequests();\n \n       // Update application requests\n       application.updateResourceRequests(ask);\n \n       LOG.debug(\"allocate: post-update\" +\n           \" applicationId=\" + applicationAttemptId + \n           \" application=\" + application);\n       application.showRequests();\n \n       LOG.debug(\"allocate:\" +\n           \" applicationId=\" + applicationAttemptId + \n           \" #ask=\" + ask.size());\n     }\n \n     return new Allocation(\n         application.pullNewlyAllocatedContainers(), \n         application.getHeadroom());\n   }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"cd7157784e5e5ddc4e77144d042e54dd0d04bac1": {
			"type": "Yfilerename",
			"commitMessage": "HADOOP-7560. Change src layout to be heirarchical. Contributed by Alejandro Abdelnur.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1161332 13f79535-47bb-0310-9956-ffa450edef68\n",
			"commitDate": "2011-08-24, 5:14 PM",
			"commitName": "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
			"commitAuthor": "Arun Murthy",
			"commitDateOld": "2011-08-24, 5:06 PM",
			"commitNameOld": "bb0005cfec5fd2861600ff5babd259b48ba18b63",
			"commitAuthorOld": "Arun Murthy",
			"daysBetweenCommits": 0.01,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "",
			"extendedDetails": {
				"oldPath": "hadoop-mapreduce/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fifo/FifoScheduler.java",
				"newPath": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fifo/FifoScheduler.java"
			}
		},
		"dbecbe5dfe50f834fc3b8401709079e9470cc517": {
			"type": "Yintroduced",
			"commitMessage": "MAPREDUCE-279. MapReduce 2.0. Merging MR-279 branch into trunk. Contributed by Arun C Murthy, Christopher Douglas, Devaraj Das, Greg Roelofs, Jeffrey Naisbitt, Josh Wills, Jonathan Eagles, Krishna Ramachandran, Luke Lu, Mahadev Konar, Robert Evans, Sharad Agarwal, Siddharth Seth, Thomas Graves, and Vinod Kumar Vavilapalli.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1159166 13f79535-47bb-0310-9956-ffa450edef68\n",
			"commitDate": "2011-08-18, 4:07 AM",
			"commitName": "dbecbe5dfe50f834fc3b8401709079e9470cc517",
			"commitAuthor": "Vinod Kumar Vavilapalli",
			"diff": "@@ -0,0 +1,42 @@\n+  public Allocation allocate(\n+      ApplicationAttemptId applicationAttemptId, List<ResourceRequest> ask,\n+      List<ContainerId> release) {\n+    SchedulerApp application = getApplication(applicationAttemptId);\n+    if (application == null) {\n+      LOG.error(\"Calling allocate on removed \" +\n+          \"or non existant application \" + applicationAttemptId);\n+      return EMPTY_ALLOCATION;\n+    }\n+\n+    // Sanity check\n+    normalizeRequests(ask);\n+\n+    // Release containers\n+    for (ContainerId releasedContainer : release) {\n+      containerCompleted(getRMContainer(releasedContainer), \n+          RMContainerEventType.RELEASED);\n+    }\n+\n+    if (!ask.isEmpty()) {\n+      LOG.debug(\"allocate: pre-update\" +\n+          \" applicationId=\" + applicationAttemptId + \n+          \" application=\" + application);\n+      application.showRequests();\n+\n+      // Update application requests\n+      application.updateResourceRequests(ask);\n+\n+      LOG.debug(\"allocate: post-update\" +\n+          \" applicationId=\" + applicationAttemptId + \n+          \" application=\" + application);\n+      application.showRequests();\n+\n+      LOG.debug(\"allocate:\" +\n+          \" applicationId=\" + applicationAttemptId + \n+          \" #ask=\" + ask.size());\n+    }\n+\n+    return new Allocation(\n+        application.pullNewlyAllocatedContainers(), \n+        application.getHeadroom());\n+  }\n\\ No newline at end of file\n"
		}
	},
	"sha": "9c3fc3ef2865164aa5f121793ac914cfeb21a181"
}