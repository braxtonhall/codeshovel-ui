{
	"repo": "https://github.com/apache/lucene-solr.git",
	"file": "lucene/core/src/java/org/apache/lucene/index/ConcurrentMergeScheduler.java",
	"method": {
		"longName": "ConcurrentMergeScheduler::updateMergeThreads()",
		"startLine": 300,
		"methodName": "updateMergeThreads",
		"isStatic": false,
		"isAbstract": false,
		"visibility": "protected"
	},
	"history": {
		"9540bc37583dfd4e995b893154039fcf031dc3c3": {
			"type": "Ybodychange",
			"commitMessage": "LUCENE-7700: Move throughput control and merge aborting out of IndexWriter's core.\n",
			"commitDate": "2017-03-10, 2:23 AM",
			"commitName": "9540bc37583dfd4e995b893154039fcf031dc3c3",
			"commitAuthor": "Dawid Weiss",
			"commitDateOld": "2016-02-22, 3:08 AM",
			"commitNameOld": "fa602bf635d4710be2ffe891e252f7d4c2baf302",
			"commitAuthorOld": "Mike McCandless",
			"daysBetweenCommits": 381.97,
			"commitsBetweenForRepo": 2379,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,108 +1,109 @@\n   protected synchronized void updateMergeThreads() {\n \n     // Only look at threads that are alive & not in the\n     // process of stopping (ie have an active merge):\n     final List<MergeThread> activeMerges = new ArrayList<>();\n \n     int threadIdx = 0;\n     while (threadIdx < mergeThreads.size()) {\n       final MergeThread mergeThread = mergeThreads.get(threadIdx);\n       if (!mergeThread.isAlive()) {\n         // Prune any dead threads\n         mergeThreads.remove(threadIdx);\n         continue;\n       }\n       activeMerges.add(mergeThread);\n       threadIdx++;\n     }\n \n     // Sort the merge threads, largest first:\n     CollectionUtil.timSort(activeMerges);\n \n     final int activeMergeCount = activeMerges.size();\n \n     int bigMergeCount = 0;\n \n     for (threadIdx=activeMergeCount-1;threadIdx>=0;threadIdx--) {\n       MergeThread mergeThread = activeMerges.get(threadIdx);\n       if (mergeThread.merge.estimatedMergeBytes > MIN_BIG_MERGE_MB*1024*1024) {\n         bigMergeCount = 1+threadIdx;\n         break;\n       }\n     }\n \n     long now = System.nanoTime();\n \n     StringBuilder message;\n     if (verbose()) {\n       message = new StringBuilder();\n       message.append(String.format(Locale.ROOT, \"updateMergeThreads ioThrottle=%s targetMBPerSec=%.1f MB/sec\", doAutoIOThrottle, targetMBPerSec));\n     } else {\n       message = null;\n     }\n \n     for (threadIdx=0;threadIdx<activeMergeCount;threadIdx++) {\n       MergeThread mergeThread = activeMerges.get(threadIdx);\n \n       OneMerge merge = mergeThread.merge;\n \n       // pause the thread if maxThreadCount is smaller than the number of merge threads.\n       final boolean doPause = threadIdx < bigMergeCount - maxThreadCount;\n \n       double newMBPerSec;\n       if (doPause) {\n         newMBPerSec = 0.0;\n       } else if (merge.maxNumSegments != -1) {\n         newMBPerSec = forceMergeMBPerSec;\n       } else if (doAutoIOThrottle == false) {\n         newMBPerSec = Double.POSITIVE_INFINITY;\n       } else if (merge.estimatedMergeBytes < MIN_BIG_MERGE_MB*1024*1024) {\n         // Don't rate limit small merges:\n         newMBPerSec = Double.POSITIVE_INFINITY;\n       } else {\n         newMBPerSec = targetMBPerSec;\n       }\n \n-      double curMBPerSec = merge.rateLimiter.getMBPerSec();\n-      \n+      MergeRateLimiter rateLimiter = mergeThread.rateLimiter;\n+      double curMBPerSec = rateLimiter.getMBPerSec();\n+\n       if (verbose()) {\n         long mergeStartNS = merge.mergeStartNS;\n         if (mergeStartNS == -1) {\n           // IndexWriter didn't start the merge yet:\n           mergeStartNS = now;\n         }\n         message.append('\\n');\n         message.append(String.format(Locale.ROOT, \"merge thread %s estSize=%.1f MB (written=%.1f MB) runTime=%.1fs (stopped=%.1fs, paused=%.1fs) rate=%s\\n\",\n                                      mergeThread.getName(),\n                                      bytesToMB(merge.estimatedMergeBytes),\n-                                     bytesToMB(merge.rateLimiter.totalBytesWritten),\n+                                     bytesToMB(rateLimiter.getTotalBytesWritten()),\n                                      nsToSec(now - mergeStartNS),\n-                                     nsToSec(merge.rateLimiter.getTotalStoppedNS()),\n-                                     nsToSec(merge.rateLimiter.getTotalPausedNS()),\n-                                     rateToString(merge.rateLimiter.getMBPerSec())));\n+                                     nsToSec(rateLimiter.getTotalStoppedNS()),\n+                                     nsToSec(rateLimiter.getTotalPausedNS()),\n+                                     rateToString(rateLimiter.getMBPerSec())));\n \n         if (newMBPerSec != curMBPerSec) {\n           if (newMBPerSec == 0.0) {\n             message.append(\"  now stop\");\n           } else if (curMBPerSec == 0.0) {\n             if (newMBPerSec == Double.POSITIVE_INFINITY) {\n               message.append(\"  now resume\");\n             } else {\n               message.append(String.format(Locale.ROOT, \"  now resume to %.1f MB/sec\", newMBPerSec));\n             }\n           } else {\n             message.append(String.format(Locale.ROOT, \"  now change from %.1f MB/sec to %.1f MB/sec\", curMBPerSec, newMBPerSec));\n           }\n         } else if (curMBPerSec == 0.0) {\n           message.append(\"  leave stopped\");\n         } else {\n           message.append(String.format(Locale.ROOT, \"  leave running at %.1f MB/sec\", curMBPerSec));\n         }\n       }\n \n-      merge.rateLimiter.setMBPerSec(newMBPerSec);\n+      rateLimiter.setMBPerSec(newMBPerSec);\n     }\n     if (verbose()) {\n       message(message.toString());\n     }\n   }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"41fcc722ff07393586f7758d8a733c7e2e59bebc": {
			"type": "Ybodychange",
			"commitMessage": "LUCENE-6119: CMS dynamically rate limits IO writes of each merge depending on incoming merge rate\n\ngit-svn-id: https://svn.apache.org/repos/asf/lucene/dev/trunk@1649532 13f79535-47bb-0310-9956-ffa450edef68\n",
			"commitDate": "2015-01-05, 7:28 AM",
			"commitName": "41fcc722ff07393586f7758d8a733c7e2e59bebc",
			"commitAuthor": "Michael McCandless",
			"commitDateOld": "2014-12-22, 3:10 AM",
			"commitNameOld": "ddc5c0c6b206e985f78f4479663583d1b64e61ac",
			"commitAuthorOld": "Michael McCandless",
			"daysBetweenCommits": 14.18,
			"commitsBetweenForRepo": 96,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,57 +1,108 @@\n   protected synchronized void updateMergeThreads() {\n \n     // Only look at threads that are alive & not in the\n     // process of stopping (ie have an active merge):\n     final List<MergeThread> activeMerges = new ArrayList<>();\n \n     int threadIdx = 0;\n     while (threadIdx < mergeThreads.size()) {\n       final MergeThread mergeThread = mergeThreads.get(threadIdx);\n       if (!mergeThread.isAlive()) {\n         // Prune any dead threads\n         mergeThreads.remove(threadIdx);\n         continue;\n       }\n-      if (mergeThread.getCurrentMerge() != null) {\n-        activeMerges.add(mergeThread);\n-      }\n+      activeMerges.add(mergeThread);\n       threadIdx++;\n     }\n \n-    // Sort the merge threads in descending order.\n-    CollectionUtil.timSort(activeMerges, compareByMergeDocCount);\n-    \n-    int pri = mergeThreadPriority;\n+    // Sort the merge threads, largest first:\n+    CollectionUtil.timSort(activeMerges);\n+\n     final int activeMergeCount = activeMerges.size();\n-    for (threadIdx=0;threadIdx<activeMergeCount;threadIdx++) {\n-      final MergeThread mergeThread = activeMerges.get(threadIdx);\n-      final MergePolicy.OneMerge merge = mergeThread.getCurrentMerge();\n-      if (merge == null) { \n-        continue;\n+\n+    int bigMergeCount = 0;\n+\n+    for (threadIdx=activeMergeCount-1;threadIdx>=0;threadIdx--) {\n+      MergeThread mergeThread = activeMerges.get(threadIdx);\n+      if (mergeThread.merge.estimatedMergeBytes > MIN_BIG_MERGE_MB*1024*1024) {\n+        bigMergeCount = 1+threadIdx;\n+        break;\n       }\n+    }\n+\n+    long now = System.nanoTime();\n+\n+    StringBuilder message;\n+    if (verbose()) {\n+      message = new StringBuilder();\n+      message.append(String.format(Locale.ROOT, \"updateMergeThreads ioThrottle=%s targetMBPerSec=%.1f MB/sec\", doAutoIOThrottle, targetMBPerSec));\n+    } else {\n+      message = null;\n+    }\n+\n+    for (threadIdx=0;threadIdx<activeMergeCount;threadIdx++) {\n+      MergeThread mergeThread = activeMerges.get(threadIdx);\n+\n+      OneMerge merge = mergeThread.merge;\n \n       // pause the thread if maxThreadCount is smaller than the number of merge threads.\n-      final boolean doPause = threadIdx < activeMergeCount - maxThreadCount;\n+      final boolean doPause = threadIdx < bigMergeCount - maxThreadCount;\n \n+      double newMBPerSec;\n+      if (doPause) {\n+        newMBPerSec = 0.0;\n+      } else if (merge.maxNumSegments != -1) {\n+        newMBPerSec = forceMergeMBPerSec;\n+      } else if (doAutoIOThrottle == false) {\n+        newMBPerSec = Double.POSITIVE_INFINITY;\n+      } else if (merge.estimatedMergeBytes < MIN_BIG_MERGE_MB*1024*1024) {\n+        // Don't rate limit small merges:\n+        newMBPerSec = Double.POSITIVE_INFINITY;\n+      } else {\n+        newMBPerSec = targetMBPerSec;\n+      }\n+\n+      double curMBPerSec = merge.rateLimiter.getMBPerSec();\n+      \n       if (verbose()) {\n-        if (doPause != merge.getPause()) {\n-          if (doPause) {\n-            message(\"pause thread \" + mergeThread.getName());\n-          } else {\n-            message(\"unpause thread \" + mergeThread.getName());\n-          }\n+        long mergeStartNS = merge.mergeStartNS;\n+        if (mergeStartNS == -1) {\n+          // IndexWriter didn't start the merge yet:\n+          mergeStartNS = now;\n         }\n-      }\n-      if (doPause != merge.getPause()) {\n-        merge.setPause(doPause);\n+        message.append('\\n');\n+        message.append(String.format(Locale.ROOT, \"merge thread %s estSize=%.1f MB (written=%.1f MB) runTime=%.1fs (stopped=%.1fs, paused=%.1fs) rate=%s\\n\",\n+                                     mergeThread.getName(),\n+                                     bytesToMB(merge.estimatedMergeBytes),\n+                                     bytesToMB(merge.rateLimiter.totalBytesWritten),\n+                                     nsToSec(now - mergeStartNS),\n+                                     nsToSec(merge.rateLimiter.getTotalStoppedNS()),\n+                                     nsToSec(merge.rateLimiter.getTotalPausedNS()),\n+                                     rateToString(merge.rateLimiter.getMBPerSec())));\n+\n+        if (newMBPerSec != curMBPerSec) {\n+          if (newMBPerSec == 0.0) {\n+            message.append(\"  now stop\");\n+          } else if (curMBPerSec == 0.0) {\n+            if (newMBPerSec == Double.POSITIVE_INFINITY) {\n+              message.append(\"  now resume\");\n+            } else {\n+              message.append(String.format(Locale.ROOT, \"  now resume to %.1f MB/sec\", newMBPerSec));\n+            }\n+          } else {\n+            message.append(String.format(Locale.ROOT, \"  now change from %.1f MB/sec to %.1f MB/sec\", curMBPerSec, newMBPerSec));\n+          }\n+        } else if (curMBPerSec == 0.0) {\n+          message.append(\"  leave stopped\");\n+        } else {\n+          message.append(String.format(Locale.ROOT, \"  leave running at %.1f MB/sec\", curMBPerSec));\n+        }\n       }\n \n-      if (!doPause) {\n-        if (verbose()) {\n-          message(\"set priority of merge thread \" + mergeThread.getName() + \" to \" + pri);\n-        }\n-        mergeThread.setThreadPriority(pri);\n-        pri = Math.min(Thread.MAX_PRIORITY, 1+pri);\n-      }\n+      merge.rateLimiter.setMBPerSec(newMBPerSec);\n+    }\n+    if (verbose()) {\n+      message(message.toString());\n     }\n   }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"3b67b17493216f6b0c81a981073fd5f61eace6f4": {
			"type": "Ybodychange",
			"commitMessage": "LUCENE-5512: remove redundant typing (diamond operator) in trunk\n\ngit-svn-id: https://svn.apache.org/repos/asf/lucene/dev/trunk@1576755 13f79535-47bb-0310-9956-ffa450edef68\n",
			"commitDate": "2014-03-12, 8:39 AM",
			"commitName": "3b67b17493216f6b0c81a981073fd5f61eace6f4",
			"commitAuthor": "Robert Muir",
			"commitDateOld": "2014-03-11, 1:11 PM",
			"commitNameOld": "7efebfa50ac667fa1714c9fc43c3d6bc113fdd34",
			"commitAuthorOld": "Simon Willnauer",
			"daysBetweenCommits": 0.81,
			"commitsBetweenForRepo": 8,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,57 +1,57 @@\n   protected synchronized void updateMergeThreads() {\n \n     // Only look at threads that are alive & not in the\n     // process of stopping (ie have an active merge):\n-    final List<MergeThread> activeMerges = new ArrayList<MergeThread>();\n+    final List<MergeThread> activeMerges = new ArrayList<>();\n \n     int threadIdx = 0;\n     while (threadIdx < mergeThreads.size()) {\n       final MergeThread mergeThread = mergeThreads.get(threadIdx);\n       if (!mergeThread.isAlive()) {\n         // Prune any dead threads\n         mergeThreads.remove(threadIdx);\n         continue;\n       }\n       if (mergeThread.getCurrentMerge() != null) {\n         activeMerges.add(mergeThread);\n       }\n       threadIdx++;\n     }\n \n     // Sort the merge threads in descending order.\n     CollectionUtil.timSort(activeMerges, compareByMergeDocCount);\n     \n     int pri = mergeThreadPriority;\n     final int activeMergeCount = activeMerges.size();\n     for (threadIdx=0;threadIdx<activeMergeCount;threadIdx++) {\n       final MergeThread mergeThread = activeMerges.get(threadIdx);\n       final MergePolicy.OneMerge merge = mergeThread.getCurrentMerge();\n       if (merge == null) { \n         continue;\n       }\n \n       // pause the thread if maxThreadCount is smaller than the number of merge threads.\n       final boolean doPause = threadIdx < activeMergeCount - maxThreadCount;\n \n       if (verbose()) {\n         if (doPause != merge.getPause()) {\n           if (doPause) {\n             message(\"pause thread \" + mergeThread.getName());\n           } else {\n             message(\"unpause thread \" + mergeThread.getName());\n           }\n         }\n       }\n       if (doPause != merge.getPause()) {\n         merge.setPause(doPause);\n       }\n \n       if (!doPause) {\n         if (verbose()) {\n           message(\"set priority of merge thread \" + mergeThread.getName() + \" to \" + pri);\n         }\n         mergeThread.setThreadPriority(pri);\n         pri = Math.min(Thread.MAX_PRIORITY, 1+pri);\n       }\n     }\n   }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"b895ebde4340ed8ae903c7ae51750da3d9837394": {
			"type": "Ybodychange",
			"commitMessage": "LUCENE-4946: Refactor SorterTemplate (now Sorter).\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/lucene/dev/trunk@1478785 13f79535-47bb-0310-9956-ffa450edef68\n",
			"commitDate": "2013-05-03, 7:37 AM",
			"commitName": "b895ebde4340ed8ae903c7ae51750da3d9837394",
			"commitAuthor": "Adrien Grand",
			"commitDateOld": "2013-03-29, 3:56 PM",
			"commitNameOld": "1f964c57642e4a686b4812241eae67e0dc83ce06",
			"commitAuthorOld": "Adrien Grand",
			"daysBetweenCommits": 34.65,
			"commitsBetweenForRepo": 231,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,57 +1,57 @@\n   protected synchronized void updateMergeThreads() {\n \n     // Only look at threads that are alive & not in the\n     // process of stopping (ie have an active merge):\n     final List<MergeThread> activeMerges = new ArrayList<MergeThread>();\n \n     int threadIdx = 0;\n     while (threadIdx < mergeThreads.size()) {\n       final MergeThread mergeThread = mergeThreads.get(threadIdx);\n       if (!mergeThread.isAlive()) {\n         // Prune any dead threads\n         mergeThreads.remove(threadIdx);\n         continue;\n       }\n       if (mergeThread.getCurrentMerge() != null) {\n         activeMerges.add(mergeThread);\n       }\n       threadIdx++;\n     }\n \n     // Sort the merge threads in descending order.\n-    CollectionUtil.mergeSort(activeMerges, compareByMergeDocCount);\n+    CollectionUtil.timSort(activeMerges, compareByMergeDocCount);\n     \n     int pri = mergeThreadPriority;\n     final int activeMergeCount = activeMerges.size();\n     for (threadIdx=0;threadIdx<activeMergeCount;threadIdx++) {\n       final MergeThread mergeThread = activeMerges.get(threadIdx);\n       final MergePolicy.OneMerge merge = mergeThread.getCurrentMerge();\n       if (merge == null) { \n         continue;\n       }\n \n       // pause the thread if maxThreadCount is smaller than the number of merge threads.\n       final boolean doPause = threadIdx < activeMergeCount - maxThreadCount;\n \n       if (verbose()) {\n         if (doPause != merge.getPause()) {\n           if (doPause) {\n             message(\"pause thread \" + mergeThread.getName());\n           } else {\n             message(\"unpause thread \" + mergeThread.getName());\n           }\n         }\n       }\n       if (doPause != merge.getPause()) {\n         merge.setPause(doPause);\n       }\n \n       if (!doPause) {\n         if (verbose()) {\n           message(\"set priority of merge thread \" + mergeThread.getName() + \" to \" + pri);\n         }\n         mergeThread.setThreadPriority(pri);\n         pri = Math.min(Thread.MAX_PRIORITY, 1+pri);\n       }\n     }\n   }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"eb0ab3d392a42c1835f79bcd7f5404bcc50c8e4c": {
			"type": "Yfilerename",
			"commitMessage": "LUCENE-3753: Restructure the Lucene build system\n\ngit-svn-id: https://svn.apache.org/repos/asf/lucene/dev/trunk@1241588 13f79535-47bb-0310-9956-ffa450edef68\n",
			"commitDate": "2012-02-07, 12:59 PM",
			"commitName": "eb0ab3d392a42c1835f79bcd7f5404bcc50c8e4c",
			"commitAuthor": "Steven Rowe",
			"commitDateOld": "2012-02-07, 11:58 AM",
			"commitNameOld": "8b939cb7d20160f9f8a7baf2030613f0e1e877b4",
			"commitAuthorOld": "Robert Muir",
			"daysBetweenCommits": 0.04,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "",
			"extendedDetails": {
				"oldPath": "lucene/src/java/org/apache/lucene/index/ConcurrentMergeScheduler.java",
				"newPath": "lucene/core/src/java/org/apache/lucene/index/ConcurrentMergeScheduler.java"
			}
		},
		"9906198ff3d65f8c9b7e99462aab19feb5334790": {
			"type": "Ybodychange",
			"commitMessage": "LUCENE-2755: documentation updates, formatting and tiny mods to CMS (trunk)\n\ngit-svn-id: https://svn.apache.org/repos/asf/lucene/dev/trunk@1059905 13f79535-47bb-0310-9956-ffa450edef68\n",
			"commitDate": "2011-01-17, 5:49 AM",
			"commitName": "9906198ff3d65f8c9b7e99462aab19feb5334790",
			"commitAuthor": "Shai Erera",
			"commitDateOld": "2010-12-20, 3:35 AM",
			"commitNameOld": "765eab4008f44bb655b3dbbe4cc625455711536b",
			"commitAuthorOld": "Michael McCandless",
			"daysBetweenCommits": 28.09,
			"commitsBetweenForRepo": 179,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,60 +1,57 @@\n   protected synchronized void updateMergeThreads() {\n \n     // Only look at threads that are alive & not in the\n     // process of stopping (ie have an active merge):\n     final List<MergeThread> activeMerges = new ArrayList<MergeThread>();\n \n     int threadIdx = 0;\n     while (threadIdx < mergeThreads.size()) {\n       final MergeThread mergeThread = mergeThreads.get(threadIdx);\n       if (!mergeThread.isAlive()) {\n         // Prune any dead threads\n         mergeThreads.remove(threadIdx);\n         continue;\n       }\n       if (mergeThread.getCurrentMerge() != null) {\n         activeMerges.add(mergeThread);\n       }\n       threadIdx++;\n     }\n \n+    // Sort the merge threads in descending order.\n     CollectionUtil.mergeSort(activeMerges, compareByMergeDocCount);\n     \n     int pri = mergeThreadPriority;\n     final int activeMergeCount = activeMerges.size();\n     for (threadIdx=0;threadIdx<activeMergeCount;threadIdx++) {\n       final MergeThread mergeThread = activeMerges.get(threadIdx);\n       final MergePolicy.OneMerge merge = mergeThread.getCurrentMerge();\n       if (merge == null) { \n         continue;\n       }\n \n-      final boolean doPause;\n-      if (threadIdx < activeMergeCount-maxThreadCount) {\n-        doPause = true;\n-      } else {\n-        doPause = false;\n-      }\n+      // pause the thread if maxThreadCount is smaller than the number of merge threads.\n+      final boolean doPause = threadIdx < activeMergeCount - maxThreadCount;\n \n       if (verbose()) {\n         if (doPause != merge.getPause()) {\n           if (doPause) {\n             message(\"pause thread \" + mergeThread.getName());\n           } else {\n             message(\"unpause thread \" + mergeThread.getName());\n           }\n         }\n       }\n       if (doPause != merge.getPause()) {\n         merge.setPause(doPause);\n       }\n \n       if (!doPause) {\n         if (verbose()) {\n           message(\"set priority of merge thread \" + mergeThread.getName() + \" to \" + pri);\n         }\n         mergeThread.setThreadPriority(pri);\n         pri = Math.min(Thread.MAX_PRIORITY, 1+pri);\n       }\n     }\n   }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"765eab4008f44bb655b3dbbe4cc625455711536b": {
			"type": "Ybodychange",
			"commitMessage": "LUCENE-2820: fix CMS to stop its threads without deadlocking!\n\ngit-svn-id: https://svn.apache.org/repos/asf/lucene/dev/trunk@1051041 13f79535-47bb-0310-9956-ffa450edef68\n",
			"commitDate": "2010-12-20, 3:35 AM",
			"commitName": "765eab4008f44bb655b3dbbe4cc625455711536b",
			"commitAuthor": "Michael McCandless",
			"commitDateOld": "2010-12-19, 10:07 AM",
			"commitNameOld": "65b27c2adb9000b64ccd9d3a3b1a5030550b06da",
			"commitAuthorOld": "Michael McCandless",
			"daysBetweenCommits": 0.73,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,41 +1,60 @@\n   protected synchronized void updateMergeThreads() {\n \n-    CollectionUtil.mergeSort(mergeThreads, compareByMergeDocCount);\n-    \n-    final int count = mergeThreads.size();\n-    int pri = mergeThreadPriority;\n-    for(int i=0;i<count;i++) {\n-      final MergeThread mergeThread = mergeThreads.get(i);\n-      final MergePolicy.OneMerge merge = mergeThread.getCurrentMerge();\n-      if (merge == null) {\n+    // Only look at threads that are alive & not in the\n+    // process of stopping (ie have an active merge):\n+    final List<MergeThread> activeMerges = new ArrayList<MergeThread>();\n+\n+    int threadIdx = 0;\n+    while (threadIdx < mergeThreads.size()) {\n+      final MergeThread mergeThread = mergeThreads.get(threadIdx);\n+      if (!mergeThread.isAlive()) {\n+        // Prune any dead threads\n+        mergeThreads.remove(threadIdx);\n         continue;\n       }\n+      if (mergeThread.getCurrentMerge() != null) {\n+        activeMerges.add(mergeThread);\n+      }\n+      threadIdx++;\n+    }\n+\n+    CollectionUtil.mergeSort(activeMerges, compareByMergeDocCount);\n+    \n+    int pri = mergeThreadPriority;\n+    final int activeMergeCount = activeMerges.size();\n+    for (threadIdx=0;threadIdx<activeMergeCount;threadIdx++) {\n+      final MergeThread mergeThread = activeMerges.get(threadIdx);\n+      final MergePolicy.OneMerge merge = mergeThread.getCurrentMerge();\n+      if (merge == null) { \n+        continue;\n+      }\n+\n       final boolean doPause;\n-      if (i < count-maxThreadCount) {\n+      if (threadIdx < activeMergeCount-maxThreadCount) {\n         doPause = true;\n       } else {\n         doPause = false;\n       }\n \n       if (verbose()) {\n         if (doPause != merge.getPause()) {\n           if (doPause) {\n             message(\"pause thread \" + mergeThread.getName());\n           } else {\n             message(\"unpause thread \" + mergeThread.getName());\n           }\n         }\n       }\n       if (doPause != merge.getPause()) {\n         merge.setPause(doPause);\n       }\n \n       if (!doPause) {\n         if (verbose()) {\n           message(\"set priority of merge thread \" + mergeThread.getName() + \" to \" + pri);\n         }\n         mergeThread.setThreadPriority(pri);\n         pri = Math.min(Thread.MAX_PRIORITY, 1+pri);\n       }\n     }\n   }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"65b27c2adb9000b64ccd9d3a3b1a5030550b06da": {
			"type": "Ybodychange",
			"commitMessage": "LUCENE-2820: revert until I find the cause of the deadlock\n\ngit-svn-id: https://svn.apache.org/repos/asf/lucene/dev/trunk@1050899 13f79535-47bb-0310-9956-ffa450edef68\n",
			"commitDate": "2010-12-19, 10:07 AM",
			"commitName": "65b27c2adb9000b64ccd9d3a3b1a5030550b06da",
			"commitAuthor": "Michael McCandless",
			"commitDateOld": "2010-12-19, 6:57 AM",
			"commitNameOld": "5f9bb3f0a860097352abfc5b4c2ac7d486c06c80",
			"commitAuthorOld": "Michael McCandless",
			"daysBetweenCommits": 0.13,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,60 +1,41 @@\n   protected synchronized void updateMergeThreads() {\n \n-    // Only look at threads that are alive & not in the\n-    // process of stopping (ie have an active merge):\n-    final List<MergeThread> activeMerges = new ArrayList<MergeThread>();\n-\n-    int threadIdx = 0;\n-    while (threadIdx < mergeThreads.size()) {\n-      final MergeThread mergeThread = mergeThreads.get(threadIdx);\n-      if (!mergeThread.isAlive()) {\n-        // Prune any dead threads\n-        mergeThreads.remove(threadIdx);\n-        continue;\n-      }\n-      if (mergeThread.getCurrentMerge() != null) {\n-        activeMerges.add(mergeThread);\n-      }\n-      threadIdx++;\n-    }\n-\n-    CollectionUtil.mergeSort(activeMerges, compareByMergeDocCount);\n+    CollectionUtil.mergeSort(mergeThreads, compareByMergeDocCount);\n     \n+    final int count = mergeThreads.size();\n     int pri = mergeThreadPriority;\n-    final int activeMergeCount = activeMerges.size();\n-    for (threadIdx=0;threadIdx<activeMergeCount;threadIdx++) {\n-      final MergeThread mergeThread = activeMerges.get(threadIdx);\n+    for(int i=0;i<count;i++) {\n+      final MergeThread mergeThread = mergeThreads.get(i);\n       final MergePolicy.OneMerge merge = mergeThread.getCurrentMerge();\n-      if (merge == null) { \n+      if (merge == null) {\n         continue;\n       }\n-\n       final boolean doPause;\n-      if (threadIdx < activeMergeCount-maxThreadCount) {\n+      if (i < count-maxThreadCount) {\n         doPause = true;\n       } else {\n         doPause = false;\n       }\n \n       if (verbose()) {\n         if (doPause != merge.getPause()) {\n           if (doPause) {\n             message(\"pause thread \" + mergeThread.getName());\n           } else {\n             message(\"unpause thread \" + mergeThread.getName());\n           }\n         }\n       }\n       if (doPause != merge.getPause()) {\n         merge.setPause(doPause);\n       }\n \n       if (!doPause) {\n         if (verbose()) {\n           message(\"set priority of merge thread \" + mergeThread.getName() + \" to \" + pri);\n         }\n         mergeThread.setThreadPriority(pri);\n         pri = Math.min(Thread.MAX_PRIORITY, 1+pri);\n       }\n     }\n   }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"5f9bb3f0a860097352abfc5b4c2ac7d486c06c80": {
			"type": "Ybodychange",
			"commitMessage": "LUCENE-2820: fix CMS to stop all threads during close\n\ngit-svn-id: https://svn.apache.org/repos/asf/lucene/dev/trunk@1050853 13f79535-47bb-0310-9956-ffa450edef68\n",
			"commitDate": "2010-12-19, 6:57 AM",
			"commitName": "5f9bb3f0a860097352abfc5b4c2ac7d486c06c80",
			"commitAuthor": "Michael McCandless",
			"commitDateOld": "2010-12-18, 12:14 PM",
			"commitNameOld": "623fd7bcd7470d5d5330d721ea89269ce93c02e5",
			"commitAuthorOld": "Robert Muir",
			"daysBetweenCommits": 0.78,
			"commitsBetweenForRepo": 10,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,41 +1,60 @@\n   protected synchronized void updateMergeThreads() {\n \n-    CollectionUtil.mergeSort(mergeThreads, compareByMergeDocCount);\n-    \n-    final int count = mergeThreads.size();\n-    int pri = mergeThreadPriority;\n-    for(int i=0;i<count;i++) {\n-      final MergeThread mergeThread = mergeThreads.get(i);\n-      final MergePolicy.OneMerge merge = mergeThread.getCurrentMerge();\n-      if (merge == null) {\n+    // Only look at threads that are alive & not in the\n+    // process of stopping (ie have an active merge):\n+    final List<MergeThread> activeMerges = new ArrayList<MergeThread>();\n+\n+    int threadIdx = 0;\n+    while (threadIdx < mergeThreads.size()) {\n+      final MergeThread mergeThread = mergeThreads.get(threadIdx);\n+      if (!mergeThread.isAlive()) {\n+        // Prune any dead threads\n+        mergeThreads.remove(threadIdx);\n         continue;\n       }\n+      if (mergeThread.getCurrentMerge() != null) {\n+        activeMerges.add(mergeThread);\n+      }\n+      threadIdx++;\n+    }\n+\n+    CollectionUtil.mergeSort(activeMerges, compareByMergeDocCount);\n+    \n+    int pri = mergeThreadPriority;\n+    final int activeMergeCount = activeMerges.size();\n+    for (threadIdx=0;threadIdx<activeMergeCount;threadIdx++) {\n+      final MergeThread mergeThread = activeMerges.get(threadIdx);\n+      final MergePolicy.OneMerge merge = mergeThread.getCurrentMerge();\n+      if (merge == null) { \n+        continue;\n+      }\n+\n       final boolean doPause;\n-      if (i < count-maxThreadCount) {\n+      if (threadIdx < activeMergeCount-maxThreadCount) {\n         doPause = true;\n       } else {\n         doPause = false;\n       }\n \n       if (verbose()) {\n         if (doPause != merge.getPause()) {\n           if (doPause) {\n             message(\"pause thread \" + mergeThread.getName());\n           } else {\n             message(\"unpause thread \" + mergeThread.getName());\n           }\n         }\n       }\n       if (doPause != merge.getPause()) {\n         merge.setPause(doPause);\n       }\n \n       if (!doPause) {\n         if (verbose()) {\n           message(\"set priority of merge thread \" + mergeThread.getName() + \" to \" + pri);\n         }\n         mergeThread.setThreadPriority(pri);\n         pri = Math.min(Thread.MAX_PRIORITY, 1+pri);\n       }\n     }\n   }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"717c67ab7c2df6901f056ae2a1b5cd8317166b93": {
			"type": "Ybodychange",
			"commitMessage": "LUCENE-2719: Readded utility class org.apche.lucene.util.SorterTemplate with support for faster quickSort using pivot values and also merge sort and insertion sort. This removes code duplication and slow Collections/Arrays.sort usage.\n\ngit-svn-id: https://svn.apache.org/repos/asf/lucene/dev/trunk@1027998 13f79535-47bb-0310-9956-ffa450edef68\n",
			"commitDate": "2010-10-27, 9:16 AM",
			"commitName": "717c67ab7c2df6901f056ae2a1b5cd8317166b93",
			"commitAuthor": "Uwe Schindler",
			"commitDateOld": "2010-06-11, 3:51 AM",
			"commitNameOld": "7fe6c0fb24051748ae3ccb1b5933244deb9570bf",
			"commitAuthorOld": "Michael McCandless",
			"daysBetweenCommits": 138.23,
			"commitsBetweenForRepo": 765,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,41 +1,41 @@\n   protected synchronized void updateMergeThreads() {\n \n-    Collections.sort(mergeThreads, new CompareByMergeDocCount());\n+    CollectionUtil.mergeSort(mergeThreads, compareByMergeDocCount);\n     \n     final int count = mergeThreads.size();\n     int pri = mergeThreadPriority;\n     for(int i=0;i<count;i++) {\n       final MergeThread mergeThread = mergeThreads.get(i);\n       final MergePolicy.OneMerge merge = mergeThread.getCurrentMerge();\n       if (merge == null) {\n         continue;\n       }\n       final boolean doPause;\n       if (i < count-maxThreadCount) {\n         doPause = true;\n       } else {\n         doPause = false;\n       }\n \n       if (verbose()) {\n         if (doPause != merge.getPause()) {\n           if (doPause) {\n             message(\"pause thread \" + mergeThread.getName());\n           } else {\n             message(\"unpause thread \" + mergeThread.getName());\n           }\n         }\n       }\n       if (doPause != merge.getPause()) {\n         merge.setPause(doPause);\n       }\n \n       if (!doPause) {\n         if (verbose()) {\n           message(\"set priority of merge thread \" + mergeThread.getName() + \" to \" + pri);\n         }\n         mergeThread.setThreadPriority(pri);\n         pri = Math.min(Thread.MAX_PRIORITY, 1+pri);\n       }\n     }\n   }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"778d96752fa94636a2136ea2b4d58a3fcbe283ec": {
			"type": "Yfilerename",
			"commitMessage": "SVN-GIT conversion, path copy emulation.\n",
			"commitDate": "2016-01-22, 5:18 PM",
			"commitName": "778d96752fa94636a2136ea2b4d58a3fcbe283ec",
			"commitAuthor": "Dawid Weiss",
			"commitDateOld": "2010-03-17, 8:57 AM",
			"commitNameOld": "2e5c6cdadc820220f8cb86e1b6e215da941649f9",
			"commitAuthorOld": "Uwe Schindler",
			"daysBetweenCommits": 2137.39,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "",
			"extendedDetails": {
				"oldPath": "src/java/org/apache/lucene/index/ConcurrentMergeScheduler.java",
				"newPath": "lucene/src/java/org/apache/lucene/index/ConcurrentMergeScheduler.java"
			}
		},
		"7d35aafe71661e51ee01639ddf88503184610329": {
			"type": "Yintroduced",
			"commitMessage": "LUCENE-2164: make CMS smarter about prioritizing its threads\n\ngit-svn-id: https://svn.apache.org/repos/asf/lucene/java/trunk@892992 13f79535-47bb-0310-9956-ffa450edef68\n",
			"commitDate": "2009-12-21, 2:38 PM",
			"commitName": "7d35aafe71661e51ee01639ddf88503184610329",
			"commitAuthor": "Michael McCandless"
		}
	},
	"sha": "38bf976cd4b9e324c21664bd7ae3d554df803705"
}