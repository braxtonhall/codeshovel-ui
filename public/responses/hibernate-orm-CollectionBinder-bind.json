{
	"repo": "https://github.com/hibernate/hibernate-orm.git",
	"file": "hibernate-core/src/main/java/org/hibernate/cfg/annotations/CollectionBinder.java",
	"method": {
		"longName": "CollectionBinder::bind()",
		"startLine": 386,
		"methodName": "bind",
		"isStatic": false,
		"isAbstract": false,
		"visibility": "public"
	},
	"history": {
		"f49efc7864ad2809e2cc42ec0185c2b07b8c4b83": {
			"type": "Ybodychange",
			"commitMessage": "HHH-12122 - Checking @OrderBy for special cases should perform case-insensitive checking\n",
			"commitDate": "2017-12-13, 5:19 AM",
			"commitName": "f49efc7864ad2809e2cc42ec0185c2b07b8c4b83",
			"commitAuthor": "Steve Ebersole",
			"commitDateOld": "2017-09-18, 3:03 AM",
			"commitNameOld": "7c2a58861341f1404b4974f1ed9809f40c1da8f6",
			"commitAuthorOld": "Alexey Nesterov",
			"daysBetweenCommits": 86.14,
			"commitsBetweenForRepo": 147,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,167 +1,167 @@\n \tpublic void bind() {\n \t\tthis.collection = createCollection( propertyHolder.getPersistentClass() );\n \t\tString role = StringHelper.qualify( propertyHolder.getPath(), propertyName );\n \t\tLOG.debugf( \"Collection role: %s\", role );\n \t\tcollection.setRole( role );\n \t\tcollection.setMappedByProperty( mappedBy );\n \n \t\tif ( property.isAnnotationPresent( MapKeyColumn.class )\n \t\t\t&& mapKeyPropertyName != null ) {\n \t\t\tthrow new AnnotationException(\n \t\t\t\t\t\"Cannot mix @javax.persistence.MapKey and @MapKeyColumn or @org.hibernate.annotations.MapKey \"\n \t\t\t\t\t\t\t+ \"on the same collection: \" + StringHelper.qualify(\n \t\t\t\t\t\t\tpropertyHolder.getPath(), propertyName\n \t\t\t\t\t)\n \t\t\t);\n \t\t}\n \n \t\t// set explicit type information\n \t\tif ( explicitType != null ) {\n \t\t\tfinal TypeDefinition typeDef = buildingContext.getMetadataCollector().getTypeDefinition( explicitType );\n \t\t\tif ( typeDef == null ) {\n \t\t\t\tcollection.setTypeName( explicitType );\n \t\t\t\tcollection.setTypeParameters( explicitTypeParameters );\n \t\t\t}\n \t\t\telse {\n \t\t\t\tcollection.setTypeName( typeDef.getTypeImplementorClass().getName() );\n \t\t\t\tcollection.setTypeParameters( typeDef.getParameters() );\n \t\t\t}\n \t\t}\n \n \t\t//set laziness\n \t\tdefineFetchingStrategy();\n \t\tcollection.setBatchSize( batchSize );\n \n \t\tcollection.setMutable( !property.isAnnotationPresent( Immutable.class ) );\n \n \t\t//work on association\n \t\tboolean isMappedBy = !BinderHelper.isEmptyAnnotationValue( mappedBy );\n \n \t\tfinal OptimisticLock lockAnn = property.getAnnotation( OptimisticLock.class );\n \t\tfinal boolean includeInOptimisticLockChecks = ( lockAnn != null )\n \t\t\t\t? ! lockAnn.excluded()\n \t\t\t\t: ! isMappedBy;\n \t\tcollection.setOptimisticLocked( includeInOptimisticLockChecks );\n \n \t\tPersister persisterAnn = property.getAnnotation( Persister.class );\n \t\tif ( persisterAnn != null ) {\n \t\t\tcollection.setCollectionPersisterClass( persisterAnn.impl() );\n \t\t}\n \n \t\tapplySortingAndOrdering( collection );\n \n \t\t//set cache\n \t\tif ( StringHelper.isNotEmpty( cacheConcurrencyStrategy ) ) {\n \t\t\tcollection.setCacheConcurrencyStrategy( cacheConcurrencyStrategy );\n \t\t\tcollection.setCacheRegionName( cacheRegionName );\n \t\t}\n \n \t\t//SQL overriding\n \t\tSQLInsert sqlInsert = property.getAnnotation( SQLInsert.class );\n \t\tSQLUpdate sqlUpdate = property.getAnnotation( SQLUpdate.class );\n \t\tSQLDelete sqlDelete = property.getAnnotation( SQLDelete.class );\n \t\tSQLDeleteAll sqlDeleteAll = property.getAnnotation( SQLDeleteAll.class );\n \t\tLoader loader = property.getAnnotation( Loader.class );\n \t\tif ( sqlInsert != null ) {\n \t\t\tcollection.setCustomSQLInsert( sqlInsert.sql().trim(), sqlInsert.callable(),\n \t\t\t\t\tExecuteUpdateResultCheckStyle.fromExternalName( sqlInsert.check().toString().toLowerCase(Locale.ROOT) )\n \t\t\t);\n \n \t\t}\n \t\tif ( sqlUpdate != null ) {\n \t\t\tcollection.setCustomSQLUpdate( sqlUpdate.sql(), sqlUpdate.callable(),\n \t\t\t\t\tExecuteUpdateResultCheckStyle.fromExternalName( sqlUpdate.check().toString().toLowerCase(Locale.ROOT) )\n \t\t\t);\n \t\t}\n \t\tif ( sqlDelete != null ) {\n \t\t\tcollection.setCustomSQLDelete( sqlDelete.sql(), sqlDelete.callable(),\n \t\t\t\t\tExecuteUpdateResultCheckStyle.fromExternalName( sqlDelete.check().toString().toLowerCase(Locale.ROOT) )\n \t\t\t);\n \t\t}\n \t\tif ( sqlDeleteAll != null ) {\n \t\t\tcollection.setCustomSQLDeleteAll( sqlDeleteAll.sql(), sqlDeleteAll.callable(),\n \t\t\t\t\tExecuteUpdateResultCheckStyle.fromExternalName( sqlDeleteAll.check().toString().toLowerCase(Locale.ROOT) )\n \t\t\t);\n \t\t}\n \t\tif ( loader != null ) {\n \t\t\tcollection.setLoaderName( loader.namedQuery() );\n \t\t}\n \n \t\tif (isMappedBy\n \t\t\t\t&& (property.isAnnotationPresent( JoinColumn.class )\n \t\t\t\t\t|| property.isAnnotationPresent( JoinColumns.class )\n \t\t\t\t\t|| propertyHolder.getJoinTable( property ) != null ) ) {\n \t\t\tString message = \"Associations marked as mappedBy must not define database mappings like @JoinTable or @JoinColumn: \";\n \t\t\tmessage += StringHelper.qualify( propertyHolder.getPath(), propertyName );\n \t\t\tthrow new AnnotationException( message );\n \t\t}\n \n \t\tif (!isMappedBy\n \t\t\t\t&& oneToMany\n \t\t\t\t&& property.isAnnotationPresent( OnDelete.class )\n \t\t\t\t&& !property.isAnnotationPresent( JoinColumn.class )) {\n \t\t\tString message = \"Unidirectional one-to-many associations annotated with @OnDelete must define @JoinColumn: \";\n \t\t\tmessage += StringHelper.qualify( propertyHolder.getPath(), propertyName );\n \t\t\tthrow new AnnotationException( message );\n \t\t}\n \n \t\tcollection.setInverse( isMappedBy );\n \n \t\t//many to many may need some second pass informations\n \t\tif ( !oneToMany && isMappedBy ) {\n \t\t\tbuildingContext.getMetadataCollector().addMappedBy( getCollectionType().getName(), mappedBy, propertyName );\n \t\t}\n \t\t//TODO reducce tableBinder != null and oneToMany\n \t\tXClass collectionType = getCollectionType();\n \t\tif ( inheritanceStatePerClass == null) throw new AssertionFailure( \"inheritanceStatePerClass not set\" );\n \t\tSecondPass sp = getSecondPass(\n \t\t\t\tfkJoinColumns,\n \t\t\t\tjoinColumns,\n \t\t\t\tinverseJoinColumns,\n \t\t\t\telementColumns,\n \t\t\t\tmapKeyColumns,\n \t\t\t\tmapKeyManyToManyColumns,\n \t\t\t\tisEmbedded,\n \t\t\t\tproperty,\n \t\t\t\tcollectionType,\n \t\t\t\tignoreNotFound,\n \t\t\t\toneToMany,\n \t\t\t\ttableBinder,\n \t\t\t\tbuildingContext\n \t\t);\n \t\tif ( collectionType.isAnnotationPresent( Embeddable.class )\n \t\t\t\t|| property.isAnnotationPresent( ElementCollection.class ) //JPA 2\n \t\t\t\t) {\n \t\t\t// do it right away, otherwise @ManyToOne on composite element call addSecondPass\n \t\t\t// and raise a ConcurrentModificationException\n \t\t\t//sp.doSecondPass( CollectionHelper.EMPTY_MAP );\n \t\t\tbuildingContext.getMetadataCollector().addSecondPass( sp, !isMappedBy );\n \t\t}\n \t\telse {\n \t\t\tbuildingContext.getMetadataCollector().addSecondPass( sp, !isMappedBy );\n \t\t}\n \n \t\tbuildingContext.getMetadataCollector().addCollectionBinding( collection );\n \n \t\t//property building\n \t\tPropertyBinder binder = new PropertyBinder();\n \t\tbinder.setName( propertyName );\n \t\tbinder.setValue( collection );\n \t\tbinder.setCascade( cascadeStrategy );\n-\t\tif ( cascadeStrategy != null && cascadeStrategy.indexOf( \"delete-orphan\" ) >= 0 ) {\n+\t\tif ( cascadeStrategy != null && cascadeStrategy.contains( \"delete-orphan\" ) ) {\n \t\t\tcollection.setOrphanDelete( true );\n \t\t}\n \t\tbinder.setLazy( collection.isLazy() );\n \t\tfinal LazyGroup lazyGroupAnnotation = property.getAnnotation( LazyGroup.class );\n \t\tif ( lazyGroupAnnotation != null ) {\n \t\t\tbinder.setLazyGroup( lazyGroupAnnotation.value() );\n \t\t}\n \t\tbinder.setAccessType( accessType );\n \t\tbinder.setProperty( property );\n \t\tbinder.setInsertable( insertable );\n \t\tbinder.setUpdatable( updatable );\n \t\tProperty prop = binder.makeProperty();\n \t\t//we don't care about the join stuffs because the column is on the association table.\n \t\tif (! declaringClassSet) throw new AssertionFailure( \"DeclaringClass is not set in CollectionBinder while binding\" );\n \t\tpropertyHolder.addProperty( prop, declaringClass );\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"7c2a58861341f1404b4974f1ed9809f40c1da8f6": {
			"type": "Ybodychange",
			"commitMessage": "HHH-6382: Allow to use @OnDelete annotation on unidirectional @OneToMany associations\n",
			"commitDate": "2017-09-18, 3:03 AM",
			"commitName": "7c2a58861341f1404b4974f1ed9809f40c1da8f6",
			"commitAuthor": "Alexey Nesterov",
			"commitDateOld": "2017-08-01, 2:13 AM",
			"commitNameOld": "47f8a679907789dd68f13cfd81a6c6caf232a81b",
			"commitAuthorOld": "Bogdan Stirbat",
			"daysBetweenCommits": 48.03,
			"commitsBetweenForRepo": 100,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,158 +1,167 @@\n \tpublic void bind() {\n \t\tthis.collection = createCollection( propertyHolder.getPersistentClass() );\n \t\tString role = StringHelper.qualify( propertyHolder.getPath(), propertyName );\n \t\tLOG.debugf( \"Collection role: %s\", role );\n \t\tcollection.setRole( role );\n \t\tcollection.setMappedByProperty( mappedBy );\n \n \t\tif ( property.isAnnotationPresent( MapKeyColumn.class )\n \t\t\t&& mapKeyPropertyName != null ) {\n \t\t\tthrow new AnnotationException(\n \t\t\t\t\t\"Cannot mix @javax.persistence.MapKey and @MapKeyColumn or @org.hibernate.annotations.MapKey \"\n \t\t\t\t\t\t\t+ \"on the same collection: \" + StringHelper.qualify(\n \t\t\t\t\t\t\tpropertyHolder.getPath(), propertyName\n \t\t\t\t\t)\n \t\t\t);\n \t\t}\n \n \t\t// set explicit type information\n \t\tif ( explicitType != null ) {\n \t\t\tfinal TypeDefinition typeDef = buildingContext.getMetadataCollector().getTypeDefinition( explicitType );\n \t\t\tif ( typeDef == null ) {\n \t\t\t\tcollection.setTypeName( explicitType );\n \t\t\t\tcollection.setTypeParameters( explicitTypeParameters );\n \t\t\t}\n \t\t\telse {\n \t\t\t\tcollection.setTypeName( typeDef.getTypeImplementorClass().getName() );\n \t\t\t\tcollection.setTypeParameters( typeDef.getParameters() );\n \t\t\t}\n \t\t}\n \n \t\t//set laziness\n \t\tdefineFetchingStrategy();\n \t\tcollection.setBatchSize( batchSize );\n \n \t\tcollection.setMutable( !property.isAnnotationPresent( Immutable.class ) );\n \n \t\t//work on association\n \t\tboolean isMappedBy = !BinderHelper.isEmptyAnnotationValue( mappedBy );\n \n \t\tfinal OptimisticLock lockAnn = property.getAnnotation( OptimisticLock.class );\n \t\tfinal boolean includeInOptimisticLockChecks = ( lockAnn != null )\n \t\t\t\t? ! lockAnn.excluded()\n \t\t\t\t: ! isMappedBy;\n \t\tcollection.setOptimisticLocked( includeInOptimisticLockChecks );\n \n \t\tPersister persisterAnn = property.getAnnotation( Persister.class );\n \t\tif ( persisterAnn != null ) {\n \t\t\tcollection.setCollectionPersisterClass( persisterAnn.impl() );\n \t\t}\n \n \t\tapplySortingAndOrdering( collection );\n \n \t\t//set cache\n \t\tif ( StringHelper.isNotEmpty( cacheConcurrencyStrategy ) ) {\n \t\t\tcollection.setCacheConcurrencyStrategy( cacheConcurrencyStrategy );\n \t\t\tcollection.setCacheRegionName( cacheRegionName );\n \t\t}\n \n \t\t//SQL overriding\n \t\tSQLInsert sqlInsert = property.getAnnotation( SQLInsert.class );\n \t\tSQLUpdate sqlUpdate = property.getAnnotation( SQLUpdate.class );\n \t\tSQLDelete sqlDelete = property.getAnnotation( SQLDelete.class );\n \t\tSQLDeleteAll sqlDeleteAll = property.getAnnotation( SQLDeleteAll.class );\n \t\tLoader loader = property.getAnnotation( Loader.class );\n \t\tif ( sqlInsert != null ) {\n \t\t\tcollection.setCustomSQLInsert( sqlInsert.sql().trim(), sqlInsert.callable(),\n \t\t\t\t\tExecuteUpdateResultCheckStyle.fromExternalName( sqlInsert.check().toString().toLowerCase(Locale.ROOT) )\n \t\t\t);\n \n \t\t}\n \t\tif ( sqlUpdate != null ) {\n \t\t\tcollection.setCustomSQLUpdate( sqlUpdate.sql(), sqlUpdate.callable(),\n \t\t\t\t\tExecuteUpdateResultCheckStyle.fromExternalName( sqlUpdate.check().toString().toLowerCase(Locale.ROOT) )\n \t\t\t);\n \t\t}\n \t\tif ( sqlDelete != null ) {\n \t\t\tcollection.setCustomSQLDelete( sqlDelete.sql(), sqlDelete.callable(),\n \t\t\t\t\tExecuteUpdateResultCheckStyle.fromExternalName( sqlDelete.check().toString().toLowerCase(Locale.ROOT) )\n \t\t\t);\n \t\t}\n \t\tif ( sqlDeleteAll != null ) {\n \t\t\tcollection.setCustomSQLDeleteAll( sqlDeleteAll.sql(), sqlDeleteAll.callable(),\n \t\t\t\t\tExecuteUpdateResultCheckStyle.fromExternalName( sqlDeleteAll.check().toString().toLowerCase(Locale.ROOT) )\n \t\t\t);\n \t\t}\n \t\tif ( loader != null ) {\n \t\t\tcollection.setLoaderName( loader.namedQuery() );\n \t\t}\n \n \t\tif (isMappedBy\n \t\t\t\t&& (property.isAnnotationPresent( JoinColumn.class )\n \t\t\t\t\t|| property.isAnnotationPresent( JoinColumns.class )\n \t\t\t\t\t|| propertyHolder.getJoinTable( property ) != null ) ) {\n \t\t\tString message = \"Associations marked as mappedBy must not define database mappings like @JoinTable or @JoinColumn: \";\n \t\t\tmessage += StringHelper.qualify( propertyHolder.getPath(), propertyName );\n \t\t\tthrow new AnnotationException( message );\n \t\t}\n \n+\t\tif (!isMappedBy\n+\t\t\t\t&& oneToMany\n+\t\t\t\t&& property.isAnnotationPresent( OnDelete.class )\n+\t\t\t\t&& !property.isAnnotationPresent( JoinColumn.class )) {\n+\t\t\tString message = \"Unidirectional one-to-many associations annotated with @OnDelete must define @JoinColumn: \";\n+\t\t\tmessage += StringHelper.qualify( propertyHolder.getPath(), propertyName );\n+\t\t\tthrow new AnnotationException( message );\n+\t\t}\n+\n \t\tcollection.setInverse( isMappedBy );\n \n \t\t//many to many may need some second pass informations\n \t\tif ( !oneToMany && isMappedBy ) {\n \t\t\tbuildingContext.getMetadataCollector().addMappedBy( getCollectionType().getName(), mappedBy, propertyName );\n \t\t}\n \t\t//TODO reducce tableBinder != null and oneToMany\n \t\tXClass collectionType = getCollectionType();\n \t\tif ( inheritanceStatePerClass == null) throw new AssertionFailure( \"inheritanceStatePerClass not set\" );\n \t\tSecondPass sp = getSecondPass(\n \t\t\t\tfkJoinColumns,\n \t\t\t\tjoinColumns,\n \t\t\t\tinverseJoinColumns,\n \t\t\t\telementColumns,\n \t\t\t\tmapKeyColumns,\n \t\t\t\tmapKeyManyToManyColumns,\n \t\t\t\tisEmbedded,\n \t\t\t\tproperty,\n \t\t\t\tcollectionType,\n \t\t\t\tignoreNotFound,\n \t\t\t\toneToMany,\n \t\t\t\ttableBinder,\n \t\t\t\tbuildingContext\n \t\t);\n \t\tif ( collectionType.isAnnotationPresent( Embeddable.class )\n \t\t\t\t|| property.isAnnotationPresent( ElementCollection.class ) //JPA 2\n \t\t\t\t) {\n \t\t\t// do it right away, otherwise @ManyToOne on composite element call addSecondPass\n \t\t\t// and raise a ConcurrentModificationException\n \t\t\t//sp.doSecondPass( CollectionHelper.EMPTY_MAP );\n \t\t\tbuildingContext.getMetadataCollector().addSecondPass( sp, !isMappedBy );\n \t\t}\n \t\telse {\n \t\t\tbuildingContext.getMetadataCollector().addSecondPass( sp, !isMappedBy );\n \t\t}\n \n \t\tbuildingContext.getMetadataCollector().addCollectionBinding( collection );\n \n \t\t//property building\n \t\tPropertyBinder binder = new PropertyBinder();\n \t\tbinder.setName( propertyName );\n \t\tbinder.setValue( collection );\n \t\tbinder.setCascade( cascadeStrategy );\n \t\tif ( cascadeStrategy != null && cascadeStrategy.indexOf( \"delete-orphan\" ) >= 0 ) {\n \t\t\tcollection.setOrphanDelete( true );\n \t\t}\n \t\tbinder.setLazy( collection.isLazy() );\n \t\tfinal LazyGroup lazyGroupAnnotation = property.getAnnotation( LazyGroup.class );\n \t\tif ( lazyGroupAnnotation != null ) {\n \t\t\tbinder.setLazyGroup( lazyGroupAnnotation.value() );\n \t\t}\n \t\tbinder.setAccessType( accessType );\n \t\tbinder.setProperty( property );\n \t\tbinder.setInsertable( insertable );\n \t\tbinder.setUpdatable( updatable );\n \t\tProperty prop = binder.makeProperty();\n \t\t//we don't care about the join stuffs because the column is on the association table.\n \t\tif (! declaringClassSet) throw new AssertionFailure( \"DeclaringClass is not set in CollectionBinder while binding\" );\n \t\tpropertyHolder.addProperty( prop, declaringClass );\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"1e44e7420b7af10adc9547a461f02a6d979624f1": {
			"type": "Ybodychange",
			"commitMessage": "HHH-10267 - Support defining lazy attribute fetch groups\n",
			"commitDate": "2015-11-16, 2:43 PM",
			"commitName": "1e44e7420b7af10adc9547a461f02a6d979624f1",
			"commitAuthor": "Steve Ebersole",
			"commitDateOld": "2015-10-06, 3:07 PM",
			"commitNameOld": "0cf66b85e03a997dc94f8f82598ca8edac04e889",
			"commitAuthorOld": "Steve Ebersole",
			"daysBetweenCommits": 41.02,
			"commitsBetweenForRepo": 106,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,154 +1,158 @@\n \tpublic void bind() {\n \t\tthis.collection = createCollection( propertyHolder.getPersistentClass() );\n \t\tString role = StringHelper.qualify( propertyHolder.getPath(), propertyName );\n \t\tLOG.debugf( \"Collection role: %s\", role );\n \t\tcollection.setRole( role );\n \t\tcollection.setMappedByProperty( mappedBy );\n \n \t\tif ( property.isAnnotationPresent( MapKeyColumn.class )\n \t\t\t&& mapKeyPropertyName != null ) {\n \t\t\tthrow new AnnotationException(\n \t\t\t\t\t\"Cannot mix @javax.persistence.MapKey and @MapKeyColumn or @org.hibernate.annotations.MapKey \"\n \t\t\t\t\t\t\t+ \"on the same collection: \" + StringHelper.qualify(\n \t\t\t\t\t\t\tpropertyHolder.getPath(), propertyName\n \t\t\t\t\t)\n \t\t\t);\n \t\t}\n \n \t\t// set explicit type information\n \t\tif ( explicitType != null ) {\n \t\t\tfinal TypeDefinition typeDef = buildingContext.getMetadataCollector().getTypeDefinition( explicitType );\n \t\t\tif ( typeDef == null ) {\n \t\t\t\tcollection.setTypeName( explicitType );\n \t\t\t\tcollection.setTypeParameters( explicitTypeParameters );\n \t\t\t}\n \t\t\telse {\n \t\t\t\tcollection.setTypeName( typeDef.getTypeImplementorClass().getName() );\n \t\t\t\tcollection.setTypeParameters( typeDef.getParameters() );\n \t\t\t}\n \t\t}\n \n \t\t//set laziness\n \t\tdefineFetchingStrategy();\n \t\tcollection.setBatchSize( batchSize );\n \n \t\tcollection.setMutable( !property.isAnnotationPresent( Immutable.class ) );\n \n \t\t//work on association\n \t\tboolean isMappedBy = !BinderHelper.isEmptyAnnotationValue( mappedBy );\n \n \t\tfinal OptimisticLock lockAnn = property.getAnnotation( OptimisticLock.class );\n \t\tfinal boolean includeInOptimisticLockChecks = ( lockAnn != null )\n \t\t\t\t? ! lockAnn.excluded()\n \t\t\t\t: ! isMappedBy;\n \t\tcollection.setOptimisticLocked( includeInOptimisticLockChecks );\n \n \t\tPersister persisterAnn = property.getAnnotation( Persister.class );\n \t\tif ( persisterAnn != null ) {\n \t\t\tcollection.setCollectionPersisterClass( persisterAnn.impl() );\n \t\t}\n \n \t\tapplySortingAndOrdering( collection );\n \n \t\t//set cache\n \t\tif ( StringHelper.isNotEmpty( cacheConcurrencyStrategy ) ) {\n \t\t\tcollection.setCacheConcurrencyStrategy( cacheConcurrencyStrategy );\n \t\t\tcollection.setCacheRegionName( cacheRegionName );\n \t\t}\n \n \t\t//SQL overriding\n \t\tSQLInsert sqlInsert = property.getAnnotation( SQLInsert.class );\n \t\tSQLUpdate sqlUpdate = property.getAnnotation( SQLUpdate.class );\n \t\tSQLDelete sqlDelete = property.getAnnotation( SQLDelete.class );\n \t\tSQLDeleteAll sqlDeleteAll = property.getAnnotation( SQLDeleteAll.class );\n \t\tLoader loader = property.getAnnotation( Loader.class );\n \t\tif ( sqlInsert != null ) {\n \t\t\tcollection.setCustomSQLInsert( sqlInsert.sql().trim(), sqlInsert.callable(),\n \t\t\t\t\tExecuteUpdateResultCheckStyle.fromExternalName( sqlInsert.check().toString().toLowerCase(Locale.ROOT) )\n \t\t\t);\n \n \t\t}\n \t\tif ( sqlUpdate != null ) {\n \t\t\tcollection.setCustomSQLUpdate( sqlUpdate.sql(), sqlUpdate.callable(),\n \t\t\t\t\tExecuteUpdateResultCheckStyle.fromExternalName( sqlUpdate.check().toString().toLowerCase(Locale.ROOT) )\n \t\t\t);\n \t\t}\n \t\tif ( sqlDelete != null ) {\n \t\t\tcollection.setCustomSQLDelete( sqlDelete.sql(), sqlDelete.callable(),\n \t\t\t\t\tExecuteUpdateResultCheckStyle.fromExternalName( sqlDelete.check().toString().toLowerCase(Locale.ROOT) )\n \t\t\t);\n \t\t}\n \t\tif ( sqlDeleteAll != null ) {\n \t\t\tcollection.setCustomSQLDeleteAll( sqlDeleteAll.sql(), sqlDeleteAll.callable(),\n \t\t\t\t\tExecuteUpdateResultCheckStyle.fromExternalName( sqlDeleteAll.check().toString().toLowerCase(Locale.ROOT) )\n \t\t\t);\n \t\t}\n \t\tif ( loader != null ) {\n \t\t\tcollection.setLoaderName( loader.namedQuery() );\n \t\t}\n \n \t\tif (isMappedBy\n \t\t\t\t&& (property.isAnnotationPresent( JoinColumn.class )\n \t\t\t\t\t|| property.isAnnotationPresent( JoinColumns.class )\n \t\t\t\t\t|| propertyHolder.getJoinTable( property ) != null ) ) {\n \t\t\tString message = \"Associations marked as mappedBy must not define database mappings like @JoinTable or @JoinColumn: \";\n \t\t\tmessage += StringHelper.qualify( propertyHolder.getPath(), propertyName );\n \t\t\tthrow new AnnotationException( message );\n \t\t}\n \n \t\tcollection.setInverse( isMappedBy );\n \n \t\t//many to many may need some second pass informations\n \t\tif ( !oneToMany && isMappedBy ) {\n \t\t\tbuildingContext.getMetadataCollector().addMappedBy( getCollectionType().getName(), mappedBy, propertyName );\n \t\t}\n \t\t//TODO reducce tableBinder != null and oneToMany\n \t\tXClass collectionType = getCollectionType();\n \t\tif ( inheritanceStatePerClass == null) throw new AssertionFailure( \"inheritanceStatePerClass not set\" );\n \t\tSecondPass sp = getSecondPass(\n \t\t\t\tfkJoinColumns,\n \t\t\t\tjoinColumns,\n \t\t\t\tinverseJoinColumns,\n \t\t\t\telementColumns,\n \t\t\t\tmapKeyColumns,\n \t\t\t\tmapKeyManyToManyColumns,\n \t\t\t\tisEmbedded,\n \t\t\t\tproperty,\n \t\t\t\tcollectionType,\n \t\t\t\tignoreNotFound,\n \t\t\t\toneToMany,\n \t\t\t\ttableBinder,\n \t\t\t\tbuildingContext\n \t\t);\n \t\tif ( collectionType.isAnnotationPresent( Embeddable.class )\n \t\t\t\t|| property.isAnnotationPresent( ElementCollection.class ) //JPA 2\n \t\t\t\t) {\n \t\t\t// do it right away, otherwise @ManyToOne on composite element call addSecondPass\n \t\t\t// and raise a ConcurrentModificationException\n \t\t\t//sp.doSecondPass( CollectionHelper.EMPTY_MAP );\n \t\t\tbuildingContext.getMetadataCollector().addSecondPass( sp, !isMappedBy );\n \t\t}\n \t\telse {\n \t\t\tbuildingContext.getMetadataCollector().addSecondPass( sp, !isMappedBy );\n \t\t}\n \n \t\tbuildingContext.getMetadataCollector().addCollectionBinding( collection );\n \n \t\t//property building\n \t\tPropertyBinder binder = new PropertyBinder();\n \t\tbinder.setName( propertyName );\n \t\tbinder.setValue( collection );\n \t\tbinder.setCascade( cascadeStrategy );\n \t\tif ( cascadeStrategy != null && cascadeStrategy.indexOf( \"delete-orphan\" ) >= 0 ) {\n \t\t\tcollection.setOrphanDelete( true );\n \t\t}\n \t\tbinder.setLazy( collection.isLazy() );\n+\t\tfinal LazyGroup lazyGroupAnnotation = property.getAnnotation( LazyGroup.class );\n+\t\tif ( lazyGroupAnnotation != null ) {\n+\t\t\tbinder.setLazyGroup( lazyGroupAnnotation.value() );\n+\t\t}\n \t\tbinder.setAccessType( accessType );\n \t\tbinder.setProperty( property );\n \t\tbinder.setInsertable( insertable );\n \t\tbinder.setUpdatable( updatable );\n \t\tProperty prop = binder.makeProperty();\n \t\t//we don't care about the join stuffs because the column is on the association table.\n \t\tif (! declaringClassSet) throw new AssertionFailure( \"DeclaringClass is not set in CollectionBinder while binding\" );\n \t\tpropertyHolder.addProperty( prop, declaringClass );\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"1376b12ca9e383ef51c2ec50c88f4ef8a01f01f8": {
			"type": "Ybodychange",
			"commitMessage": "HHH-10073 Not propagating XML node names configured in mappings\n",
			"commitDate": "2015-09-01, 10:34 AM",
			"commitName": "1376b12ca9e383ef51c2ec50c88f4ef8a01f01f8",
			"commitAuthor": "Gunnar Morling",
			"commitDateOld": "2015-07-16, 2:05 AM",
			"commitNameOld": "e4781feb7423c1bc74f1c43d6665c9a0d1730e31",
			"commitAuthorOld": "Gunnar Morling",
			"daysBetweenCommits": 47.35,
			"commitsBetweenForRepo": 176,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,155 +1,154 @@\n \tpublic void bind() {\n \t\tthis.collection = createCollection( propertyHolder.getPersistentClass() );\n \t\tString role = StringHelper.qualify( propertyHolder.getPath(), propertyName );\n \t\tLOG.debugf( \"Collection role: %s\", role );\n \t\tcollection.setRole( role );\n-\t\tcollection.setNodeName( propertyName );\n \t\tcollection.setMappedByProperty( mappedBy );\n \n \t\tif ( property.isAnnotationPresent( MapKeyColumn.class )\n \t\t\t&& mapKeyPropertyName != null ) {\n \t\t\tthrow new AnnotationException(\n \t\t\t\t\t\"Cannot mix @javax.persistence.MapKey and @MapKeyColumn or @org.hibernate.annotations.MapKey \"\n \t\t\t\t\t\t\t+ \"on the same collection: \" + StringHelper.qualify(\n \t\t\t\t\t\t\tpropertyHolder.getPath(), propertyName\n \t\t\t\t\t)\n \t\t\t);\n \t\t}\n \n \t\t// set explicit type information\n \t\tif ( explicitType != null ) {\n \t\t\tfinal TypeDefinition typeDef = buildingContext.getMetadataCollector().getTypeDefinition( explicitType );\n \t\t\tif ( typeDef == null ) {\n \t\t\t\tcollection.setTypeName( explicitType );\n \t\t\t\tcollection.setTypeParameters( explicitTypeParameters );\n \t\t\t}\n \t\t\telse {\n \t\t\t\tcollection.setTypeName( typeDef.getTypeImplementorClass().getName() );\n \t\t\t\tcollection.setTypeParameters( typeDef.getParameters() );\n \t\t\t}\n \t\t}\n \n \t\t//set laziness\n \t\tdefineFetchingStrategy();\n \t\tcollection.setBatchSize( batchSize );\n \n \t\tcollection.setMutable( !property.isAnnotationPresent( Immutable.class ) );\n \n \t\t//work on association\n \t\tboolean isMappedBy = !BinderHelper.isEmptyAnnotationValue( mappedBy );\n \n \t\tfinal OptimisticLock lockAnn = property.getAnnotation( OptimisticLock.class );\n \t\tfinal boolean includeInOptimisticLockChecks = ( lockAnn != null )\n \t\t\t\t? ! lockAnn.excluded()\n \t\t\t\t: ! isMappedBy;\n \t\tcollection.setOptimisticLocked( includeInOptimisticLockChecks );\n \n \t\tPersister persisterAnn = property.getAnnotation( Persister.class );\n \t\tif ( persisterAnn != null ) {\n \t\t\tcollection.setCollectionPersisterClass( persisterAnn.impl() );\n \t\t}\n \n \t\tapplySortingAndOrdering( collection );\n \n \t\t//set cache\n \t\tif ( StringHelper.isNotEmpty( cacheConcurrencyStrategy ) ) {\n \t\t\tcollection.setCacheConcurrencyStrategy( cacheConcurrencyStrategy );\n \t\t\tcollection.setCacheRegionName( cacheRegionName );\n \t\t}\n \n \t\t//SQL overriding\n \t\tSQLInsert sqlInsert = property.getAnnotation( SQLInsert.class );\n \t\tSQLUpdate sqlUpdate = property.getAnnotation( SQLUpdate.class );\n \t\tSQLDelete sqlDelete = property.getAnnotation( SQLDelete.class );\n \t\tSQLDeleteAll sqlDeleteAll = property.getAnnotation( SQLDeleteAll.class );\n \t\tLoader loader = property.getAnnotation( Loader.class );\n \t\tif ( sqlInsert != null ) {\n \t\t\tcollection.setCustomSQLInsert( sqlInsert.sql().trim(), sqlInsert.callable(),\n \t\t\t\t\tExecuteUpdateResultCheckStyle.fromExternalName( sqlInsert.check().toString().toLowerCase(Locale.ROOT) )\n \t\t\t);\n \n \t\t}\n \t\tif ( sqlUpdate != null ) {\n \t\t\tcollection.setCustomSQLUpdate( sqlUpdate.sql(), sqlUpdate.callable(),\n \t\t\t\t\tExecuteUpdateResultCheckStyle.fromExternalName( sqlUpdate.check().toString().toLowerCase(Locale.ROOT) )\n \t\t\t);\n \t\t}\n \t\tif ( sqlDelete != null ) {\n \t\t\tcollection.setCustomSQLDelete( sqlDelete.sql(), sqlDelete.callable(),\n \t\t\t\t\tExecuteUpdateResultCheckStyle.fromExternalName( sqlDelete.check().toString().toLowerCase(Locale.ROOT) )\n \t\t\t);\n \t\t}\n \t\tif ( sqlDeleteAll != null ) {\n \t\t\tcollection.setCustomSQLDeleteAll( sqlDeleteAll.sql(), sqlDeleteAll.callable(),\n \t\t\t\t\tExecuteUpdateResultCheckStyle.fromExternalName( sqlDeleteAll.check().toString().toLowerCase(Locale.ROOT) )\n \t\t\t);\n \t\t}\n \t\tif ( loader != null ) {\n \t\t\tcollection.setLoaderName( loader.namedQuery() );\n \t\t}\n \n \t\tif (isMappedBy\n \t\t\t\t&& (property.isAnnotationPresent( JoinColumn.class )\n \t\t\t\t\t|| property.isAnnotationPresent( JoinColumns.class )\n \t\t\t\t\t|| propertyHolder.getJoinTable( property ) != null ) ) {\n \t\t\tString message = \"Associations marked as mappedBy must not define database mappings like @JoinTable or @JoinColumn: \";\n \t\t\tmessage += StringHelper.qualify( propertyHolder.getPath(), propertyName );\n \t\t\tthrow new AnnotationException( message );\n \t\t}\n \n \t\tcollection.setInverse( isMappedBy );\n \n \t\t//many to many may need some second pass informations\n \t\tif ( !oneToMany && isMappedBy ) {\n \t\t\tbuildingContext.getMetadataCollector().addMappedBy( getCollectionType().getName(), mappedBy, propertyName );\n \t\t}\n \t\t//TODO reducce tableBinder != null and oneToMany\n \t\tXClass collectionType = getCollectionType();\n \t\tif ( inheritanceStatePerClass == null) throw new AssertionFailure( \"inheritanceStatePerClass not set\" );\n \t\tSecondPass sp = getSecondPass(\n \t\t\t\tfkJoinColumns,\n \t\t\t\tjoinColumns,\n \t\t\t\tinverseJoinColumns,\n \t\t\t\telementColumns,\n \t\t\t\tmapKeyColumns,\n \t\t\t\tmapKeyManyToManyColumns,\n \t\t\t\tisEmbedded,\n \t\t\t\tproperty,\n \t\t\t\tcollectionType,\n \t\t\t\tignoreNotFound,\n \t\t\t\toneToMany,\n \t\t\t\ttableBinder,\n \t\t\t\tbuildingContext\n \t\t);\n \t\tif ( collectionType.isAnnotationPresent( Embeddable.class )\n \t\t\t\t|| property.isAnnotationPresent( ElementCollection.class ) //JPA 2\n \t\t\t\t) {\n \t\t\t// do it right away, otherwise @ManyToOne on composite element call addSecondPass\n \t\t\t// and raise a ConcurrentModificationException\n \t\t\t//sp.doSecondPass( CollectionHelper.EMPTY_MAP );\n \t\t\tbuildingContext.getMetadataCollector().addSecondPass( sp, !isMappedBy );\n \t\t}\n \t\telse {\n \t\t\tbuildingContext.getMetadataCollector().addSecondPass( sp, !isMappedBy );\n \t\t}\n \n \t\tbuildingContext.getMetadataCollector().addCollectionBinding( collection );\n \n \t\t//property building\n \t\tPropertyBinder binder = new PropertyBinder();\n \t\tbinder.setName( propertyName );\n \t\tbinder.setValue( collection );\n \t\tbinder.setCascade( cascadeStrategy );\n \t\tif ( cascadeStrategy != null && cascadeStrategy.indexOf( \"delete-orphan\" ) >= 0 ) {\n \t\t\tcollection.setOrphanDelete( true );\n \t\t}\n \t\tbinder.setLazy( collection.isLazy() );\n \t\tbinder.setAccessType( accessType );\n \t\tbinder.setProperty( property );\n \t\tbinder.setInsertable( insertable );\n \t\tbinder.setUpdatable( updatable );\n \t\tProperty prop = binder.makeProperty();\n \t\t//we don't care about the join stuffs because the column is on the association table.\n \t\tif (! declaringClassSet) throw new AssertionFailure( \"DeclaringClass is not set in CollectionBinder while binding\" );\n \t\tpropertyHolder.addProperty( prop, declaringClass );\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"c6fa2b1df18ce0a6ad8e99f4c7b964ce84cda050": {
			"type": "Ybodychange",
			"commitMessage": "HHH-8558 - Bytecode enhancer: lazy loading support\n",
			"commitDate": "2015-07-06, 12:34 PM",
			"commitName": "c6fa2b1df18ce0a6ad8e99f4c7b964ce84cda050",
			"commitAuthor": "barreiro",
			"commitDateOld": "2015-05-18, 10:25 PM",
			"commitNameOld": "bd256e4783219f4a765219cf625bb658fcb5fde1",
			"commitAuthorOld": "Steve Ebersole",
			"daysBetweenCommits": 48.59,
			"commitsBetweenForRepo": 81,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,154 +1,155 @@\n \tpublic void bind() {\n \t\tthis.collection = createCollection( propertyHolder.getPersistentClass() );\n \t\tString role = StringHelper.qualify( propertyHolder.getPath(), propertyName );\n \t\tLOG.debugf( \"Collection role: %s\", role );\n \t\tcollection.setRole( role );\n \t\tcollection.setNodeName( propertyName );\n \t\tcollection.setMappedByProperty( mappedBy );\n \n \t\tif ( property.isAnnotationPresent( MapKeyColumn.class )\n \t\t\t&& mapKeyPropertyName != null ) {\n \t\t\tthrow new AnnotationException(\n \t\t\t\t\t\"Cannot mix @javax.persistence.MapKey and @MapKeyColumn or @org.hibernate.annotations.MapKey \"\n \t\t\t\t\t\t\t+ \"on the same collection: \" + StringHelper.qualify(\n \t\t\t\t\t\t\tpropertyHolder.getPath(), propertyName\n \t\t\t\t\t)\n \t\t\t);\n \t\t}\n \n \t\t// set explicit type information\n \t\tif ( explicitType != null ) {\n \t\t\tfinal TypeDefinition typeDef = buildingContext.getMetadataCollector().getTypeDefinition( explicitType );\n \t\t\tif ( typeDef == null ) {\n \t\t\t\tcollection.setTypeName( explicitType );\n \t\t\t\tcollection.setTypeParameters( explicitTypeParameters );\n \t\t\t}\n \t\t\telse {\n \t\t\t\tcollection.setTypeName( typeDef.getTypeImplementorClass().getName() );\n \t\t\t\tcollection.setTypeParameters( typeDef.getParameters() );\n \t\t\t}\n \t\t}\n \n \t\t//set laziness\n \t\tdefineFetchingStrategy();\n \t\tcollection.setBatchSize( batchSize );\n \n \t\tcollection.setMutable( !property.isAnnotationPresent( Immutable.class ) );\n \n \t\t//work on association\n \t\tboolean isMappedBy = !BinderHelper.isEmptyAnnotationValue( mappedBy );\n \n \t\tfinal OptimisticLock lockAnn = property.getAnnotation( OptimisticLock.class );\n \t\tfinal boolean includeInOptimisticLockChecks = ( lockAnn != null )\n \t\t\t\t? ! lockAnn.excluded()\n \t\t\t\t: ! isMappedBy;\n \t\tcollection.setOptimisticLocked( includeInOptimisticLockChecks );\n \n \t\tPersister persisterAnn = property.getAnnotation( Persister.class );\n \t\tif ( persisterAnn != null ) {\n \t\t\tcollection.setCollectionPersisterClass( persisterAnn.impl() );\n \t\t}\n \n \t\tapplySortingAndOrdering( collection );\n \n \t\t//set cache\n \t\tif ( StringHelper.isNotEmpty( cacheConcurrencyStrategy ) ) {\n \t\t\tcollection.setCacheConcurrencyStrategy( cacheConcurrencyStrategy );\n \t\t\tcollection.setCacheRegionName( cacheRegionName );\n \t\t}\n \n \t\t//SQL overriding\n \t\tSQLInsert sqlInsert = property.getAnnotation( SQLInsert.class );\n \t\tSQLUpdate sqlUpdate = property.getAnnotation( SQLUpdate.class );\n \t\tSQLDelete sqlDelete = property.getAnnotation( SQLDelete.class );\n \t\tSQLDeleteAll sqlDeleteAll = property.getAnnotation( SQLDeleteAll.class );\n \t\tLoader loader = property.getAnnotation( Loader.class );\n \t\tif ( sqlInsert != null ) {\n \t\t\tcollection.setCustomSQLInsert( sqlInsert.sql().trim(), sqlInsert.callable(),\n \t\t\t\t\tExecuteUpdateResultCheckStyle.fromExternalName( sqlInsert.check().toString().toLowerCase(Locale.ROOT) )\n \t\t\t);\n \n \t\t}\n \t\tif ( sqlUpdate != null ) {\n \t\t\tcollection.setCustomSQLUpdate( sqlUpdate.sql(), sqlUpdate.callable(),\n \t\t\t\t\tExecuteUpdateResultCheckStyle.fromExternalName( sqlUpdate.check().toString().toLowerCase(Locale.ROOT) )\n \t\t\t);\n \t\t}\n \t\tif ( sqlDelete != null ) {\n \t\t\tcollection.setCustomSQLDelete( sqlDelete.sql(), sqlDelete.callable(),\n \t\t\t\t\tExecuteUpdateResultCheckStyle.fromExternalName( sqlDelete.check().toString().toLowerCase(Locale.ROOT) )\n \t\t\t);\n \t\t}\n \t\tif ( sqlDeleteAll != null ) {\n \t\t\tcollection.setCustomSQLDeleteAll( sqlDeleteAll.sql(), sqlDeleteAll.callable(),\n \t\t\t\t\tExecuteUpdateResultCheckStyle.fromExternalName( sqlDeleteAll.check().toString().toLowerCase(Locale.ROOT) )\n \t\t\t);\n \t\t}\n \t\tif ( loader != null ) {\n \t\t\tcollection.setLoaderName( loader.namedQuery() );\n \t\t}\n \n \t\tif (isMappedBy\n \t\t\t\t&& (property.isAnnotationPresent( JoinColumn.class )\n \t\t\t\t\t|| property.isAnnotationPresent( JoinColumns.class )\n \t\t\t\t\t|| propertyHolder.getJoinTable( property ) != null ) ) {\n \t\t\tString message = \"Associations marked as mappedBy must not define database mappings like @JoinTable or @JoinColumn: \";\n \t\t\tmessage += StringHelper.qualify( propertyHolder.getPath(), propertyName );\n \t\t\tthrow new AnnotationException( message );\n \t\t}\n \n \t\tcollection.setInverse( isMappedBy );\n \n \t\t//many to many may need some second pass informations\n \t\tif ( !oneToMany && isMappedBy ) {\n \t\t\tbuildingContext.getMetadataCollector().addMappedBy( getCollectionType().getName(), mappedBy, propertyName );\n \t\t}\n \t\t//TODO reducce tableBinder != null and oneToMany\n \t\tXClass collectionType = getCollectionType();\n \t\tif ( inheritanceStatePerClass == null) throw new AssertionFailure( \"inheritanceStatePerClass not set\" );\n \t\tSecondPass sp = getSecondPass(\n \t\t\t\tfkJoinColumns,\n \t\t\t\tjoinColumns,\n \t\t\t\tinverseJoinColumns,\n \t\t\t\telementColumns,\n \t\t\t\tmapKeyColumns,\n \t\t\t\tmapKeyManyToManyColumns,\n \t\t\t\tisEmbedded,\n \t\t\t\tproperty,\n \t\t\t\tcollectionType,\n \t\t\t\tignoreNotFound,\n \t\t\t\toneToMany,\n \t\t\t\ttableBinder,\n \t\t\t\tbuildingContext\n \t\t);\n \t\tif ( collectionType.isAnnotationPresent( Embeddable.class )\n \t\t\t\t|| property.isAnnotationPresent( ElementCollection.class ) //JPA 2\n \t\t\t\t) {\n \t\t\t// do it right away, otherwise @ManyToOne on composite element call addSecondPass\n \t\t\t// and raise a ConcurrentModificationException\n \t\t\t//sp.doSecondPass( CollectionHelper.EMPTY_MAP );\n \t\t\tbuildingContext.getMetadataCollector().addSecondPass( sp, !isMappedBy );\n \t\t}\n \t\telse {\n \t\t\tbuildingContext.getMetadataCollector().addSecondPass( sp, !isMappedBy );\n \t\t}\n \n \t\tbuildingContext.getMetadataCollector().addCollectionBinding( collection );\n \n \t\t//property building\n \t\tPropertyBinder binder = new PropertyBinder();\n \t\tbinder.setName( propertyName );\n \t\tbinder.setValue( collection );\n \t\tbinder.setCascade( cascadeStrategy );\n \t\tif ( cascadeStrategy != null && cascadeStrategy.indexOf( \"delete-orphan\" ) >= 0 ) {\n \t\t\tcollection.setOrphanDelete( true );\n \t\t}\n+\t\tbinder.setLazy( collection.isLazy() );\n \t\tbinder.setAccessType( accessType );\n \t\tbinder.setProperty( property );\n \t\tbinder.setInsertable( insertable );\n \t\tbinder.setUpdatable( updatable );\n \t\tProperty prop = binder.makeProperty();\n \t\t//we don't care about the join stuffs because the column is on the association table.\n \t\tif (! declaringClassSet) throw new AssertionFailure( \"DeclaringClass is not set in CollectionBinder while binding\" );\n \t\tpropertyHolder.addProperty( prop, declaringClass );\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"1361925bc73a539bd6bd5d4a93de162e4a5b332b": {
			"type": "Ybodychange",
			"commitMessage": "HHH-9722\n\nChanged all toLowerCase() and toUpperCase() to toLowerCase(Locale.ROOT),\ntoUpperCase(Locale.ROOT).\n",
			"commitDate": "2015-04-17, 1:53 PM",
			"commitName": "1361925bc73a539bd6bd5d4a93de162e4a5b332b",
			"commitAuthor": "10urshin",
			"commitDateOld": "2015-04-02, 4:02 PM",
			"commitNameOld": "22ca7125f74621c09f7c2eedbc399160ce2755d5",
			"commitAuthorOld": "Steve Ebersole",
			"daysBetweenCommits": 14.91,
			"commitsBetweenForRepo": 20,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,154 +1,154 @@\n \tpublic void bind() {\n \t\tthis.collection = createCollection( propertyHolder.getPersistentClass() );\n \t\tString role = StringHelper.qualify( propertyHolder.getPath(), propertyName );\n \t\tLOG.debugf( \"Collection role: %s\", role );\n \t\tcollection.setRole( role );\n \t\tcollection.setNodeName( propertyName );\n \t\tcollection.setMappedByProperty( mappedBy );\n \n \t\tif ( property.isAnnotationPresent( MapKeyColumn.class )\n \t\t\t&& mapKeyPropertyName != null ) {\n \t\t\tthrow new AnnotationException(\n \t\t\t\t\t\"Cannot mix @javax.persistence.MapKey and @MapKeyColumn or @org.hibernate.annotations.MapKey \"\n \t\t\t\t\t\t\t+ \"on the same collection: \" + StringHelper.qualify(\n \t\t\t\t\t\t\tpropertyHolder.getPath(), propertyName\n \t\t\t\t\t)\n \t\t\t);\n \t\t}\n \n \t\t// set explicit type information\n \t\tif ( explicitType != null ) {\n \t\t\tfinal TypeDefinition typeDef = buildingContext.getMetadataCollector().getTypeDefinition( explicitType );\n \t\t\tif ( typeDef == null ) {\n \t\t\t\tcollection.setTypeName( explicitType );\n \t\t\t\tcollection.setTypeParameters( explicitTypeParameters );\n \t\t\t}\n \t\t\telse {\n \t\t\t\tcollection.setTypeName( typeDef.getTypeImplementorClass().getName() );\n \t\t\t\tcollection.setTypeParameters( typeDef.getParameters() );\n \t\t\t}\n \t\t}\n \n \t\t//set laziness\n \t\tdefineFetchingStrategy();\n \t\tcollection.setBatchSize( batchSize );\n \n \t\tcollection.setMutable( !property.isAnnotationPresent( Immutable.class ) );\n \n \t\t//work on association\n \t\tboolean isMappedBy = !BinderHelper.isEmptyAnnotationValue( mappedBy );\n \n \t\tfinal OptimisticLock lockAnn = property.getAnnotation( OptimisticLock.class );\n \t\tfinal boolean includeInOptimisticLockChecks = ( lockAnn != null )\n \t\t\t\t? ! lockAnn.excluded()\n \t\t\t\t: ! isMappedBy;\n \t\tcollection.setOptimisticLocked( includeInOptimisticLockChecks );\n \n \t\tPersister persisterAnn = property.getAnnotation( Persister.class );\n \t\tif ( persisterAnn != null ) {\n \t\t\tcollection.setCollectionPersisterClass( persisterAnn.impl() );\n \t\t}\n \n \t\tapplySortingAndOrdering( collection );\n \n \t\t//set cache\n \t\tif ( StringHelper.isNotEmpty( cacheConcurrencyStrategy ) ) {\n \t\t\tcollection.setCacheConcurrencyStrategy( cacheConcurrencyStrategy );\n \t\t\tcollection.setCacheRegionName( cacheRegionName );\n \t\t}\n \n \t\t//SQL overriding\n \t\tSQLInsert sqlInsert = property.getAnnotation( SQLInsert.class );\n \t\tSQLUpdate sqlUpdate = property.getAnnotation( SQLUpdate.class );\n \t\tSQLDelete sqlDelete = property.getAnnotation( SQLDelete.class );\n \t\tSQLDeleteAll sqlDeleteAll = property.getAnnotation( SQLDeleteAll.class );\n \t\tLoader loader = property.getAnnotation( Loader.class );\n \t\tif ( sqlInsert != null ) {\n \t\t\tcollection.setCustomSQLInsert( sqlInsert.sql().trim(), sqlInsert.callable(),\n-\t\t\t\t\tExecuteUpdateResultCheckStyle.fromExternalName( sqlInsert.check().toString().toLowerCase() )\n+\t\t\t\t\tExecuteUpdateResultCheckStyle.fromExternalName( sqlInsert.check().toString().toLowerCase(Locale.ROOT) )\n \t\t\t);\n \n \t\t}\n \t\tif ( sqlUpdate != null ) {\n \t\t\tcollection.setCustomSQLUpdate( sqlUpdate.sql(), sqlUpdate.callable(),\n-\t\t\t\t\tExecuteUpdateResultCheckStyle.fromExternalName( sqlUpdate.check().toString().toLowerCase() )\n+\t\t\t\t\tExecuteUpdateResultCheckStyle.fromExternalName( sqlUpdate.check().toString().toLowerCase(Locale.ROOT) )\n \t\t\t);\n \t\t}\n \t\tif ( sqlDelete != null ) {\n \t\t\tcollection.setCustomSQLDelete( sqlDelete.sql(), sqlDelete.callable(),\n-\t\t\t\t\tExecuteUpdateResultCheckStyle.fromExternalName( sqlDelete.check().toString().toLowerCase() )\n+\t\t\t\t\tExecuteUpdateResultCheckStyle.fromExternalName( sqlDelete.check().toString().toLowerCase(Locale.ROOT) )\n \t\t\t);\n \t\t}\n \t\tif ( sqlDeleteAll != null ) {\n \t\t\tcollection.setCustomSQLDeleteAll( sqlDeleteAll.sql(), sqlDeleteAll.callable(),\n-\t\t\t\t\tExecuteUpdateResultCheckStyle.fromExternalName( sqlDeleteAll.check().toString().toLowerCase() )\n+\t\t\t\t\tExecuteUpdateResultCheckStyle.fromExternalName( sqlDeleteAll.check().toString().toLowerCase(Locale.ROOT) )\n \t\t\t);\n \t\t}\n \t\tif ( loader != null ) {\n \t\t\tcollection.setLoaderName( loader.namedQuery() );\n \t\t}\n \n \t\tif (isMappedBy\n \t\t\t\t&& (property.isAnnotationPresent( JoinColumn.class )\n \t\t\t\t\t|| property.isAnnotationPresent( JoinColumns.class )\n \t\t\t\t\t|| propertyHolder.getJoinTable( property ) != null ) ) {\n \t\t\tString message = \"Associations marked as mappedBy must not define database mappings like @JoinTable or @JoinColumn: \";\n \t\t\tmessage += StringHelper.qualify( propertyHolder.getPath(), propertyName );\n \t\t\tthrow new AnnotationException( message );\n \t\t}\n \n \t\tcollection.setInverse( isMappedBy );\n \n \t\t//many to many may need some second pass informations\n \t\tif ( !oneToMany && isMappedBy ) {\n \t\t\tbuildingContext.getMetadataCollector().addMappedBy( getCollectionType().getName(), mappedBy, propertyName );\n \t\t}\n \t\t//TODO reducce tableBinder != null and oneToMany\n \t\tXClass collectionType = getCollectionType();\n \t\tif ( inheritanceStatePerClass == null) throw new AssertionFailure( \"inheritanceStatePerClass not set\" );\n \t\tSecondPass sp = getSecondPass(\n \t\t\t\tfkJoinColumns,\n \t\t\t\tjoinColumns,\n \t\t\t\tinverseJoinColumns,\n \t\t\t\telementColumns,\n \t\t\t\tmapKeyColumns,\n \t\t\t\tmapKeyManyToManyColumns,\n \t\t\t\tisEmbedded,\n \t\t\t\tproperty,\n \t\t\t\tcollectionType,\n \t\t\t\tignoreNotFound,\n \t\t\t\toneToMany,\n \t\t\t\ttableBinder,\n \t\t\t\tbuildingContext\n \t\t);\n \t\tif ( collectionType.isAnnotationPresent( Embeddable.class )\n \t\t\t\t|| property.isAnnotationPresent( ElementCollection.class ) //JPA 2\n \t\t\t\t) {\n \t\t\t// do it right away, otherwise @ManyToOne on composite element call addSecondPass\n \t\t\t// and raise a ConcurrentModificationException\n \t\t\t//sp.doSecondPass( CollectionHelper.EMPTY_MAP );\n \t\t\tbuildingContext.getMetadataCollector().addSecondPass( sp, !isMappedBy );\n \t\t}\n \t\telse {\n \t\t\tbuildingContext.getMetadataCollector().addSecondPass( sp, !isMappedBy );\n \t\t}\n \n \t\tbuildingContext.getMetadataCollector().addCollectionBinding( collection );\n \n \t\t//property building\n \t\tPropertyBinder binder = new PropertyBinder();\n \t\tbinder.setName( propertyName );\n \t\tbinder.setValue( collection );\n \t\tbinder.setCascade( cascadeStrategy );\n \t\tif ( cascadeStrategy != null && cascadeStrategy.indexOf( \"delete-orphan\" ) >= 0 ) {\n \t\t\tcollection.setOrphanDelete( true );\n \t\t}\n \t\tbinder.setAccessType( accessType );\n \t\tbinder.setProperty( property );\n \t\tbinder.setInsertable( insertable );\n \t\tbinder.setUpdatable( updatable );\n \t\tProperty prop = binder.makeProperty();\n \t\t//we don't care about the join stuffs because the column is on the association table.\n \t\tif (! declaringClassSet) throw new AssertionFailure( \"DeclaringClass is not set in CollectionBinder while binding\" );\n \t\tpropertyHolder.addProperty( prop, declaringClass );\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"9caca0ce37d5a2763d476c6fa2471addcca710ca": {
			"type": "Ybodychange",
			"commitMessage": "HHH-9490 - Migrate from dom4j to jaxb for XML processing;\nHHH-9492 - Migrate to new bootstrap API (MetadataSources, etc);\nHHH-7078 - Split NamingStrategy into ImplicitNamingStrategy/PhysicalNamingStrategy;\nHHH-6005 - Better handling of implicit column naming with @ElementCollection of @Embeddables;\nHHH-9633 - Add tests that explicitly test the \"main\" NamingStrategy impls\n",
			"commitDate": "2015-03-10, 3:53 PM",
			"commitName": "9caca0ce37d5a2763d476c6fa2471addcca710ca",
			"commitAuthor": "Steve Ebersole",
			"commitDateOld": "2014-10-20, 11:18 PM",
			"commitNameOld": "1cba98022ec0ccb30f6a68547c050663daf51a96",
			"commitAuthorOld": "Gail Badner",
			"daysBetweenCommits": 140.69,
			"commitsBetweenForRepo": 59,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,149 +1,154 @@\n \tpublic void bind() {\n \t\tthis.collection = createCollection( propertyHolder.getPersistentClass() );\n \t\tString role = StringHelper.qualify( propertyHolder.getPath(), propertyName );\n \t\tLOG.debugf( \"Collection role: %s\", role );\n \t\tcollection.setRole( role );\n \t\tcollection.setNodeName( propertyName );\n \t\tcollection.setMappedByProperty( mappedBy );\n \n \t\tif ( property.isAnnotationPresent( MapKeyColumn.class )\n \t\t\t&& mapKeyPropertyName != null ) {\n \t\t\tthrow new AnnotationException(\n \t\t\t\t\t\"Cannot mix @javax.persistence.MapKey and @MapKeyColumn or @org.hibernate.annotations.MapKey \"\n \t\t\t\t\t\t\t+ \"on the same collection: \" + StringHelper.qualify(\n \t\t\t\t\t\t\tpropertyHolder.getPath(), propertyName\n \t\t\t\t\t)\n \t\t\t);\n \t\t}\n \n \t\t// set explicit type information\n \t\tif ( explicitType != null ) {\n-\t\t\tfinal TypeDef typeDef = mappings.getTypeDef( explicitType );\n+\t\t\tfinal TypeDefinition typeDef = buildingContext.getMetadataCollector().getTypeDefinition( explicitType );\n \t\t\tif ( typeDef == null ) {\n \t\t\t\tcollection.setTypeName( explicitType );\n \t\t\t\tcollection.setTypeParameters( explicitTypeParameters );\n \t\t\t}\n \t\t\telse {\n-\t\t\t\tcollection.setTypeName( typeDef.getTypeClass() );\n+\t\t\t\tcollection.setTypeName( typeDef.getTypeImplementorClass().getName() );\n \t\t\t\tcollection.setTypeParameters( typeDef.getParameters() );\n \t\t\t}\n \t\t}\n \n \t\t//set laziness\n \t\tdefineFetchingStrategy();\n \t\tcollection.setBatchSize( batchSize );\n \n \t\tcollection.setMutable( !property.isAnnotationPresent( Immutable.class ) );\n \n \t\t//work on association\n \t\tboolean isMappedBy = !BinderHelper.isEmptyAnnotationValue( mappedBy );\n \n \t\tfinal OptimisticLock lockAnn = property.getAnnotation( OptimisticLock.class );\n \t\tfinal boolean includeInOptimisticLockChecks = ( lockAnn != null )\n \t\t\t\t? ! lockAnn.excluded()\n \t\t\t\t: ! isMappedBy;\n \t\tcollection.setOptimisticLocked( includeInOptimisticLockChecks );\n \n \t\tPersister persisterAnn = property.getAnnotation( Persister.class );\n \t\tif ( persisterAnn != null ) {\n \t\t\tcollection.setCollectionPersisterClass( persisterAnn.impl() );\n \t\t}\n \n \t\tapplySortingAndOrdering( collection );\n \n \t\t//set cache\n \t\tif ( StringHelper.isNotEmpty( cacheConcurrencyStrategy ) ) {\n \t\t\tcollection.setCacheConcurrencyStrategy( cacheConcurrencyStrategy );\n \t\t\tcollection.setCacheRegionName( cacheRegionName );\n \t\t}\n \n \t\t//SQL overriding\n \t\tSQLInsert sqlInsert = property.getAnnotation( SQLInsert.class );\n \t\tSQLUpdate sqlUpdate = property.getAnnotation( SQLUpdate.class );\n \t\tSQLDelete sqlDelete = property.getAnnotation( SQLDelete.class );\n \t\tSQLDeleteAll sqlDeleteAll = property.getAnnotation( SQLDeleteAll.class );\n \t\tLoader loader = property.getAnnotation( Loader.class );\n \t\tif ( sqlInsert != null ) {\n \t\t\tcollection.setCustomSQLInsert( sqlInsert.sql().trim(), sqlInsert.callable(),\n \t\t\t\t\tExecuteUpdateResultCheckStyle.fromExternalName( sqlInsert.check().toString().toLowerCase() )\n \t\t\t);\n \n \t\t}\n \t\tif ( sqlUpdate != null ) {\n \t\t\tcollection.setCustomSQLUpdate( sqlUpdate.sql(), sqlUpdate.callable(),\n \t\t\t\t\tExecuteUpdateResultCheckStyle.fromExternalName( sqlUpdate.check().toString().toLowerCase() )\n \t\t\t);\n \t\t}\n \t\tif ( sqlDelete != null ) {\n \t\t\tcollection.setCustomSQLDelete( sqlDelete.sql(), sqlDelete.callable(),\n \t\t\t\t\tExecuteUpdateResultCheckStyle.fromExternalName( sqlDelete.check().toString().toLowerCase() )\n \t\t\t);\n \t\t}\n \t\tif ( sqlDeleteAll != null ) {\n \t\t\tcollection.setCustomSQLDeleteAll( sqlDeleteAll.sql(), sqlDeleteAll.callable(),\n \t\t\t\t\tExecuteUpdateResultCheckStyle.fromExternalName( sqlDeleteAll.check().toString().toLowerCase() )\n \t\t\t);\n \t\t}\n \t\tif ( loader != null ) {\n \t\t\tcollection.setLoaderName( loader.namedQuery() );\n \t\t}\n \n \t\tif (isMappedBy\n \t\t\t\t&& (property.isAnnotationPresent( JoinColumn.class )\n \t\t\t\t\t|| property.isAnnotationPresent( JoinColumns.class )\n \t\t\t\t\t|| propertyHolder.getJoinTable( property ) != null ) ) {\n \t\t\tString message = \"Associations marked as mappedBy must not define database mappings like @JoinTable or @JoinColumn: \";\n \t\t\tmessage += StringHelper.qualify( propertyHolder.getPath(), propertyName );\n \t\t\tthrow new AnnotationException( message );\n \t\t}\n \n \t\tcollection.setInverse( isMappedBy );\n \n \t\t//many to many may need some second pass informations\n \t\tif ( !oneToMany && isMappedBy ) {\n-\t\t\tmappings.addMappedBy( getCollectionType().getName(), mappedBy, propertyName );\n+\t\t\tbuildingContext.getMetadataCollector().addMappedBy( getCollectionType().getName(), mappedBy, propertyName );\n \t\t}\n \t\t//TODO reducce tableBinder != null and oneToMany\n \t\tXClass collectionType = getCollectionType();\n \t\tif ( inheritanceStatePerClass == null) throw new AssertionFailure( \"inheritanceStatePerClass not set\" );\n \t\tSecondPass sp = getSecondPass(\n \t\t\t\tfkJoinColumns,\n \t\t\t\tjoinColumns,\n \t\t\t\tinverseJoinColumns,\n \t\t\t\telementColumns,\n-\t\t\t\tmapKeyColumns, mapKeyManyToManyColumns, isEmbedded,\n-\t\t\t\tproperty, collectionType,\n-\t\t\t\tignoreNotFound, oneToMany,\n-\t\t\t\ttableBinder, mappings\n+\t\t\t\tmapKeyColumns,\n+\t\t\t\tmapKeyManyToManyColumns,\n+\t\t\t\tisEmbedded,\n+\t\t\t\tproperty,\n+\t\t\t\tcollectionType,\n+\t\t\t\tignoreNotFound,\n+\t\t\t\toneToMany,\n+\t\t\t\ttableBinder,\n+\t\t\t\tbuildingContext\n \t\t);\n \t\tif ( collectionType.isAnnotationPresent( Embeddable.class )\n \t\t\t\t|| property.isAnnotationPresent( ElementCollection.class ) //JPA 2\n \t\t\t\t) {\n \t\t\t// do it right away, otherwise @ManyToOne on composite element call addSecondPass\n \t\t\t// and raise a ConcurrentModificationException\n \t\t\t//sp.doSecondPass( CollectionHelper.EMPTY_MAP );\n-\t\t\tmappings.addSecondPass( sp, !isMappedBy );\n+\t\t\tbuildingContext.getMetadataCollector().addSecondPass( sp, !isMappedBy );\n \t\t}\n \t\telse {\n-\t\t\tmappings.addSecondPass( sp, !isMappedBy );\n+\t\t\tbuildingContext.getMetadataCollector().addSecondPass( sp, !isMappedBy );\n \t\t}\n \n-\t\tmappings.addCollection( collection );\n+\t\tbuildingContext.getMetadataCollector().addCollectionBinding( collection );\n \n \t\t//property building\n \t\tPropertyBinder binder = new PropertyBinder();\n \t\tbinder.setName( propertyName );\n \t\tbinder.setValue( collection );\n \t\tbinder.setCascade( cascadeStrategy );\n \t\tif ( cascadeStrategy != null && cascadeStrategy.indexOf( \"delete-orphan\" ) >= 0 ) {\n \t\t\tcollection.setOrphanDelete( true );\n \t\t}\n \t\tbinder.setAccessType( accessType );\n \t\tbinder.setProperty( property );\n \t\tbinder.setInsertable( insertable );\n \t\tbinder.setUpdatable( updatable );\n \t\tProperty prop = binder.makeProperty();\n \t\t//we don't care about the join stuffs because the column is on the association table.\n \t\tif (! declaringClassSet) throw new AssertionFailure( \"DeclaringClass is not set in CollectionBinder while binding\" );\n \t\tpropertyHolder.addProperty( prop, declaringClass );\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"bcd6185809ecf9202267134d646037e8acdd0939": {
			"type": "Ybodychange",
			"commitMessage": "HHH-4910 The collection cache is evicted if a related collection element is inserted, removed or updated\n\nHHH-4910 minor fixes\n\nHHH-4910 make this feature configurable\n",
			"commitDate": "2013-09-18, 10:26 AM",
			"commitName": "bcd6185809ecf9202267134d646037e8acdd0939",
			"commitAuthor": "Andy2003",
			"commitDateOld": "2013-09-06, 12:38 PM",
			"commitNameOld": "1f6daa67854e1fd6c464fe3d2a98bda1047b252d",
			"commitAuthorOld": "Steve Ebersole",
			"daysBetweenCommits": 11.91,
			"commitsBetweenForRepo": 51,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,148 +1,149 @@\n \tpublic void bind() {\n \t\tthis.collection = createCollection( propertyHolder.getPersistentClass() );\n \t\tString role = StringHelper.qualify( propertyHolder.getPath(), propertyName );\n \t\tLOG.debugf( \"Collection role: %s\", role );\n \t\tcollection.setRole( role );\n \t\tcollection.setNodeName( propertyName );\n+\t\tcollection.setMappedByProperty( mappedBy );\n \n \t\tif ( property.isAnnotationPresent( MapKeyColumn.class )\n \t\t\t&& mapKeyPropertyName != null ) {\n \t\t\tthrow new AnnotationException(\n \t\t\t\t\t\"Cannot mix @javax.persistence.MapKey and @MapKeyColumn or @org.hibernate.annotations.MapKey \"\n \t\t\t\t\t\t\t+ \"on the same collection: \" + StringHelper.qualify(\n \t\t\t\t\t\t\tpropertyHolder.getPath(), propertyName\n \t\t\t\t\t)\n \t\t\t);\n \t\t}\n \n \t\t// set explicit type information\n \t\tif ( explicitType != null ) {\n \t\t\tfinal TypeDef typeDef = mappings.getTypeDef( explicitType );\n \t\t\tif ( typeDef == null ) {\n \t\t\t\tcollection.setTypeName( explicitType );\n \t\t\t\tcollection.setTypeParameters( explicitTypeParameters );\n \t\t\t}\n \t\t\telse {\n \t\t\t\tcollection.setTypeName( typeDef.getTypeClass() );\n \t\t\t\tcollection.setTypeParameters( typeDef.getParameters() );\n \t\t\t}\n \t\t}\n \n \t\t//set laziness\n \t\tdefineFetchingStrategy();\n \t\tcollection.setBatchSize( batchSize );\n \n \t\tcollection.setMutable( !property.isAnnotationPresent( Immutable.class ) );\n \n \t\t//work on association\n \t\tboolean isMappedBy = !BinderHelper.isEmptyAnnotationValue( mappedBy );\n \n \t\tfinal OptimisticLock lockAnn = property.getAnnotation( OptimisticLock.class );\n \t\tfinal boolean includeInOptimisticLockChecks = ( lockAnn != null )\n \t\t\t\t? ! lockAnn.excluded()\n \t\t\t\t: ! isMappedBy;\n \t\tcollection.setOptimisticLocked( includeInOptimisticLockChecks );\n \n \t\tPersister persisterAnn = property.getAnnotation( Persister.class );\n \t\tif ( persisterAnn != null ) {\n \t\t\tcollection.setCollectionPersisterClass( persisterAnn.impl() );\n \t\t}\n \n \t\tapplySortingAndOrdering( collection );\n \n \t\t//set cache\n \t\tif ( StringHelper.isNotEmpty( cacheConcurrencyStrategy ) ) {\n \t\t\tcollection.setCacheConcurrencyStrategy( cacheConcurrencyStrategy );\n \t\t\tcollection.setCacheRegionName( cacheRegionName );\n \t\t}\n \n \t\t//SQL overriding\n \t\tSQLInsert sqlInsert = property.getAnnotation( SQLInsert.class );\n \t\tSQLUpdate sqlUpdate = property.getAnnotation( SQLUpdate.class );\n \t\tSQLDelete sqlDelete = property.getAnnotation( SQLDelete.class );\n \t\tSQLDeleteAll sqlDeleteAll = property.getAnnotation( SQLDeleteAll.class );\n \t\tLoader loader = property.getAnnotation( Loader.class );\n \t\tif ( sqlInsert != null ) {\n \t\t\tcollection.setCustomSQLInsert( sqlInsert.sql().trim(), sqlInsert.callable(),\n \t\t\t\t\tExecuteUpdateResultCheckStyle.fromExternalName( sqlInsert.check().toString().toLowerCase() )\n \t\t\t);\n \n \t\t}\n \t\tif ( sqlUpdate != null ) {\n \t\t\tcollection.setCustomSQLUpdate( sqlUpdate.sql(), sqlUpdate.callable(),\n \t\t\t\t\tExecuteUpdateResultCheckStyle.fromExternalName( sqlUpdate.check().toString().toLowerCase() )\n \t\t\t);\n \t\t}\n \t\tif ( sqlDelete != null ) {\n \t\t\tcollection.setCustomSQLDelete( sqlDelete.sql(), sqlDelete.callable(),\n \t\t\t\t\tExecuteUpdateResultCheckStyle.fromExternalName( sqlDelete.check().toString().toLowerCase() )\n \t\t\t);\n \t\t}\n \t\tif ( sqlDeleteAll != null ) {\n \t\t\tcollection.setCustomSQLDeleteAll( sqlDeleteAll.sql(), sqlDeleteAll.callable(),\n \t\t\t\t\tExecuteUpdateResultCheckStyle.fromExternalName( sqlDeleteAll.check().toString().toLowerCase() )\n \t\t\t);\n \t\t}\n \t\tif ( loader != null ) {\n \t\t\tcollection.setLoaderName( loader.namedQuery() );\n \t\t}\n \n \t\tif (isMappedBy\n \t\t\t\t&& (property.isAnnotationPresent( JoinColumn.class )\n \t\t\t\t\t|| property.isAnnotationPresent( JoinColumns.class )\n \t\t\t\t\t|| propertyHolder.getJoinTable( property ) != null ) ) {\n \t\t\tString message = \"Associations marked as mappedBy must not define database mappings like @JoinTable or @JoinColumn: \";\n \t\t\tmessage += StringHelper.qualify( propertyHolder.getPath(), propertyName );\n \t\t\tthrow new AnnotationException( message );\n \t\t}\n \n \t\tcollection.setInverse( isMappedBy );\n \n \t\t//many to many may need some second pass informations\n \t\tif ( !oneToMany && isMappedBy ) {\n \t\t\tmappings.addMappedBy( getCollectionType().getName(), mappedBy, propertyName );\n \t\t}\n \t\t//TODO reducce tableBinder != null and oneToMany\n \t\tXClass collectionType = getCollectionType();\n \t\tif ( inheritanceStatePerClass == null) throw new AssertionFailure( \"inheritanceStatePerClass not set\" );\n \t\tSecondPass sp = getSecondPass(\n \t\t\t\tfkJoinColumns,\n \t\t\t\tjoinColumns,\n \t\t\t\tinverseJoinColumns,\n \t\t\t\telementColumns,\n \t\t\t\tmapKeyColumns, mapKeyManyToManyColumns, isEmbedded,\n \t\t\t\tproperty, collectionType,\n \t\t\t\tignoreNotFound, oneToMany,\n \t\t\t\ttableBinder, mappings\n \t\t);\n \t\tif ( collectionType.isAnnotationPresent( Embeddable.class )\n \t\t\t\t|| property.isAnnotationPresent( ElementCollection.class ) //JPA 2\n \t\t\t\t) {\n \t\t\t// do it right away, otherwise @ManyToOne on composite element call addSecondPass\n \t\t\t// and raise a ConcurrentModificationException\n \t\t\t//sp.doSecondPass( CollectionHelper.EMPTY_MAP );\n \t\t\tmappings.addSecondPass( sp, !isMappedBy );\n \t\t}\n \t\telse {\n \t\t\tmappings.addSecondPass( sp, !isMappedBy );\n \t\t}\n \n \t\tmappings.addCollection( collection );\n \n \t\t//property building\n \t\tPropertyBinder binder = new PropertyBinder();\n \t\tbinder.setName( propertyName );\n \t\tbinder.setValue( collection );\n \t\tbinder.setCascade( cascadeStrategy );\n \t\tif ( cascadeStrategy != null && cascadeStrategy.indexOf( \"delete-orphan\" ) >= 0 ) {\n \t\t\tcollection.setOrphanDelete( true );\n \t\t}\n \t\tbinder.setAccessType( accessType );\n \t\tbinder.setProperty( property );\n \t\tbinder.setInsertable( insertable );\n \t\tbinder.setUpdatable( updatable );\n \t\tProperty prop = binder.makeProperty();\n \t\t//we don't care about the join stuffs because the column is on the association table.\n \t\tif (! declaringClassSet) throw new AssertionFailure( \"DeclaringClass is not set in CollectionBinder while binding\" );\n \t\tpropertyHolder.addProperty( prop, declaringClass );\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"33640ae2bdd37a0102e21f5a3ff8a47f0d6361b5": {
			"type": "Ybodychange",
			"commitMessage": "HHH-8164 - Deprecate @Sort in favor of @SortNatural and @SortComparator\n",
			"commitDate": "2013-04-10, 3:25 PM",
			"commitName": "33640ae2bdd37a0102e21f5a3ff8a47f0d6361b5",
			"commitAuthor": "Steve Ebersole",
			"commitDateOld": "2012-10-29, 9:37 AM",
			"commitNameOld": "eae079d283683497d50861c78d0d84b765255105",
			"commitAuthorOld": "brmeyer",
			"daysBetweenCommits": 163.24,
			"commitsBetweenForRepo": 348,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,182 +1,148 @@\n \tpublic void bind() {\n \t\tthis.collection = createCollection( propertyHolder.getPersistentClass() );\n \t\tString role = StringHelper.qualify( propertyHolder.getPath(), propertyName );\n \t\tLOG.debugf( \"Collection role: %s\", role );\n \t\tcollection.setRole( role );\n \t\tcollection.setNodeName( propertyName );\n \n \t\tif ( property.isAnnotationPresent( MapKeyColumn.class )\n \t\t\t&& mapKeyPropertyName != null ) {\n \t\t\tthrow new AnnotationException(\n \t\t\t\t\t\"Cannot mix @javax.persistence.MapKey and @MapKeyColumn or @org.hibernate.annotations.MapKey \"\n \t\t\t\t\t\t\t+ \"on the same collection: \" + StringHelper.qualify(\n \t\t\t\t\t\t\tpropertyHolder.getPath(), propertyName\n \t\t\t\t\t)\n \t\t\t);\n \t\t}\n \n \t\t// set explicit type information\n \t\tif ( explicitType != null ) {\n \t\t\tfinal TypeDef typeDef = mappings.getTypeDef( explicitType );\n \t\t\tif ( typeDef == null ) {\n \t\t\t\tcollection.setTypeName( explicitType );\n \t\t\t\tcollection.setTypeParameters( explicitTypeParameters );\n \t\t\t}\n \t\t\telse {\n \t\t\t\tcollection.setTypeName( typeDef.getTypeClass() );\n \t\t\t\tcollection.setTypeParameters( typeDef.getParameters() );\n \t\t\t}\n \t\t}\n \n \t\t//set laziness\n \t\tdefineFetchingStrategy();\n \t\tcollection.setBatchSize( batchSize );\n-\t\tif ( orderBy != null && hqlOrderBy != null ) {\n-\t\t\tthrow new AnnotationException(\n-\t\t\t\t\t\"Cannot use sql order by clause in conjunction of EJB3 order by clause: \" + safeCollectionRole()\n-\t\t\t);\n-\t\t}\n \n \t\tcollection.setMutable( !property.isAnnotationPresent( Immutable.class ) );\n \n \t\t//work on association\n \t\tboolean isMappedBy = !BinderHelper.isEmptyAnnotationValue( mappedBy );\n \n \t\tfinal OptimisticLock lockAnn = property.getAnnotation( OptimisticLock.class );\n \t\tfinal boolean includeInOptimisticLockChecks = ( lockAnn != null )\n \t\t\t\t? ! lockAnn.excluded()\n \t\t\t\t: ! isMappedBy;\n \t\tcollection.setOptimisticLocked( includeInOptimisticLockChecks );\n \n \t\tPersister persisterAnn = property.getAnnotation( Persister.class );\n \t\tif ( persisterAnn != null ) {\n \t\t\tcollection.setCollectionPersisterClass( persisterAnn.impl() );\n \t\t}\n \n-\t\t// set ordering\n-\t\tif ( orderBy != null ) collection.setOrderBy( orderBy );\n-\t\tif ( isSorted ) {\n-\t\t\tcollection.setSorted( true );\n-\t\t\tif ( comparator != null ) {\n-\t\t\t\ttry {\n-\t\t\t\t\tcollection.setComparator( (Comparator) comparator.newInstance() );\n-\t\t\t\t}\n-\t\t\t\tcatch (ClassCastException e) {\n-\t\t\t\t\tthrow new AnnotationException(\n-\t\t\t\t\t\t\t\"Comparator not implementing java.util.Comparator class: \"\n-\t\t\t\t\t\t\t\t\t+ comparator.getName() + \"(\" + safeCollectionRole() + \")\"\n-\t\t\t\t\t);\n-\t\t\t\t}\n-\t\t\t\tcatch (Exception e) {\n-\t\t\t\t\tthrow new AnnotationException(\n-\t\t\t\t\t\t\t\"Could not instantiate comparator class: \"\n-\t\t\t\t\t\t\t\t\t+ comparator.getName() + \"(\" + safeCollectionRole() + \")\"\n-\t\t\t\t\t);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t\telse {\n-\t\t\tif ( hasToBeSorted ) {\n-\t\t\t\tthrow new AnnotationException(\n-\t\t\t\t\t\t\"A sorted collection has to define @Sort: \"\n-\t\t\t\t\t\t\t\t+ safeCollectionRole()\n-\t\t\t\t);\n-\t\t\t}\n-\t\t}\n+\t\tapplySortingAndOrdering( collection );\n \n \t\t//set cache\n \t\tif ( StringHelper.isNotEmpty( cacheConcurrencyStrategy ) ) {\n \t\t\tcollection.setCacheConcurrencyStrategy( cacheConcurrencyStrategy );\n \t\t\tcollection.setCacheRegionName( cacheRegionName );\n \t\t}\n \n \t\t//SQL overriding\n \t\tSQLInsert sqlInsert = property.getAnnotation( SQLInsert.class );\n \t\tSQLUpdate sqlUpdate = property.getAnnotation( SQLUpdate.class );\n \t\tSQLDelete sqlDelete = property.getAnnotation( SQLDelete.class );\n \t\tSQLDeleteAll sqlDeleteAll = property.getAnnotation( SQLDeleteAll.class );\n \t\tLoader loader = property.getAnnotation( Loader.class );\n \t\tif ( sqlInsert != null ) {\n \t\t\tcollection.setCustomSQLInsert( sqlInsert.sql().trim(), sqlInsert.callable(),\n \t\t\t\t\tExecuteUpdateResultCheckStyle.fromExternalName( sqlInsert.check().toString().toLowerCase() )\n \t\t\t);\n \n \t\t}\n \t\tif ( sqlUpdate != null ) {\n \t\t\tcollection.setCustomSQLUpdate( sqlUpdate.sql(), sqlUpdate.callable(),\n \t\t\t\t\tExecuteUpdateResultCheckStyle.fromExternalName( sqlUpdate.check().toString().toLowerCase() )\n \t\t\t);\n \t\t}\n \t\tif ( sqlDelete != null ) {\n \t\t\tcollection.setCustomSQLDelete( sqlDelete.sql(), sqlDelete.callable(),\n \t\t\t\t\tExecuteUpdateResultCheckStyle.fromExternalName( sqlDelete.check().toString().toLowerCase() )\n \t\t\t);\n \t\t}\n \t\tif ( sqlDeleteAll != null ) {\n \t\t\tcollection.setCustomSQLDeleteAll( sqlDeleteAll.sql(), sqlDeleteAll.callable(),\n \t\t\t\t\tExecuteUpdateResultCheckStyle.fromExternalName( sqlDeleteAll.check().toString().toLowerCase() )\n \t\t\t);\n \t\t}\n \t\tif ( loader != null ) {\n \t\t\tcollection.setLoaderName( loader.namedQuery() );\n \t\t}\n \n \t\tif (isMappedBy\n \t\t\t\t&& (property.isAnnotationPresent( JoinColumn.class )\n \t\t\t\t\t|| property.isAnnotationPresent( JoinColumns.class )\n \t\t\t\t\t|| propertyHolder.getJoinTable( property ) != null ) ) {\n \t\t\tString message = \"Associations marked as mappedBy must not define database mappings like @JoinTable or @JoinColumn: \";\n \t\t\tmessage += StringHelper.qualify( propertyHolder.getPath(), propertyName );\n \t\t\tthrow new AnnotationException( message );\n \t\t}\n \n \t\tcollection.setInverse( isMappedBy );\n \n \t\t//many to many may need some second pass informations\n \t\tif ( !oneToMany && isMappedBy ) {\n \t\t\tmappings.addMappedBy( getCollectionType().getName(), mappedBy, propertyName );\n \t\t}\n \t\t//TODO reducce tableBinder != null and oneToMany\n \t\tXClass collectionType = getCollectionType();\n \t\tif ( inheritanceStatePerClass == null) throw new AssertionFailure( \"inheritanceStatePerClass not set\" );\n \t\tSecondPass sp = getSecondPass(\n \t\t\t\tfkJoinColumns,\n \t\t\t\tjoinColumns,\n \t\t\t\tinverseJoinColumns,\n \t\t\t\telementColumns,\n \t\t\t\tmapKeyColumns, mapKeyManyToManyColumns, isEmbedded,\n \t\t\t\tproperty, collectionType,\n \t\t\t\tignoreNotFound, oneToMany,\n \t\t\t\ttableBinder, mappings\n \t\t);\n \t\tif ( collectionType.isAnnotationPresent( Embeddable.class )\n \t\t\t\t|| property.isAnnotationPresent( ElementCollection.class ) //JPA 2\n \t\t\t\t) {\n \t\t\t// do it right away, otherwise @ManyToOne on composite element call addSecondPass\n \t\t\t// and raise a ConcurrentModificationException\n \t\t\t//sp.doSecondPass( CollectionHelper.EMPTY_MAP );\n \t\t\tmappings.addSecondPass( sp, !isMappedBy );\n \t\t}\n \t\telse {\n \t\t\tmappings.addSecondPass( sp, !isMappedBy );\n \t\t}\n \n \t\tmappings.addCollection( collection );\n \n \t\t//property building\n \t\tPropertyBinder binder = new PropertyBinder();\n \t\tbinder.setName( propertyName );\n \t\tbinder.setValue( collection );\n \t\tbinder.setCascade( cascadeStrategy );\n \t\tif ( cascadeStrategy != null && cascadeStrategy.indexOf( \"delete-orphan\" ) >= 0 ) {\n \t\t\tcollection.setOrphanDelete( true );\n \t\t}\n \t\tbinder.setAccessType( accessType );\n \t\tbinder.setProperty( property );\n \t\tbinder.setInsertable( insertable );\n \t\tbinder.setUpdatable( updatable );\n \t\tProperty prop = binder.makeProperty();\n \t\t//we don't care about the join stuffs because the column is on the association table.\n \t\tif (! declaringClassSet) throw new AssertionFailure( \"DeclaringClass is not set in CollectionBinder while binding\" );\n \t\tpropertyHolder.addProperty( prop, declaringClass );\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"05c36793730fb1b4e3d08c731998c7649c9b34ef": {
			"type": "Ybodychange",
			"commitMessage": "HHH-7138 - Hibernate implements JPA @OneToMany collection versioning incorrectly\n",
			"commitDate": "2012-03-07, 7:40 PM",
			"commitName": "05c36793730fb1b4e3d08c731998c7649c9b34ef",
			"commitAuthor": "Steve Ebersole",
			"commitDateOld": "2012-03-05, 9:24 AM",
			"commitNameOld": "36c135ab6619cc56af293060c0216e924e16b187",
			"commitAuthorOld": "Steve Ebersole",
			"daysBetweenCommits": 2.43,
			"commitsBetweenForRepo": 8,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,178 +1,182 @@\n \tpublic void bind() {\n \t\tthis.collection = createCollection( propertyHolder.getPersistentClass() );\n \t\tString role = StringHelper.qualify( propertyHolder.getPath(), propertyName );\n \t\tLOG.debugf( \"Collection role: %s\", role );\n \t\tcollection.setRole( role );\n \t\tcollection.setNodeName( propertyName );\n \n \t\tif ( property.isAnnotationPresent( MapKeyColumn.class )\n \t\t\t&& mapKeyPropertyName != null ) {\n \t\t\tthrow new AnnotationException(\n \t\t\t\t\t\"Cannot mix @javax.persistence.MapKey and @MapKeyColumn or @org.hibernate.annotations.MapKey \"\n \t\t\t\t\t\t\t+ \"on the same collection: \" + StringHelper.qualify(\n \t\t\t\t\t\t\tpropertyHolder.getPath(), propertyName\n \t\t\t\t\t)\n \t\t\t);\n \t\t}\n \n \t\t// set explicit type information\n \t\tif ( explicitType != null ) {\n \t\t\tfinal TypeDef typeDef = mappings.getTypeDef( explicitType );\n \t\t\tif ( typeDef == null ) {\n \t\t\t\tcollection.setTypeName( explicitType );\n \t\t\t\tcollection.setTypeParameters( explicitTypeParameters );\n \t\t\t}\n \t\t\telse {\n \t\t\t\tcollection.setTypeName( typeDef.getTypeClass() );\n \t\t\t\tcollection.setTypeParameters( typeDef.getParameters() );\n \t\t\t}\n \t\t}\n \n \t\t//set laziness\n \t\tdefineFetchingStrategy();\n \t\tcollection.setBatchSize( batchSize );\n \t\tif ( orderBy != null && hqlOrderBy != null ) {\n \t\t\tthrow new AnnotationException(\n \t\t\t\t\t\"Cannot use sql order by clause in conjunction of EJB3 order by clause: \" + safeCollectionRole()\n \t\t\t);\n \t\t}\n \n \t\tcollection.setMutable( !property.isAnnotationPresent( Immutable.class ) );\n-\t\tOptimisticLock lockAnn = property.getAnnotation( OptimisticLock.class );\n-\t\tif ( lockAnn != null ) collection.setOptimisticLocked( !lockAnn.excluded() );\n+\n+\t\t//work on association\n+\t\tboolean isMappedBy = !BinderHelper.isEmptyAnnotationValue( mappedBy );\n+\n+\t\tfinal OptimisticLock lockAnn = property.getAnnotation( OptimisticLock.class );\n+\t\tfinal boolean includeInOptimisticLockChecks = ( lockAnn != null )\n+\t\t\t\t? ! lockAnn.excluded()\n+\t\t\t\t: ! isMappedBy;\n+\t\tcollection.setOptimisticLocked( includeInOptimisticLockChecks );\n \n \t\tPersister persisterAnn = property.getAnnotation( Persister.class );\n \t\tif ( persisterAnn != null ) {\n \t\t\tcollection.setCollectionPersisterClass( persisterAnn.impl() );\n \t\t}\n \n \t\t// set ordering\n \t\tif ( orderBy != null ) collection.setOrderBy( orderBy );\n \t\tif ( isSorted ) {\n \t\t\tcollection.setSorted( true );\n \t\t\tif ( comparator != null ) {\n \t\t\t\ttry {\n \t\t\t\t\tcollection.setComparator( (Comparator) comparator.newInstance() );\n \t\t\t\t}\n \t\t\t\tcatch (ClassCastException e) {\n \t\t\t\t\tthrow new AnnotationException(\n \t\t\t\t\t\t\t\"Comparator not implementing java.util.Comparator class: \"\n \t\t\t\t\t\t\t\t\t+ comparator.getName() + \"(\" + safeCollectionRole() + \")\"\n \t\t\t\t\t);\n \t\t\t\t}\n \t\t\t\tcatch (Exception e) {\n \t\t\t\t\tthrow new AnnotationException(\n \t\t\t\t\t\t\t\"Could not instantiate comparator class: \"\n \t\t\t\t\t\t\t\t\t+ comparator.getName() + \"(\" + safeCollectionRole() + \")\"\n \t\t\t\t\t);\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\telse {\n \t\t\tif ( hasToBeSorted ) {\n \t\t\t\tthrow new AnnotationException(\n \t\t\t\t\t\t\"A sorted collection has to define @Sort: \"\n \t\t\t\t\t\t\t\t+ safeCollectionRole()\n \t\t\t\t);\n \t\t\t}\n \t\t}\n \n \t\t//set cache\n \t\tif ( StringHelper.isNotEmpty( cacheConcurrencyStrategy ) ) {\n \t\t\tcollection.setCacheConcurrencyStrategy( cacheConcurrencyStrategy );\n \t\t\tcollection.setCacheRegionName( cacheRegionName );\n \t\t}\n \n \t\t//SQL overriding\n \t\tSQLInsert sqlInsert = property.getAnnotation( SQLInsert.class );\n \t\tSQLUpdate sqlUpdate = property.getAnnotation( SQLUpdate.class );\n \t\tSQLDelete sqlDelete = property.getAnnotation( SQLDelete.class );\n \t\tSQLDeleteAll sqlDeleteAll = property.getAnnotation( SQLDeleteAll.class );\n \t\tLoader loader = property.getAnnotation( Loader.class );\n \t\tif ( sqlInsert != null ) {\n \t\t\tcollection.setCustomSQLInsert( sqlInsert.sql().trim(), sqlInsert.callable(),\n \t\t\t\t\tExecuteUpdateResultCheckStyle.fromExternalName( sqlInsert.check().toString().toLowerCase() )\n \t\t\t);\n \n \t\t}\n \t\tif ( sqlUpdate != null ) {\n \t\t\tcollection.setCustomSQLUpdate( sqlUpdate.sql(), sqlUpdate.callable(),\n \t\t\t\t\tExecuteUpdateResultCheckStyle.fromExternalName( sqlUpdate.check().toString().toLowerCase() )\n \t\t\t);\n \t\t}\n \t\tif ( sqlDelete != null ) {\n \t\t\tcollection.setCustomSQLDelete( sqlDelete.sql(), sqlDelete.callable(),\n \t\t\t\t\tExecuteUpdateResultCheckStyle.fromExternalName( sqlDelete.check().toString().toLowerCase() )\n \t\t\t);\n \t\t}\n \t\tif ( sqlDeleteAll != null ) {\n \t\t\tcollection.setCustomSQLDeleteAll( sqlDeleteAll.sql(), sqlDeleteAll.callable(),\n \t\t\t\t\tExecuteUpdateResultCheckStyle.fromExternalName( sqlDeleteAll.check().toString().toLowerCase() )\n \t\t\t);\n \t\t}\n \t\tif ( loader != null ) {\n \t\t\tcollection.setLoaderName( loader.namedQuery() );\n \t\t}\n \n-\t\t//work on association\n-\t\tboolean isMappedBy = !BinderHelper.isEmptyAnnotationValue( mappedBy );\n-\n \t\tif (isMappedBy\n \t\t\t\t&& (property.isAnnotationPresent( JoinColumn.class )\n \t\t\t\t\t|| property.isAnnotationPresent( JoinColumns.class )\n \t\t\t\t\t|| propertyHolder.getJoinTable( property ) != null ) ) {\n \t\t\tString message = \"Associations marked as mappedBy must not define database mappings like @JoinTable or @JoinColumn: \";\n \t\t\tmessage += StringHelper.qualify( propertyHolder.getPath(), propertyName );\n \t\t\tthrow new AnnotationException( message );\n \t\t}\n \n \t\tcollection.setInverse( isMappedBy );\n \n \t\t//many to many may need some second pass informations\n \t\tif ( !oneToMany && isMappedBy ) {\n \t\t\tmappings.addMappedBy( getCollectionType().getName(), mappedBy, propertyName );\n \t\t}\n \t\t//TODO reducce tableBinder != null and oneToMany\n \t\tXClass collectionType = getCollectionType();\n \t\tif ( inheritanceStatePerClass == null) throw new AssertionFailure( \"inheritanceStatePerClass not set\" );\n \t\tSecondPass sp = getSecondPass(\n \t\t\t\tfkJoinColumns,\n \t\t\t\tjoinColumns,\n \t\t\t\tinverseJoinColumns,\n \t\t\t\telementColumns,\n \t\t\t\tmapKeyColumns, mapKeyManyToManyColumns, isEmbedded,\n \t\t\t\tproperty, collectionType,\n \t\t\t\tignoreNotFound, oneToMany,\n \t\t\t\ttableBinder, mappings\n \t\t);\n \t\tif ( collectionType.isAnnotationPresent( Embeddable.class )\n \t\t\t\t|| property.isAnnotationPresent( ElementCollection.class ) //JPA 2\n \t\t\t\t) {\n \t\t\t// do it right away, otherwise @ManyToOne on composite element call addSecondPass\n \t\t\t// and raise a ConcurrentModificationException\n \t\t\t//sp.doSecondPass( CollectionHelper.EMPTY_MAP );\n \t\t\tmappings.addSecondPass( sp, !isMappedBy );\n \t\t}\n \t\telse {\n \t\t\tmappings.addSecondPass( sp, !isMappedBy );\n \t\t}\n \n \t\tmappings.addCollection( collection );\n \n \t\t//property building\n \t\tPropertyBinder binder = new PropertyBinder();\n \t\tbinder.setName( propertyName );\n \t\tbinder.setValue( collection );\n \t\tbinder.setCascade( cascadeStrategy );\n \t\tif ( cascadeStrategy != null && cascadeStrategy.indexOf( \"delete-orphan\" ) >= 0 ) {\n \t\t\tcollection.setOrphanDelete( true );\n \t\t}\n \t\tbinder.setAccessType( accessType );\n \t\tbinder.setProperty( property );\n \t\tbinder.setInsertable( insertable );\n \t\tbinder.setUpdatable( updatable );\n \t\tProperty prop = binder.makeProperty();\n \t\t//we don't care about the join stuffs because the column is on the association table.\n \t\tif (! declaringClassSet) throw new AssertionFailure( \"DeclaringClass is not set in CollectionBinder while binding\" );\n \t\tpropertyHolder.addProperty( prop, declaringClass );\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"d7d9f0dfb207cb8238ea2962fee81708942fa368": {
			"type": "Ybodychange",
			"commitMessage": "HHH-4417 - Add annotation support for UserCollectionType\n",
			"commitDate": "2012-03-02, 12:17 PM",
			"commitName": "d7d9f0dfb207cb8238ea2962fee81708942fa368",
			"commitAuthor": "Steve Ebersole",
			"commitDateOld": "2011-10-26, 4:24 PM",
			"commitNameOld": "129c0f13482b99e2705f0e234b6bc0572a95c271",
			"commitAuthorOld": "Sanne Grinovero",
			"daysBetweenCommits": 127.87,
			"commitsBetweenForRepo": 349,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,165 +1,178 @@\n \tpublic void bind() {\n \t\tthis.collection = createCollection( propertyHolder.getPersistentClass() );\n \t\tString role = StringHelper.qualify( propertyHolder.getPath(), propertyName );\n \t\tLOG.debugf( \"Collection role: %s\", role );\n \t\tcollection.setRole( role );\n \t\tcollection.setNodeName( propertyName );\n \n \t\tif ( property.isAnnotationPresent( MapKeyColumn.class )\n \t\t\t&& mapKeyPropertyName != null ) {\n \t\t\tthrow new AnnotationException(\n \t\t\t\t\t\"Cannot mix @javax.persistence.MapKey and @MapKeyColumn or @org.hibernate.annotations.MapKey \"\n \t\t\t\t\t\t\t+ \"on the same collection: \" + StringHelper.qualify(\n \t\t\t\t\t\t\tpropertyHolder.getPath(), propertyName\n \t\t\t\t\t)\n \t\t\t);\n \t\t}\n \n+\t\t// set explicit type information\n+\t\tif ( explicitType != null ) {\n+\t\t\tfinal TypeDef typeDef = mappings.getTypeDef( explicitType );\n+\t\t\tif ( typeDef == null ) {\n+\t\t\t\tcollection.setTypeName( explicitType );\n+\t\t\t\tcollection.setTypeParameters( explicitTypeParameters );\n+\t\t\t}\n+\t\t\telse {\n+\t\t\t\tcollection.setTypeName( typeDef.getTypeClass() );\n+\t\t\t\tcollection.setTypeParameters( typeDef.getParameters() );\n+\t\t\t}\n+\t\t}\n+\n \t\t//set laziness\n \t\tdefineFetchingStrategy();\n \t\tcollection.setBatchSize( batchSize );\n \t\tif ( orderBy != null && hqlOrderBy != null ) {\n \t\t\tthrow new AnnotationException(\n \t\t\t\t\t\"Cannot use sql order by clause in conjunction of EJB3 order by clause: \" + safeCollectionRole()\n \t\t\t);\n \t\t}\n \n \t\tcollection.setMutable( !property.isAnnotationPresent( Immutable.class ) );\n \t\tOptimisticLock lockAnn = property.getAnnotation( OptimisticLock.class );\n \t\tif ( lockAnn != null ) collection.setOptimisticLocked( !lockAnn.excluded() );\n \n \t\tPersister persisterAnn = property.getAnnotation( Persister.class );\n \t\tif ( persisterAnn != null ) {\n \t\t\tcollection.setCollectionPersisterClass( persisterAnn.impl() );\n \t\t}\n \n \t\t// set ordering\n \t\tif ( orderBy != null ) collection.setOrderBy( orderBy );\n \t\tif ( isSorted ) {\n \t\t\tcollection.setSorted( true );\n \t\t\tif ( comparator != null ) {\n \t\t\t\ttry {\n \t\t\t\t\tcollection.setComparator( (Comparator) comparator.newInstance() );\n \t\t\t\t}\n \t\t\t\tcatch (ClassCastException e) {\n \t\t\t\t\tthrow new AnnotationException(\n \t\t\t\t\t\t\t\"Comparator not implementing java.util.Comparator class: \"\n \t\t\t\t\t\t\t\t\t+ comparator.getName() + \"(\" + safeCollectionRole() + \")\"\n \t\t\t\t\t);\n \t\t\t\t}\n \t\t\t\tcatch (Exception e) {\n \t\t\t\t\tthrow new AnnotationException(\n \t\t\t\t\t\t\t\"Could not instantiate comparator class: \"\n \t\t\t\t\t\t\t\t\t+ comparator.getName() + \"(\" + safeCollectionRole() + \")\"\n \t\t\t\t\t);\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\telse {\n \t\t\tif ( hasToBeSorted ) {\n \t\t\t\tthrow new AnnotationException(\n \t\t\t\t\t\t\"A sorted collection has to define @Sort: \"\n \t\t\t\t\t\t\t\t+ safeCollectionRole()\n \t\t\t\t);\n \t\t\t}\n \t\t}\n \n \t\t//set cache\n \t\tif ( StringHelper.isNotEmpty( cacheConcurrencyStrategy ) ) {\n \t\t\tcollection.setCacheConcurrencyStrategy( cacheConcurrencyStrategy );\n \t\t\tcollection.setCacheRegionName( cacheRegionName );\n \t\t}\n \n \t\t//SQL overriding\n \t\tSQLInsert sqlInsert = property.getAnnotation( SQLInsert.class );\n \t\tSQLUpdate sqlUpdate = property.getAnnotation( SQLUpdate.class );\n \t\tSQLDelete sqlDelete = property.getAnnotation( SQLDelete.class );\n \t\tSQLDeleteAll sqlDeleteAll = property.getAnnotation( SQLDeleteAll.class );\n \t\tLoader loader = property.getAnnotation( Loader.class );\n \t\tif ( sqlInsert != null ) {\n \t\t\tcollection.setCustomSQLInsert( sqlInsert.sql().trim(), sqlInsert.callable(),\n \t\t\t\t\tExecuteUpdateResultCheckStyle.fromExternalName( sqlInsert.check().toString().toLowerCase() )\n \t\t\t);\n \n \t\t}\n \t\tif ( sqlUpdate != null ) {\n \t\t\tcollection.setCustomSQLUpdate( sqlUpdate.sql(), sqlUpdate.callable(),\n \t\t\t\t\tExecuteUpdateResultCheckStyle.fromExternalName( sqlUpdate.check().toString().toLowerCase() )\n \t\t\t);\n \t\t}\n \t\tif ( sqlDelete != null ) {\n \t\t\tcollection.setCustomSQLDelete( sqlDelete.sql(), sqlDelete.callable(),\n \t\t\t\t\tExecuteUpdateResultCheckStyle.fromExternalName( sqlDelete.check().toString().toLowerCase() )\n \t\t\t);\n \t\t}\n \t\tif ( sqlDeleteAll != null ) {\n \t\t\tcollection.setCustomSQLDeleteAll( sqlDeleteAll.sql(), sqlDeleteAll.callable(),\n \t\t\t\t\tExecuteUpdateResultCheckStyle.fromExternalName( sqlDeleteAll.check().toString().toLowerCase() )\n \t\t\t);\n \t\t}\n \t\tif ( loader != null ) {\n \t\t\tcollection.setLoaderName( loader.namedQuery() );\n \t\t}\n \n \t\t//work on association\n \t\tboolean isMappedBy = !BinderHelper.isEmptyAnnotationValue( mappedBy );\n \n \t\tif (isMappedBy\n \t\t\t\t&& (property.isAnnotationPresent( JoinColumn.class )\n \t\t\t\t\t|| property.isAnnotationPresent( JoinColumns.class )\n \t\t\t\t\t|| propertyHolder.getJoinTable( property ) != null ) ) {\n \t\t\tString message = \"Associations marked as mappedBy must not define database mappings like @JoinTable or @JoinColumn: \";\n \t\t\tmessage += StringHelper.qualify( propertyHolder.getPath(), propertyName );\n \t\t\tthrow new AnnotationException( message );\n \t\t}\n \n \t\tcollection.setInverse( isMappedBy );\n \n \t\t//many to many may need some second pass informations\n \t\tif ( !oneToMany && isMappedBy ) {\n \t\t\tmappings.addMappedBy( getCollectionType().getName(), mappedBy, propertyName );\n \t\t}\n \t\t//TODO reducce tableBinder != null and oneToMany\n \t\tXClass collectionType = getCollectionType();\n \t\tif ( inheritanceStatePerClass == null) throw new AssertionFailure( \"inheritanceStatePerClass not set\" );\n \t\tSecondPass sp = getSecondPass(\n \t\t\t\tfkJoinColumns,\n \t\t\t\tjoinColumns,\n \t\t\t\tinverseJoinColumns,\n \t\t\t\telementColumns,\n \t\t\t\tmapKeyColumns, mapKeyManyToManyColumns, isEmbedded,\n \t\t\t\tproperty, collectionType,\n \t\t\t\tignoreNotFound, oneToMany,\n \t\t\t\ttableBinder, mappings\n \t\t);\n \t\tif ( collectionType.isAnnotationPresent( Embeddable.class )\n \t\t\t\t|| property.isAnnotationPresent( ElementCollection.class ) //JPA 2\n \t\t\t\t) {\n \t\t\t// do it right away, otherwise @ManyToOne on composite element call addSecondPass\n \t\t\t// and raise a ConcurrentModificationException\n \t\t\t//sp.doSecondPass( CollectionHelper.EMPTY_MAP );\n \t\t\tmappings.addSecondPass( sp, !isMappedBy );\n \t\t}\n \t\telse {\n \t\t\tmappings.addSecondPass( sp, !isMappedBy );\n \t\t}\n \n \t\tmappings.addCollection( collection );\n \n \t\t//property building\n \t\tPropertyBinder binder = new PropertyBinder();\n \t\tbinder.setName( propertyName );\n \t\tbinder.setValue( collection );\n \t\tbinder.setCascade( cascadeStrategy );\n \t\tif ( cascadeStrategy != null && cascadeStrategy.indexOf( \"delete-orphan\" ) >= 0 ) {\n \t\t\tcollection.setOrphanDelete( true );\n \t\t}\n \t\tbinder.setAccessType( accessType );\n \t\tbinder.setProperty( property );\n \t\tbinder.setInsertable( insertable );\n \t\tbinder.setUpdatable( updatable );\n \t\tProperty prop = binder.makeProperty();\n \t\t//we don't care about the join stuffs because the column is on the association table.\n \t\tif (! declaringClassSet) throw new AssertionFailure( \"DeclaringClass is not set in CollectionBinder while binding\" );\n \t\tpropertyHolder.addProperty( prop, declaringClass );\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"ffb14b28b72c67dc2d658bfeb89545ca16eb3399": {
			"type": "Ybodychange",
			"commitMessage": "HHH-6368 remove deprecated hibernate annotations\n",
			"commitDate": "2011-06-28, 2:29 AM",
			"commitName": "ffb14b28b72c67dc2d658bfeb89545ca16eb3399",
			"commitAuthor": "Strong Liu",
			"commitDateOld": "2011-05-04, 4:15 PM",
			"commitNameOld": "fb44ad936d8d54d311ecbaea1633683a8d809d04",
			"commitAuthorOld": "Steve Ebersole",
			"daysBetweenCommits": 54.43,
			"commitsBetweenForRepo": 238,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,167 +1,165 @@\n \tpublic void bind() {\n \t\tthis.collection = createCollection( propertyHolder.getPersistentClass() );\n         String role = StringHelper.qualify(propertyHolder.getPath(), propertyName);\n         LOG.debugf(\"Collection role: %s\", role);\n         collection.setRole(role);\n \t\tcollection.setNodeName( propertyName );\n \n-\t\tif ( (property.isAnnotationPresent( org.hibernate.annotations.MapKey.class )\n-\t\t\t\t|| property.isAnnotationPresent( MapKeyColumn.class ) )\n+\t\tif ( property.isAnnotationPresent( MapKeyColumn.class )\n \t\t\t&& mapKeyPropertyName != null ) {\n \t\t\tthrow new AnnotationException(\n \t\t\t\t\t\"Cannot mix @javax.persistence.MapKey and @MapKeyColumn or @org.hibernate.annotations.MapKey \"\n \t\t\t\t\t\t\t+ \"on the same collection: \" + StringHelper.qualify(\n \t\t\t\t\t\t\tpropertyHolder.getPath(), propertyName\n \t\t\t\t\t)\n \t\t\t);\n \t\t}\n \n \t\t//set laziness\n \t\tdefineFetchingStrategy();\n \t\tcollection.setBatchSize( batchSize );\n \t\tif ( orderBy != null && hqlOrderBy != null ) {\n \t\t\tthrow new AnnotationException(\n \t\t\t\t\t\"Cannot use sql order by clause in conjunction of EJB3 order by clause: \" + safeCollectionRole()\n \t\t\t);\n \t\t}\n \n \t\tcollection.setMutable( !property.isAnnotationPresent( Immutable.class ) );\n \t\tOptimisticLock lockAnn = property.getAnnotation( OptimisticLock.class );\n \t\tif ( lockAnn != null ) collection.setOptimisticLocked( !lockAnn.excluded() );\n \n \t\tPersister persisterAnn = property.getAnnotation( Persister.class );\n \t\tif ( persisterAnn != null ) {\n \t\t\tcollection.setCollectionPersisterClass( persisterAnn.impl() );\n \t\t}\n \n \t\t// set ordering\n \t\tif ( orderBy != null ) collection.setOrderBy( orderBy );\n \t\tif ( isSorted ) {\n \t\t\tcollection.setSorted( true );\n \t\t\tif ( comparator != null ) {\n \t\t\t\ttry {\n \t\t\t\t\tcollection.setComparator( (Comparator) comparator.newInstance() );\n \t\t\t\t}\n \t\t\t\tcatch (ClassCastException e) {\n \t\t\t\t\tthrow new AnnotationException(\n \t\t\t\t\t\t\t\"Comparator not implementing java.util.Comparator class: \"\n \t\t\t\t\t\t\t\t\t+ comparator.getName() + \"(\" + safeCollectionRole() + \")\"\n \t\t\t\t\t);\n \t\t\t\t}\n \t\t\t\tcatch (Exception e) {\n \t\t\t\t\tthrow new AnnotationException(\n \t\t\t\t\t\t\t\"Could not instantiate comparator class: \"\n \t\t\t\t\t\t\t\t\t+ comparator.getName() + \"(\" + safeCollectionRole() + \")\"\n \t\t\t\t\t);\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\telse {\n \t\t\tif ( hasToBeSorted ) {\n \t\t\t\tthrow new AnnotationException(\n \t\t\t\t\t\t\"A sorted collection has to define @Sort: \"\n \t\t\t\t\t\t\t\t+ safeCollectionRole()\n \t\t\t\t);\n \t\t\t}\n \t\t}\n \n \t\t//set cache\n \t\tif ( StringHelper.isNotEmpty( cacheConcurrencyStrategy ) ) {\n \t\t\tcollection.setCacheConcurrencyStrategy( cacheConcurrencyStrategy );\n \t\t\tcollection.setCacheRegionName( cacheRegionName );\n \t\t}\n \n \t\t//SQL overriding\n \t\tSQLInsert sqlInsert = property.getAnnotation( SQLInsert.class );\n \t\tSQLUpdate sqlUpdate = property.getAnnotation( SQLUpdate.class );\n \t\tSQLDelete sqlDelete = property.getAnnotation( SQLDelete.class );\n \t\tSQLDeleteAll sqlDeleteAll = property.getAnnotation( SQLDeleteAll.class );\n \t\tLoader loader = property.getAnnotation( Loader.class );\n \t\tif ( sqlInsert != null ) {\n \t\t\tcollection.setCustomSQLInsert( sqlInsert.sql().trim(), sqlInsert.callable(),\n \t\t\t\t\tExecuteUpdateResultCheckStyle.fromExternalName( sqlInsert.check().toString().toLowerCase() )\n \t\t\t);\n \n \t\t}\n \t\tif ( sqlUpdate != null ) {\n \t\t\tcollection.setCustomSQLUpdate( sqlUpdate.sql(), sqlUpdate.callable(),\n \t\t\t\t\tExecuteUpdateResultCheckStyle.fromExternalName( sqlUpdate.check().toString().toLowerCase() )\n \t\t\t);\n \t\t}\n \t\tif ( sqlDelete != null ) {\n \t\t\tcollection.setCustomSQLDelete( sqlDelete.sql(), sqlDelete.callable(),\n \t\t\t\t\tExecuteUpdateResultCheckStyle.fromExternalName( sqlDelete.check().toString().toLowerCase() )\n \t\t\t);\n \t\t}\n \t\tif ( sqlDeleteAll != null ) {\n \t\t\tcollection.setCustomSQLDeleteAll( sqlDeleteAll.sql(), sqlDeleteAll.callable(),\n \t\t\t\t\tExecuteUpdateResultCheckStyle.fromExternalName( sqlDeleteAll.check().toString().toLowerCase() )\n \t\t\t);\n \t\t}\n \t\tif ( loader != null ) {\n \t\t\tcollection.setLoaderName( loader.namedQuery() );\n \t\t}\n \n \t\t//work on association\n \t\tboolean isMappedBy = !BinderHelper.isEmptyAnnotationValue( mappedBy );\n \n \t\tif (isMappedBy\n \t\t\t\t&& (property.isAnnotationPresent( JoinColumn.class )\n \t\t\t\t\t|| property.isAnnotationPresent( JoinColumns.class )\n \t\t\t\t\t|| propertyHolder.getJoinTable( property ) != null ) ) {\n \t\t\tString message = \"Associations marked as mappedBy must not define database mappings like @JoinTable or @JoinColumn: \";\n \t\t\tmessage += StringHelper.qualify( propertyHolder.getPath(), propertyName );\n \t\t\tthrow new AnnotationException( message );\n \t\t}\n \n \t\tcollection.setInverse( isMappedBy );\n \n \t\t//many to many may need some second pass informations\n \t\tif ( !oneToMany && isMappedBy ) {\n \t\t\tmappings.addMappedBy( getCollectionType().getName(), mappedBy, propertyName );\n \t\t}\n \t\t//TODO reducce tableBinder != null and oneToMany\n \t\tXClass collectionType = getCollectionType();\n \t\tif ( inheritanceStatePerClass == null) throw new AssertionFailure( \"inheritanceStatePerClass not set\" );\n \t\tSecondPass sp = getSecondPass(\n \t\t\t\tfkJoinColumns,\n \t\t\t\tjoinColumns,\n \t\t\t\tinverseJoinColumns,\n \t\t\t\telementColumns,\n \t\t\t\tmapKeyColumns, mapKeyManyToManyColumns, isEmbedded,\n \t\t\t\tproperty, collectionType,\n \t\t\t\tignoreNotFound, oneToMany,\n \t\t\t\ttableBinder, mappings\n \t\t);\n \t\tif ( collectionType.isAnnotationPresent( Embeddable.class )\n-\t\t\t\t|| property.isAnnotationPresent( CollectionOfElements.class ) //legacy hibernate\n \t\t\t\t|| property.isAnnotationPresent( ElementCollection.class ) //JPA 2\n \t\t\t\t) {\n \t\t\t// do it right away, otherwise @ManyToOne on composite element call addSecondPass\n \t\t\t// and raise a ConcurrentModificationException\n \t\t\t//sp.doSecondPass( CollectionHelper.EMPTY_MAP );\n \t\t\tmappings.addSecondPass( sp, !isMappedBy );\n \t\t}\n \t\telse {\n \t\t\tmappings.addSecondPass( sp, !isMappedBy );\n \t\t}\n \n \t\tmappings.addCollection( collection );\n \n \t\t//property building\n \t\tPropertyBinder binder = new PropertyBinder();\n \t\tbinder.setName( propertyName );\n \t\tbinder.setValue( collection );\n \t\tbinder.setCascade( cascadeStrategy );\n \t\tif ( cascadeStrategy != null && cascadeStrategy.indexOf( \"delete-orphan\" ) >= 0 ) {\n \t\t\tcollection.setOrphanDelete( true );\n \t\t}\n \t\tbinder.setAccessType( accessType );\n \t\tbinder.setProperty( property );\n \t\tbinder.setInsertable( insertable );\n \t\tbinder.setUpdatable( updatable );\n \t\tProperty prop = binder.makeProperty();\n \t\t//we don't care about the join stuffs because the column is on the association table.\n \t\tif (! declaringClassSet) throw new AssertionFailure( \"DeclaringClass is not set in CollectionBinder while binding\" );\n \t\tpropertyHolder.addProperty( prop, declaringClass );\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"fb44ad936d8d54d311ecbaea1633683a8d809d04": {
			"type": "Ybodychange",
			"commitMessage": "HHH-6196 - Split org.hibernate.engine package into api/spi/internal\n",
			"commitDate": "2011-05-04, 4:15 PM",
			"commitName": "fb44ad936d8d54d311ecbaea1633683a8d809d04",
			"commitAuthor": "Steve Ebersole",
			"commitDateOld": "2011-04-12, 8:07 AM",
			"commitNameOld": "ad17f89c4c29f0327c843cf5265e156d65743ab1",
			"commitAuthorOld": "Steve Ebersole",
			"daysBetweenCommits": 22.34,
			"commitsBetweenForRepo": 88,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,167 +1,167 @@\n \tpublic void bind() {\n \t\tthis.collection = createCollection( propertyHolder.getPersistentClass() );\n         String role = StringHelper.qualify(propertyHolder.getPath(), propertyName);\n         LOG.debugf(\"Collection role: %s\", role);\n         collection.setRole(role);\n \t\tcollection.setNodeName( propertyName );\n \n \t\tif ( (property.isAnnotationPresent( org.hibernate.annotations.MapKey.class )\n \t\t\t\t|| property.isAnnotationPresent( MapKeyColumn.class ) )\n \t\t\t&& mapKeyPropertyName != null ) {\n \t\t\tthrow new AnnotationException(\n \t\t\t\t\t\"Cannot mix @javax.persistence.MapKey and @MapKeyColumn or @org.hibernate.annotations.MapKey \"\n \t\t\t\t\t\t\t+ \"on the same collection: \" + StringHelper.qualify(\n \t\t\t\t\t\t\tpropertyHolder.getPath(), propertyName\n \t\t\t\t\t)\n \t\t\t);\n \t\t}\n \n \t\t//set laziness\n \t\tdefineFetchingStrategy();\n \t\tcollection.setBatchSize( batchSize );\n \t\tif ( orderBy != null && hqlOrderBy != null ) {\n \t\t\tthrow new AnnotationException(\n \t\t\t\t\t\"Cannot use sql order by clause in conjunction of EJB3 order by clause: \" + safeCollectionRole()\n \t\t\t);\n \t\t}\n \n \t\tcollection.setMutable( !property.isAnnotationPresent( Immutable.class ) );\n \t\tOptimisticLock lockAnn = property.getAnnotation( OptimisticLock.class );\n \t\tif ( lockAnn != null ) collection.setOptimisticLocked( !lockAnn.excluded() );\n \n \t\tPersister persisterAnn = property.getAnnotation( Persister.class );\n \t\tif ( persisterAnn != null ) {\n \t\t\tcollection.setCollectionPersisterClass( persisterAnn.impl() );\n \t\t}\n \n \t\t// set ordering\n \t\tif ( orderBy != null ) collection.setOrderBy( orderBy );\n \t\tif ( isSorted ) {\n \t\t\tcollection.setSorted( true );\n \t\t\tif ( comparator != null ) {\n \t\t\t\ttry {\n \t\t\t\t\tcollection.setComparator( (Comparator) comparator.newInstance() );\n \t\t\t\t}\n \t\t\t\tcatch (ClassCastException e) {\n \t\t\t\t\tthrow new AnnotationException(\n \t\t\t\t\t\t\t\"Comparator not implementing java.util.Comparator class: \"\n \t\t\t\t\t\t\t\t\t+ comparator.getName() + \"(\" + safeCollectionRole() + \")\"\n \t\t\t\t\t);\n \t\t\t\t}\n \t\t\t\tcatch (Exception e) {\n \t\t\t\t\tthrow new AnnotationException(\n \t\t\t\t\t\t\t\"Could not instantiate comparator class: \"\n \t\t\t\t\t\t\t\t\t+ comparator.getName() + \"(\" + safeCollectionRole() + \")\"\n \t\t\t\t\t);\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\telse {\n \t\t\tif ( hasToBeSorted ) {\n \t\t\t\tthrow new AnnotationException(\n \t\t\t\t\t\t\"A sorted collection has to define @Sort: \"\n \t\t\t\t\t\t\t\t+ safeCollectionRole()\n \t\t\t\t);\n \t\t\t}\n \t\t}\n \n \t\t//set cache\n \t\tif ( StringHelper.isNotEmpty( cacheConcurrencyStrategy ) ) {\n \t\t\tcollection.setCacheConcurrencyStrategy( cacheConcurrencyStrategy );\n \t\t\tcollection.setCacheRegionName( cacheRegionName );\n \t\t}\n \n \t\t//SQL overriding\n \t\tSQLInsert sqlInsert = property.getAnnotation( SQLInsert.class );\n \t\tSQLUpdate sqlUpdate = property.getAnnotation( SQLUpdate.class );\n \t\tSQLDelete sqlDelete = property.getAnnotation( SQLDelete.class );\n \t\tSQLDeleteAll sqlDeleteAll = property.getAnnotation( SQLDeleteAll.class );\n \t\tLoader loader = property.getAnnotation( Loader.class );\n \t\tif ( sqlInsert != null ) {\n \t\t\tcollection.setCustomSQLInsert( sqlInsert.sql().trim(), sqlInsert.callable(),\n-\t\t\t\t\tExecuteUpdateResultCheckStyle.parse( sqlInsert.check().toString().toLowerCase() )\n+\t\t\t\t\tExecuteUpdateResultCheckStyle.fromExternalName( sqlInsert.check().toString().toLowerCase() )\n \t\t\t);\n \n \t\t}\n \t\tif ( sqlUpdate != null ) {\n \t\t\tcollection.setCustomSQLUpdate( sqlUpdate.sql(), sqlUpdate.callable(),\n-\t\t\t\t\tExecuteUpdateResultCheckStyle.parse( sqlUpdate.check().toString().toLowerCase() )\n+\t\t\t\t\tExecuteUpdateResultCheckStyle.fromExternalName( sqlUpdate.check().toString().toLowerCase() )\n \t\t\t);\n \t\t}\n \t\tif ( sqlDelete != null ) {\n \t\t\tcollection.setCustomSQLDelete( sqlDelete.sql(), sqlDelete.callable(),\n-\t\t\t\t\tExecuteUpdateResultCheckStyle.parse( sqlDelete.check().toString().toLowerCase() )\n+\t\t\t\t\tExecuteUpdateResultCheckStyle.fromExternalName( sqlDelete.check().toString().toLowerCase() )\n \t\t\t);\n \t\t}\n \t\tif ( sqlDeleteAll != null ) {\n \t\t\tcollection.setCustomSQLDeleteAll( sqlDeleteAll.sql(), sqlDeleteAll.callable(),\n-\t\t\t\t\tExecuteUpdateResultCheckStyle.parse( sqlDeleteAll.check().toString().toLowerCase() )\n+\t\t\t\t\tExecuteUpdateResultCheckStyle.fromExternalName( sqlDeleteAll.check().toString().toLowerCase() )\n \t\t\t);\n \t\t}\n \t\tif ( loader != null ) {\n \t\t\tcollection.setLoaderName( loader.namedQuery() );\n \t\t}\n \n \t\t//work on association\n \t\tboolean isMappedBy = !BinderHelper.isEmptyAnnotationValue( mappedBy );\n \n \t\tif (isMappedBy\n \t\t\t\t&& (property.isAnnotationPresent( JoinColumn.class )\n \t\t\t\t\t|| property.isAnnotationPresent( JoinColumns.class )\n \t\t\t\t\t|| propertyHolder.getJoinTable( property ) != null ) ) {\n \t\t\tString message = \"Associations marked as mappedBy must not define database mappings like @JoinTable or @JoinColumn: \";\n \t\t\tmessage += StringHelper.qualify( propertyHolder.getPath(), propertyName );\n \t\t\tthrow new AnnotationException( message );\n \t\t}\n \n \t\tcollection.setInverse( isMappedBy );\n \n \t\t//many to many may need some second pass informations\n \t\tif ( !oneToMany && isMappedBy ) {\n \t\t\tmappings.addMappedBy( getCollectionType().getName(), mappedBy, propertyName );\n \t\t}\n \t\t//TODO reducce tableBinder != null and oneToMany\n \t\tXClass collectionType = getCollectionType();\n \t\tif ( inheritanceStatePerClass == null) throw new AssertionFailure( \"inheritanceStatePerClass not set\" );\n \t\tSecondPass sp = getSecondPass(\n \t\t\t\tfkJoinColumns,\n \t\t\t\tjoinColumns,\n \t\t\t\tinverseJoinColumns,\n \t\t\t\telementColumns,\n \t\t\t\tmapKeyColumns, mapKeyManyToManyColumns, isEmbedded,\n \t\t\t\tproperty, collectionType,\n \t\t\t\tignoreNotFound, oneToMany,\n \t\t\t\ttableBinder, mappings\n \t\t);\n \t\tif ( collectionType.isAnnotationPresent( Embeddable.class )\n \t\t\t\t|| property.isAnnotationPresent( CollectionOfElements.class ) //legacy hibernate\n \t\t\t\t|| property.isAnnotationPresent( ElementCollection.class ) //JPA 2\n \t\t\t\t) {\n \t\t\t// do it right away, otherwise @ManyToOne on composite element call addSecondPass\n \t\t\t// and raise a ConcurrentModificationException\n \t\t\t//sp.doSecondPass( CollectionHelper.EMPTY_MAP );\n \t\t\tmappings.addSecondPass( sp, !isMappedBy );\n \t\t}\n \t\telse {\n \t\t\tmappings.addSecondPass( sp, !isMappedBy );\n \t\t}\n \n \t\tmappings.addCollection( collection );\n \n \t\t//property building\n \t\tPropertyBinder binder = new PropertyBinder();\n \t\tbinder.setName( propertyName );\n \t\tbinder.setValue( collection );\n \t\tbinder.setCascade( cascadeStrategy );\n \t\tif ( cascadeStrategy != null && cascadeStrategy.indexOf( \"delete-orphan\" ) >= 0 ) {\n \t\t\tcollection.setOrphanDelete( true );\n \t\t}\n \t\tbinder.setAccessType( accessType );\n \t\tbinder.setProperty( property );\n \t\tbinder.setInsertable( insertable );\n \t\tbinder.setUpdatable( updatable );\n \t\tProperty prop = binder.makeProperty();\n \t\t//we don't care about the join stuffs because the column is on the association table.\n \t\tif (! declaringClassSet) throw new AssertionFailure( \"DeclaringClass is not set in CollectionBinder while binding\" );\n \t\tpropertyHolder.addProperty( prop, declaringClass );\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"ddfcc44d760938578771cb6ce24c809c980c8b8b": {
			"type": "Ybodychange",
			"commitMessage": "HHH-5916 - Add support for a programmatic way to define a default EntityPersister and CollectionPersister class implementation\n",
			"commitDate": "2011-03-04, 2:37 PM",
			"commitName": "ddfcc44d760938578771cb6ce24c809c980c8b8b",
			"commitAuthor": "Steve Ebersole",
			"commitDateOld": "2011-02-14, 11:20 AM",
			"commitNameOld": "e18799b03611ef8dc37690585de984f63b35bc34",
			"commitAuthorOld": "Emmanuel Bernard",
			"daysBetweenCommits": 18.14,
			"commitsBetweenForRepo": 23,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,178 +1,166 @@\n \tpublic void bind() {\n \t\tthis.collection = createCollection( propertyHolder.getPersistentClass() );\n \t\tlog.debug( \"Collection role: {}\", StringHelper.qualify( propertyHolder.getPath(), propertyName ) );\n \t\tcollection.setRole( StringHelper.qualify( propertyHolder.getPath(), propertyName ) );\n \t\tcollection.setNodeName( propertyName );\n \n \t\tif ( (property.isAnnotationPresent( org.hibernate.annotations.MapKey.class )\n \t\t\t\t|| property.isAnnotationPresent( MapKeyColumn.class ) )\n \t\t\t&& mapKeyPropertyName != null ) {\n \t\t\tthrow new AnnotationException(\n \t\t\t\t\t\"Cannot mix @javax.persistence.MapKey and @MapKeyColumn or @org.hibernate.annotations.MapKey \"\n \t\t\t\t\t\t\t+ \"on the same collection: \" + StringHelper.qualify(\n \t\t\t\t\t\t\tpropertyHolder.getPath(), propertyName\n \t\t\t\t\t)\n \t\t\t);\n \t\t}\n \n \t\t//set laziness\n \t\tdefineFetchingStrategy();\n \t\tcollection.setBatchSize( batchSize );\n \t\tif ( orderBy != null && hqlOrderBy != null ) {\n \t\t\tthrow new AnnotationException(\n \t\t\t\t\t\"Cannot use sql order by clause in conjunction of EJB3 order by clause: \" + safeCollectionRole()\n \t\t\t);\n \t\t}\n \n \t\tcollection.setMutable( !property.isAnnotationPresent( Immutable.class ) );\n \t\tOptimisticLock lockAnn = property.getAnnotation( OptimisticLock.class );\n \t\tif ( lockAnn != null ) collection.setOptimisticLocked( !lockAnn.excluded() );\n \n-\t\t//@Persister has priority over PersisterClassProvider\n-\t\t//if all fail, left null and Hibernate defaults kick in\n \t\tPersister persisterAnn = property.getAnnotation( Persister.class );\n \t\tif ( persisterAnn != null ) {\n \t\t\tcollection.setCollectionPersisterClass( persisterAnn.impl() );\n \t\t}\n-\t\telse {\n-\t\t\tfinal PersisterClassProvider persisterClassProvider = mappings.getPersisterClassProvider();\n-\t\t\tif (persisterClassProvider != null) {\n-\t\t\t\tfinal Class<? extends CollectionPersister> persister =\n-\t\t\t\t\t\tpersisterClassProvider.getCollectionPersisterClass( collection.getRole() );\n-\t\t\t\tif (persister != null) {\n-\t\t\t\t\tcollection.setCollectionPersisterClass( persister );\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n \n \t\t// set ordering\n \t\tif ( orderBy != null ) collection.setOrderBy( orderBy );\n \t\tif ( isSorted ) {\n \t\t\tcollection.setSorted( true );\n \t\t\tif ( comparator != null ) {\n \t\t\t\ttry {\n \t\t\t\t\tcollection.setComparator( (Comparator) comparator.newInstance() );\n \t\t\t\t}\n \t\t\t\tcatch (ClassCastException e) {\n \t\t\t\t\tthrow new AnnotationException(\n \t\t\t\t\t\t\t\"Comparator not implementing java.util.Comparator class: \"\n \t\t\t\t\t\t\t\t\t+ comparator.getName() + \"(\" + safeCollectionRole() + \")\"\n \t\t\t\t\t);\n \t\t\t\t}\n \t\t\t\tcatch (Exception e) {\n \t\t\t\t\tthrow new AnnotationException(\n \t\t\t\t\t\t\t\"Could not instantiate comparator class: \"\n \t\t\t\t\t\t\t\t\t+ comparator.getName() + \"(\" + safeCollectionRole() + \")\"\n \t\t\t\t\t);\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\telse {\n \t\t\tif ( hasToBeSorted ) {\n \t\t\t\tthrow new AnnotationException(\n \t\t\t\t\t\t\"A sorted collection has to define @Sort: \"\n \t\t\t\t\t\t\t\t+ safeCollectionRole()\n \t\t\t\t);\n \t\t\t}\n \t\t}\n \n \t\t//set cache\n \t\tif ( StringHelper.isNotEmpty( cacheConcurrencyStrategy ) ) {\n \t\t\tcollection.setCacheConcurrencyStrategy( cacheConcurrencyStrategy );\n \t\t\tcollection.setCacheRegionName( cacheRegionName );\n \t\t}\n \n \t\t//SQL overriding\n \t\tSQLInsert sqlInsert = property.getAnnotation( SQLInsert.class );\n \t\tSQLUpdate sqlUpdate = property.getAnnotation( SQLUpdate.class );\n \t\tSQLDelete sqlDelete = property.getAnnotation( SQLDelete.class );\n \t\tSQLDeleteAll sqlDeleteAll = property.getAnnotation( SQLDeleteAll.class );\n \t\tLoader loader = property.getAnnotation( Loader.class );\n \t\tif ( sqlInsert != null ) {\n \t\t\tcollection.setCustomSQLInsert( sqlInsert.sql().trim(), sqlInsert.callable(),\n \t\t\t\t\tExecuteUpdateResultCheckStyle.parse( sqlInsert.check().toString().toLowerCase() )\n \t\t\t);\n \n \t\t}\n \t\tif ( sqlUpdate != null ) {\n \t\t\tcollection.setCustomSQLUpdate( sqlUpdate.sql(), sqlUpdate.callable(),\n \t\t\t\t\tExecuteUpdateResultCheckStyle.parse( sqlUpdate.check().toString().toLowerCase() )\n \t\t\t);\n \t\t}\n \t\tif ( sqlDelete != null ) {\n \t\t\tcollection.setCustomSQLDelete( sqlDelete.sql(), sqlDelete.callable(),\n \t\t\t\t\tExecuteUpdateResultCheckStyle.parse( sqlDelete.check().toString().toLowerCase() )\n \t\t\t);\n \t\t}\n \t\tif ( sqlDeleteAll != null ) {\n \t\t\tcollection.setCustomSQLDeleteAll( sqlDeleteAll.sql(), sqlDeleteAll.callable(),\n \t\t\t\t\tExecuteUpdateResultCheckStyle.parse( sqlDeleteAll.check().toString().toLowerCase() )\n \t\t\t);\n \t\t}\n \t\tif ( loader != null ) {\n \t\t\tcollection.setLoaderName( loader.namedQuery() );\n \t\t}\n \n \t\t//work on association\n \t\tboolean isMappedBy = !BinderHelper.isEmptyAnnotationValue( mappedBy );\n \n \t\tif (isMappedBy\n \t\t\t\t&& (property.isAnnotationPresent( JoinColumn.class )\n \t\t\t\t\t|| property.isAnnotationPresent( JoinColumns.class )\n \t\t\t\t\t|| propertyHolder.getJoinTable( property ) != null ) ) {\n \t\t\tString message = \"Associations marked as mappedBy must not define database mappings like @JoinTable or @JoinColumn: \";\n \t\t\tmessage += StringHelper.qualify( propertyHolder.getPath(), propertyName );\n \t\t\tthrow new AnnotationException( message );\n \t\t}\n \n \t\tcollection.setInverse( isMappedBy );\n \n \t\t//many to many may need some second pass informations\n \t\tif ( !oneToMany && isMappedBy ) {\n \t\t\tmappings.addMappedBy( getCollectionType().getName(), mappedBy, propertyName );\n \t\t}\n \t\t//TODO reducce tableBinder != null and oneToMany\n \t\tXClass collectionType = getCollectionType();\n \t\tif ( inheritanceStatePerClass == null) throw new AssertionFailure( \"inheritanceStatePerClass not set\" );\n \t\tSecondPass sp = getSecondPass(\n \t\t\t\tfkJoinColumns,\n \t\t\t\tjoinColumns,\n \t\t\t\tinverseJoinColumns,\n \t\t\t\telementColumns,\n \t\t\t\tmapKeyColumns, mapKeyManyToManyColumns, isEmbedded,\n \t\t\t\tproperty, collectionType,\n \t\t\t\tignoreNotFound, oneToMany,\n \t\t\t\ttableBinder, mappings\n \t\t);\n \t\tif ( collectionType.isAnnotationPresent( Embeddable.class )\n \t\t\t\t|| property.isAnnotationPresent( CollectionOfElements.class ) //legacy hibernate\n \t\t\t\t|| property.isAnnotationPresent( ElementCollection.class ) //JPA 2\n \t\t\t\t) {\n \t\t\t// do it right away, otherwise @ManyToOne on composite element call addSecondPass\n \t\t\t// and raise a ConcurrentModificationException\n \t\t\t//sp.doSecondPass( CollectionHelper.EMPTY_MAP );\n \t\t\tmappings.addSecondPass( sp, !isMappedBy );\n \t\t}\n \t\telse {\n \t\t\tmappings.addSecondPass( sp, !isMappedBy );\n \t\t}\n \n \t\tmappings.addCollection( collection );\n \n \t\t//property building\n \t\tPropertyBinder binder = new PropertyBinder();\n \t\tbinder.setName( propertyName );\n \t\tbinder.setValue( collection );\n \t\tbinder.setCascade( cascadeStrategy );\n \t\tif ( cascadeStrategy != null && cascadeStrategy.indexOf( \"delete-orphan\" ) >= 0 ) {\n \t\t\tcollection.setOrphanDelete( true );\n \t\t}\n \t\tbinder.setAccessType( accessType );\n \t\tbinder.setProperty( property );\n \t\tbinder.setInsertable( insertable );\n \t\tbinder.setUpdatable( updatable );\n \t\tProperty prop = binder.makeProperty();\n \t\t//we don't care about the join stuffs because the column is on the association table.\n \t\tif (! declaringClassSet) throw new AssertionFailure( \"DeclaringClass is not set in CollectionBinder while binding\" );\n \t\tpropertyHolder.addProperty( prop, declaringClass );\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"4ffba763cf6645e722a2deeea552f998ec7dc22a": {
			"type": "Ybodychange",
			"commitMessage": "HHH-5916 Use PersisterClassProvider in Binders\n",
			"commitDate": "2011-02-23, 2:33 PM",
			"commitName": "4ffba763cf6645e722a2deeea552f998ec7dc22a",
			"commitAuthor": "Emmanuel Bernard",
			"commitDateOld": "2011-02-08, 12:55 PM",
			"commitNameOld": "8c806d361d63764e8523006944dde52aff70532c",
			"commitAuthorOld": "JPAV",
			"daysBetweenCommits": 15.07,
			"commitsBetweenForRepo": 41,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,164 +1,179 @@\n \tpublic void bind() {\n \t\tthis.collection = createCollection( propertyHolder.getPersistentClass() );\n         String role = StringHelper.qualify(propertyHolder.getPath(), propertyName);\n         LOG.debugf(\"Collection role: %s\", role);\n         collection.setRole(role);\n \t\tcollection.setNodeName( propertyName );\n \n \t\tif ( (property.isAnnotationPresent( org.hibernate.annotations.MapKey.class )\n \t\t\t\t|| property.isAnnotationPresent( MapKeyColumn.class ) )\n \t\t\t&& mapKeyPropertyName != null ) {\n \t\t\tthrow new AnnotationException(\n \t\t\t\t\t\"Cannot mix @javax.persistence.MapKey and @MapKeyColumn or @org.hibernate.annotations.MapKey \"\n \t\t\t\t\t\t\t+ \"on the same collection: \" + StringHelper.qualify(\n \t\t\t\t\t\t\tpropertyHolder.getPath(), propertyName\n \t\t\t\t\t)\n \t\t\t);\n \t\t}\n \n \t\t//set laziness\n \t\tdefineFetchingStrategy();\n \t\tcollection.setBatchSize( batchSize );\n \t\tif ( orderBy != null && hqlOrderBy != null ) {\n \t\t\tthrow new AnnotationException(\n \t\t\t\t\t\"Cannot use sql order by clause in conjunction of EJB3 order by clause: \" + safeCollectionRole()\n \t\t\t);\n \t\t}\n \n \t\tcollection.setMutable( !property.isAnnotationPresent( Immutable.class ) );\n \t\tOptimisticLock lockAnn = property.getAnnotation( OptimisticLock.class );\n \t\tif ( lockAnn != null ) collection.setOptimisticLocked( !lockAnn.excluded() );\n+\n+\t\t//@Persister has priority over PersisterClassProvider\n+\t\t//if all fail, left null and Hibernate defaults kick in\n \t\tPersister persisterAnn = property.getAnnotation( Persister.class );\n-\t\tif ( persisterAnn != null ) collection.setCollectionPersisterClass( persisterAnn.impl() );\n+\t\tif ( persisterAnn != null ) {\n+\t\t\tcollection.setCollectionPersisterClass( persisterAnn.impl() );\n+\t\t}\n+\t\telse {\n+\t\t\tfinal PersisterClassProvider persisterClassProvider = mappings.getPersisterClassProvider();\n+\t\t\tif (persisterClassProvider != null) {\n+\t\t\t\tfinal Class<? extends CollectionPersister> persister =\n+\t\t\t\t\t\tpersisterClassProvider.getCollectionPersisterClass( collection.getRole() );\n+\t\t\t\tif (persister != null) {\n+\t\t\t\t\tcollection.setCollectionPersisterClass( persister );\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n \t\t// set ordering\n \t\tif ( orderBy != null ) collection.setOrderBy( orderBy );\n \t\tif ( isSorted ) {\n \t\t\tcollection.setSorted( true );\n \t\t\tif ( comparator != null ) {\n \t\t\t\ttry {\n \t\t\t\t\tcollection.setComparator( (Comparator) comparator.newInstance() );\n \t\t\t\t}\n \t\t\t\tcatch (ClassCastException e) {\n \t\t\t\t\tthrow new AnnotationException(\n \t\t\t\t\t\t\t\"Comparator not implementing java.util.Comparator class: \"\n \t\t\t\t\t\t\t\t\t+ comparator.getName() + \"(\" + safeCollectionRole() + \")\"\n \t\t\t\t\t);\n \t\t\t\t}\n \t\t\t\tcatch (Exception e) {\n \t\t\t\t\tthrow new AnnotationException(\n \t\t\t\t\t\t\t\"Could not instantiate comparator class: \"\n \t\t\t\t\t\t\t\t\t+ comparator.getName() + \"(\" + safeCollectionRole() + \")\"\n \t\t\t\t\t);\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\telse {\n \t\t\tif ( hasToBeSorted ) {\n \t\t\t\tthrow new AnnotationException(\n \t\t\t\t\t\t\"A sorted collection has to define @Sort: \"\n \t\t\t\t\t\t\t\t+ safeCollectionRole()\n \t\t\t\t);\n \t\t\t}\n \t\t}\n \n \t\t//set cache\n \t\tif ( StringHelper.isNotEmpty( cacheConcurrencyStrategy ) ) {\n \t\t\tcollection.setCacheConcurrencyStrategy( cacheConcurrencyStrategy );\n \t\t\tcollection.setCacheRegionName( cacheRegionName );\n \t\t}\n \n \t\t//SQL overriding\n \t\tSQLInsert sqlInsert = property.getAnnotation( SQLInsert.class );\n \t\tSQLUpdate sqlUpdate = property.getAnnotation( SQLUpdate.class );\n \t\tSQLDelete sqlDelete = property.getAnnotation( SQLDelete.class );\n \t\tSQLDeleteAll sqlDeleteAll = property.getAnnotation( SQLDeleteAll.class );\n \t\tLoader loader = property.getAnnotation( Loader.class );\n \t\tif ( sqlInsert != null ) {\n \t\t\tcollection.setCustomSQLInsert( sqlInsert.sql().trim(), sqlInsert.callable(),\n \t\t\t\t\tExecuteUpdateResultCheckStyle.parse( sqlInsert.check().toString().toLowerCase() )\n \t\t\t);\n \n \t\t}\n \t\tif ( sqlUpdate != null ) {\n \t\t\tcollection.setCustomSQLUpdate( sqlUpdate.sql(), sqlUpdate.callable(),\n \t\t\t\t\tExecuteUpdateResultCheckStyle.parse( sqlUpdate.check().toString().toLowerCase() )\n \t\t\t);\n \t\t}\n \t\tif ( sqlDelete != null ) {\n \t\t\tcollection.setCustomSQLDelete( sqlDelete.sql(), sqlDelete.callable(),\n \t\t\t\t\tExecuteUpdateResultCheckStyle.parse( sqlDelete.check().toString().toLowerCase() )\n \t\t\t);\n \t\t}\n \t\tif ( sqlDeleteAll != null ) {\n \t\t\tcollection.setCustomSQLDeleteAll( sqlDeleteAll.sql(), sqlDeleteAll.callable(),\n \t\t\t\t\tExecuteUpdateResultCheckStyle.parse( sqlDeleteAll.check().toString().toLowerCase() )\n \t\t\t);\n \t\t}\n \t\tif ( loader != null ) {\n \t\t\tcollection.setLoaderName( loader.namedQuery() );\n \t\t}\n \n \t\t//work on association\n \t\tboolean isMappedBy = !BinderHelper.isEmptyAnnotationValue( mappedBy );\n \n \t\tif (isMappedBy\n \t\t\t\t&& (property.isAnnotationPresent( JoinColumn.class )\n \t\t\t\t\t|| property.isAnnotationPresent( JoinColumns.class )\n \t\t\t\t\t|| propertyHolder.getJoinTable( property ) != null ) ) {\n \t\t\tString message = \"Associations marked as mappedBy must not define database mappings like @JoinTable or @JoinColumn: \";\n \t\t\tmessage += StringHelper.qualify( propertyHolder.getPath(), propertyName );\n \t\t\tthrow new AnnotationException( message );\n \t\t}\n \n \t\tcollection.setInverse( isMappedBy );\n \n \t\t//many to many may need some second pass informations\n \t\tif ( !oneToMany && isMappedBy ) {\n \t\t\tmappings.addMappedBy( getCollectionType().getName(), mappedBy, propertyName );\n \t\t}\n \t\t//TODO reducce tableBinder != null and oneToMany\n \t\tXClass collectionType = getCollectionType();\n \t\tif ( inheritanceStatePerClass == null) throw new AssertionFailure( \"inheritanceStatePerClass not set\" );\n \t\tSecondPass sp = getSecondPass(\n \t\t\t\tfkJoinColumns,\n \t\t\t\tjoinColumns,\n \t\t\t\tinverseJoinColumns,\n \t\t\t\telementColumns,\n \t\t\t\tmapKeyColumns, mapKeyManyToManyColumns, isEmbedded,\n \t\t\t\tproperty, collectionType,\n \t\t\t\tignoreNotFound, oneToMany,\n \t\t\t\ttableBinder, mappings\n \t\t);\n \t\tif ( collectionType.isAnnotationPresent( Embeddable.class )\n \t\t\t\t|| property.isAnnotationPresent( CollectionOfElements.class ) //legacy hibernate\n \t\t\t\t|| property.isAnnotationPresent( ElementCollection.class ) //JPA 2\n \t\t\t\t) {\n \t\t\t// do it right away, otherwise @ManyToOne on composite element call addSecondPass\n \t\t\t// and raise a ConcurrentModificationException\n \t\t\t//sp.doSecondPass( CollectionHelper.EMPTY_MAP );\n \t\t\tmappings.addSecondPass( sp, !isMappedBy );\n \t\t}\n \t\telse {\n \t\t\tmappings.addSecondPass( sp, !isMappedBy );\n \t\t}\n \n \t\tmappings.addCollection( collection );\n \n \t\t//property building\n \t\tPropertyBinder binder = new PropertyBinder();\n \t\tbinder.setName( propertyName );\n \t\tbinder.setValue( collection );\n \t\tbinder.setCascade( cascadeStrategy );\n \t\tif ( cascadeStrategy != null && cascadeStrategy.indexOf( \"delete-orphan\" ) >= 0 ) {\n \t\t\tcollection.setOrphanDelete( true );\n \t\t}\n \t\tbinder.setAccessType( accessType );\n \t\tbinder.setProperty( property );\n \t\tbinder.setInsertable( insertable );\n \t\tbinder.setUpdatable( updatable );\n \t\tProperty prop = binder.makeProperty();\n \t\t//we don't care about the join stuffs because the column is on the association table.\n \t\tif (! declaringClassSet) throw new AssertionFailure( \"DeclaringClass is not set in CollectionBinder while binding\" );\n \t\tpropertyHolder.addProperty( prop, declaringClass );\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"e18799b03611ef8dc37690585de984f63b35bc34": {
			"type": "Ybodychange",
			"commitMessage": "HHH-5916 Use PersisterClassProvider in Binders\n",
			"commitDate": "2011-02-14, 11:20 AM",
			"commitName": "e18799b03611ef8dc37690585de984f63b35bc34",
			"commitAuthor": "Emmanuel Bernard",
			"commitDateOld": "2010-10-11, 1:41 PM",
			"commitNameOld": "34c2839dccef33a8f3abb4eaf3192c1e1d9e1814",
			"commitAuthorOld": "Steve Ebersole",
			"daysBetweenCommits": 125.94,
			"commitsBetweenForRepo": 229,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,163 +1,178 @@\n \tpublic void bind() {\n \t\tthis.collection = createCollection( propertyHolder.getPersistentClass() );\n \t\tlog.debug( \"Collection role: {}\", StringHelper.qualify( propertyHolder.getPath(), propertyName ) );\n \t\tcollection.setRole( StringHelper.qualify( propertyHolder.getPath(), propertyName ) );\n \t\tcollection.setNodeName( propertyName );\n \n \t\tif ( (property.isAnnotationPresent( org.hibernate.annotations.MapKey.class )\n \t\t\t\t|| property.isAnnotationPresent( MapKeyColumn.class ) )\n \t\t\t&& mapKeyPropertyName != null ) {\n \t\t\tthrow new AnnotationException(\n \t\t\t\t\t\"Cannot mix @javax.persistence.MapKey and @MapKeyColumn or @org.hibernate.annotations.MapKey \"\n \t\t\t\t\t\t\t+ \"on the same collection: \" + StringHelper.qualify(\n \t\t\t\t\t\t\tpropertyHolder.getPath(), propertyName\n \t\t\t\t\t)\n \t\t\t);\n \t\t}\n \n \t\t//set laziness\n \t\tdefineFetchingStrategy();\n \t\tcollection.setBatchSize( batchSize );\n \t\tif ( orderBy != null && hqlOrderBy != null ) {\n \t\t\tthrow new AnnotationException(\n \t\t\t\t\t\"Cannot use sql order by clause in conjunction of EJB3 order by clause: \" + safeCollectionRole()\n \t\t\t);\n \t\t}\n \n \t\tcollection.setMutable( !property.isAnnotationPresent( Immutable.class ) );\n \t\tOptimisticLock lockAnn = property.getAnnotation( OptimisticLock.class );\n \t\tif ( lockAnn != null ) collection.setOptimisticLocked( !lockAnn.excluded() );\n+\n+\t\t//@Persister has priority over PersisterClassProvider\n+\t\t//if all fail, left null and Hibernate defaults kick in\n \t\tPersister persisterAnn = property.getAnnotation( Persister.class );\n-\t\tif ( persisterAnn != null ) collection.setCollectionPersisterClass( persisterAnn.impl() );\n+\t\tif ( persisterAnn != null ) {\n+\t\t\tcollection.setCollectionPersisterClass( persisterAnn.impl() );\n+\t\t}\n+\t\telse {\n+\t\t\tfinal PersisterClassProvider persisterClassProvider = mappings.getPersisterClassProvider();\n+\t\t\tif (persisterClassProvider != null) {\n+\t\t\t\tfinal Class<? extends CollectionPersister> persister =\n+\t\t\t\t\t\tpersisterClassProvider.getCollectionPersisterClass( collection.getRole() );\n+\t\t\t\tif (persister != null) {\n+\t\t\t\t\tcollection.setCollectionPersisterClass( persister );\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n \t\t// set ordering\n \t\tif ( orderBy != null ) collection.setOrderBy( orderBy );\n \t\tif ( isSorted ) {\n \t\t\tcollection.setSorted( true );\n \t\t\tif ( comparator != null ) {\n \t\t\t\ttry {\n \t\t\t\t\tcollection.setComparator( (Comparator) comparator.newInstance() );\n \t\t\t\t}\n \t\t\t\tcatch (ClassCastException e) {\n \t\t\t\t\tthrow new AnnotationException(\n \t\t\t\t\t\t\t\"Comparator not implementing java.util.Comparator class: \"\n \t\t\t\t\t\t\t\t\t+ comparator.getName() + \"(\" + safeCollectionRole() + \")\"\n \t\t\t\t\t);\n \t\t\t\t}\n \t\t\t\tcatch (Exception e) {\n \t\t\t\t\tthrow new AnnotationException(\n \t\t\t\t\t\t\t\"Could not instantiate comparator class: \"\n \t\t\t\t\t\t\t\t\t+ comparator.getName() + \"(\" + safeCollectionRole() + \")\"\n \t\t\t\t\t);\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\telse {\n \t\t\tif ( hasToBeSorted ) {\n \t\t\t\tthrow new AnnotationException(\n \t\t\t\t\t\t\"A sorted collection has to define @Sort: \"\n \t\t\t\t\t\t\t\t+ safeCollectionRole()\n \t\t\t\t);\n \t\t\t}\n \t\t}\n \n \t\t//set cache\n \t\tif ( StringHelper.isNotEmpty( cacheConcurrencyStrategy ) ) {\n \t\t\tcollection.setCacheConcurrencyStrategy( cacheConcurrencyStrategy );\n \t\t\tcollection.setCacheRegionName( cacheRegionName );\n \t\t}\n \n \t\t//SQL overriding\n \t\tSQLInsert sqlInsert = property.getAnnotation( SQLInsert.class );\n \t\tSQLUpdate sqlUpdate = property.getAnnotation( SQLUpdate.class );\n \t\tSQLDelete sqlDelete = property.getAnnotation( SQLDelete.class );\n \t\tSQLDeleteAll sqlDeleteAll = property.getAnnotation( SQLDeleteAll.class );\n \t\tLoader loader = property.getAnnotation( Loader.class );\n \t\tif ( sqlInsert != null ) {\n \t\t\tcollection.setCustomSQLInsert( sqlInsert.sql().trim(), sqlInsert.callable(),\n \t\t\t\t\tExecuteUpdateResultCheckStyle.parse( sqlInsert.check().toString().toLowerCase() )\n \t\t\t);\n \n \t\t}\n \t\tif ( sqlUpdate != null ) {\n \t\t\tcollection.setCustomSQLUpdate( sqlUpdate.sql(), sqlUpdate.callable(),\n \t\t\t\t\tExecuteUpdateResultCheckStyle.parse( sqlUpdate.check().toString().toLowerCase() )\n \t\t\t);\n \t\t}\n \t\tif ( sqlDelete != null ) {\n \t\t\tcollection.setCustomSQLDelete( sqlDelete.sql(), sqlDelete.callable(),\n \t\t\t\t\tExecuteUpdateResultCheckStyle.parse( sqlDelete.check().toString().toLowerCase() )\n \t\t\t);\n \t\t}\n \t\tif ( sqlDeleteAll != null ) {\n \t\t\tcollection.setCustomSQLDeleteAll( sqlDeleteAll.sql(), sqlDeleteAll.callable(),\n \t\t\t\t\tExecuteUpdateResultCheckStyle.parse( sqlDeleteAll.check().toString().toLowerCase() )\n \t\t\t);\n \t\t}\n \t\tif ( loader != null ) {\n \t\t\tcollection.setLoaderName( loader.namedQuery() );\n \t\t}\n \n \t\t//work on association\n \t\tboolean isMappedBy = !BinderHelper.isEmptyAnnotationValue( mappedBy );\n \n \t\tif (isMappedBy\n \t\t\t\t&& (property.isAnnotationPresent( JoinColumn.class )\n \t\t\t\t\t|| property.isAnnotationPresent( JoinColumns.class )\n \t\t\t\t\t|| propertyHolder.getJoinTable( property ) != null ) ) {\n \t\t\tString message = \"Associations marked as mappedBy must not define database mappings like @JoinTable or @JoinColumn: \";\n \t\t\tmessage += StringHelper.qualify( propertyHolder.getPath(), propertyName );\n \t\t\tthrow new AnnotationException( message );\n \t\t}\n \n \t\tcollection.setInverse( isMappedBy );\n \n \t\t//many to many may need some second pass informations\n \t\tif ( !oneToMany && isMappedBy ) {\n \t\t\tmappings.addMappedBy( getCollectionType().getName(), mappedBy, propertyName );\n \t\t}\n \t\t//TODO reducce tableBinder != null and oneToMany\n \t\tXClass collectionType = getCollectionType();\n \t\tif ( inheritanceStatePerClass == null) throw new AssertionFailure( \"inheritanceStatePerClass not set\" );\n \t\tSecondPass sp = getSecondPass(\n \t\t\t\tfkJoinColumns,\n \t\t\t\tjoinColumns,\n \t\t\t\tinverseJoinColumns,\n \t\t\t\telementColumns,\n \t\t\t\tmapKeyColumns, mapKeyManyToManyColumns, isEmbedded,\n \t\t\t\tproperty, collectionType,\n \t\t\t\tignoreNotFound, oneToMany,\n \t\t\t\ttableBinder, mappings\n \t\t);\n \t\tif ( collectionType.isAnnotationPresent( Embeddable.class )\n \t\t\t\t|| property.isAnnotationPresent( CollectionOfElements.class ) //legacy hibernate\n \t\t\t\t|| property.isAnnotationPresent( ElementCollection.class ) //JPA 2\n \t\t\t\t) {\n \t\t\t// do it right away, otherwise @ManyToOne on composite element call addSecondPass\n \t\t\t// and raise a ConcurrentModificationException\n \t\t\t//sp.doSecondPass( CollectionHelper.EMPTY_MAP );\n \t\t\tmappings.addSecondPass( sp, !isMappedBy );\n \t\t}\n \t\telse {\n \t\t\tmappings.addSecondPass( sp, !isMappedBy );\n \t\t}\n \n \t\tmappings.addCollection( collection );\n \n \t\t//property building\n \t\tPropertyBinder binder = new PropertyBinder();\n \t\tbinder.setName( propertyName );\n \t\tbinder.setValue( collection );\n \t\tbinder.setCascade( cascadeStrategy );\n \t\tif ( cascadeStrategy != null && cascadeStrategy.indexOf( \"delete-orphan\" ) >= 0 ) {\n \t\t\tcollection.setOrphanDelete( true );\n \t\t}\n \t\tbinder.setAccessType( accessType );\n \t\tbinder.setProperty( property );\n \t\tbinder.setInsertable( insertable );\n \t\tbinder.setUpdatable( updatable );\n \t\tProperty prop = binder.makeProperty();\n \t\t//we don't care about the join stuffs because the column is on the association table.\n \t\tif (! declaringClassSet) throw new AssertionFailure( \"DeclaringClass is not set in CollectionBinder while binding\" );\n \t\tpropertyHolder.addProperty( prop, declaringClass );\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"8c806d361d63764e8523006944dde52aff70532c": {
			"type": "Ybodychange",
			"commitMessage": "Changes from requests at Hibernate meeting: message codes, use XXXf methods for debug and trace, use @Cause\n",
			"commitDate": "2011-02-08, 12:55 PM",
			"commitName": "8c806d361d63764e8523006944dde52aff70532c",
			"commitAuthor": "JPAV",
			"commitDateOld": "2011-01-18, 3:00 PM",
			"commitNameOld": "3712e1ad7efccd2ba0c24b3d7d3b23f84d948b9d",
			"commitAuthorOld": "JPAV",
			"daysBetweenCommits": 20.91,
			"commitsBetweenForRepo": 3,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,164 +1,164 @@\n \tpublic void bind() {\n \t\tthis.collection = createCollection( propertyHolder.getPersistentClass() );\n         String role = StringHelper.qualify(propertyHolder.getPath(), propertyName);\n-        LOG.debug(\"Collection role: \" + role);\n+        LOG.debugf(\"Collection role: %s\", role);\n         collection.setRole(role);\n \t\tcollection.setNodeName( propertyName );\n \n \t\tif ( (property.isAnnotationPresent( org.hibernate.annotations.MapKey.class )\n \t\t\t\t|| property.isAnnotationPresent( MapKeyColumn.class ) )\n \t\t\t&& mapKeyPropertyName != null ) {\n \t\t\tthrow new AnnotationException(\n \t\t\t\t\t\"Cannot mix @javax.persistence.MapKey and @MapKeyColumn or @org.hibernate.annotations.MapKey \"\n \t\t\t\t\t\t\t+ \"on the same collection: \" + StringHelper.qualify(\n \t\t\t\t\t\t\tpropertyHolder.getPath(), propertyName\n \t\t\t\t\t)\n \t\t\t);\n \t\t}\n \n \t\t//set laziness\n \t\tdefineFetchingStrategy();\n \t\tcollection.setBatchSize( batchSize );\n \t\tif ( orderBy != null && hqlOrderBy != null ) {\n \t\t\tthrow new AnnotationException(\n \t\t\t\t\t\"Cannot use sql order by clause in conjunction of EJB3 order by clause: \" + safeCollectionRole()\n \t\t\t);\n \t\t}\n \n \t\tcollection.setMutable( !property.isAnnotationPresent( Immutable.class ) );\n \t\tOptimisticLock lockAnn = property.getAnnotation( OptimisticLock.class );\n \t\tif ( lockAnn != null ) collection.setOptimisticLocked( !lockAnn.excluded() );\n \t\tPersister persisterAnn = property.getAnnotation( Persister.class );\n \t\tif ( persisterAnn != null ) collection.setCollectionPersisterClass( persisterAnn.impl() );\n \n \t\t// set ordering\n \t\tif ( orderBy != null ) collection.setOrderBy( orderBy );\n \t\tif ( isSorted ) {\n \t\t\tcollection.setSorted( true );\n \t\t\tif ( comparator != null ) {\n \t\t\t\ttry {\n \t\t\t\t\tcollection.setComparator( (Comparator) comparator.newInstance() );\n \t\t\t\t}\n \t\t\t\tcatch (ClassCastException e) {\n \t\t\t\t\tthrow new AnnotationException(\n \t\t\t\t\t\t\t\"Comparator not implementing java.util.Comparator class: \"\n \t\t\t\t\t\t\t\t\t+ comparator.getName() + \"(\" + safeCollectionRole() + \")\"\n \t\t\t\t\t);\n \t\t\t\t}\n \t\t\t\tcatch (Exception e) {\n \t\t\t\t\tthrow new AnnotationException(\n \t\t\t\t\t\t\t\"Could not instantiate comparator class: \"\n \t\t\t\t\t\t\t\t\t+ comparator.getName() + \"(\" + safeCollectionRole() + \")\"\n \t\t\t\t\t);\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\telse {\n \t\t\tif ( hasToBeSorted ) {\n \t\t\t\tthrow new AnnotationException(\n \t\t\t\t\t\t\"A sorted collection has to define @Sort: \"\n \t\t\t\t\t\t\t\t+ safeCollectionRole()\n \t\t\t\t);\n \t\t\t}\n \t\t}\n \n \t\t//set cache\n \t\tif ( StringHelper.isNotEmpty( cacheConcurrencyStrategy ) ) {\n \t\t\tcollection.setCacheConcurrencyStrategy( cacheConcurrencyStrategy );\n \t\t\tcollection.setCacheRegionName( cacheRegionName );\n \t\t}\n \n \t\t//SQL overriding\n \t\tSQLInsert sqlInsert = property.getAnnotation( SQLInsert.class );\n \t\tSQLUpdate sqlUpdate = property.getAnnotation( SQLUpdate.class );\n \t\tSQLDelete sqlDelete = property.getAnnotation( SQLDelete.class );\n \t\tSQLDeleteAll sqlDeleteAll = property.getAnnotation( SQLDeleteAll.class );\n \t\tLoader loader = property.getAnnotation( Loader.class );\n \t\tif ( sqlInsert != null ) {\n \t\t\tcollection.setCustomSQLInsert( sqlInsert.sql().trim(), sqlInsert.callable(),\n \t\t\t\t\tExecuteUpdateResultCheckStyle.parse( sqlInsert.check().toString().toLowerCase() )\n \t\t\t);\n \n \t\t}\n \t\tif ( sqlUpdate != null ) {\n \t\t\tcollection.setCustomSQLUpdate( sqlUpdate.sql(), sqlUpdate.callable(),\n \t\t\t\t\tExecuteUpdateResultCheckStyle.parse( sqlUpdate.check().toString().toLowerCase() )\n \t\t\t);\n \t\t}\n \t\tif ( sqlDelete != null ) {\n \t\t\tcollection.setCustomSQLDelete( sqlDelete.sql(), sqlDelete.callable(),\n \t\t\t\t\tExecuteUpdateResultCheckStyle.parse( sqlDelete.check().toString().toLowerCase() )\n \t\t\t);\n \t\t}\n \t\tif ( sqlDeleteAll != null ) {\n \t\t\tcollection.setCustomSQLDeleteAll( sqlDeleteAll.sql(), sqlDeleteAll.callable(),\n \t\t\t\t\tExecuteUpdateResultCheckStyle.parse( sqlDeleteAll.check().toString().toLowerCase() )\n \t\t\t);\n \t\t}\n \t\tif ( loader != null ) {\n \t\t\tcollection.setLoaderName( loader.namedQuery() );\n \t\t}\n \n \t\t//work on association\n \t\tboolean isMappedBy = !BinderHelper.isEmptyAnnotationValue( mappedBy );\n \n \t\tif (isMappedBy\n \t\t\t\t&& (property.isAnnotationPresent( JoinColumn.class )\n \t\t\t\t\t|| property.isAnnotationPresent( JoinColumns.class )\n \t\t\t\t\t|| propertyHolder.getJoinTable( property ) != null ) ) {\n \t\t\tString message = \"Associations marked as mappedBy must not define database mappings like @JoinTable or @JoinColumn: \";\n \t\t\tmessage += StringHelper.qualify( propertyHolder.getPath(), propertyName );\n \t\t\tthrow new AnnotationException( message );\n \t\t}\n \n \t\tcollection.setInverse( isMappedBy );\n \n \t\t//many to many may need some second pass informations\n \t\tif ( !oneToMany && isMappedBy ) {\n \t\t\tmappings.addMappedBy( getCollectionType().getName(), mappedBy, propertyName );\n \t\t}\n \t\t//TODO reducce tableBinder != null and oneToMany\n \t\tXClass collectionType = getCollectionType();\n \t\tif ( inheritanceStatePerClass == null) throw new AssertionFailure( \"inheritanceStatePerClass not set\" );\n \t\tSecondPass sp = getSecondPass(\n \t\t\t\tfkJoinColumns,\n \t\t\t\tjoinColumns,\n \t\t\t\tinverseJoinColumns,\n \t\t\t\telementColumns,\n \t\t\t\tmapKeyColumns, mapKeyManyToManyColumns, isEmbedded,\n \t\t\t\tproperty, collectionType,\n \t\t\t\tignoreNotFound, oneToMany,\n \t\t\t\ttableBinder, mappings\n \t\t);\n \t\tif ( collectionType.isAnnotationPresent( Embeddable.class )\n \t\t\t\t|| property.isAnnotationPresent( CollectionOfElements.class ) //legacy hibernate\n \t\t\t\t|| property.isAnnotationPresent( ElementCollection.class ) //JPA 2\n \t\t\t\t) {\n \t\t\t// do it right away, otherwise @ManyToOne on composite element call addSecondPass\n \t\t\t// and raise a ConcurrentModificationException\n \t\t\t//sp.doSecondPass( CollectionHelper.EMPTY_MAP );\n \t\t\tmappings.addSecondPass( sp, !isMappedBy );\n \t\t}\n \t\telse {\n \t\t\tmappings.addSecondPass( sp, !isMappedBy );\n \t\t}\n \n \t\tmappings.addCollection( collection );\n \n \t\t//property building\n \t\tPropertyBinder binder = new PropertyBinder();\n \t\tbinder.setName( propertyName );\n \t\tbinder.setValue( collection );\n \t\tbinder.setCascade( cascadeStrategy );\n \t\tif ( cascadeStrategy != null && cascadeStrategy.indexOf( \"delete-orphan\" ) >= 0 ) {\n \t\t\tcollection.setOrphanDelete( true );\n \t\t}\n \t\tbinder.setAccessType( accessType );\n \t\tbinder.setProperty( property );\n \t\tbinder.setInsertable( insertable );\n \t\tbinder.setUpdatable( updatable );\n \t\tProperty prop = binder.makeProperty();\n \t\t//we don't care about the join stuffs because the column is on the association table.\n \t\tif (! declaringClassSet) throw new AssertionFailure( \"DeclaringClass is not set in CollectionBinder while binding\" );\n \t\tpropertyHolder.addProperty( prop, declaringClass );\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"3712e1ad7efccd2ba0c24b3d7d3b23f84d948b9d": {
			"type": "Ybodychange",
			"commitMessage": "Give each project a single logger\n",
			"commitDate": "2011-01-18, 3:00 PM",
			"commitName": "3712e1ad7efccd2ba0c24b3d7d3b23f84d948b9d",
			"commitAuthor": "JPAV",
			"commitDateOld": "2011-01-18, 2:35 PM",
			"commitNameOld": "a9b1425f3f07021dae556e710b2bdfdc3812661b",
			"commitAuthorOld": "JPAV",
			"daysBetweenCommits": 0.02,
			"commitsBetweenForRepo": 2,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,164 +1,164 @@\n \tpublic void bind() {\n \t\tthis.collection = createCollection( propertyHolder.getPersistentClass() );\n         String role = StringHelper.qualify(propertyHolder.getPath(), propertyName);\n-        LOG.collectionRole(role);\n+        LOG.debug(\"Collection role: \" + role);\n         collection.setRole(role);\n \t\tcollection.setNodeName( propertyName );\n \n \t\tif ( (property.isAnnotationPresent( org.hibernate.annotations.MapKey.class )\n \t\t\t\t|| property.isAnnotationPresent( MapKeyColumn.class ) )\n \t\t\t&& mapKeyPropertyName != null ) {\n \t\t\tthrow new AnnotationException(\n \t\t\t\t\t\"Cannot mix @javax.persistence.MapKey and @MapKeyColumn or @org.hibernate.annotations.MapKey \"\n \t\t\t\t\t\t\t+ \"on the same collection: \" + StringHelper.qualify(\n \t\t\t\t\t\t\tpropertyHolder.getPath(), propertyName\n \t\t\t\t\t)\n \t\t\t);\n \t\t}\n \n \t\t//set laziness\n \t\tdefineFetchingStrategy();\n \t\tcollection.setBatchSize( batchSize );\n \t\tif ( orderBy != null && hqlOrderBy != null ) {\n \t\t\tthrow new AnnotationException(\n \t\t\t\t\t\"Cannot use sql order by clause in conjunction of EJB3 order by clause: \" + safeCollectionRole()\n \t\t\t);\n \t\t}\n \n \t\tcollection.setMutable( !property.isAnnotationPresent( Immutable.class ) );\n \t\tOptimisticLock lockAnn = property.getAnnotation( OptimisticLock.class );\n \t\tif ( lockAnn != null ) collection.setOptimisticLocked( !lockAnn.excluded() );\n \t\tPersister persisterAnn = property.getAnnotation( Persister.class );\n \t\tif ( persisterAnn != null ) collection.setCollectionPersisterClass( persisterAnn.impl() );\n \n \t\t// set ordering\n \t\tif ( orderBy != null ) collection.setOrderBy( orderBy );\n \t\tif ( isSorted ) {\n \t\t\tcollection.setSorted( true );\n \t\t\tif ( comparator != null ) {\n \t\t\t\ttry {\n \t\t\t\t\tcollection.setComparator( (Comparator) comparator.newInstance() );\n \t\t\t\t}\n \t\t\t\tcatch (ClassCastException e) {\n \t\t\t\t\tthrow new AnnotationException(\n \t\t\t\t\t\t\t\"Comparator not implementing java.util.Comparator class: \"\n \t\t\t\t\t\t\t\t\t+ comparator.getName() + \"(\" + safeCollectionRole() + \")\"\n \t\t\t\t\t);\n \t\t\t\t}\n \t\t\t\tcatch (Exception e) {\n \t\t\t\t\tthrow new AnnotationException(\n \t\t\t\t\t\t\t\"Could not instantiate comparator class: \"\n \t\t\t\t\t\t\t\t\t+ comparator.getName() + \"(\" + safeCollectionRole() + \")\"\n \t\t\t\t\t);\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\telse {\n \t\t\tif ( hasToBeSorted ) {\n \t\t\t\tthrow new AnnotationException(\n \t\t\t\t\t\t\"A sorted collection has to define @Sort: \"\n \t\t\t\t\t\t\t\t+ safeCollectionRole()\n \t\t\t\t);\n \t\t\t}\n \t\t}\n \n \t\t//set cache\n \t\tif ( StringHelper.isNotEmpty( cacheConcurrencyStrategy ) ) {\n \t\t\tcollection.setCacheConcurrencyStrategy( cacheConcurrencyStrategy );\n \t\t\tcollection.setCacheRegionName( cacheRegionName );\n \t\t}\n \n \t\t//SQL overriding\n \t\tSQLInsert sqlInsert = property.getAnnotation( SQLInsert.class );\n \t\tSQLUpdate sqlUpdate = property.getAnnotation( SQLUpdate.class );\n \t\tSQLDelete sqlDelete = property.getAnnotation( SQLDelete.class );\n \t\tSQLDeleteAll sqlDeleteAll = property.getAnnotation( SQLDeleteAll.class );\n \t\tLoader loader = property.getAnnotation( Loader.class );\n \t\tif ( sqlInsert != null ) {\n \t\t\tcollection.setCustomSQLInsert( sqlInsert.sql().trim(), sqlInsert.callable(),\n \t\t\t\t\tExecuteUpdateResultCheckStyle.parse( sqlInsert.check().toString().toLowerCase() )\n \t\t\t);\n \n \t\t}\n \t\tif ( sqlUpdate != null ) {\n \t\t\tcollection.setCustomSQLUpdate( sqlUpdate.sql(), sqlUpdate.callable(),\n \t\t\t\t\tExecuteUpdateResultCheckStyle.parse( sqlUpdate.check().toString().toLowerCase() )\n \t\t\t);\n \t\t}\n \t\tif ( sqlDelete != null ) {\n \t\t\tcollection.setCustomSQLDelete( sqlDelete.sql(), sqlDelete.callable(),\n \t\t\t\t\tExecuteUpdateResultCheckStyle.parse( sqlDelete.check().toString().toLowerCase() )\n \t\t\t);\n \t\t}\n \t\tif ( sqlDeleteAll != null ) {\n \t\t\tcollection.setCustomSQLDeleteAll( sqlDeleteAll.sql(), sqlDeleteAll.callable(),\n \t\t\t\t\tExecuteUpdateResultCheckStyle.parse( sqlDeleteAll.check().toString().toLowerCase() )\n \t\t\t);\n \t\t}\n \t\tif ( loader != null ) {\n \t\t\tcollection.setLoaderName( loader.namedQuery() );\n \t\t}\n \n \t\t//work on association\n \t\tboolean isMappedBy = !BinderHelper.isEmptyAnnotationValue( mappedBy );\n \n \t\tif (isMappedBy\n \t\t\t\t&& (property.isAnnotationPresent( JoinColumn.class )\n \t\t\t\t\t|| property.isAnnotationPresent( JoinColumns.class )\n \t\t\t\t\t|| propertyHolder.getJoinTable( property ) != null ) ) {\n \t\t\tString message = \"Associations marked as mappedBy must not define database mappings like @JoinTable or @JoinColumn: \";\n \t\t\tmessage += StringHelper.qualify( propertyHolder.getPath(), propertyName );\n \t\t\tthrow new AnnotationException( message );\n \t\t}\n \n \t\tcollection.setInverse( isMappedBy );\n \n \t\t//many to many may need some second pass informations\n \t\tif ( !oneToMany && isMappedBy ) {\n \t\t\tmappings.addMappedBy( getCollectionType().getName(), mappedBy, propertyName );\n \t\t}\n \t\t//TODO reducce tableBinder != null and oneToMany\n \t\tXClass collectionType = getCollectionType();\n \t\tif ( inheritanceStatePerClass == null) throw new AssertionFailure( \"inheritanceStatePerClass not set\" );\n \t\tSecondPass sp = getSecondPass(\n \t\t\t\tfkJoinColumns,\n \t\t\t\tjoinColumns,\n \t\t\t\tinverseJoinColumns,\n \t\t\t\telementColumns,\n \t\t\t\tmapKeyColumns, mapKeyManyToManyColumns, isEmbedded,\n \t\t\t\tproperty, collectionType,\n \t\t\t\tignoreNotFound, oneToMany,\n \t\t\t\ttableBinder, mappings\n \t\t);\n \t\tif ( collectionType.isAnnotationPresent( Embeddable.class )\n \t\t\t\t|| property.isAnnotationPresent( CollectionOfElements.class ) //legacy hibernate\n \t\t\t\t|| property.isAnnotationPresent( ElementCollection.class ) //JPA 2\n \t\t\t\t) {\n \t\t\t// do it right away, otherwise @ManyToOne on composite element call addSecondPass\n \t\t\t// and raise a ConcurrentModificationException\n \t\t\t//sp.doSecondPass( CollectionHelper.EMPTY_MAP );\n \t\t\tmappings.addSecondPass( sp, !isMappedBy );\n \t\t}\n \t\telse {\n \t\t\tmappings.addSecondPass( sp, !isMappedBy );\n \t\t}\n \n \t\tmappings.addCollection( collection );\n \n \t\t//property building\n \t\tPropertyBinder binder = new PropertyBinder();\n \t\tbinder.setName( propertyName );\n \t\tbinder.setValue( collection );\n \t\tbinder.setCascade( cascadeStrategy );\n \t\tif ( cascadeStrategy != null && cascadeStrategy.indexOf( \"delete-orphan\" ) >= 0 ) {\n \t\t\tcollection.setOrphanDelete( true );\n \t\t}\n \t\tbinder.setAccessType( accessType );\n \t\tbinder.setProperty( property );\n \t\tbinder.setInsertable( insertable );\n \t\tbinder.setUpdatable( updatable );\n \t\tProperty prop = binder.makeProperty();\n \t\t//we don't care about the join stuffs because the column is on the association table.\n \t\tif (! declaringClassSet) throw new AssertionFailure( \"DeclaringClass is not set in CollectionBinder while binding\" );\n \t\tpropertyHolder.addProperty( prop, declaringClass );\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"a9b1425f3f07021dae556e710b2bdfdc3812661b": {
			"type": "Ybodychange",
			"commitMessage": "Replaced references to slf4j with references to new jboss.logging.Logger implementations and i18n'd where it was clear how to do so.\n",
			"commitDate": "2011-01-18, 2:35 PM",
			"commitName": "a9b1425f3f07021dae556e710b2bdfdc3812661b",
			"commitAuthor": "JPAV",
			"commitDateOld": "2010-10-11, 1:41 PM",
			"commitNameOld": "34c2839dccef33a8f3abb4eaf3192c1e1d9e1814",
			"commitAuthorOld": "Steve Ebersole",
			"daysBetweenCommits": 99.08,
			"commitsBetweenForRepo": 193,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,163 +1,164 @@\n \tpublic void bind() {\n \t\tthis.collection = createCollection( propertyHolder.getPersistentClass() );\n-\t\tlog.debug( \"Collection role: {}\", StringHelper.qualify( propertyHolder.getPath(), propertyName ) );\n-\t\tcollection.setRole( StringHelper.qualify( propertyHolder.getPath(), propertyName ) );\n+        String role = StringHelper.qualify(propertyHolder.getPath(), propertyName);\n+        LOG.collectionRole(role);\n+        collection.setRole(role);\n \t\tcollection.setNodeName( propertyName );\n \n \t\tif ( (property.isAnnotationPresent( org.hibernate.annotations.MapKey.class )\n \t\t\t\t|| property.isAnnotationPresent( MapKeyColumn.class ) )\n \t\t\t&& mapKeyPropertyName != null ) {\n \t\t\tthrow new AnnotationException(\n \t\t\t\t\t\"Cannot mix @javax.persistence.MapKey and @MapKeyColumn or @org.hibernate.annotations.MapKey \"\n \t\t\t\t\t\t\t+ \"on the same collection: \" + StringHelper.qualify(\n \t\t\t\t\t\t\tpropertyHolder.getPath(), propertyName\n \t\t\t\t\t)\n \t\t\t);\n \t\t}\n \n \t\t//set laziness\n \t\tdefineFetchingStrategy();\n \t\tcollection.setBatchSize( batchSize );\n \t\tif ( orderBy != null && hqlOrderBy != null ) {\n \t\t\tthrow new AnnotationException(\n \t\t\t\t\t\"Cannot use sql order by clause in conjunction of EJB3 order by clause: \" + safeCollectionRole()\n \t\t\t);\n \t\t}\n \n \t\tcollection.setMutable( !property.isAnnotationPresent( Immutable.class ) );\n \t\tOptimisticLock lockAnn = property.getAnnotation( OptimisticLock.class );\n \t\tif ( lockAnn != null ) collection.setOptimisticLocked( !lockAnn.excluded() );\n \t\tPersister persisterAnn = property.getAnnotation( Persister.class );\n \t\tif ( persisterAnn != null ) collection.setCollectionPersisterClass( persisterAnn.impl() );\n \n \t\t// set ordering\n \t\tif ( orderBy != null ) collection.setOrderBy( orderBy );\n \t\tif ( isSorted ) {\n \t\t\tcollection.setSorted( true );\n \t\t\tif ( comparator != null ) {\n \t\t\t\ttry {\n \t\t\t\t\tcollection.setComparator( (Comparator) comparator.newInstance() );\n \t\t\t\t}\n \t\t\t\tcatch (ClassCastException e) {\n \t\t\t\t\tthrow new AnnotationException(\n \t\t\t\t\t\t\t\"Comparator not implementing java.util.Comparator class: \"\n \t\t\t\t\t\t\t\t\t+ comparator.getName() + \"(\" + safeCollectionRole() + \")\"\n \t\t\t\t\t);\n \t\t\t\t}\n \t\t\t\tcatch (Exception e) {\n \t\t\t\t\tthrow new AnnotationException(\n \t\t\t\t\t\t\t\"Could not instantiate comparator class: \"\n \t\t\t\t\t\t\t\t\t+ comparator.getName() + \"(\" + safeCollectionRole() + \")\"\n \t\t\t\t\t);\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\telse {\n \t\t\tif ( hasToBeSorted ) {\n \t\t\t\tthrow new AnnotationException(\n \t\t\t\t\t\t\"A sorted collection has to define @Sort: \"\n \t\t\t\t\t\t\t\t+ safeCollectionRole()\n \t\t\t\t);\n \t\t\t}\n \t\t}\n \n \t\t//set cache\n \t\tif ( StringHelper.isNotEmpty( cacheConcurrencyStrategy ) ) {\n \t\t\tcollection.setCacheConcurrencyStrategy( cacheConcurrencyStrategy );\n \t\t\tcollection.setCacheRegionName( cacheRegionName );\n \t\t}\n \n \t\t//SQL overriding\n \t\tSQLInsert sqlInsert = property.getAnnotation( SQLInsert.class );\n \t\tSQLUpdate sqlUpdate = property.getAnnotation( SQLUpdate.class );\n \t\tSQLDelete sqlDelete = property.getAnnotation( SQLDelete.class );\n \t\tSQLDeleteAll sqlDeleteAll = property.getAnnotation( SQLDeleteAll.class );\n \t\tLoader loader = property.getAnnotation( Loader.class );\n \t\tif ( sqlInsert != null ) {\n \t\t\tcollection.setCustomSQLInsert( sqlInsert.sql().trim(), sqlInsert.callable(),\n \t\t\t\t\tExecuteUpdateResultCheckStyle.parse( sqlInsert.check().toString().toLowerCase() )\n \t\t\t);\n \n \t\t}\n \t\tif ( sqlUpdate != null ) {\n \t\t\tcollection.setCustomSQLUpdate( sqlUpdate.sql(), sqlUpdate.callable(),\n \t\t\t\t\tExecuteUpdateResultCheckStyle.parse( sqlUpdate.check().toString().toLowerCase() )\n \t\t\t);\n \t\t}\n \t\tif ( sqlDelete != null ) {\n \t\t\tcollection.setCustomSQLDelete( sqlDelete.sql(), sqlDelete.callable(),\n \t\t\t\t\tExecuteUpdateResultCheckStyle.parse( sqlDelete.check().toString().toLowerCase() )\n \t\t\t);\n \t\t}\n \t\tif ( sqlDeleteAll != null ) {\n \t\t\tcollection.setCustomSQLDeleteAll( sqlDeleteAll.sql(), sqlDeleteAll.callable(),\n \t\t\t\t\tExecuteUpdateResultCheckStyle.parse( sqlDeleteAll.check().toString().toLowerCase() )\n \t\t\t);\n \t\t}\n \t\tif ( loader != null ) {\n \t\t\tcollection.setLoaderName( loader.namedQuery() );\n \t\t}\n \n \t\t//work on association\n \t\tboolean isMappedBy = !BinderHelper.isEmptyAnnotationValue( mappedBy );\n \n \t\tif (isMappedBy\n \t\t\t\t&& (property.isAnnotationPresent( JoinColumn.class )\n \t\t\t\t\t|| property.isAnnotationPresent( JoinColumns.class )\n \t\t\t\t\t|| propertyHolder.getJoinTable( property ) != null ) ) {\n \t\t\tString message = \"Associations marked as mappedBy must not define database mappings like @JoinTable or @JoinColumn: \";\n \t\t\tmessage += StringHelper.qualify( propertyHolder.getPath(), propertyName );\n \t\t\tthrow new AnnotationException( message );\n \t\t}\n \n \t\tcollection.setInverse( isMappedBy );\n \n \t\t//many to many may need some second pass informations\n \t\tif ( !oneToMany && isMappedBy ) {\n \t\t\tmappings.addMappedBy( getCollectionType().getName(), mappedBy, propertyName );\n \t\t}\n \t\t//TODO reducce tableBinder != null and oneToMany\n \t\tXClass collectionType = getCollectionType();\n \t\tif ( inheritanceStatePerClass == null) throw new AssertionFailure( \"inheritanceStatePerClass not set\" );\n \t\tSecondPass sp = getSecondPass(\n \t\t\t\tfkJoinColumns,\n \t\t\t\tjoinColumns,\n \t\t\t\tinverseJoinColumns,\n \t\t\t\telementColumns,\n \t\t\t\tmapKeyColumns, mapKeyManyToManyColumns, isEmbedded,\n \t\t\t\tproperty, collectionType,\n \t\t\t\tignoreNotFound, oneToMany,\n \t\t\t\ttableBinder, mappings\n \t\t);\n \t\tif ( collectionType.isAnnotationPresent( Embeddable.class )\n \t\t\t\t|| property.isAnnotationPresent( CollectionOfElements.class ) //legacy hibernate\n \t\t\t\t|| property.isAnnotationPresent( ElementCollection.class ) //JPA 2\n \t\t\t\t) {\n \t\t\t// do it right away, otherwise @ManyToOne on composite element call addSecondPass\n \t\t\t// and raise a ConcurrentModificationException\n \t\t\t//sp.doSecondPass( CollectionHelper.EMPTY_MAP );\n \t\t\tmappings.addSecondPass( sp, !isMappedBy );\n \t\t}\n \t\telse {\n \t\t\tmappings.addSecondPass( sp, !isMappedBy );\n \t\t}\n \n \t\tmappings.addCollection( collection );\n \n \t\t//property building\n \t\tPropertyBinder binder = new PropertyBinder();\n \t\tbinder.setName( propertyName );\n \t\tbinder.setValue( collection );\n \t\tbinder.setCascade( cascadeStrategy );\n \t\tif ( cascadeStrategy != null && cascadeStrategy.indexOf( \"delete-orphan\" ) >= 0 ) {\n \t\t\tcollection.setOrphanDelete( true );\n \t\t}\n \t\tbinder.setAccessType( accessType );\n \t\tbinder.setProperty( property );\n \t\tbinder.setInsertable( insertable );\n \t\tbinder.setUpdatable( updatable );\n \t\tProperty prop = binder.makeProperty();\n \t\t//we don't care about the join stuffs because the column is on the association table.\n \t\tif (! declaringClassSet) throw new AssertionFailure( \"DeclaringClass is not set in CollectionBinder while binding\" );\n \t\tpropertyHolder.addProperty( prop, declaringClass );\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"34c2839dccef33a8f3abb4eaf3192c1e1d9e1814": {
			"type": "Yfilerename",
			"commitMessage": "HHH-5616 - Switch to Gradle for builds\n",
			"commitDate": "2010-10-11, 1:41 PM",
			"commitName": "34c2839dccef33a8f3abb4eaf3192c1e1d9e1814",
			"commitAuthor": "Steve Ebersole",
			"commitDateOld": "2010-10-11, 12:51 PM",
			"commitNameOld": "0bfe7869e41076fd0846ca7592740710876f2427",
			"commitAuthorOld": "Gail Badner",
			"daysBetweenCommits": 0.04,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "",
			"extendedDetails": {
				"oldPath": "core/src/main/java/org/hibernate/cfg/annotations/CollectionBinder.java",
				"newPath": "hibernate-core/src/main/java/org/hibernate/cfg/annotations/CollectionBinder.java"
			}
		},
		"7419fc298dab9afe82fbdbb8b64854fa37f60817": {
			"type": "Ybodychange",
			"commitMessage": "HHH-5205 - Renamed BinderHelper.isDefault() to BinderHelper.isEmptyAnnotationValue() , because this describes better what the function does. Also renamed VersionTest to OptimisitcLockAnnotationTest to better describe what gets tested.\n\ngit-svn-id: https://svn.jboss.org/repos/hibernate/core/trunk@20741 1b8cb986-b30d-0410-93ca-fae66ebed9b2\n",
			"commitDate": "2010-09-28, 10:32 AM",
			"commitName": "7419fc298dab9afe82fbdbb8b64854fa37f60817",
			"commitAuthor": "Hardy Ferentschik",
			"commitDateOld": "2010-08-12, 1:13 PM",
			"commitNameOld": "f0f82e4f1ba7416ef010d5d71914a2bbde7fc22f",
			"commitAuthorOld": "Steve Ebersole",
			"daysBetweenCommits": 46.89,
			"commitsBetweenForRepo": 132,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,163 +1,163 @@\n \tpublic void bind() {\n \t\tthis.collection = createCollection( propertyHolder.getPersistentClass() );\n \t\tlog.debug( \"Collection role: {}\", StringHelper.qualify( propertyHolder.getPath(), propertyName ) );\n \t\tcollection.setRole( StringHelper.qualify( propertyHolder.getPath(), propertyName ) );\n \t\tcollection.setNodeName( propertyName );\n \n \t\tif ( (property.isAnnotationPresent( org.hibernate.annotations.MapKey.class )\n \t\t\t\t|| property.isAnnotationPresent( MapKeyColumn.class ) )\n \t\t\t&& mapKeyPropertyName != null ) {\n \t\t\tthrow new AnnotationException(\n \t\t\t\t\t\"Cannot mix @javax.persistence.MapKey and @MapKeyColumn or @org.hibernate.annotations.MapKey \"\n \t\t\t\t\t\t\t+ \"on the same collection: \" + StringHelper.qualify(\n \t\t\t\t\t\t\tpropertyHolder.getPath(), propertyName\n \t\t\t\t\t)\n \t\t\t);\n \t\t}\n \n \t\t//set laziness\n \t\tdefineFetchingStrategy();\n \t\tcollection.setBatchSize( batchSize );\n \t\tif ( orderBy != null && hqlOrderBy != null ) {\n \t\t\tthrow new AnnotationException(\n \t\t\t\t\t\"Cannot use sql order by clause in conjunction of EJB3 order by clause: \" + safeCollectionRole()\n \t\t\t);\n \t\t}\n \n \t\tcollection.setMutable( !property.isAnnotationPresent( Immutable.class ) );\n \t\tOptimisticLock lockAnn = property.getAnnotation( OptimisticLock.class );\n \t\tif ( lockAnn != null ) collection.setOptimisticLocked( !lockAnn.excluded() );\n \t\tPersister persisterAnn = property.getAnnotation( Persister.class );\n \t\tif ( persisterAnn != null ) collection.setCollectionPersisterClass( persisterAnn.impl() );\n \n \t\t// set ordering\n \t\tif ( orderBy != null ) collection.setOrderBy( orderBy );\n \t\tif ( isSorted ) {\n \t\t\tcollection.setSorted( true );\n \t\t\tif ( comparator != null ) {\n \t\t\t\ttry {\n \t\t\t\t\tcollection.setComparator( (Comparator) comparator.newInstance() );\n \t\t\t\t}\n \t\t\t\tcatch (ClassCastException e) {\n \t\t\t\t\tthrow new AnnotationException(\n \t\t\t\t\t\t\t\"Comparator not implementing java.util.Comparator class: \"\n \t\t\t\t\t\t\t\t\t+ comparator.getName() + \"(\" + safeCollectionRole() + \")\"\n \t\t\t\t\t);\n \t\t\t\t}\n \t\t\t\tcatch (Exception e) {\n \t\t\t\t\tthrow new AnnotationException(\n \t\t\t\t\t\t\t\"Could not instantiate comparator class: \"\n \t\t\t\t\t\t\t\t\t+ comparator.getName() + \"(\" + safeCollectionRole() + \")\"\n \t\t\t\t\t);\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\telse {\n \t\t\tif ( hasToBeSorted ) {\n \t\t\t\tthrow new AnnotationException(\n \t\t\t\t\t\t\"A sorted collection has to define @Sort: \"\n \t\t\t\t\t\t\t\t+ safeCollectionRole()\n \t\t\t\t);\n \t\t\t}\n \t\t}\n \n \t\t//set cache\n \t\tif ( StringHelper.isNotEmpty( cacheConcurrencyStrategy ) ) {\n \t\t\tcollection.setCacheConcurrencyStrategy( cacheConcurrencyStrategy );\n \t\t\tcollection.setCacheRegionName( cacheRegionName );\n \t\t}\n \n \t\t//SQL overriding\n \t\tSQLInsert sqlInsert = property.getAnnotation( SQLInsert.class );\n \t\tSQLUpdate sqlUpdate = property.getAnnotation( SQLUpdate.class );\n \t\tSQLDelete sqlDelete = property.getAnnotation( SQLDelete.class );\n \t\tSQLDeleteAll sqlDeleteAll = property.getAnnotation( SQLDeleteAll.class );\n \t\tLoader loader = property.getAnnotation( Loader.class );\n \t\tif ( sqlInsert != null ) {\n \t\t\tcollection.setCustomSQLInsert( sqlInsert.sql().trim(), sqlInsert.callable(),\n \t\t\t\t\tExecuteUpdateResultCheckStyle.parse( sqlInsert.check().toString().toLowerCase() )\n \t\t\t);\n \n \t\t}\n \t\tif ( sqlUpdate != null ) {\n \t\t\tcollection.setCustomSQLUpdate( sqlUpdate.sql(), sqlUpdate.callable(),\n \t\t\t\t\tExecuteUpdateResultCheckStyle.parse( sqlUpdate.check().toString().toLowerCase() )\n \t\t\t);\n \t\t}\n \t\tif ( sqlDelete != null ) {\n \t\t\tcollection.setCustomSQLDelete( sqlDelete.sql(), sqlDelete.callable(),\n \t\t\t\t\tExecuteUpdateResultCheckStyle.parse( sqlDelete.check().toString().toLowerCase() )\n \t\t\t);\n \t\t}\n \t\tif ( sqlDeleteAll != null ) {\n \t\t\tcollection.setCustomSQLDeleteAll( sqlDeleteAll.sql(), sqlDeleteAll.callable(),\n \t\t\t\t\tExecuteUpdateResultCheckStyle.parse( sqlDeleteAll.check().toString().toLowerCase() )\n \t\t\t);\n \t\t}\n \t\tif ( loader != null ) {\n \t\t\tcollection.setLoaderName( loader.namedQuery() );\n \t\t}\n \n \t\t//work on association\n-\t\tboolean isMappedBy = !BinderHelper.isDefault( mappedBy );\n+\t\tboolean isMappedBy = !BinderHelper.isEmptyAnnotationValue( mappedBy );\n \n \t\tif (isMappedBy\n \t\t\t\t&& (property.isAnnotationPresent( JoinColumn.class )\n \t\t\t\t\t|| property.isAnnotationPresent( JoinColumns.class )\n \t\t\t\t\t|| propertyHolder.getJoinTable( property ) != null ) ) {\n \t\t\tString message = \"Associations marked as mappedBy must not define database mappings like @JoinTable or @JoinColumn: \";\n \t\t\tmessage += StringHelper.qualify( propertyHolder.getPath(), propertyName );\n \t\t\tthrow new AnnotationException( message );\n \t\t}\n \n \t\tcollection.setInverse( isMappedBy );\n \n \t\t//many to many may need some second pass informations\n \t\tif ( !oneToMany && isMappedBy ) {\n \t\t\tmappings.addMappedBy( getCollectionType().getName(), mappedBy, propertyName );\n \t\t}\n \t\t//TODO reducce tableBinder != null and oneToMany\n \t\tXClass collectionType = getCollectionType();\n \t\tif ( inheritanceStatePerClass == null) throw new AssertionFailure( \"inheritanceStatePerClass not set\" );\n \t\tSecondPass sp = getSecondPass(\n \t\t\t\tfkJoinColumns,\n \t\t\t\tjoinColumns,\n \t\t\t\tinverseJoinColumns,\n \t\t\t\telementColumns,\n \t\t\t\tmapKeyColumns, mapKeyManyToManyColumns, isEmbedded,\n \t\t\t\tproperty, collectionType,\n \t\t\t\tignoreNotFound, oneToMany,\n \t\t\t\ttableBinder, mappings\n \t\t);\n \t\tif ( collectionType.isAnnotationPresent( Embeddable.class )\n \t\t\t\t|| property.isAnnotationPresent( CollectionOfElements.class ) //legacy hibernate\n \t\t\t\t|| property.isAnnotationPresent( ElementCollection.class ) //JPA 2\n \t\t\t\t) {\n \t\t\t// do it right away, otherwise @ManyToOne on composite element call addSecondPass\n \t\t\t// and raise a ConcurrentModificationException\n \t\t\t//sp.doSecondPass( CollectionHelper.EMPTY_MAP );\n \t\t\tmappings.addSecondPass( sp, !isMappedBy );\n \t\t}\n \t\telse {\n \t\t\tmappings.addSecondPass( sp, !isMappedBy );\n \t\t}\n \n \t\tmappings.addCollection( collection );\n \n \t\t//property building\n \t\tPropertyBinder binder = new PropertyBinder();\n \t\tbinder.setName( propertyName );\n \t\tbinder.setValue( collection );\n \t\tbinder.setCascade( cascadeStrategy );\n \t\tif ( cascadeStrategy != null && cascadeStrategy.indexOf( \"delete-orphan\" ) >= 0 ) {\n \t\t\tcollection.setOrphanDelete( true );\n \t\t}\n \t\tbinder.setAccessType( accessType );\n \t\tbinder.setProperty( property );\n \t\tbinder.setInsertable( insertable );\n \t\tbinder.setUpdatable( updatable );\n \t\tProperty prop = binder.makeProperty();\n \t\t//we don't care about the join stuffs because the column is on the association table.\n \t\tif (! declaringClassSet) throw new AssertionFailure( \"DeclaringClass is not set in CollectionBinder while binding\" );\n \t\tpropertyHolder.addProperty( prop, declaringClass );\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"1ca2bc19a5f667e10f9a2c2b10320b9c40921563": {
			"type": "Yfilerename",
			"commitMessage": "HHH-5367 - Move annotations module sources into core module\n\n\ngit-svn-id: https://svn.jboss.org/repos/hibernate/core/trunk@19921 1b8cb986-b30d-0410-93ca-fae66ebed9b2\n",
			"commitDate": "2010-07-08, 5:41 PM",
			"commitName": "1ca2bc19a5f667e10f9a2c2b10320b9c40921563",
			"commitAuthor": "Steve Ebersole",
			"commitDateOld": "2010-07-08, 11:32 AM",
			"commitNameOld": "cc3b41a09c983913594b16d6c909be0bfd41bd7a",
			"commitAuthorOld": "Steve Ebersole",
			"daysBetweenCommits": 0.26,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "",
			"extendedDetails": {
				"oldPath": "annotations/src/main/java/org/hibernate/cfg/annotations/CollectionBinder.java",
				"newPath": "core/src/main/java/org/hibernate/cfg/annotations/CollectionBinder.java"
			}
		},
		"8577a68e69d30d9e671024bf3330616000a3ec54": {
			"type": "Ybodychange",
			"commitMessage": "HHH-4529 clean @Id/@EmbeddedId mapping and merge with the regular basic and component mapping to open possibilities for @Id @ManyToOne support\n\ngit-svn-id: https://svn.jboss.org/repos/hibernate/core/trunk@18600 1b8cb986-b30d-0410-93ca-fae66ebed9b2\n",
			"commitDate": "2010-01-21, 10:51 AM",
			"commitName": "8577a68e69d30d9e671024bf3330616000a3ec54",
			"commitAuthor": "Emmanuel Bernard",
			"commitDateOld": "2010-01-12, 11:48 AM",
			"commitNameOld": "b1f925458eeb636897bf8a053712ed25fff39054",
			"commitAuthorOld": "Emmanuel Bernard",
			"daysBetweenCommits": 8.96,
			"commitsBetweenForRepo": 59,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,163 +1,163 @@\n \tpublic void bind() {\n \t\tthis.collection = createCollection( propertyHolder.getPersistentClass() );\n \t\tlog.debug( \"Collection role: {}\", StringHelper.qualify( propertyHolder.getPath(), propertyName ) );\n \t\tcollection.setRole( StringHelper.qualify( propertyHolder.getPath(), propertyName ) );\n \t\tcollection.setNodeName( propertyName );\n \n \t\tif ( (property.isAnnotationPresent( org.hibernate.annotations.MapKey.class )\n \t\t\t\t|| property.isAnnotationPresent( MapKeyColumn.class ) )\n \t\t\t&& mapKeyPropertyName != null ) {\n \t\t\tthrow new AnnotationException(\n \t\t\t\t\t\"Cannot mix @javax.persistence.MapKey and @MapKeyColumn or @org.hibernate.annotations.MapKey \"\n \t\t\t\t\t\t\t+ \"on the same collection: \" + StringHelper.qualify(\n \t\t\t\t\t\t\tpropertyHolder.getPath(), propertyName\n \t\t\t\t\t)\n \t\t\t);\n \t\t}\n \n \t\t//set laziness\n \t\tdefineFetchingStrategy();\n \t\tcollection.setBatchSize( batchSize );\n \t\tif ( orderBy != null && hqlOrderBy != null ) {\n \t\t\tthrow new AnnotationException(\n \t\t\t\t\t\"Cannot use sql order by clause in conjunction of EJB3 order by clause: \" + safeCollectionRole()\n \t\t\t);\n \t\t}\n \n \t\tcollection.setMutable( !property.isAnnotationPresent( Immutable.class ) );\n \t\tOptimisticLock lockAnn = property.getAnnotation( OptimisticLock.class );\n \t\tif ( lockAnn != null ) collection.setOptimisticLocked( !lockAnn.excluded() );\n \t\tPersister persisterAnn = property.getAnnotation( Persister.class );\n \t\tif ( persisterAnn != null ) collection.setCollectionPersisterClass( persisterAnn.impl() );\n \n \t\t// set ordering\n \t\tif ( orderBy != null ) collection.setOrderBy( orderBy );\n \t\tif ( isSorted ) {\n \t\t\tcollection.setSorted( true );\n \t\t\tif ( comparator != null ) {\n \t\t\t\ttry {\n \t\t\t\t\tcollection.setComparator( (Comparator) comparator.newInstance() );\n \t\t\t\t}\n \t\t\t\tcatch (ClassCastException e) {\n \t\t\t\t\tthrow new AnnotationException(\n \t\t\t\t\t\t\t\"Comparator not implementing java.util.Comparator class: \"\n \t\t\t\t\t\t\t\t\t+ comparator.getName() + \"(\" + safeCollectionRole() + \")\"\n \t\t\t\t\t);\n \t\t\t\t}\n \t\t\t\tcatch (Exception e) {\n \t\t\t\t\tthrow new AnnotationException(\n \t\t\t\t\t\t\t\"Could not instantiate comparator class: \"\n \t\t\t\t\t\t\t\t\t+ comparator.getName() + \"(\" + safeCollectionRole() + \")\"\n \t\t\t\t\t);\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\telse {\n \t\t\tif ( hasToBeSorted ) {\n \t\t\t\tthrow new AnnotationException(\n \t\t\t\t\t\t\"A sorted collection has to define @Sort: \"\n \t\t\t\t\t\t\t\t+ safeCollectionRole()\n \t\t\t\t);\n \t\t\t}\n \t\t}\n \n \t\t//set cache\n \t\tif ( StringHelper.isNotEmpty( cacheConcurrencyStrategy ) ) {\n \t\t\tcollection.setCacheConcurrencyStrategy( cacheConcurrencyStrategy );\n \t\t\tcollection.setCacheRegionName( cacheRegionName );\n \t\t}\n \n \t\t//SQL overriding\n \t\tSQLInsert sqlInsert = property.getAnnotation( SQLInsert.class );\n \t\tSQLUpdate sqlUpdate = property.getAnnotation( SQLUpdate.class );\n \t\tSQLDelete sqlDelete = property.getAnnotation( SQLDelete.class );\n \t\tSQLDeleteAll sqlDeleteAll = property.getAnnotation( SQLDeleteAll.class );\n \t\tLoader loader = property.getAnnotation( Loader.class );\n \t\tif ( sqlInsert != null ) {\n \t\t\tcollection.setCustomSQLInsert( sqlInsert.sql().trim(), sqlInsert.callable(),\n \t\t\t\t\tExecuteUpdateResultCheckStyle.parse( sqlInsert.check().toString().toLowerCase() )\n \t\t\t);\n \n \t\t}\n \t\tif ( sqlUpdate != null ) {\n \t\t\tcollection.setCustomSQLUpdate( sqlUpdate.sql(), sqlUpdate.callable(),\n \t\t\t\t\tExecuteUpdateResultCheckStyle.parse( sqlUpdate.check().toString().toLowerCase() )\n \t\t\t);\n \t\t}\n \t\tif ( sqlDelete != null ) {\n \t\t\tcollection.setCustomSQLDelete( sqlDelete.sql(), sqlDelete.callable(),\n \t\t\t\t\tExecuteUpdateResultCheckStyle.parse( sqlDelete.check().toString().toLowerCase() )\n \t\t\t);\n \t\t}\n \t\tif ( sqlDeleteAll != null ) {\n \t\t\tcollection.setCustomSQLDeleteAll( sqlDeleteAll.sql(), sqlDeleteAll.callable(),\n \t\t\t\t\tExecuteUpdateResultCheckStyle.parse( sqlDeleteAll.check().toString().toLowerCase() )\n \t\t\t);\n \t\t}\n \t\tif ( loader != null ) {\n \t\t\tcollection.setLoaderName( loader.namedQuery() );\n \t\t}\n \n \t\t//work on association\n \t\tboolean isMappedBy = !BinderHelper.isDefault( mappedBy );\n \n \t\tif (isMappedBy\n \t\t\t\t&& (property.isAnnotationPresent( JoinColumn.class )\n \t\t\t\t\t|| property.isAnnotationPresent( JoinColumns.class )\n \t\t\t\t\t|| propertyHolder.getJoinTable( property ) != null ) ) {\n \t\t\tString message = \"Associations marked as mappedBy must not define database mappings like @JoinTable or @JoinColumn: \";\n \t\t\tmessage += StringHelper.qualify( propertyHolder.getPath(), propertyName );\n \t\t\tthrow new AnnotationException( message );\n \t\t}\n \n \t\tcollection.setInverse( isMappedBy );\n \n \t\t//many to many may need some second pass informations\n \t\tif ( !oneToMany && isMappedBy ) {\n \t\t\tmappings.addMappedBy( getCollectionType().getName(), mappedBy, propertyName );\n \t\t}\n \t\t//TODO reducce tableBinder != null and oneToMany\n \t\tXClass collectionType = getCollectionType();\n \t\tif ( inheritanceStatePerClass == null) throw new AssertionFailure( \"inheritanceStatePerClass not set\" );\n \t\tSecondPass sp = getSecondPass(\n \t\t\t\tfkJoinColumns,\n \t\t\t\tjoinColumns,\n \t\t\t\tinverseJoinColumns,\n \t\t\t\telementColumns,\n \t\t\t\tmapKeyColumns, mapKeyManyToManyColumns, isEmbedded,\n \t\t\t\tproperty, collectionType,\n \t\t\t\tignoreNotFound, oneToMany,\n \t\t\t\ttableBinder, mappings\n \t\t);\n \t\tif ( collectionType.isAnnotationPresent( Embeddable.class )\n \t\t\t\t|| property.isAnnotationPresent( CollectionOfElements.class ) //legacy hibernate\n \t\t\t\t|| property.isAnnotationPresent( ElementCollection.class ) //JPA 2\n \t\t\t\t) {\n \t\t\t// do it right away, otherwise @ManyToOne on composite element call addSecondPass\n \t\t\t// and raise a ConcurrentModificationException\n \t\t\t//sp.doSecondPass( CollectionHelper.EMPTY_MAP );\n \t\t\tmappings.addSecondPass( sp, !isMappedBy );\n \t\t}\n \t\telse {\n \t\t\tmappings.addSecondPass( sp, !isMappedBy );\n \t\t}\n \n \t\tmappings.addCollection( collection );\n \n \t\t//property building\n \t\tPropertyBinder binder = new PropertyBinder();\n \t\tbinder.setName( propertyName );\n \t\tbinder.setValue( collection );\n \t\tbinder.setCascade( cascadeStrategy );\n \t\tif ( cascadeStrategy != null && cascadeStrategy.indexOf( \"delete-orphan\" ) >= 0 ) {\n \t\t\tcollection.setOrphanDelete( true );\n \t\t}\n \t\tbinder.setAccessType( accessType );\n \t\tbinder.setProperty( property );\n \t\tbinder.setInsertable( insertable );\n \t\tbinder.setUpdatable( updatable );\n-\t\tProperty prop = binder.make();\n+\t\tProperty prop = binder.makeProperty();\n \t\t//we don't care about the join stuffs because the column is on the association table.\n \t\tif (! declaringClassSet) throw new AssertionFailure( \"DeclaringClass is not set in CollectionBinder while binding\" );\n \t\tpropertyHolder.addProperty( prop, declaringClass );\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"b1f925458eeb636897bf8a053712ed25fff39054": {
			"type": "Ybodychange",
			"commitMessage": "HHH-4782 supports @AssociationOverride.joinTable\nHHH-4679 add tests for dot notations in @AssocuiationOverride\n\ngit-svn-id: https://svn.jboss.org/repos/hibernate/core/trunk@18518 1b8cb986-b30d-0410-93ca-fae66ebed9b2\n",
			"commitDate": "2010-01-12, 11:48 AM",
			"commitName": "b1f925458eeb636897bf8a053712ed25fff39054",
			"commitAuthor": "Emmanuel Bernard",
			"commitDateOld": "2010-01-08, 9:58 AM",
			"commitNameOld": "e44b5f197d77e1d1a847cd04eaa0d25254362483",
			"commitAuthorOld": "Emmanuel Bernard",
			"daysBetweenCommits": 4.08,
			"commitsBetweenForRepo": 24,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,163 +1,163 @@\n \tpublic void bind() {\n \t\tthis.collection = createCollection( propertyHolder.getPersistentClass() );\n \t\tlog.debug( \"Collection role: {}\", StringHelper.qualify( propertyHolder.getPath(), propertyName ) );\n \t\tcollection.setRole( StringHelper.qualify( propertyHolder.getPath(), propertyName ) );\n \t\tcollection.setNodeName( propertyName );\n \n \t\tif ( (property.isAnnotationPresent( org.hibernate.annotations.MapKey.class )\n \t\t\t\t|| property.isAnnotationPresent( MapKeyColumn.class ) )\n \t\t\t&& mapKeyPropertyName != null ) {\n \t\t\tthrow new AnnotationException(\n \t\t\t\t\t\"Cannot mix @javax.persistence.MapKey and @MapKeyColumn or @org.hibernate.annotations.MapKey \"\n \t\t\t\t\t\t\t+ \"on the same collection: \" + StringHelper.qualify(\n \t\t\t\t\t\t\tpropertyHolder.getPath(), propertyName\n \t\t\t\t\t)\n \t\t\t);\n \t\t}\n \n \t\t//set laziness\n \t\tdefineFetchingStrategy();\n \t\tcollection.setBatchSize( batchSize );\n \t\tif ( orderBy != null && hqlOrderBy != null ) {\n \t\t\tthrow new AnnotationException(\n \t\t\t\t\t\"Cannot use sql order by clause in conjunction of EJB3 order by clause: \" + safeCollectionRole()\n \t\t\t);\n \t\t}\n \n \t\tcollection.setMutable( !property.isAnnotationPresent( Immutable.class ) );\n \t\tOptimisticLock lockAnn = property.getAnnotation( OptimisticLock.class );\n \t\tif ( lockAnn != null ) collection.setOptimisticLocked( !lockAnn.excluded() );\n \t\tPersister persisterAnn = property.getAnnotation( Persister.class );\n \t\tif ( persisterAnn != null ) collection.setCollectionPersisterClass( persisterAnn.impl() );\n \n \t\t// set ordering\n \t\tif ( orderBy != null ) collection.setOrderBy( orderBy );\n \t\tif ( isSorted ) {\n \t\t\tcollection.setSorted( true );\n \t\t\tif ( comparator != null ) {\n \t\t\t\ttry {\n \t\t\t\t\tcollection.setComparator( (Comparator) comparator.newInstance() );\n \t\t\t\t}\n \t\t\t\tcatch (ClassCastException e) {\n \t\t\t\t\tthrow new AnnotationException(\n \t\t\t\t\t\t\t\"Comparator not implementing java.util.Comparator class: \"\n \t\t\t\t\t\t\t\t\t+ comparator.getName() + \"(\" + safeCollectionRole() + \")\"\n \t\t\t\t\t);\n \t\t\t\t}\n \t\t\t\tcatch (Exception e) {\n \t\t\t\t\tthrow new AnnotationException(\n \t\t\t\t\t\t\t\"Could not instantiate comparator class: \"\n \t\t\t\t\t\t\t\t\t+ comparator.getName() + \"(\" + safeCollectionRole() + \")\"\n \t\t\t\t\t);\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\telse {\n \t\t\tif ( hasToBeSorted ) {\n \t\t\t\tthrow new AnnotationException(\n \t\t\t\t\t\t\"A sorted collection has to define @Sort: \"\n \t\t\t\t\t\t\t\t+ safeCollectionRole()\n \t\t\t\t);\n \t\t\t}\n \t\t}\n \n \t\t//set cache\n \t\tif ( StringHelper.isNotEmpty( cacheConcurrencyStrategy ) ) {\n \t\t\tcollection.setCacheConcurrencyStrategy( cacheConcurrencyStrategy );\n \t\t\tcollection.setCacheRegionName( cacheRegionName );\n \t\t}\n \n \t\t//SQL overriding\n \t\tSQLInsert sqlInsert = property.getAnnotation( SQLInsert.class );\n \t\tSQLUpdate sqlUpdate = property.getAnnotation( SQLUpdate.class );\n \t\tSQLDelete sqlDelete = property.getAnnotation( SQLDelete.class );\n \t\tSQLDeleteAll sqlDeleteAll = property.getAnnotation( SQLDeleteAll.class );\n \t\tLoader loader = property.getAnnotation( Loader.class );\n \t\tif ( sqlInsert != null ) {\n \t\t\tcollection.setCustomSQLInsert( sqlInsert.sql().trim(), sqlInsert.callable(),\n \t\t\t\t\tExecuteUpdateResultCheckStyle.parse( sqlInsert.check().toString().toLowerCase() )\n \t\t\t);\n \n \t\t}\n \t\tif ( sqlUpdate != null ) {\n \t\t\tcollection.setCustomSQLUpdate( sqlUpdate.sql(), sqlUpdate.callable(),\n \t\t\t\t\tExecuteUpdateResultCheckStyle.parse( sqlUpdate.check().toString().toLowerCase() )\n \t\t\t);\n \t\t}\n \t\tif ( sqlDelete != null ) {\n \t\t\tcollection.setCustomSQLDelete( sqlDelete.sql(), sqlDelete.callable(),\n \t\t\t\t\tExecuteUpdateResultCheckStyle.parse( sqlDelete.check().toString().toLowerCase() )\n \t\t\t);\n \t\t}\n \t\tif ( sqlDeleteAll != null ) {\n \t\t\tcollection.setCustomSQLDeleteAll( sqlDeleteAll.sql(), sqlDeleteAll.callable(),\n \t\t\t\t\tExecuteUpdateResultCheckStyle.parse( sqlDeleteAll.check().toString().toLowerCase() )\n \t\t\t);\n \t\t}\n \t\tif ( loader != null ) {\n \t\t\tcollection.setLoaderName( loader.namedQuery() );\n \t\t}\n \n \t\t//work on association\n \t\tboolean isMappedBy = !BinderHelper.isDefault( mappedBy );\n \n \t\tif (isMappedBy\n \t\t\t\t&& (property.isAnnotationPresent( JoinColumn.class )\n \t\t\t\t\t|| property.isAnnotationPresent( JoinColumns.class )\n-\t\t\t\t\t|| property.isAnnotationPresent( JoinTable.class ) ) ) {\n+\t\t\t\t\t|| propertyHolder.getJoinTable( property ) != null ) ) {\n \t\t\tString message = \"Associations marked as mappedBy must not define database mappings like @JoinTable or @JoinColumn: \";\n \t\t\tmessage += StringHelper.qualify( propertyHolder.getPath(), propertyName );\n \t\t\tthrow new AnnotationException( message );\n \t\t}\n \n \t\tcollection.setInverse( isMappedBy );\n \n \t\t//many to many may need some second pass informations\n \t\tif ( !oneToMany && isMappedBy ) {\n \t\t\tmappings.addMappedBy( getCollectionType().getName(), mappedBy, propertyName );\n \t\t}\n \t\t//TODO reducce tableBinder != null and oneToMany\n \t\tXClass collectionType = getCollectionType();\n \t\tif ( inheritanceStatePerClass == null) throw new AssertionFailure( \"inheritanceStatePerClass not set\" );\n \t\tSecondPass sp = getSecondPass(\n \t\t\t\tfkJoinColumns,\n \t\t\t\tjoinColumns,\n \t\t\t\tinverseJoinColumns,\n \t\t\t\telementColumns,\n \t\t\t\tmapKeyColumns, mapKeyManyToManyColumns, isEmbedded,\n \t\t\t\tproperty, collectionType,\n \t\t\t\tignoreNotFound, oneToMany,\n \t\t\t\ttableBinder, mappings\n \t\t);\n \t\tif ( collectionType.isAnnotationPresent( Embeddable.class )\n \t\t\t\t|| property.isAnnotationPresent( CollectionOfElements.class ) //legacy hibernate\n \t\t\t\t|| property.isAnnotationPresent( ElementCollection.class ) //JPA 2\n \t\t\t\t) {\n \t\t\t// do it right away, otherwise @ManyToOne on composite element call addSecondPass\n \t\t\t// and raise a ConcurrentModificationException\n \t\t\t//sp.doSecondPass( CollectionHelper.EMPTY_MAP );\n \t\t\tmappings.addSecondPass( sp, !isMappedBy );\n \t\t}\n \t\telse {\n \t\t\tmappings.addSecondPass( sp, !isMappedBy );\n \t\t}\n \n \t\tmappings.addCollection( collection );\n \n \t\t//property building\n \t\tPropertyBinder binder = new PropertyBinder();\n \t\tbinder.setName( propertyName );\n \t\tbinder.setValue( collection );\n \t\tbinder.setCascade( cascadeStrategy );\n \t\tif ( cascadeStrategy != null && cascadeStrategy.indexOf( \"delete-orphan\" ) >= 0 ) {\n \t\t\tcollection.setOrphanDelete( true );\n \t\t}\n \t\tbinder.setAccessType( accessType );\n \t\tbinder.setProperty( property );\n \t\tbinder.setInsertable( insertable );\n \t\tbinder.setUpdatable( updatable );\n \t\tProperty prop = binder.make();\n \t\t//we don't care about the join stuffs because the column is on the association table.\n \t\tif (! declaringClassSet) throw new AssertionFailure( \"DeclaringClass is not set in CollectionBinder while binding\" );\n \t\tpropertyHolder.addProperty( prop, declaringClass );\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"e44b5f197d77e1d1a847cd04eaa0d25254362483": {
			"type": "Ybodychange",
			"commitMessage": "HHH-4771 @ElementCollection fk column should default to entityName_columnNameOfOwningId\n\ngit-svn-id: https://svn.jboss.org/repos/hibernate/core/trunk@18455 1b8cb986-b30d-0410-93ca-fae66ebed9b2\n",
			"commitDate": "2010-01-08, 9:58 AM",
			"commitName": "e44b5f197d77e1d1a847cd04eaa0d25254362483",
			"commitAuthor": "Emmanuel Bernard",
			"commitDateOld": "2010-01-07, 10:41 AM",
			"commitNameOld": "9ef2317e28887cf48d8fb96775b24ec832386d3f",
			"commitAuthorOld": "Scott Marlow",
			"daysBetweenCommits": 0.97,
			"commitsBetweenForRepo": 11,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,162 +1,163 @@\n \tpublic void bind() {\n \t\tthis.collection = createCollection( propertyHolder.getPersistentClass() );\n \t\tlog.debug( \"Collection role: {}\", StringHelper.qualify( propertyHolder.getPath(), propertyName ) );\n \t\tcollection.setRole( StringHelper.qualify( propertyHolder.getPath(), propertyName ) );\n \t\tcollection.setNodeName( propertyName );\n \n \t\tif ( (property.isAnnotationPresent( org.hibernate.annotations.MapKey.class )\n \t\t\t\t|| property.isAnnotationPresent( MapKeyColumn.class ) )\n \t\t\t&& mapKeyPropertyName != null ) {\n \t\t\tthrow new AnnotationException(\n \t\t\t\t\t\"Cannot mix @javax.persistence.MapKey and @MapKeyColumn or @org.hibernate.annotations.MapKey \"\n \t\t\t\t\t\t\t+ \"on the same collection: \" + StringHelper.qualify(\n \t\t\t\t\t\t\tpropertyHolder.getPath(), propertyName\n \t\t\t\t\t)\n \t\t\t);\n \t\t}\n \n \t\t//set laziness\n \t\tdefineFetchingStrategy();\n \t\tcollection.setBatchSize( batchSize );\n \t\tif ( orderBy != null && hqlOrderBy != null ) {\n \t\t\tthrow new AnnotationException(\n \t\t\t\t\t\"Cannot use sql order by clause in conjunction of EJB3 order by clause: \" + safeCollectionRole()\n \t\t\t);\n \t\t}\n \n \t\tcollection.setMutable( !property.isAnnotationPresent( Immutable.class ) );\n \t\tOptimisticLock lockAnn = property.getAnnotation( OptimisticLock.class );\n \t\tif ( lockAnn != null ) collection.setOptimisticLocked( !lockAnn.excluded() );\n \t\tPersister persisterAnn = property.getAnnotation( Persister.class );\n \t\tif ( persisterAnn != null ) collection.setCollectionPersisterClass( persisterAnn.impl() );\n \n \t\t// set ordering\n \t\tif ( orderBy != null ) collection.setOrderBy( orderBy );\n \t\tif ( isSorted ) {\n \t\t\tcollection.setSorted( true );\n \t\t\tif ( comparator != null ) {\n \t\t\t\ttry {\n \t\t\t\t\tcollection.setComparator( (Comparator) comparator.newInstance() );\n \t\t\t\t}\n \t\t\t\tcatch (ClassCastException e) {\n \t\t\t\t\tthrow new AnnotationException(\n \t\t\t\t\t\t\t\"Comparator not implementing java.util.Comparator class: \"\n \t\t\t\t\t\t\t\t\t+ comparator.getName() + \"(\" + safeCollectionRole() + \")\"\n \t\t\t\t\t);\n \t\t\t\t}\n \t\t\t\tcatch (Exception e) {\n \t\t\t\t\tthrow new AnnotationException(\n \t\t\t\t\t\t\t\"Could not instantiate comparator class: \"\n \t\t\t\t\t\t\t\t\t+ comparator.getName() + \"(\" + safeCollectionRole() + \")\"\n \t\t\t\t\t);\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\telse {\n \t\t\tif ( hasToBeSorted ) {\n \t\t\t\tthrow new AnnotationException(\n \t\t\t\t\t\t\"A sorted collection has to define @Sort: \"\n \t\t\t\t\t\t\t\t+ safeCollectionRole()\n \t\t\t\t);\n \t\t\t}\n \t\t}\n \n \t\t//set cache\n \t\tif ( StringHelper.isNotEmpty( cacheConcurrencyStrategy ) ) {\n \t\t\tcollection.setCacheConcurrencyStrategy( cacheConcurrencyStrategy );\n \t\t\tcollection.setCacheRegionName( cacheRegionName );\n \t\t}\n \n \t\t//SQL overriding\n \t\tSQLInsert sqlInsert = property.getAnnotation( SQLInsert.class );\n \t\tSQLUpdate sqlUpdate = property.getAnnotation( SQLUpdate.class );\n \t\tSQLDelete sqlDelete = property.getAnnotation( SQLDelete.class );\n \t\tSQLDeleteAll sqlDeleteAll = property.getAnnotation( SQLDeleteAll.class );\n \t\tLoader loader = property.getAnnotation( Loader.class );\n \t\tif ( sqlInsert != null ) {\n \t\t\tcollection.setCustomSQLInsert( sqlInsert.sql().trim(), sqlInsert.callable(),\n \t\t\t\t\tExecuteUpdateResultCheckStyle.parse( sqlInsert.check().toString().toLowerCase() )\n \t\t\t);\n \n \t\t}\n \t\tif ( sqlUpdate != null ) {\n \t\t\tcollection.setCustomSQLUpdate( sqlUpdate.sql(), sqlUpdate.callable(),\n \t\t\t\t\tExecuteUpdateResultCheckStyle.parse( sqlUpdate.check().toString().toLowerCase() )\n \t\t\t);\n \t\t}\n \t\tif ( sqlDelete != null ) {\n \t\t\tcollection.setCustomSQLDelete( sqlDelete.sql(), sqlDelete.callable(),\n \t\t\t\t\tExecuteUpdateResultCheckStyle.parse( sqlDelete.check().toString().toLowerCase() )\n \t\t\t);\n \t\t}\n \t\tif ( sqlDeleteAll != null ) {\n \t\t\tcollection.setCustomSQLDeleteAll( sqlDeleteAll.sql(), sqlDeleteAll.callable(),\n \t\t\t\t\tExecuteUpdateResultCheckStyle.parse( sqlDeleteAll.check().toString().toLowerCase() )\n \t\t\t);\n \t\t}\n \t\tif ( loader != null ) {\n \t\t\tcollection.setLoaderName( loader.namedQuery() );\n \t\t}\n \n \t\t//work on association\n \t\tboolean isMappedBy = !BinderHelper.isDefault( mappedBy );\n \n \t\tif (isMappedBy\n \t\t\t\t&& (property.isAnnotationPresent( JoinColumn.class )\n+\t\t\t\t\t|| property.isAnnotationPresent( JoinColumns.class )\n \t\t\t\t\t|| property.isAnnotationPresent( JoinTable.class ) ) ) {\n \t\t\tString message = \"Associations marked as mappedBy must not define database mappings like @JoinTable or @JoinColumn: \";\n \t\t\tmessage += StringHelper.qualify( propertyHolder.getPath(), propertyName );\n \t\t\tthrow new AnnotationException( message );\n \t\t}\n \n \t\tcollection.setInverse( isMappedBy );\n \n \t\t//many to many may need some second pass informations\n \t\tif ( !oneToMany && isMappedBy ) {\n \t\t\tmappings.addMappedBy( getCollectionType().getName(), mappedBy, propertyName );\n \t\t}\n \t\t//TODO reducce tableBinder != null and oneToMany\n \t\tXClass collectionType = getCollectionType();\n \t\tif ( inheritanceStatePerClass == null) throw new AssertionFailure( \"inheritanceStatePerClass not set\" );\n \t\tSecondPass sp = getSecondPass(\n \t\t\t\tfkJoinColumns,\n \t\t\t\tjoinColumns,\n \t\t\t\tinverseJoinColumns,\n \t\t\t\telementColumns,\n \t\t\t\tmapKeyColumns, mapKeyManyToManyColumns, isEmbedded,\n \t\t\t\tproperty, collectionType,\n \t\t\t\tignoreNotFound, oneToMany,\n \t\t\t\ttableBinder, mappings\n \t\t);\n \t\tif ( collectionType.isAnnotationPresent( Embeddable.class )\n \t\t\t\t|| property.isAnnotationPresent( CollectionOfElements.class ) //legacy hibernate\n \t\t\t\t|| property.isAnnotationPresent( ElementCollection.class ) //JPA 2\n \t\t\t\t) {\n \t\t\t// do it right away, otherwise @ManyToOne on composite element call addSecondPass\n \t\t\t// and raise a ConcurrentModificationException\n \t\t\t//sp.doSecondPass( CollectionHelper.EMPTY_MAP );\n \t\t\tmappings.addSecondPass( sp, !isMappedBy );\n \t\t}\n \t\telse {\n \t\t\tmappings.addSecondPass( sp, !isMappedBy );\n \t\t}\n \n \t\tmappings.addCollection( collection );\n \n \t\t//property building\n \t\tPropertyBinder binder = new PropertyBinder();\n \t\tbinder.setName( propertyName );\n \t\tbinder.setValue( collection );\n \t\tbinder.setCascade( cascadeStrategy );\n \t\tif ( cascadeStrategy != null && cascadeStrategy.indexOf( \"delete-orphan\" ) >= 0 ) {\n \t\t\tcollection.setOrphanDelete( true );\n \t\t}\n \t\tbinder.setAccessType( accessType );\n \t\tbinder.setProperty( property );\n \t\tbinder.setInsertable( insertable );\n \t\tbinder.setUpdatable( updatable );\n \t\tProperty prop = binder.make();\n \t\t//we don't care about the join stuffs because the column is on the association table.\n \t\tif (! declaringClassSet) throw new AssertionFailure( \"DeclaringClass is not set in CollectionBinder while binding\" );\n \t\tpropertyHolder.addProperty( prop, declaringClass );\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"658df91a5e308fd1d97cec62acf6110143012592": {
			"type": "Ybodychange",
			"commitMessage": "HHH-4283 fix the incorrect test case and add a proper exception when the user error occurs\n\ngit-svn-id: https://svn.jboss.org/repos/hibernate/core/trunk@18421 1b8cb986-b30d-0410-93ca-fae66ebed9b2\n",
			"commitDate": "2010-01-06, 10:28 AM",
			"commitName": "658df91a5e308fd1d97cec62acf6110143012592",
			"commitAuthor": "Emmanuel Bernard",
			"commitDateOld": "2010-01-06, 9:59 AM",
			"commitNameOld": "71d9459a20c4f769a205b70537fe416bd992e76e",
			"commitAuthorOld": "Scott Marlow",
			"daysBetweenCommits": 0.02,
			"commitsBetweenForRepo": 2,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,153 +1,162 @@\n \tpublic void bind() {\n \t\tthis.collection = createCollection( propertyHolder.getPersistentClass() );\n \t\tlog.debug( \"Collection role: {}\", StringHelper.qualify( propertyHolder.getPath(), propertyName ) );\n \t\tcollection.setRole( StringHelper.qualify( propertyHolder.getPath(), propertyName ) );\n \t\tcollection.setNodeName( propertyName );\n \n \t\tif ( (property.isAnnotationPresent( org.hibernate.annotations.MapKey.class )\n \t\t\t\t|| property.isAnnotationPresent( MapKeyColumn.class ) )\n \t\t\t&& mapKeyPropertyName != null ) {\n \t\t\tthrow new AnnotationException(\n \t\t\t\t\t\"Cannot mix @javax.persistence.MapKey and @MapKeyColumn or @org.hibernate.annotations.MapKey \"\n \t\t\t\t\t\t\t+ \"on the same collection: \" + StringHelper.qualify(\n \t\t\t\t\t\t\tpropertyHolder.getPath(), propertyName\n \t\t\t\t\t)\n \t\t\t);\n \t\t}\n \n \t\t//set laziness\n \t\tdefineFetchingStrategy();\n \t\tcollection.setBatchSize( batchSize );\n \t\tif ( orderBy != null && hqlOrderBy != null ) {\n \t\t\tthrow new AnnotationException(\n \t\t\t\t\t\"Cannot use sql order by clause in conjunction of EJB3 order by clause: \" + safeCollectionRole()\n \t\t\t);\n \t\t}\n \n \t\tcollection.setMutable( !property.isAnnotationPresent( Immutable.class ) );\n \t\tOptimisticLock lockAnn = property.getAnnotation( OptimisticLock.class );\n \t\tif ( lockAnn != null ) collection.setOptimisticLocked( !lockAnn.excluded() );\n \t\tPersister persisterAnn = property.getAnnotation( Persister.class );\n \t\tif ( persisterAnn != null ) collection.setCollectionPersisterClass( persisterAnn.impl() );\n \n \t\t// set ordering\n \t\tif ( orderBy != null ) collection.setOrderBy( orderBy );\n \t\tif ( isSorted ) {\n \t\t\tcollection.setSorted( true );\n \t\t\tif ( comparator != null ) {\n \t\t\t\ttry {\n \t\t\t\t\tcollection.setComparator( (Comparator) comparator.newInstance() );\n \t\t\t\t}\n \t\t\t\tcatch (ClassCastException e) {\n \t\t\t\t\tthrow new AnnotationException(\n \t\t\t\t\t\t\t\"Comparator not implementing java.util.Comparator class: \"\n \t\t\t\t\t\t\t\t\t+ comparator.getName() + \"(\" + safeCollectionRole() + \")\"\n \t\t\t\t\t);\n \t\t\t\t}\n \t\t\t\tcatch (Exception e) {\n \t\t\t\t\tthrow new AnnotationException(\n \t\t\t\t\t\t\t\"Could not instantiate comparator class: \"\n \t\t\t\t\t\t\t\t\t+ comparator.getName() + \"(\" + safeCollectionRole() + \")\"\n \t\t\t\t\t);\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\telse {\n \t\t\tif ( hasToBeSorted ) {\n \t\t\t\tthrow new AnnotationException(\n \t\t\t\t\t\t\"A sorted collection has to define @Sort: \"\n \t\t\t\t\t\t\t\t+ safeCollectionRole()\n \t\t\t\t);\n \t\t\t}\n \t\t}\n \n \t\t//set cache\n \t\tif ( StringHelper.isNotEmpty( cacheConcurrencyStrategy ) ) {\n \t\t\tcollection.setCacheConcurrencyStrategy( cacheConcurrencyStrategy );\n \t\t\tcollection.setCacheRegionName( cacheRegionName );\n \t\t}\n \n \t\t//SQL overriding\n \t\tSQLInsert sqlInsert = property.getAnnotation( SQLInsert.class );\n \t\tSQLUpdate sqlUpdate = property.getAnnotation( SQLUpdate.class );\n \t\tSQLDelete sqlDelete = property.getAnnotation( SQLDelete.class );\n \t\tSQLDeleteAll sqlDeleteAll = property.getAnnotation( SQLDeleteAll.class );\n \t\tLoader loader = property.getAnnotation( Loader.class );\n \t\tif ( sqlInsert != null ) {\n \t\t\tcollection.setCustomSQLInsert( sqlInsert.sql().trim(), sqlInsert.callable(),\n \t\t\t\t\tExecuteUpdateResultCheckStyle.parse( sqlInsert.check().toString().toLowerCase() )\n \t\t\t);\n \n \t\t}\n \t\tif ( sqlUpdate != null ) {\n \t\t\tcollection.setCustomSQLUpdate( sqlUpdate.sql(), sqlUpdate.callable(),\n \t\t\t\t\tExecuteUpdateResultCheckStyle.parse( sqlUpdate.check().toString().toLowerCase() )\n \t\t\t);\n \t\t}\n \t\tif ( sqlDelete != null ) {\n \t\t\tcollection.setCustomSQLDelete( sqlDelete.sql(), sqlDelete.callable(),\n \t\t\t\t\tExecuteUpdateResultCheckStyle.parse( sqlDelete.check().toString().toLowerCase() )\n \t\t\t);\n \t\t}\n \t\tif ( sqlDeleteAll != null ) {\n \t\t\tcollection.setCustomSQLDeleteAll( sqlDeleteAll.sql(), sqlDeleteAll.callable(),\n \t\t\t\t\tExecuteUpdateResultCheckStyle.parse( sqlDeleteAll.check().toString().toLowerCase() )\n \t\t\t);\n \t\t}\n \t\tif ( loader != null ) {\n \t\t\tcollection.setLoaderName( loader.namedQuery() );\n \t\t}\n \n \t\t//work on association\n \t\tboolean isMappedBy = !BinderHelper.isDefault( mappedBy );\n+\n+\t\tif (isMappedBy\n+\t\t\t\t&& (property.isAnnotationPresent( JoinColumn.class )\n+\t\t\t\t\t|| property.isAnnotationPresent( JoinTable.class ) ) ) {\n+\t\t\tString message = \"Associations marked as mappedBy must not define database mappings like @JoinTable or @JoinColumn: \";\n+\t\t\tmessage += StringHelper.qualify( propertyHolder.getPath(), propertyName );\n+\t\t\tthrow new AnnotationException( message );\n+\t\t}\n+\n \t\tcollection.setInverse( isMappedBy );\n \n \t\t//many to many may need some second pass informations\n \t\tif ( !oneToMany && isMappedBy ) {\n \t\t\tmappings.addMappedBy( getCollectionType().getName(), mappedBy, propertyName );\n \t\t}\n \t\t//TODO reducce tableBinder != null and oneToMany\n \t\tXClass collectionType = getCollectionType();\n \t\tif ( inheritanceStatePerClass == null) throw new AssertionFailure( \"inheritanceStatePerClass not set\" );\n \t\tSecondPass sp = getSecondPass(\n \t\t\t\tfkJoinColumns,\n \t\t\t\tjoinColumns,\n \t\t\t\tinverseJoinColumns,\n \t\t\t\telementColumns,\n \t\t\t\tmapKeyColumns, mapKeyManyToManyColumns, isEmbedded,\n \t\t\t\tproperty, collectionType,\n \t\t\t\tignoreNotFound, oneToMany,\n \t\t\t\ttableBinder, mappings\n \t\t);\n \t\tif ( collectionType.isAnnotationPresent( Embeddable.class )\n \t\t\t\t|| property.isAnnotationPresent( CollectionOfElements.class ) //legacy hibernate\n \t\t\t\t|| property.isAnnotationPresent( ElementCollection.class ) //JPA 2\n \t\t\t\t) {\n-\t\t\t// do it right away, otherwise @ManyToon on composite element call addSecondPass \n+\t\t\t// do it right away, otherwise @ManyToOne on composite element call addSecondPass\n \t\t\t// and raise a ConcurrentModificationException\n \t\t\t//sp.doSecondPass( CollectionHelper.EMPTY_MAP );\n \t\t\tmappings.addSecondPass( sp, !isMappedBy );\n \t\t}\n \t\telse {\n \t\t\tmappings.addSecondPass( sp, !isMappedBy );\n \t\t}\n \n \t\tmappings.addCollection( collection );\n \n \t\t//property building\n \t\tPropertyBinder binder = new PropertyBinder();\n \t\tbinder.setName( propertyName );\n \t\tbinder.setValue( collection );\n \t\tbinder.setCascade( cascadeStrategy );\n \t\tif ( cascadeStrategy != null && cascadeStrategy.indexOf( \"delete-orphan\" ) >= 0 ) {\n \t\t\tcollection.setOrphanDelete( true );\n \t\t}\n \t\tbinder.setAccessType( accessType );\n \t\tbinder.setProperty( property );\n \t\tbinder.setInsertable( insertable );\n \t\tbinder.setUpdatable( updatable );\n \t\tProperty prop = binder.make();\n \t\t//we don't care about the join stuffs because the column is on the association table.\n \t\tif (! declaringClassSet) throw new AssertionFailure( \"DeclaringClass is not set in CollectionBinder while binding\" );\n \t\tpropertyHolder.addProperty( prop, declaringClass );\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"4a9d8dcf0b054d4dc769b463145c1fdecede6e09": {
			"type": "Ybodychange",
			"commitMessage": " HHH-4527 - first cut for supporting JPA2 @Access annotation. Not quite complete and needs some more tests.\n\ngit-svn-id: https://svn.jboss.org/repos/hibernate/core/trunk@18260 1b8cb986-b30d-0410-93ca-fae66ebed9b2\n",
			"commitDate": "2009-12-17, 2:14 PM",
			"commitName": "4a9d8dcf0b054d4dc769b463145c1fdecede6e09",
			"commitAuthor": "Hardy Ferentschik",
			"commitDateOld": "2009-10-28, 12:14 PM",
			"commitNameOld": "c7c6981a558e35f01ff8d27938e98aa83896765c",
			"commitAuthorOld": "Emmanuel Bernard",
			"daysBetweenCommits": 50.12,
			"commitsBetweenForRepo": 155,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,153 +1,153 @@\n \tpublic void bind() {\n \t\tthis.collection = createCollection( propertyHolder.getPersistentClass() );\n \t\tlog.debug( \"Collection role: {}\", StringHelper.qualify( propertyHolder.getPath(), propertyName ) );\n \t\tcollection.setRole( StringHelper.qualify( propertyHolder.getPath(), propertyName ) );\n \t\tcollection.setNodeName( propertyName );\n \n \t\tif ( (property.isAnnotationPresent( org.hibernate.annotations.MapKey.class )\n \t\t\t\t|| property.isAnnotationPresent( MapKeyColumn.class ) )\n \t\t\t&& mapKeyPropertyName != null ) {\n \t\t\tthrow new AnnotationException(\n \t\t\t\t\t\"Cannot mix @javax.persistence.MapKey and @MapKeyColumn or @org.hibernate.annotations.MapKey \"\n \t\t\t\t\t\t\t+ \"on the same collection: \" + StringHelper.qualify(\n \t\t\t\t\t\t\tpropertyHolder.getPath(), propertyName\n \t\t\t\t\t)\n \t\t\t);\n \t\t}\n \n \t\t//set laziness\n \t\tdefineFetchingStrategy();\n \t\tcollection.setBatchSize( batchSize );\n \t\tif ( orderBy != null && hqlOrderBy != null ) {\n \t\t\tthrow new AnnotationException(\n \t\t\t\t\t\"Cannot use sql order by clause in conjunction of EJB3 order by clause: \" + safeCollectionRole()\n \t\t\t);\n \t\t}\n \n \t\tcollection.setMutable( !property.isAnnotationPresent( Immutable.class ) );\n \t\tOptimisticLock lockAnn = property.getAnnotation( OptimisticLock.class );\n \t\tif ( lockAnn != null ) collection.setOptimisticLocked( !lockAnn.excluded() );\n \t\tPersister persisterAnn = property.getAnnotation( Persister.class );\n \t\tif ( persisterAnn != null ) collection.setCollectionPersisterClass( persisterAnn.impl() );\n \n \t\t// set ordering\n \t\tif ( orderBy != null ) collection.setOrderBy( orderBy );\n \t\tif ( isSorted ) {\n \t\t\tcollection.setSorted( true );\n \t\t\tif ( comparator != null ) {\n \t\t\t\ttry {\n \t\t\t\t\tcollection.setComparator( (Comparator) comparator.newInstance() );\n \t\t\t\t}\n \t\t\t\tcatch (ClassCastException e) {\n \t\t\t\t\tthrow new AnnotationException(\n \t\t\t\t\t\t\t\"Comparator not implementing java.util.Comparator class: \"\n \t\t\t\t\t\t\t\t\t+ comparator.getName() + \"(\" + safeCollectionRole() + \")\"\n \t\t\t\t\t);\n \t\t\t\t}\n \t\t\t\tcatch (Exception e) {\n \t\t\t\t\tthrow new AnnotationException(\n \t\t\t\t\t\t\t\"Could not instantiate comparator class: \"\n \t\t\t\t\t\t\t\t\t+ comparator.getName() + \"(\" + safeCollectionRole() + \")\"\n \t\t\t\t\t);\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\telse {\n \t\t\tif ( hasToBeSorted ) {\n \t\t\t\tthrow new AnnotationException(\n \t\t\t\t\t\t\"A sorted collection has to define @Sort: \"\n \t\t\t\t\t\t\t\t+ safeCollectionRole()\n \t\t\t\t);\n \t\t\t}\n \t\t}\n \n \t\t//set cache\n \t\tif ( StringHelper.isNotEmpty( cacheConcurrencyStrategy ) ) {\n \t\t\tcollection.setCacheConcurrencyStrategy( cacheConcurrencyStrategy );\n \t\t\tcollection.setCacheRegionName( cacheRegionName );\n \t\t}\n \n \t\t//SQL overriding\n \t\tSQLInsert sqlInsert = property.getAnnotation( SQLInsert.class );\n \t\tSQLUpdate sqlUpdate = property.getAnnotation( SQLUpdate.class );\n \t\tSQLDelete sqlDelete = property.getAnnotation( SQLDelete.class );\n \t\tSQLDeleteAll sqlDeleteAll = property.getAnnotation( SQLDeleteAll.class );\n \t\tLoader loader = property.getAnnotation( Loader.class );\n \t\tif ( sqlInsert != null ) {\n \t\t\tcollection.setCustomSQLInsert( sqlInsert.sql().trim(), sqlInsert.callable(),\n \t\t\t\t\tExecuteUpdateResultCheckStyle.parse( sqlInsert.check().toString().toLowerCase() )\n \t\t\t);\n \n \t\t}\n \t\tif ( sqlUpdate != null ) {\n \t\t\tcollection.setCustomSQLUpdate( sqlUpdate.sql(), sqlUpdate.callable(),\n \t\t\t\t\tExecuteUpdateResultCheckStyle.parse( sqlUpdate.check().toString().toLowerCase() )\n \t\t\t);\n \t\t}\n \t\tif ( sqlDelete != null ) {\n \t\t\tcollection.setCustomSQLDelete( sqlDelete.sql(), sqlDelete.callable(),\n \t\t\t\t\tExecuteUpdateResultCheckStyle.parse( sqlDelete.check().toString().toLowerCase() )\n \t\t\t);\n \t\t}\n \t\tif ( sqlDeleteAll != null ) {\n \t\t\tcollection.setCustomSQLDeleteAll( sqlDeleteAll.sql(), sqlDeleteAll.callable(),\n \t\t\t\t\tExecuteUpdateResultCheckStyle.parse( sqlDeleteAll.check().toString().toLowerCase() )\n \t\t\t);\n \t\t}\n \t\tif ( loader != null ) {\n \t\t\tcollection.setLoaderName( loader.namedQuery() );\n \t\t}\n \n \t\t//work on association\n \t\tboolean isMappedBy = !BinderHelper.isDefault( mappedBy );\n \t\tcollection.setInverse( isMappedBy );\n \n \t\t//many to many may need some second pass informations\n \t\tif ( !oneToMany && isMappedBy ) {\n \t\t\tmappings.addMappedBy( getCollectionType().getName(), mappedBy, propertyName );\n \t\t}\n \t\t//TODO reducce tableBinder != null and oneToMany\n \t\tXClass collectionType = getCollectionType();\n \t\tif ( inheritanceStatePerClass == null) throw new AssertionFailure( \"inheritanceStatePerClass not set\" );\n \t\tSecondPass sp = getSecondPass(\n \t\t\t\tfkJoinColumns,\n \t\t\t\tjoinColumns,\n \t\t\t\tinverseJoinColumns,\n \t\t\t\telementColumns,\n \t\t\t\tmapKeyColumns, mapKeyManyToManyColumns, isEmbedded,\n \t\t\t\tproperty, collectionType,\n \t\t\t\tignoreNotFound, oneToMany,\n \t\t\t\ttableBinder, mappings\n \t\t);\n \t\tif ( collectionType.isAnnotationPresent( Embeddable.class )\n \t\t\t\t|| property.isAnnotationPresent( CollectionOfElements.class ) //legacy hibernate\n \t\t\t\t|| property.isAnnotationPresent( ElementCollection.class ) //JPA 2\n \t\t\t\t) {\n \t\t\t// do it right away, otherwise @ManyToon on composite element call addSecondPass \n \t\t\t// and raise a ConcurrentModificationException\n \t\t\t//sp.doSecondPass( CollectionHelper.EMPTY_MAP );\n \t\t\tmappings.addSecondPass( sp, !isMappedBy );\n \t\t}\n \t\telse {\n \t\t\tmappings.addSecondPass( sp, !isMappedBy );\n \t\t}\n \n \t\tmappings.addCollection( collection );\n \n \t\t//property building\n \t\tPropertyBinder binder = new PropertyBinder();\n \t\tbinder.setName( propertyName );\n \t\tbinder.setValue( collection );\n \t\tbinder.setCascade( cascadeStrategy );\n \t\tif ( cascadeStrategy != null && cascadeStrategy.indexOf( \"delete-orphan\" ) >= 0 ) {\n \t\t\tcollection.setOrphanDelete( true );\n \t\t}\n-\t\tbinder.setPropertyAccessorName( propertyAccessorName );\n+\t\tbinder.setAccessType( accessType );\n \t\tbinder.setProperty( property );\n \t\tbinder.setInsertable( insertable );\n \t\tbinder.setUpdatable( updatable );\n \t\tProperty prop = binder.make();\n \t\t//we don't care about the join stuffs because the column is on the association table.\n \t\tif (! declaringClassSet) throw new AssertionFailure( \"DeclaringClass is not set in CollectionBinder while binding\" );\n \t\tpropertyHolder.addProperty( prop, declaringClass );\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"c7c6981a558e35f01ff8d27938e98aa83896765c": {
			"type": "Ybodychange",
			"commitMessage": "HHH-4533 add representation for @MappedSuperclass in the Hibernate Core metamodel and properly populate this model extension in Hibernate Annotations\n\ngit-svn-id: https://svn.jboss.org/repos/hibernate/core/trunk@17871 1b8cb986-b30d-0410-93ca-fae66ebed9b2\n",
			"commitDate": "2009-10-28, 12:14 PM",
			"commitName": "c7c6981a558e35f01ff8d27938e98aa83896765c",
			"commitAuthor": "Emmanuel Bernard",
			"commitDateOld": "2009-07-22, 2:40 PM",
			"commitNameOld": "eeb136fa719fe007158d90ba011473ea7d1fa38b",
			"commitAuthorOld": "Emmanuel Bernard",
			"daysBetweenCommits": 97.9,
			"commitsBetweenForRepo": 186,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,151 +1,153 @@\n \tpublic void bind() {\n \t\tthis.collection = createCollection( propertyHolder.getPersistentClass() );\n \t\tlog.debug( \"Collection role: {}\", StringHelper.qualify( propertyHolder.getPath(), propertyName ) );\n \t\tcollection.setRole( StringHelper.qualify( propertyHolder.getPath(), propertyName ) );\n \t\tcollection.setNodeName( propertyName );\n \n \t\tif ( (property.isAnnotationPresent( org.hibernate.annotations.MapKey.class )\n \t\t\t\t|| property.isAnnotationPresent( MapKeyColumn.class ) )\n \t\t\t&& mapKeyPropertyName != null ) {\n \t\t\tthrow new AnnotationException(\n \t\t\t\t\t\"Cannot mix @javax.persistence.MapKey and @MapKeyColumn or @org.hibernate.annotations.MapKey \"\n \t\t\t\t\t\t\t+ \"on the same collection: \" + StringHelper.qualify(\n \t\t\t\t\t\t\tpropertyHolder.getPath(), propertyName\n \t\t\t\t\t)\n \t\t\t);\n \t\t}\n \n \t\t//set laziness\n \t\tdefineFetchingStrategy();\n \t\tcollection.setBatchSize( batchSize );\n \t\tif ( orderBy != null && hqlOrderBy != null ) {\n \t\t\tthrow new AnnotationException(\n \t\t\t\t\t\"Cannot use sql order by clause in conjunction of EJB3 order by clause: \" + safeCollectionRole()\n \t\t\t);\n \t\t}\n \n \t\tcollection.setMutable( !property.isAnnotationPresent( Immutable.class ) );\n \t\tOptimisticLock lockAnn = property.getAnnotation( OptimisticLock.class );\n \t\tif ( lockAnn != null ) collection.setOptimisticLocked( !lockAnn.excluded() );\n \t\tPersister persisterAnn = property.getAnnotation( Persister.class );\n \t\tif ( persisterAnn != null ) collection.setCollectionPersisterClass( persisterAnn.impl() );\n \n \t\t// set ordering\n \t\tif ( orderBy != null ) collection.setOrderBy( orderBy );\n \t\tif ( isSorted ) {\n \t\t\tcollection.setSorted( true );\n \t\t\tif ( comparator != null ) {\n \t\t\t\ttry {\n \t\t\t\t\tcollection.setComparator( (Comparator) comparator.newInstance() );\n \t\t\t\t}\n \t\t\t\tcatch (ClassCastException e) {\n \t\t\t\t\tthrow new AnnotationException(\n \t\t\t\t\t\t\t\"Comparator not implementing java.util.Comparator class: \"\n \t\t\t\t\t\t\t\t\t+ comparator.getName() + \"(\" + safeCollectionRole() + \")\"\n \t\t\t\t\t);\n \t\t\t\t}\n \t\t\t\tcatch (Exception e) {\n \t\t\t\t\tthrow new AnnotationException(\n \t\t\t\t\t\t\t\"Could not instantiate comparator class: \"\n \t\t\t\t\t\t\t\t\t+ comparator.getName() + \"(\" + safeCollectionRole() + \")\"\n \t\t\t\t\t);\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\telse {\n \t\t\tif ( hasToBeSorted ) {\n \t\t\t\tthrow new AnnotationException(\n \t\t\t\t\t\t\"A sorted collection has to define @Sort: \"\n \t\t\t\t\t\t\t\t+ safeCollectionRole()\n \t\t\t\t);\n \t\t\t}\n \t\t}\n \n \t\t//set cache\n \t\tif ( StringHelper.isNotEmpty( cacheConcurrencyStrategy ) ) {\n \t\t\tcollection.setCacheConcurrencyStrategy( cacheConcurrencyStrategy );\n \t\t\tcollection.setCacheRegionName( cacheRegionName );\n \t\t}\n \n \t\t//SQL overriding\n \t\tSQLInsert sqlInsert = property.getAnnotation( SQLInsert.class );\n \t\tSQLUpdate sqlUpdate = property.getAnnotation( SQLUpdate.class );\n \t\tSQLDelete sqlDelete = property.getAnnotation( SQLDelete.class );\n \t\tSQLDeleteAll sqlDeleteAll = property.getAnnotation( SQLDeleteAll.class );\n \t\tLoader loader = property.getAnnotation( Loader.class );\n \t\tif ( sqlInsert != null ) {\n \t\t\tcollection.setCustomSQLInsert( sqlInsert.sql().trim(), sqlInsert.callable(),\n \t\t\t\t\tExecuteUpdateResultCheckStyle.parse( sqlInsert.check().toString().toLowerCase() )\n \t\t\t);\n \n \t\t}\n \t\tif ( sqlUpdate != null ) {\n \t\t\tcollection.setCustomSQLUpdate( sqlUpdate.sql(), sqlUpdate.callable(),\n \t\t\t\t\tExecuteUpdateResultCheckStyle.parse( sqlUpdate.check().toString().toLowerCase() )\n \t\t\t);\n \t\t}\n \t\tif ( sqlDelete != null ) {\n \t\t\tcollection.setCustomSQLDelete( sqlDelete.sql(), sqlDelete.callable(),\n \t\t\t\t\tExecuteUpdateResultCheckStyle.parse( sqlDelete.check().toString().toLowerCase() )\n \t\t\t);\n \t\t}\n \t\tif ( sqlDeleteAll != null ) {\n \t\t\tcollection.setCustomSQLDeleteAll( sqlDeleteAll.sql(), sqlDeleteAll.callable(),\n \t\t\t\t\tExecuteUpdateResultCheckStyle.parse( sqlDeleteAll.check().toString().toLowerCase() )\n \t\t\t);\n \t\t}\n \t\tif ( loader != null ) {\n \t\t\tcollection.setLoaderName( loader.namedQuery() );\n \t\t}\n \n \t\t//work on association\n \t\tboolean isMappedBy = !BinderHelper.isDefault( mappedBy );\n \t\tcollection.setInverse( isMappedBy );\n \n \t\t//many to many may need some second pass informations\n \t\tif ( !oneToMany && isMappedBy ) {\n \t\t\tmappings.addMappedBy( getCollectionType().getName(), mappedBy, propertyName );\n \t\t}\n \t\t//TODO reducce tableBinder != null and oneToMany\n \t\tXClass collectionType = getCollectionType();\n+\t\tif ( inheritanceStatePerClass == null) throw new AssertionFailure( \"inheritanceStatePerClass not set\" );\n \t\tSecondPass sp = getSecondPass(\n \t\t\t\tfkJoinColumns,\n \t\t\t\tjoinColumns,\n \t\t\t\tinverseJoinColumns,\n \t\t\t\telementColumns,\n \t\t\t\tmapKeyColumns, mapKeyManyToManyColumns, isEmbedded,\n \t\t\t\tproperty, collectionType,\n \t\t\t\tignoreNotFound, oneToMany,\n \t\t\t\ttableBinder, mappings\n \t\t);\n \t\tif ( collectionType.isAnnotationPresent( Embeddable.class )\n \t\t\t\t|| property.isAnnotationPresent( CollectionOfElements.class ) //legacy hibernate\n \t\t\t\t|| property.isAnnotationPresent( ElementCollection.class ) //JPA 2\n \t\t\t\t) {\n \t\t\t// do it right away, otherwise @ManyToon on composite element call addSecondPass \n \t\t\t// and raise a ConcurrentModificationException\n \t\t\t//sp.doSecondPass( CollectionHelper.EMPTY_MAP );\n \t\t\tmappings.addSecondPass( sp, !isMappedBy );\n \t\t}\n \t\telse {\n \t\t\tmappings.addSecondPass( sp, !isMappedBy );\n \t\t}\n \n \t\tmappings.addCollection( collection );\n \n \t\t//property building\n \t\tPropertyBinder binder = new PropertyBinder();\n \t\tbinder.setName( propertyName );\n \t\tbinder.setValue( collection );\n \t\tbinder.setCascade( cascadeStrategy );\n \t\tif ( cascadeStrategy != null && cascadeStrategy.indexOf( \"delete-orphan\" ) >= 0 ) {\n \t\t\tcollection.setOrphanDelete( true );\n \t\t}\n \t\tbinder.setPropertyAccessorName( propertyAccessorName );\n \t\tbinder.setProperty( property );\n \t\tbinder.setInsertable( insertable );\n \t\tbinder.setUpdatable( updatable );\n \t\tProperty prop = binder.make();\n \t\t//we don't care about the join stuffs because the column is on the association table.\n-\t\tpropertyHolder.addProperty( prop );\n+\t\tif (! declaringClassSet) throw new AssertionFailure( \"DeclaringClass is not set in CollectionBinder while binding\" );\n+\t\tpropertyHolder.addProperty( prop, declaringClass );\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"20d22941c0e07b37295704d5300a7071e48e640d": {
			"type": "Ybodychange",
			"commitMessage": "ANN-856 implement @MapKeyColumn\n\ngit-svn-id: https://svn.jboss.org/repos/hibernate/core/trunk@17173 1b8cb986-b30d-0410-93ca-fae66ebed9b2\n",
			"commitDate": "2009-07-20, 8:07 PM",
			"commitName": "20d22941c0e07b37295704d5300a7071e48e640d",
			"commitAuthor": "Emmanuel Bernard",
			"commitDateOld": "2009-05-07, 3:34 PM",
			"commitNameOld": "11668ca67c916595d2789787e37b3ed1affc1aa8",
			"commitAuthorOld": "Emmanuel Bernard",
			"daysBetweenCommits": 74.19,
			"commitsBetweenForRepo": 88,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,149 +1,151 @@\n \tpublic void bind() {\n \t\tthis.collection = createCollection( propertyHolder.getPersistentClass() );\n \t\tlog.debug( \"Collection role: {}\", StringHelper.qualify( propertyHolder.getPath(), propertyName ) );\n \t\tcollection.setRole( StringHelper.qualify( propertyHolder.getPath(), propertyName ) );\n \t\tcollection.setNodeName( propertyName );\n \n-\t\tif ( property.isAnnotationPresent( org.hibernate.annotations.MapKey.class ) && mapKeyPropertyName != null ) {\n+\t\tif ( (property.isAnnotationPresent( org.hibernate.annotations.MapKey.class )\n+\t\t\t\t|| property.isAnnotationPresent( MapKeyColumn.class ) )\n+\t\t\t&& mapKeyPropertyName != null ) {\n \t\t\tthrow new AnnotationException(\n-\t\t\t\t\t\"Cannot mix @javax.persistence.MapKey and @org.hibernate.annotations.MapKey \"\n+\t\t\t\t\t\"Cannot mix @javax.persistence.MapKey and @MapKeyColumn or @org.hibernate.annotations.MapKey \"\n \t\t\t\t\t\t\t+ \"on the same collection: \" + StringHelper.qualify(\n \t\t\t\t\t\t\tpropertyHolder.getPath(), propertyName\n \t\t\t\t\t)\n \t\t\t);\n \t\t}\n \n \t\t//set laziness\n \t\tdefineFetchingStrategy();\n \t\tcollection.setBatchSize( batchSize );\n \t\tif ( orderBy != null && hqlOrderBy != null ) {\n \t\t\tthrow new AnnotationException(\n \t\t\t\t\t\"Cannot use sql order by clause in conjunction of EJB3 order by clause: \" + safeCollectionRole()\n \t\t\t);\n \t\t}\n \n \t\tcollection.setMutable( !property.isAnnotationPresent( Immutable.class ) );\n \t\tOptimisticLock lockAnn = property.getAnnotation( OptimisticLock.class );\n \t\tif ( lockAnn != null ) collection.setOptimisticLocked( !lockAnn.excluded() );\n \t\tPersister persisterAnn = property.getAnnotation( Persister.class );\n \t\tif ( persisterAnn != null ) collection.setCollectionPersisterClass( persisterAnn.impl() );\n \n \t\t// set ordering\n \t\tif ( orderBy != null ) collection.setOrderBy( orderBy );\n \t\tif ( isSorted ) {\n \t\t\tcollection.setSorted( true );\n \t\t\tif ( comparator != null ) {\n \t\t\t\ttry {\n \t\t\t\t\tcollection.setComparator( (Comparator) comparator.newInstance() );\n \t\t\t\t}\n \t\t\t\tcatch (ClassCastException e) {\n \t\t\t\t\tthrow new AnnotationException(\n \t\t\t\t\t\t\t\"Comparator not implementing java.util.Comparator class: \"\n \t\t\t\t\t\t\t\t\t+ comparator.getName() + \"(\" + safeCollectionRole() + \")\"\n \t\t\t\t\t);\n \t\t\t\t}\n \t\t\t\tcatch (Exception e) {\n \t\t\t\t\tthrow new AnnotationException(\n \t\t\t\t\t\t\t\"Could not instantiate comparator class: \"\n \t\t\t\t\t\t\t\t\t+ comparator.getName() + \"(\" + safeCollectionRole() + \")\"\n \t\t\t\t\t);\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\telse {\n \t\t\tif ( hasToBeSorted ) {\n \t\t\t\tthrow new AnnotationException(\n \t\t\t\t\t\t\"A sorted collection has to define @Sort: \"\n \t\t\t\t\t\t\t\t+ safeCollectionRole()\n \t\t\t\t);\n \t\t\t}\n \t\t}\n \n \t\t//set cache\n \t\tif ( StringHelper.isNotEmpty( cacheConcurrencyStrategy ) ) {\n \t\t\tcollection.setCacheConcurrencyStrategy( cacheConcurrencyStrategy );\n \t\t\tcollection.setCacheRegionName( cacheRegionName );\n \t\t}\n \n \t\t//SQL overriding\n \t\tSQLInsert sqlInsert = property.getAnnotation( SQLInsert.class );\n \t\tSQLUpdate sqlUpdate = property.getAnnotation( SQLUpdate.class );\n \t\tSQLDelete sqlDelete = property.getAnnotation( SQLDelete.class );\n \t\tSQLDeleteAll sqlDeleteAll = property.getAnnotation( SQLDeleteAll.class );\n \t\tLoader loader = property.getAnnotation( Loader.class );\n \t\tif ( sqlInsert != null ) {\n \t\t\tcollection.setCustomSQLInsert( sqlInsert.sql().trim(), sqlInsert.callable(),\n \t\t\t\t\tExecuteUpdateResultCheckStyle.parse( sqlInsert.check().toString().toLowerCase() )\n \t\t\t);\n \n \t\t}\n \t\tif ( sqlUpdate != null ) {\n \t\t\tcollection.setCustomSQLUpdate( sqlUpdate.sql(), sqlUpdate.callable(),\n \t\t\t\t\tExecuteUpdateResultCheckStyle.parse( sqlUpdate.check().toString().toLowerCase() )\n \t\t\t);\n \t\t}\n \t\tif ( sqlDelete != null ) {\n \t\t\tcollection.setCustomSQLDelete( sqlDelete.sql(), sqlDelete.callable(),\n \t\t\t\t\tExecuteUpdateResultCheckStyle.parse( sqlDelete.check().toString().toLowerCase() )\n \t\t\t);\n \t\t}\n \t\tif ( sqlDeleteAll != null ) {\n \t\t\tcollection.setCustomSQLDeleteAll( sqlDeleteAll.sql(), sqlDeleteAll.callable(),\n \t\t\t\t\tExecuteUpdateResultCheckStyle.parse( sqlDeleteAll.check().toString().toLowerCase() )\n \t\t\t);\n \t\t}\n \t\tif ( loader != null ) {\n \t\t\tcollection.setLoaderName( loader.namedQuery() );\n \t\t}\n \n \t\t//work on association\n \t\tboolean isMappedBy = !BinderHelper.isDefault( mappedBy );\n \t\tcollection.setInverse( isMappedBy );\n \n \t\t//many to many may need some second pass informations\n \t\tif ( !oneToMany && isMappedBy ) {\n \t\t\tmappings.addMappedBy( getCollectionType().getName(), mappedBy, propertyName );\n \t\t}\n \t\t//TODO reducce tableBinder != null and oneToMany\n \t\tXClass collectionType = getCollectionType();\n \t\tSecondPass sp = getSecondPass(\n \t\t\t\tfkJoinColumns,\n \t\t\t\tjoinColumns,\n \t\t\t\tinverseJoinColumns,\n \t\t\t\telementColumns,\n \t\t\t\tmapKeyColumns, mapKeyManyToManyColumns, isEmbedded,\n \t\t\t\tproperty, collectionType,\n \t\t\t\tignoreNotFound, oneToMany,\n \t\t\t\ttableBinder, mappings\n \t\t);\n \t\tif ( collectionType.isAnnotationPresent( Embeddable.class )\n \t\t\t\t|| property.isAnnotationPresent( CollectionOfElements.class ) //legacy hibernate\n \t\t\t\t|| property.isAnnotationPresent( ElementCollection.class ) //JPA 2\n \t\t\t\t) {\n \t\t\t// do it right away, otherwise @ManyToon on composite element call addSecondPass \n \t\t\t// and raise a ConcurrentModificationException\n \t\t\t//sp.doSecondPass( CollectionHelper.EMPTY_MAP );\n \t\t\tmappings.addSecondPass( sp, !isMappedBy );\n \t\t}\n \t\telse {\n \t\t\tmappings.addSecondPass( sp, !isMappedBy );\n \t\t}\n \n \t\tmappings.addCollection( collection );\n \n \t\t//property building\n \t\tPropertyBinder binder = new PropertyBinder();\n \t\tbinder.setName( propertyName );\n \t\tbinder.setValue( collection );\n \t\tbinder.setCascade( cascadeStrategy );\n \t\tif ( cascadeStrategy != null && cascadeStrategy.indexOf( \"delete-orphan\" ) >= 0 ) {\n \t\t\tcollection.setOrphanDelete( true );\n \t\t}\n \t\tbinder.setPropertyAccessorName( propertyAccessorName );\n \t\tbinder.setProperty( property );\n \t\tbinder.setInsertable( insertable );\n \t\tbinder.setUpdatable( updatable );\n \t\tProperty prop = binder.make();\n \t\t//we don't care about the join stuffs because the column is on the association table.\n \t\tpropertyHolder.addProperty( prop );\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"11668ca67c916595d2789787e37b3ed1affc1aa8": {
			"type": "Ybodychange",
			"commitMessage": "HHH-3906 EJB-436 ANN-830 Move to JPA 2 API as a dependency\n\ngit-svn-id: https://svn.jboss.org/repos/hibernate/core/trunk@16523 1b8cb986-b30d-0410-93ca-fae66ebed9b2\n",
			"commitDate": "2009-05-07, 3:34 PM",
			"commitName": "11668ca67c916595d2789787e37b3ed1affc1aa8",
			"commitAuthor": "Emmanuel Bernard",
			"commitDateOld": "2008-10-28, 3:41 PM",
			"commitNameOld": "513c71de5c5c6fb65bbc2a191ab7a9e565e304d5",
			"commitAuthorOld": "Steve Ebersole",
			"daysBetweenCommits": 190.99,
			"commitsBetweenForRepo": 188,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,147 +1,149 @@\n \tpublic void bind() {\n \t\tthis.collection = createCollection( propertyHolder.getPersistentClass() );\n \t\tlog.debug( \"Collection role: {}\", StringHelper.qualify( propertyHolder.getPath(), propertyName ) );\n \t\tcollection.setRole( StringHelper.qualify( propertyHolder.getPath(), propertyName ) );\n \t\tcollection.setNodeName( propertyName );\n \n \t\tif ( property.isAnnotationPresent( org.hibernate.annotations.MapKey.class ) && mapKeyPropertyName != null ) {\n \t\t\tthrow new AnnotationException(\n \t\t\t\t\t\"Cannot mix @javax.persistence.MapKey and @org.hibernate.annotations.MapKey \"\n \t\t\t\t\t\t\t+ \"on the same collection: \" + StringHelper.qualify(\n \t\t\t\t\t\t\tpropertyHolder.getPath(), propertyName\n \t\t\t\t\t)\n \t\t\t);\n \t\t}\n \n \t\t//set laziness\n \t\tdefineFetchingStrategy();\n \t\tcollection.setBatchSize( batchSize );\n \t\tif ( orderBy != null && hqlOrderBy != null ) {\n \t\t\tthrow new AnnotationException(\n \t\t\t\t\t\"Cannot use sql order by clause in conjunction of EJB3 order by clause: \" + safeCollectionRole()\n \t\t\t);\n \t\t}\n \n \t\tcollection.setMutable( !property.isAnnotationPresent( Immutable.class ) );\n \t\tOptimisticLock lockAnn = property.getAnnotation( OptimisticLock.class );\n \t\tif ( lockAnn != null ) collection.setOptimisticLocked( !lockAnn.excluded() );\n \t\tPersister persisterAnn = property.getAnnotation( Persister.class );\n \t\tif ( persisterAnn != null ) collection.setCollectionPersisterClass( persisterAnn.impl() );\n \n \t\t// set ordering\n \t\tif ( orderBy != null ) collection.setOrderBy( orderBy );\n \t\tif ( isSorted ) {\n \t\t\tcollection.setSorted( true );\n \t\t\tif ( comparator != null ) {\n \t\t\t\ttry {\n \t\t\t\t\tcollection.setComparator( (Comparator) comparator.newInstance() );\n \t\t\t\t}\n \t\t\t\tcatch (ClassCastException e) {\n \t\t\t\t\tthrow new AnnotationException(\n \t\t\t\t\t\t\t\"Comparator not implementing java.util.Comparator class: \"\n \t\t\t\t\t\t\t\t\t+ comparator.getName() + \"(\" + safeCollectionRole() + \")\"\n \t\t\t\t\t);\n \t\t\t\t}\n \t\t\t\tcatch (Exception e) {\n \t\t\t\t\tthrow new AnnotationException(\n \t\t\t\t\t\t\t\"Could not instantiate comparator class: \"\n \t\t\t\t\t\t\t\t\t+ comparator.getName() + \"(\" + safeCollectionRole() + \")\"\n \t\t\t\t\t);\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\telse {\n \t\t\tif ( hasToBeSorted ) {\n \t\t\t\tthrow new AnnotationException(\n \t\t\t\t\t\t\"A sorted collection has to define @Sort: \"\n \t\t\t\t\t\t\t\t+ safeCollectionRole()\n \t\t\t\t);\n \t\t\t}\n \t\t}\n \n \t\t//set cache\n \t\tif ( StringHelper.isNotEmpty( cacheConcurrencyStrategy ) ) {\n \t\t\tcollection.setCacheConcurrencyStrategy( cacheConcurrencyStrategy );\n \t\t\tcollection.setCacheRegionName( cacheRegionName );\n \t\t}\n \n \t\t//SQL overriding\n \t\tSQLInsert sqlInsert = property.getAnnotation( SQLInsert.class );\n \t\tSQLUpdate sqlUpdate = property.getAnnotation( SQLUpdate.class );\n \t\tSQLDelete sqlDelete = property.getAnnotation( SQLDelete.class );\n \t\tSQLDeleteAll sqlDeleteAll = property.getAnnotation( SQLDeleteAll.class );\n \t\tLoader loader = property.getAnnotation( Loader.class );\n \t\tif ( sqlInsert != null ) {\n \t\t\tcollection.setCustomSQLInsert( sqlInsert.sql().trim(), sqlInsert.callable(),\n \t\t\t\t\tExecuteUpdateResultCheckStyle.parse( sqlInsert.check().toString().toLowerCase() )\n \t\t\t);\n \n \t\t}\n \t\tif ( sqlUpdate != null ) {\n \t\t\tcollection.setCustomSQLUpdate( sqlUpdate.sql(), sqlUpdate.callable(),\n \t\t\t\t\tExecuteUpdateResultCheckStyle.parse( sqlUpdate.check().toString().toLowerCase() )\n \t\t\t);\n \t\t}\n \t\tif ( sqlDelete != null ) {\n \t\t\tcollection.setCustomSQLDelete( sqlDelete.sql(), sqlDelete.callable(),\n \t\t\t\t\tExecuteUpdateResultCheckStyle.parse( sqlDelete.check().toString().toLowerCase() )\n \t\t\t);\n \t\t}\n \t\tif ( sqlDeleteAll != null ) {\n \t\t\tcollection.setCustomSQLDeleteAll( sqlDeleteAll.sql(), sqlDeleteAll.callable(),\n \t\t\t\t\tExecuteUpdateResultCheckStyle.parse( sqlDeleteAll.check().toString().toLowerCase() )\n \t\t\t);\n \t\t}\n \t\tif ( loader != null ) {\n \t\t\tcollection.setLoaderName( loader.namedQuery() );\n \t\t}\n \n \t\t//work on association\n \t\tboolean isMappedBy = !BinderHelper.isDefault( mappedBy );\n \t\tcollection.setInverse( isMappedBy );\n \n \t\t//many to many may need some second pass informations\n \t\tif ( !oneToMany && isMappedBy ) {\n \t\t\tmappings.addMappedBy( getCollectionType().getName(), mappedBy, propertyName );\n \t\t}\n \t\t//TODO reducce tableBinder != null and oneToMany\n \t\tXClass collectionType = getCollectionType();\n \t\tSecondPass sp = getSecondPass(\n \t\t\t\tfkJoinColumns,\n \t\t\t\tjoinColumns,\n \t\t\t\tinverseJoinColumns,\n \t\t\t\telementColumns,\n \t\t\t\tmapKeyColumns, mapKeyManyToManyColumns, isEmbedded,\n \t\t\t\tproperty, collectionType,\n \t\t\t\tignoreNotFound, oneToMany,\n \t\t\t\ttableBinder, mappings\n \t\t);\n \t\tif ( collectionType.isAnnotationPresent( Embeddable.class )\n-\t\t\t\t|| property.isAnnotationPresent( CollectionOfElements.class ) ) {\n+\t\t\t\t|| property.isAnnotationPresent( CollectionOfElements.class ) //legacy hibernate\n+\t\t\t\t|| property.isAnnotationPresent( ElementCollection.class ) //JPA 2\n+\t\t\t\t) {\n \t\t\t// do it right away, otherwise @ManyToon on composite element call addSecondPass \n \t\t\t// and raise a ConcurrentModificationException\n \t\t\t//sp.doSecondPass( CollectionHelper.EMPTY_MAP );\n \t\t\tmappings.addSecondPass( sp, !isMappedBy );\n \t\t}\n \t\telse {\n \t\t\tmappings.addSecondPass( sp, !isMappedBy );\n \t\t}\n \n \t\tmappings.addCollection( collection );\n \n \t\t//property building\n \t\tPropertyBinder binder = new PropertyBinder();\n \t\tbinder.setName( propertyName );\n \t\tbinder.setValue( collection );\n \t\tbinder.setCascade( cascadeStrategy );\n \t\tif ( cascadeStrategy != null && cascadeStrategy.indexOf( \"delete-orphan\" ) >= 0 ) {\n \t\t\tcollection.setOrphanDelete( true );\n \t\t}\n \t\tbinder.setPropertyAccessorName( propertyAccessorName );\n \t\tbinder.setProperty( property );\n \t\tbinder.setInsertable( insertable );\n \t\tbinder.setUpdatable( updatable );\n \t\tProperty prop = binder.make();\n \t\t//we don't care about the join stuffs because the column is on the association table.\n \t\tpropertyHolder.addProperty( prop );\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"9d7a03a5f7f03bc803d897baa590861154b39f5e": {
			"type": "Yfilerename",
			"commitMessage": "HHH-3550 : import annotations into core\n\ngit-svn-id: https://svn.jboss.org/repos/hibernate/core/trunk@15418 1b8cb986-b30d-0410-93ca-fae66ebed9b2\n",
			"commitDate": "2008-10-28, 12:53 PM",
			"commitName": "9d7a03a5f7f03bc803d897baa590861154b39f5e",
			"commitAuthor": "Steve Ebersole",
			"commitDateOld": "2008-10-28, 12:52 PM",
			"commitNameOld": "c457f2b3258fc48ef4010a9e58cd2fc3baaca6cc",
			"commitAuthorOld": "Steve Ebersole",
			"daysBetweenCommits": 0,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "",
			"extendedDetails": {
				"oldPath": "annotations/src/java/org/hibernate/cfg/annotations/CollectionBinder.java",
				"newPath": "annotations/src/main/java/org/hibernate/cfg/annotations/CollectionBinder.java"
			}
		},
		"7337743c93574823424ed6c399cfcf6bd75614f8": {
			"type": "Yintroduced",
			"commitMessage": "HHH-3550 : import annotations into core\n\ngit-svn-id: https://svn.jboss.org/repos/hibernate/core/trunk@15415 1b8cb986-b30d-0410-93ca-fae66ebed9b2\n",
			"commitDate": "2008-10-28, 12:41 PM",
			"commitName": "7337743c93574823424ed6c399cfcf6bd75614f8",
			"commitAuthor": "Steve Ebersole"
		}
	},
	"sha": "8bd79b29cfa7b2d539a746dc356d60b66e1e596b"
}