{
	"repo": "https://github.com/square/okhttp.git",
	"file": "okhttp/src/main/java/okhttp3/RealCall.java",
	"method": {
		"longName": "protected void execute();",
		"startLine": 144,
		"methodName": "execute",
		"isStatic": false,
		"isAbstract": false,
		"visibility": "protected"
	},
	"history": {
		"9b0d19f913465483d0942558eb21e37868040050": {
			"type": "Ybodychange",
			"commitMessage": "Don't call callEnd until after the responseBody is done (#3551)\n\n",
			"commitDate": "2017-08-29, 10:14 PM",
			"commitName": "9b0d19f913465483d0942558eb21e37868040050",
			"commitAuthor": "Jesse Wilson",
			"commitDateOld": "2017-08-29, 1:14 PM",
			"commitNameOld": "1c98464839434a0fe7c7581cdae44bd3f2e6edd3",
			"commitAuthorOld": "Jesse Wilson",
			"daysBetweenCommits": 0.37,
			"commitsBetweenForRepo": 2,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,24 +1,23 @@\n     @Override protected void execute() {\n       boolean signalledCallback = false;\n       try {\n         Response response = getResponseWithInterceptorChain();\n         if (retryAndFollowUpInterceptor.isCanceled()) {\n           signalledCallback = true;\n           responseCallback.onFailure(RealCall.this, new IOException(\"Canceled\"));\n         } else {\n           signalledCallback = true;\n           responseCallback.onResponse(RealCall.this, response);\n         }\n-        eventListener.callEnd(RealCall.this);\n       } catch (IOException e) {\n         if (signalledCallback) {\n           // Do not signal the callback twice!\n           Platform.get().log(INFO, \"Callback failure for \" + toLoggableString(), e);\n         } else {\n           eventListener.callFailed(RealCall.this, e);\n           responseCallback.onFailure(RealCall.this, e);\n         }\n       } finally {\n         client.dispatcher().finished(this);\n       }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"1c98464839434a0fe7c7581cdae44bd3f2e6edd3": {
			"type": "Ybodychange",
			"commitMessage": "Move all failures into connectFailed and callFailed. (#3550)\n\nI think applications might be simple by tracking successful events\r\nseparately from failure events.",
			"commitDate": "2017-08-29, 1:14 PM",
			"commitName": "1c98464839434a0fe7c7581cdae44bd3f2e6edd3",
			"commitAuthor": "Jesse Wilson",
			"commitDateOld": "2017-08-14, 7:29 AM",
			"commitNameOld": "7489193d5953bfba8c892e5aa98624e4ec73dbde",
			"commitAuthorOld": "Dave Roberge",
			"daysBetweenCommits": 15.24,
			"commitsBetweenForRepo": 8,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,24 +1,24 @@\n     @Override protected void execute() {\n       boolean signalledCallback = false;\n       try {\n         Response response = getResponseWithInterceptorChain();\n         if (retryAndFollowUpInterceptor.isCanceled()) {\n           signalledCallback = true;\n           responseCallback.onFailure(RealCall.this, new IOException(\"Canceled\"));\n         } else {\n           signalledCallback = true;\n           responseCallback.onResponse(RealCall.this, response);\n         }\n-        eventListener.callEnd(RealCall.this, null);\n+        eventListener.callEnd(RealCall.this);\n       } catch (IOException e) {\n         if (signalledCallback) {\n           // Do not signal the callback twice!\n           Platform.get().log(INFO, \"Callback failure for \" + toLoggableString(), e);\n         } else {\n-          eventListener.callEnd(RealCall.this, e);\n+          eventListener.callFailed(RealCall.this, e);\n           responseCallback.onFailure(RealCall.this, e);\n         }\n       } finally {\n         client.dispatcher().finished(this);\n       }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"7489193d5953bfba8c892e5aa98624e4ec73dbde": {
			"type": "Ybodychange",
			"commitMessage": "Rename fetchStart/fetchEnd to callStart/callEnd. (#3522)\n\n",
			"commitDate": "2017-08-14, 7:29 AM",
			"commitName": "7489193d5953bfba8c892e5aa98624e4ec73dbde",
			"commitAuthor": "Dave Roberge",
			"commitDateOld": "2017-08-05, 1:25 PM",
			"commitNameOld": "51ca7c55da6fac733eb08a613c1c614ad2e66b5f",
			"commitAuthorOld": "Yuri Schimke",
			"daysBetweenCommits": 8.75,
			"commitsBetweenForRepo": 12,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,24 +1,24 @@\n     @Override protected void execute() {\n       boolean signalledCallback = false;\n       try {\n         Response response = getResponseWithInterceptorChain();\n         if (retryAndFollowUpInterceptor.isCanceled()) {\n           signalledCallback = true;\n           responseCallback.onFailure(RealCall.this, new IOException(\"Canceled\"));\n         } else {\n           signalledCallback = true;\n           responseCallback.onResponse(RealCall.this, response);\n         }\n-        eventListener.fetchEnd(RealCall.this, null);\n+        eventListener.callEnd(RealCall.this, null);\n       } catch (IOException e) {\n         if (signalledCallback) {\n           // Do not signal the callback twice!\n           Platform.get().log(INFO, \"Callback failure for \" + toLoggableString(), e);\n         } else {\n-          eventListener.fetchEnd(RealCall.this, e);\n+          eventListener.callEnd(RealCall.this, e);\n           responseCallback.onFailure(RealCall.this, e);\n         }\n       } finally {\n         client.dispatcher().finished(this);\n       }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"51ca7c55da6fac733eb08a613c1c614ad2e66b5f": {
			"type": "Ybodychange",
			"commitMessage": "Complete EventListener (#3476)\n\n\r\n\r\n* more docs\r\n\r\n* cleanup\r\n\r\n* log events\r\n\r\n* check end events and connectionReleased\r\n\r\n* change connectEnd signature\r\n\r\n* move response body events to codec\r\n\r\n* revert small changes\r\n\r\n* revert incidental change\r\n",
			"commitDate": "2017-08-05, 1:25 PM",
			"commitName": "51ca7c55da6fac733eb08a613c1c614ad2e66b5f",
			"commitAuthor": "Yuri Schimke",
			"commitDateOld": "2017-07-23, 3:59 PM",
			"commitNameOld": "1d8233ddb7a0dfa490a340a06433909148f21610",
			"commitAuthorOld": "ericaschulz",
			"daysBetweenCommits": 12.89,
			"commitsBetweenForRepo": 7,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,22 +1,24 @@\n     @Override protected void execute() {\n       boolean signalledCallback = false;\n       try {\n         Response response = getResponseWithInterceptorChain();\n         if (retryAndFollowUpInterceptor.isCanceled()) {\n           signalledCallback = true;\n           responseCallback.onFailure(RealCall.this, new IOException(\"Canceled\"));\n         } else {\n           signalledCallback = true;\n           responseCallback.onResponse(RealCall.this, response);\n         }\n+        eventListener.fetchEnd(RealCall.this, null);\n       } catch (IOException e) {\n         if (signalledCallback) {\n           // Do not signal the callback twice!\n           Platform.get().log(INFO, \"Callback failure for \" + toLoggableString(), e);\n         } else {\n+          eventListener.fetchEnd(RealCall.this, e);\n           responseCallback.onFailure(RealCall.this, e);\n         }\n       } finally {\n         client.dispatcher().finished(this);\n       }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"c6a578ec7696430ecf5a4d4fd8f49c39b105b471": {
			"type": "Ybodychange",
			"commitMessage": "Move core interceptors into top level classes.\n\nNo behavior changes here.\n",
			"commitDate": "2016-06-25, 4:13 PM",
			"commitName": "c6a578ec7696430ecf5a4d4fd8f49c39b105b471",
			"commitAuthor": "jwilson",
			"commitDateOld": "2016-06-25, 3:04 PM",
			"commitNameOld": "15a5bc40a4520d935bbc02a3552f51dda77fcc9c",
			"commitAuthorOld": "jwilson",
			"daysBetweenCommits": 0.05,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,22 +1,22 @@\n     @Override protected void execute() {\n       boolean signalledCallback = false;\n       try {\n         Response response = getResponseWithInterceptorChain();\n-        if (canceled) {\n+        if (retryAndFollowUpInterceptor.isCanceled()) {\n           signalledCallback = true;\n           responseCallback.onFailure(RealCall.this, new IOException(\"Canceled\"));\n         } else {\n           signalledCallback = true;\n           responseCallback.onResponse(RealCall.this, response);\n         }\n       } catch (IOException e) {\n         if (signalledCallback) {\n           // Do not signal the callback twice!\n           Platform.get().log(INFO, \"Callback failure for \" + toLoggableString(), e);\n         } else {\n           responseCallback.onFailure(RealCall.this, e);\n         }\n       } finally {\n         client.dispatcher().finished(this);\n       }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"576408374d58a3e9a63714b6f7761cb42a315102": {
			"type": "Ybodychange",
			"commitMessage": "Begin to fold together parts of RealCall and HttpEngine.\n\nPreviously we had an awkward, arbitrary separation because RealCall contained\nthe stuff that wasn't in HttpURLConnection, and HttpEngine contained everything\nthat was shared.\n\nIt was also awkward because HttpEngine could be interrupted in various parts\nof the HttpURLConnection flow: after connecting, while transmitting the request\nbody, etc. With this change we no longer need to handle API calls while we're\nin these intermediate states, which means we can reduce the scope of certain\nthings from fields to local variables.\n\nThere's still a way to go here but this is more easy wins.\n",
			"commitDate": "2016-06-23, 7:54 PM",
			"commitName": "576408374d58a3e9a63714b6f7761cb42a315102",
			"commitAuthor": "jwilson",
			"commitDateOld": "2016-06-21, 1:18 PM",
			"commitNameOld": "0f5c5c6431cfe7e5227d90fc08e822cd3b2cec9f",
			"commitAuthorOld": "jwilson",
			"daysBetweenCommits": 2.28,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,22 +1,22 @@\n     @Override protected void execute() {\n       boolean signalledCallback = false;\n       try {\n-        Response response = getResponseWithInterceptorChain(forWebSocket);\n+        Response response = getResponseWithInterceptorChain();\n         if (canceled) {\n           signalledCallback = true;\n           responseCallback.onFailure(RealCall.this, new IOException(\"Canceled\"));\n         } else {\n           signalledCallback = true;\n           responseCallback.onResponse(RealCall.this, response);\n         }\n       } catch (IOException e) {\n         if (signalledCallback) {\n           // Do not signal the callback twice!\n           Platform.get().log(INFO, \"Callback failure for \" + toLoggableString(), e);\n         } else {\n           responseCallback.onFailure(RealCall.this, e);\n         }\n       } finally {\n         client.dispatcher().finished(this);\n       }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"4f24a30c12032b7033884a630696014afd3e77cb": {
			"type": "Ybodychange",
			"commitMessage": "Make logging more consistent throughout OkHttp.\n\nAvoid using System.out.\n\nUse the best logging implementation on the host platform. On Java this is\njava.util.logging. On Android it's Android.util.Log.\n\nCloses https://github.com/square/okhttp/issues/2505\n",
			"commitDate": "2016-05-07, 6:08 PM",
			"commitName": "4f24a30c12032b7033884a630696014afd3e77cb",
			"commitAuthor": "jwilson",
			"commitDateOld": "2016-04-21, 5:52 AM",
			"commitNameOld": "047b56833ccd293ab8f9b1f61460d6d4cc1075da",
			"commitAuthorOld": "Dave Roberge",
			"daysBetweenCommits": 16.51,
			"commitsBetweenForRepo": 9,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,22 +1,22 @@\n     @Override protected void execute() {\n       boolean signalledCallback = false;\n       try {\n         Response response = getResponseWithInterceptorChain(forWebSocket);\n         if (canceled) {\n           signalledCallback = true;\n           responseCallback.onFailure(RealCall.this, new IOException(\"Canceled\"));\n         } else {\n           signalledCallback = true;\n           responseCallback.onResponse(RealCall.this, response);\n         }\n       } catch (IOException e) {\n         if (signalledCallback) {\n           // Do not signal the callback twice!\n-          logger.log(Level.INFO, \"Callback failure for \" + toLoggableString(), e);\n+          Platform.get().log(INFO, \"Callback failure for \" + toLoggableString(), e);\n         } else {\n           responseCallback.onFailure(RealCall.this, e);\n         }\n       } finally {\n         client.dispatcher().finished(this);\n       }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"8ff37250310e8d2f9e73293199b3b6e42ec45b0f": {
			"type": "Ybodychange",
			"commitMessage": "Change Callback to take a Call.\n\nThis makes it much easier to test if the call was canceled.\n\nNote that the Call's request is always the original user request.\nThis is different than the previous request that was passed in, as\nthat could have been the follow up to a redirect.\n",
			"commitDate": "2016-01-11, 3:40 PM",
			"commitName": "8ff37250310e8d2f9e73293199b3b6e42ec45b0f",
			"commitAuthor": "jwilson",
			"commitDateOld": "2016-01-01, 9:12 AM",
			"commitNameOld": "38d570a6b28664b398cfa50c5c243c3631cde997",
			"commitAuthorOld": "jwilson",
			"daysBetweenCommits": 10.27,
			"commitsBetweenForRepo": 25,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,23 +1,22 @@\n     @Override protected void execute() {\n       boolean signalledCallback = false;\n       try {\n         Response response = getResponseWithInterceptorChain(forWebSocket);\n         if (canceled) {\n           signalledCallback = true;\n-          responseCallback.onFailure(originalRequest, new IOException(\"Canceled\"));\n+          responseCallback.onFailure(RealCall.this, new IOException(\"Canceled\"));\n         } else {\n           signalledCallback = true;\n-          responseCallback.onResponse(response);\n+          responseCallback.onResponse(RealCall.this, response);\n         }\n       } catch (IOException e) {\n         if (signalledCallback) {\n           // Do not signal the callback twice!\n           logger.log(Level.INFO, \"Callback failure for \" + toLoggableString(), e);\n         } else {\n-          Request request = engine == null ? originalRequest : engine.getRequest();\n-          responseCallback.onFailure(request, e);\n+          responseCallback.onFailure(RealCall.this, e);\n         }\n       } finally {\n         client.dispatcher().finished(this);\n       }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"38d570a6b28664b398cfa50c5c243c3631cde997": {
			"type": "Ybodychange",
			"commitMessage": "Drop get and set prefixes in OkHttpClient, OkHttpClient.Builder\n",
			"commitDate": "2016-01-01, 9:12 AM",
			"commitName": "38d570a6b28664b398cfa50c5c243c3631cde997",
			"commitAuthor": "jwilson",
			"commitDateOld": "2016-01-01, 7:55 AM",
			"commitNameOld": "71ec4917b51faeba98db149739576feb51b4d505",
			"commitAuthorOld": "",
			"daysBetweenCommits": 0.05,
			"commitsBetweenForRepo": 2,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,23 +1,23 @@\n     @Override protected void execute() {\n       boolean signalledCallback = false;\n       try {\n         Response response = getResponseWithInterceptorChain(forWebSocket);\n         if (canceled) {\n           signalledCallback = true;\n           responseCallback.onFailure(originalRequest, new IOException(\"Canceled\"));\n         } else {\n           signalledCallback = true;\n           responseCallback.onResponse(response);\n         }\n       } catch (IOException e) {\n         if (signalledCallback) {\n           // Do not signal the callback twice!\n           logger.log(Level.INFO, \"Callback failure for \" + toLoggableString(), e);\n         } else {\n           Request request = engine == null ? originalRequest : engine.getRequest();\n           responseCallback.onFailure(request, e);\n         }\n       } finally {\n-        client.getDispatcher().finished(this);\n+        client.dispatcher().finished(this);\n       }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"fb700e20af6fa71a20656cd240df4df3c8f15976": {
			"type": "Ymovefromfile",
			"commitMessage": "Make call an interface, and introduce Call.Factory.\n\nMore documentation forthcoming.\n",
			"commitDate": "2015-12-23, 12:55 PM",
			"commitName": "fb700e20af6fa71a20656cd240df4df3c8f15976",
			"commitAuthor": "jwilson",
			"commitDateOld": "2015-12-22, 7:15 PM",
			"commitNameOld": "6aff563d5a730d49ced0663235b16331d6716f15",
			"commitAuthorOld": "Jake Wharton",
			"daysBetweenCommits": 0.74,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "",
			"extendedDetails": {
				"oldPath": "okhttp/src/main/java/okhttp3/Call.java",
				"newPath": "okhttp/src/main/java/okhttp3/RealCall.java",
				"oldMethodName": "execute",
				"newMethodName": "execute"
			}
		},
		"c9a89876de476983f273edbf108c365127c18c5e": {
			"type": "Ymovefromfile",
			"commitMessage": "Rename com.squareup.okhttp to okhttp3\n\nMaven group changes will come in follow up.\n",
			"commitDate": "2015-12-15, 10:34 PM",
			"commitName": "c9a89876de476983f273edbf108c365127c18c5e",
			"commitAuthor": "jwilson",
			"commitDateOld": "2015-12-15, 6:36 PM",
			"commitNameOld": "54dc2df914f2aae37fb48cc2c2f7560ee664bc2b",
			"commitAuthorOld": "Jake Wharton",
			"daysBetweenCommits": 0.17,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "",
			"extendedDetails": {
				"oldPath": "okhttp/src/main/java/com/squareup/okhttp/Call.java",
				"newPath": "okhttp/src/main/java/okhttp3/Call.java",
				"oldMethodName": "execute",
				"newMethodName": "execute"
			}
		},
		"0c1481a2d3d7482a3e0c4e63f8d99ba6cea9c24b": {
			"type": "Ybodychange",
			"commitMessage": "Make AsyncCall handle interceptors that throws an IOException\n\nThis closes #1801\n",
			"commitDate": "2015-10-20, 10:41 PM",
			"commitName": "0c1481a2d3d7482a3e0c4e63f8d99ba6cea9c24b",
			"commitAuthor": "Nicklas Ansman Giertz",
			"commitDateOld": "2015-08-02, 6:01 PM",
			"commitNameOld": "4c90a2e04a83646597a506a80b5a885d5c515bf0",
			"commitAuthorOld": "jwilson",
			"daysBetweenCommits": 79.19,
			"commitsBetweenForRepo": 46,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,22 +1,23 @@\n     @Override protected void execute() {\n       boolean signalledCallback = false;\n       try {\n         Response response = getResponseWithInterceptorChain(forWebSocket);\n         if (canceled) {\n           signalledCallback = true;\n           responseCallback.onFailure(originalRequest, new IOException(\"Canceled\"));\n         } else {\n           signalledCallback = true;\n           responseCallback.onResponse(response);\n         }\n       } catch (IOException e) {\n         if (signalledCallback) {\n           // Do not signal the callback twice!\n           logger.log(Level.INFO, \"Callback failure for \" + toLoggableString(), e);\n         } else {\n-          responseCallback.onFailure(engine.getRequest(), e);\n+          Request request = engine == null ? originalRequest : engine.getRequest();\n+          responseCallback.onFailure(request, e);\n         }\n       } finally {\n         client.getDispatcher().finished(this);\n       }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"9631227619ffe9497c67d92d20428682e5df8862": {
			"type": "Ybodychange",
			"commitMessage": "Add a web socket call concept for connecting.\n\nSimilar to HTTP and Call, the WebSocketCall is a representation of a pending HTTP request and subsequent upgrade to speak web sockets. Upon synchronous execution you are handed a WebSocket instance for synchronous writing and also pass in a WebSocketListener for async callbacks due to reading.\n\nThe API changes in this commits also generalize WebSocket such that it's agnostic to being a client or server peer.\n",
			"commitDate": "2014-12-31, 11:13 PM",
			"commitName": "9631227619ffe9497c67d92d20428682e5df8862",
			"commitAuthor": "Jake Wharton",
			"commitDateOld": "2014-12-30, 9:14 AM",
			"commitNameOld": "e49dd7a2f08deac92fab3de2b8a63e90b588f746",
			"commitAuthorOld": "Jesse Wilson",
			"daysBetweenCommits": 1.58,
			"commitsBetweenForRepo": 10,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,22 +1,22 @@\n     @Override protected void execute() {\n       boolean signalledCallback = false;\n       try {\n-        Response response = getResponseWithInterceptorChain();\n+        Response response = getResponseWithInterceptorChain(forWebSocket);\n         if (canceled) {\n           signalledCallback = true;\n           responseCallback.onFailure(originalRequest, new IOException(\"Canceled\"));\n         } else {\n           signalledCallback = true;\n           responseCallback.onResponse(response);\n         }\n       } catch (IOException e) {\n         if (signalledCallback) {\n           // Do not signal the callback twice!\n           logger.log(Level.INFO, \"Callback failure for \" + toLoggableString(), e);\n         } else {\n           responseCallback.onFailure(engine.getRequest(), e);\n         }\n       } finally {\n         client.getDispatcher().finished(this);\n       }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"e74e3f3bf744ef7f4d8ee724a7cf2347e486cfab": {
			"type": "Ybodychange",
			"commitMessage": "Move cache writing out of the transport.\n\nThis is necessary to unblock network interceptors, where the interceptor\nmay elect to rewrite the response body. If we've already cached the\noriginal response body, we're too late.\n",
			"commitDate": "2014-12-21, 6:21 PM",
			"commitName": "e74e3f3bf744ef7f4d8ee724a7cf2347e486cfab",
			"commitAuthor": "Jesse Wilson",
			"commitDateOld": "2014-12-08, 10:25 AM",
			"commitNameOld": "6184a7f5cf2a1d97072aaccb9fc00e08003848e3",
			"commitAuthorOld": "Jesse Wilson",
			"daysBetweenCommits": 13.33,
			"commitsBetweenForRepo": 11,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,22 +1,22 @@\n     @Override protected void execute() {\n       boolean signalledCallback = false;\n       try {\n         Response response = getResponseWithInterceptorChain();\n         if (canceled) {\n           signalledCallback = true;\n           responseCallback.onFailure(originalRequest, new IOException(\"Canceled\"));\n         } else {\n           signalledCallback = true;\n           responseCallback.onResponse(response);\n         }\n       } catch (IOException e) {\n         if (signalledCallback) {\n           // Do not signal the callback twice!\n           logger.log(Level.INFO, \"Callback failure for \" + toLoggableString(), e);\n         } else {\n-          responseCallback.onFailure(originalRequest, e);\n+          responseCallback.onFailure(engine.getRequest(), e);\n         }\n       } finally {\n         client.getDispatcher().finished(this);\n       }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"6184a7f5cf2a1d97072aaccb9fc00e08003848e3": {
			"type": "Ybodychange",
			"commitMessage": "Initial implementation of interceptors.\n\nI'm anticipating implementing interceptors at two independent parts\nof the API. The first is high-level interceptors, that intercept\nbefore the socket connection has been established.\n\nThe second set of interceptors will only execute for requests that\nrequire a socket connection. Those are forthcoming.\n",
			"commitDate": "2014-12-08, 10:25 AM",
			"commitName": "6184a7f5cf2a1d97072aaccb9fc00e08003848e3",
			"commitAuthor": "Jesse Wilson",
			"commitDateOld": "2014-11-30, 2:12 PM",
			"commitNameOld": "986b6b65bac1d825b1c09079625f50dbd67a1e32",
			"commitAuthorOld": "Jake Wharton",
			"daysBetweenCommits": 7.84,
			"commitsBetweenForRepo": 4,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,23 +1,22 @@\n     @Override protected void execute() {\n       boolean signalledCallback = false;\n       try {\n-        Response response = getResponse(false);\n+        Response response = getResponseWithInterceptorChain();\n         if (canceled) {\n           signalledCallback = true;\n-          responseCallback.onFailure(request, new IOException(\"Canceled\"));\n+          responseCallback.onFailure(originalRequest, new IOException(\"Canceled\"));\n         } else {\n           signalledCallback = true;\n-          engine.releaseConnection();\n           responseCallback.onResponse(response);\n         }\n       } catch (IOException e) {\n         if (signalledCallback) {\n           // Do not signal the callback twice!\n           logger.log(Level.INFO, \"Callback failure for \" + toLoggableString(), e);\n         } else {\n-          responseCallback.onFailure(request, e);\n+          responseCallback.onFailure(originalRequest, e);\n         }\n       } finally {\n         client.getDispatcher().finished(this);\n       }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"b72c9567df964696afdf4335b9456c28d017afde": {
			"type": "Ybodychange",
			"commitMessage": "Hook up the web socket reader and writer together.\n\nAdd a simple real-world recipe which talks to an echo server.\n",
			"commitDate": "2014-11-04, 11:29 PM",
			"commitName": "b72c9567df964696afdf4335b9456c28d017afde",
			"commitAuthor": "Jake Wharton",
			"commitDateOld": "2014-11-02, 9:48 AM",
			"commitNameOld": "5991ab1ecb9ea0b31826bab38ec855a893475562",
			"commitAuthorOld": "Jesse Wilson",
			"daysBetweenCommits": 2.57,
			"commitsBetweenForRepo": 15,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,23 +1,23 @@\n     @Override protected void execute() {\n       boolean signalledCallback = false;\n       try {\n-        Response response = getResponse();\n+        Response response = getResponse(false);\n         if (canceled) {\n           signalledCallback = true;\n           responseCallback.onFailure(request, new IOException(\"Canceled\"));\n         } else {\n           signalledCallback = true;\n           engine.releaseConnection();\n           responseCallback.onResponse(response);\n         }\n       } catch (IOException e) {\n         if (signalledCallback) {\n           // Do not signal the callback twice!\n           logger.log(Level.INFO, \"Callback failure for \" + toLoggableString(), e);\n         } else {\n           responseCallback.onFailure(request, e);\n         }\n       } finally {\n         client.getDispatcher().finished(this);\n       }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"40c2e6aec09d139a4e96b45856020a5b324b01ef": {
			"type": "Ybodychange",
			"commitMessage": "Use one logger for all logging.\n\nThere was a concurrency problem in CallTest where multiple calls to\nLogger.getLogger() didn't return the same instance, leading to failures\nin the test.\n",
			"commitDate": "2014-10-26, 8:48 AM",
			"commitName": "40c2e6aec09d139a4e96b45856020a5b324b01ef",
			"commitAuthor": "Jesse Wilson",
			"commitDateOld": "2014-10-25, 7:50 PM",
			"commitNameOld": "9cc7a5219f8f88bec35a073feab96abab4a9b42f",
			"commitAuthorOld": "Jesse Wilson",
			"daysBetweenCommits": 0.54,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,24 +1,23 @@\n     @Override protected void execute() {\n       boolean signalledCallback = false;\n       try {\n         Response response = getResponse();\n         if (canceled) {\n           signalledCallback = true;\n           responseCallback.onFailure(request, new IOException(\"Canceled\"));\n         } else {\n           signalledCallback = true;\n           engine.releaseConnection();\n           responseCallback.onResponse(response);\n         }\n       } catch (IOException e) {\n         if (signalledCallback) {\n           // Do not signal the callback twice!\n-          Logger.getLogger(OkHttpClient.class.getName())\n-              .log(Level.INFO, \"Callback failure for \" + toLoggableString(), e);\n+          logger.log(Level.INFO, \"Callback failure for \" + toLoggableString(), e);\n         } else {\n           responseCallback.onFailure(request, e);\n         }\n       } finally {\n         client.getDispatcher().finished(this);\n       }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"36cff8b86438a3b0f3bd3e701b374a1404a9168d": {
			"type": "Ybodychange",
			"commitMessage": "Log uncaught IOExceptions instead of rethrowing them.\n\nThe application layer can handle these with a try/catch block in their\nonResponse method if desired.\n\nThis prevents a crash for applications that haven't deliberately configured\ntheir uncaught exception handlers.\n\nCloses https://github.com/square/okhttp/issues/1049\n",
			"commitDate": "2014-10-25, 3:34 PM",
			"commitName": "36cff8b86438a3b0f3bd3e701b374a1404a9168d",
			"commitAuthor": "Jesse Wilson",
			"commitDateOld": "2014-10-11, 7:27 PM",
			"commitNameOld": "83090befcca69b44c257b96afb519ca66282ca63",
			"commitAuthorOld": "Jesse Wilson",
			"daysBetweenCommits": 13.84,
			"commitsBetweenForRepo": 7,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,19 +1,24 @@\n     @Override protected void execute() {\n       boolean signalledCallback = false;\n       try {\n         Response response = getResponse();\n         if (canceled) {\n           signalledCallback = true;\n           responseCallback.onFailure(request, new IOException(\"Canceled\"));\n         } else {\n           signalledCallback = true;\n           engine.releaseConnection();\n           responseCallback.onResponse(response);\n         }\n       } catch (IOException e) {\n-        if (signalledCallback) throw new RuntimeException(e); // Do not signal the callback twice!\n-        responseCallback.onFailure(request, e);\n+        if (signalledCallback) {\n+          // Do not signal the callback twice!\n+          Logger.getLogger(OkHttpClient.class.getName())\n+              .log(Level.INFO, \"Callback failure for \" + toLoggableString(), e);\n+        } else {\n+          responseCallback.onFailure(request, e);\n+        }\n       } finally {\n         client.getDispatcher().finished(this);\n       }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"83e42cb9288896f88c934faa116b89165b3b9689": {
			"type": "Ybodychange",
			"commitMessage": "Make it possible to mock OkHttpClient and Call.\n\nCloses https://github.com/square/okhttp/issues/956\n",
			"commitDate": "2014-06-29, 10:46 PM",
			"commitName": "83e42cb9288896f88c934faa116b89165b3b9689",
			"commitAuthor": "Jesse Wilson",
			"commitDateOld": "2014-06-10, 4:45 PM",
			"commitNameOld": "aa7e7a751c8e0096e18f792f3a737ed21d265ead",
			"commitAuthorOld": "Jesse Wilson",
			"daysBetweenCommits": 19.25,
			"commitsBetweenForRepo": 34,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,19 +1,19 @@\n     @Override protected void execute() {\n       boolean signalledCallback = false;\n       try {\n         Response response = getResponse();\n         if (canceled) {\n           signalledCallback = true;\n           responseCallback.onFailure(request, new IOException(\"Canceled\"));\n         } else {\n           signalledCallback = true;\n           engine.releaseConnection();\n           responseCallback.onResponse(response);\n         }\n       } catch (IOException e) {\n         if (signalledCallback) throw new RuntimeException(e); // Do not signal the callback twice!\n         responseCallback.onFailure(request, e);\n       } finally {\n-        dispatcher.finished(this);\n+        client.getDispatcher().finished(this);\n       }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"aa7e7a751c8e0096e18f792f3a737ed21d265ead": {
			"type": "Ybodychange",
			"commitMessage": "Keep the response body alive after the callback.\n",
			"commitDate": "2014-06-10, 4:45 PM",
			"commitName": "aa7e7a751c8e0096e18f792f3a737ed21d265ead",
			"commitAuthor": "Jesse Wilson",
			"commitDateOld": "2014-06-08, 8:29 AM",
			"commitNameOld": "baba1c090dde4d2e40479d9178bdcecafa76daa5",
			"commitAuthorOld": "Jesse Wilson",
			"daysBetweenCommits": 2.34,
			"commitsBetweenForRepo": 8,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,19 +1,19 @@\n     @Override protected void execute() {\n       boolean signalledCallback = false;\n       try {\n         Response response = getResponse();\n         if (canceled) {\n           signalledCallback = true;\n           responseCallback.onFailure(request, new IOException(\"Canceled\"));\n         } else {\n           signalledCallback = true;\n+          engine.releaseConnection();\n           responseCallback.onResponse(response);\n         }\n       } catch (IOException e) {\n         if (signalledCallback) throw new RuntimeException(e); // Do not signal the callback twice!\n         responseCallback.onFailure(request, e);\n       } finally {\n-        engine.close(); // Close the connection if it isn't already.\n         dispatcher.finished(this);\n       }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"f6a46b8992e486fb881b77c2fd533dc4d71dfd5b": {
			"type": "Ybodychange",
			"commitMessage": "Don't lose uncaught exceptions.\n",
			"commitDate": "2014-05-27, 6:33 AM",
			"commitName": "f6a46b8992e486fb881b77c2fd533dc4d71dfd5b",
			"commitAuthor": "Jesse Wilson",
			"commitDateOld": "2014-05-19, 8:18 PM",
			"commitNameOld": "ed70981925e64fd0cb593d09bdd401ea4ea19848",
			"commitAuthorOld": "Jesse Wilson",
			"daysBetweenCommits": 7.43,
			"commitsBetweenForRepo": 12,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,19 +1,19 @@\n     @Override protected void execute() {\n       boolean signalledCallback = false;\n       try {\n         Response response = getResponse();\n         if (canceled) {\n           signalledCallback = true;\n           responseCallback.onFailure(request, new IOException(\"Canceled\"));\n         } else {\n           signalledCallback = true;\n           responseCallback.onResponse(response);\n         }\n       } catch (IOException e) {\n-        if (signalledCallback) return; // Do not signal the callback twice!\n+        if (signalledCallback) throw new RuntimeException(e); // Do not signal the callback twice!\n         responseCallback.onFailure(request, e);\n       } finally {\n         engine.close(); // Close the connection if it isn't already.\n         dispatcher.finished(this);\n       }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"53b9f84cb694a6267373b1fdd6d2144a6f05b68b": {
			"type": "Ybodychange",
			"commitMessage": "Remove Failure wrapper type.\n",
			"commitDate": "2014-05-19, 1:15 PM",
			"commitName": "53b9f84cb694a6267373b1fdd6d2144a6f05b68b",
			"commitAuthor": "Jake Wharton",
			"commitDateOld": "2014-05-10, 8:20 AM",
			"commitNameOld": "84312bd93f895641f90900952dba6bb48d0b247e",
			"commitAuthorOld": "Jesse Wilson",
			"daysBetweenCommits": 9.21,
			"commitsBetweenForRepo": 14,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,25 +1,19 @@\n     @Override protected void execute() {\n       boolean signalledCallback = false;\n       try {\n         Response response = getResponse();\n         if (canceled) {\n           signalledCallback = true;\n-          responseCallback.onFailure(new Failure.Builder()\n-              .request(request)\n-              .exception(new IOException(\"Canceled\"))\n-              .build());\n+          responseCallback.onFailure(request, new IOException(\"Canceled\"));\n         } else {\n           signalledCallback = true;\n           responseCallback.onResponse(response);\n         }\n       } catch (IOException e) {\n         if (signalledCallback) return; // Do not signal the callback twice!\n-        responseCallback.onFailure(new Failure.Builder()\n-            .request(request)\n-            .exception(e)\n-            .build());\n+        responseCallback.onFailure(request, e);\n       } finally {\n         engine.close(); // Close the connection if it isn't already.\n         dispatcher.finished(this);\n       }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"c3e8a5d326f026ba6af20d0bf7da41c005ff1915": {
			"type": "Ybodychange",
			"commitMessage": "Use IOE for canceled streams.\n",
			"commitDate": "2014-04-25, 3:21 PM",
			"commitName": "c3e8a5d326f026ba6af20d0bf7da41c005ff1915",
			"commitAuthor": "Adrian Cole",
			"commitDateOld": "2014-04-25, 2:30 PM",
			"commitNameOld": "38ea820a73eb318254e9722653aac8878598c266",
			"commitAuthorOld": "Adrian Cole",
			"daysBetweenCommits": 0.04,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,25 +1,25 @@\n     @Override protected void execute() {\n       boolean signalledCallback = false;\n       try {\n         Response response = getResponse();\n         if (canceled) {\n           signalledCallback = true;\n           responseCallback.onFailure(new Failure.Builder()\n               .request(request)\n-              .exception(new CancellationException(\"Canceled\"))\n+              .exception(new IOException(\"Canceled\"))\n               .build());\n         } else {\n           signalledCallback = true;\n           responseCallback.onResponse(response);\n         }\n       } catch (IOException e) {\n         if (signalledCallback) return; // Do not signal the callback twice!\n         responseCallback.onFailure(new Failure.Builder()\n             .request(request)\n             .exception(e)\n             .build());\n       } finally {\n         engine.close(); // Close the connection if it isn't already.\n         dispatcher.finished(this);\n       }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"63d4dfaaa622d4cce72a09cdeead267afa3453a6": {
			"type": "Ymovefromfile",
			"commitMessage": "Merge Job into Call. CallTest = AsyncApiTest + SyncApiTest.\n",
			"commitDate": "2014-04-25, 11:13 AM",
			"commitName": "63d4dfaaa622d4cce72a09cdeead267afa3453a6",
			"commitAuthor": "Adrian Cole",
			"commitDateOld": "2014-04-25, 8:18 AM",
			"commitNameOld": "f4c83e8eb86ac4afb224f91cd68bd9650351fe64",
			"commitAuthorOld": "Adrian Cole",
			"daysBetweenCommits": 0.12,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,25 +1,25 @@\n-  @Override protected void execute() {\n-    boolean signalledCallback = false;\n-    try {\n-      Response response = getResponse();\n-      if (canceled) {\n-        signalledCallback = true;\n+    @Override protected void execute() {\n+      boolean signalledCallback = false;\n+      try {\n+        Response response = getResponse();\n+        if (canceled) {\n+          signalledCallback = true;\n+          responseCallback.onFailure(new Failure.Builder()\n+              .request(request)\n+              .exception(new CancellationException(\"Canceled\"))\n+              .build());\n+        } else {\n+          signalledCallback = true;\n+          responseCallback.onResponse(response);\n+        }\n+      } catch (IOException e) {\n+        if (signalledCallback) return; // Do not signal the callback twice!\n         responseCallback.onFailure(new Failure.Builder()\n             .request(request)\n-            .exception(new CancellationException(\"Canceled\"))\n+            .exception(e)\n             .build());\n-      } else {\n-        signalledCallback = true;\n-        responseCallback.onResponse(response);\n+      } finally {\n+        engine.close(); // Close the connection if it isn't already.\n+        dispatcher.finished(this);\n       }\n-    } catch (IOException e) {\n-      if (signalledCallback) return; // Do not signal the callback twice!\n-      responseCallback.onFailure(new Failure.Builder()\n-          .request(request)\n-          .exception(e)\n-          .build());\n-    } finally {\n-      engine.close(); // Close the connection if it isn't already.\n-      dispatcher.finished(this);\n-    }\n-  }\n\\ No newline at end of file\n+    }\n\\ No newline at end of file\n",
			"extendedDetails": {
				"oldPath": "okhttp/src/main/java/com/squareup/okhttp/Job.java",
				"newPath": "okhttp/src/main/java/com/squareup/okhttp/Call.java",
				"oldMethodName": "execute",
				"newMethodName": "execute"
			}
		},
		"0b677ac70d37f9064d3a0c0914794f60f66d64be": {
			"type": "Ybodychange",
			"commitMessage": "Introduce Call for async invocations.\n",
			"commitDate": "2014-04-24, 9:25 PM",
			"commitName": "0b677ac70d37f9064d3a0c0914794f60f66d64be",
			"commitAuthor": "Adrian Cole",
			"commitDateOld": "2014-04-22, 9:55 PM",
			"commitNameOld": "5b6f64a46220911466350202ae974f167497225a",
			"commitAuthorOld": "Jesse Wilson",
			"daysBetweenCommits": 1.98,
			"commitsBetweenForRepo": 4,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,25 +1,25 @@\n   @Override protected void execute() {\n-    boolean signalledReceiver = false;\n+    boolean signalledCallback = false;\n     try {\n       Response response = getResponse();\n       if (canceled) {\n-        signalledReceiver = true;\n-        responseReceiver.onFailure(new Failure.Builder()\n+        signalledCallback = true;\n+        responseCallback.onFailure(new Failure.Builder()\n             .request(request)\n             .exception(new CancellationException(\"Canceled\"))\n             .build());\n       } else {\n-        signalledReceiver = true;\n-        responseReceiver.onResponse(response);\n+        signalledCallback = true;\n+        responseCallback.onResponse(response);\n       }\n     } catch (IOException e) {\n-      if (signalledReceiver) return; // Do not signal the receiver twice!\n-      responseReceiver.onFailure(new Failure.Builder()\n+      if (signalledCallback) return; // Do not signal the callback twice!\n+      responseCallback.onFailure(new Failure.Builder()\n           .request(request)\n           .exception(e)\n           .build());\n     } finally {\n       engine.close(); // Close the connection if it isn't already.\n       dispatcher.finished(this);\n     }\n   }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"112dcc40900d503ea7e416e0da0a8fd9b08a9c17": {
			"type": "Ybodychange",
			"commitMessage": "Clarified behavior of AsyncApi when a request is canceled, including its implied disconnect.\n",
			"commitDate": "2014-04-22, 8:39 AM",
			"commitName": "112dcc40900d503ea7e416e0da0a8fd9b08a9c17",
			"commitAuthor": "Adrian Cole",
			"commitDateOld": "2014-04-21, 9:14 PM",
			"commitNameOld": "9146c579dd9110d0028144c59515da9be1ce7108",
			"commitAuthorOld": "Jesse Wilson",
			"daysBetweenCommits": 0.48,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,16 +1,25 @@\n   @Override protected void execute() {\n+    boolean signalledReceiver = false;\n     try {\n       Response response = getResponse();\n-      if (response != null && !canceled) {\n+      if (canceled) {\n+        signalledReceiver = true;\n+        responseReceiver.onFailure(new Failure.Builder()\n+            .request(request)\n+            .exception(new CancellationException(\"Canceled\"))\n+            .build());\n+      } else {\n+        signalledReceiver = true;\n         responseReceiver.onResponse(response);\n       }\n     } catch (IOException e) {\n+      if (signalledReceiver) return; // Do not signal the receiver twice!\n       responseReceiver.onFailure(new Failure.Builder()\n           .request(request)\n           .exception(e)\n           .build());\n     } finally {\n       engine.close(); // Close the connection if it isn't already.\n       dispatcher.finished(this);\n     }\n   }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"dac5aed3d5f9307b9d1ab0a8c7840b232d053ef3": {
			"type": "Ybodychange",
			"commitMessage": "Move connection pooling logic.\n\nPreviously we had this ugly, awkward release() method that\nattempted to manage connection pooling, discarding streams\nfor caching, and closing broken streams.\n\nMove connection reuse to HttpConnection, with policy informed\nby HttpEngine. It specifies what to do when the connection\nbecomes idle: pool, close or hold. The connection does what\nit's told.\n",
			"commitDate": "2014-02-15, 3:44 PM",
			"commitName": "dac5aed3d5f9307b9d1ab0a8c7840b232d053ef3",
			"commitAuthor": "jwilson",
			"commitDateOld": "2014-01-13, 8:10 PM",
			"commitNameOld": "8972a94aee5b1a8732b4f8246c6ce43fd9e5e1cb",
			"commitAuthorOld": "jwilson",
			"daysBetweenCommits": 32.82,
			"commitsBetweenForRepo": 77,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,16 +1,16 @@\n   @Override protected void execute() {\n     try {\n       Response response = getResponse();\n       if (response != null && !canceled) {\n         responseReceiver.onResponse(response);\n       }\n     } catch (IOException e) {\n       responseReceiver.onFailure(new Failure.Builder()\n           .request(request)\n           .exception(e)\n           .build());\n     } finally {\n-      engine.release(true); // Release the connection if it isn't already released.\n+      engine.close(); // Close the connection if it isn't already.\n       dispatcher.finished(this);\n     }\n   }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"749a65b776c8fc4b39b6463695980275da34da51": {
			"type": "Ymultichange(Yreturntypechange,Ymodifierchange,Yexceptionschange,Ybodychange)",
			"commitMessage": "Use thread names everywhere.\n\nSometimes we name a thread both via its ExecutorService\nand via a NamedRunnable. The ExecutorService thread needs\nto be named because threads are cached and will be visible\nin a thread dump even when no runnables are running.\n\nNamedRunnables are also used because they provide additional\ncontext: the host or URL being serviced by a thread.\n",
			"commitDate": "2014-01-12, 6:47 AM",
			"commitName": "749a65b776c8fc4b39b6463695980275da34da51",
			"commitAuthor": "jwilson",
			"subchanges": [
				{
					"type": "Yreturntypechange",
					"commitMessage": "Use thread names everywhere.\n\nSometimes we name a thread both via its ExecutorService\nand via a NamedRunnable. The ExecutorService thread needs\nto be named because threads are cached and will be visible\nin a thread dump even when no runnables are running.\n\nNamedRunnables are also used because they provide additional\ncontext: the host or URL being serviced by a thread.\n",
					"commitDate": "2014-01-12, 6:47 AM",
					"commitName": "749a65b776c8fc4b39b6463695980275da34da51",
					"commitAuthor": "jwilson",
					"commitDateOld": "2014-01-07, 7:41 PM",
					"commitNameOld": "2fb9064eb6ecbd5bafc0bc8fd0e42933dd13fe7a",
					"commitAuthorOld": "jwilson",
					"daysBetweenCommits": 4.46,
					"commitsBetweenForRepo": 14,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,57 +1,16 @@\n-  private Response execute() throws IOException {\n-    Connection connection = null;\n-    Response redirectedBy = null;\n-\n-    while (true) {\n-      if (canceled) return null;\n-\n-      Request.Body body = request.body();\n-      if (body != null) {\n-        MediaType contentType = body.contentType();\n-        if (contentType == null) throw new IllegalStateException(\"contentType == null\");\n-\n-        Request.Builder requestBuilder = request.newBuilder();\n-        requestBuilder.header(\"Content-Type\", contentType.toString());\n-\n-        long contentLength = body.contentLength();\n-        if (contentLength != -1) {\n-          requestBuilder.header(\"Content-Length\", Long.toString(contentLength));\n-          requestBuilder.removeHeader(\"Transfer-Encoding\");\n-        } else {\n-          requestBuilder.header(\"Transfer-Encoding\", \"chunked\");\n-          requestBuilder.removeHeader(\"Content-Length\");\n-        }\n-\n-        request = requestBuilder.build();\n+  @Override protected void execute() {\n+    try {\n+      Response response = getResponse();\n+      if (response != null && !canceled) {\n+        responseReceiver.onResponse(response);\n       }\n-\n-      engine = new HttpEngine(client, request, false, connection, null);\n-      engine.sendRequest();\n-\n-      if (body != null) {\n-        body.writeTo(engine.getRequestBody());\n-      }\n-\n-      engine.readResponse();\n-\n-      Response response = engine.getResponse();\n-      Request redirect = processResponse(engine, response);\n-\n-      if (redirect == null) {\n-        engine.automaticallyReleaseConnectionToPool();\n-        return response.newBuilder()\n-            .body(new RealResponseBody(response, engine.getResponseBody()))\n-            .redirectedBy(redirectedBy)\n-            .build();\n-      }\n-\n-      if (!sameConnection(request, redirect)) {\n-        engine.automaticallyReleaseConnectionToPool();\n-      }\n-\n-      engine.release(false);\n-      connection = engine.getConnection();\n-      redirectedBy = response.newBuilder().redirectedBy(redirectedBy).build(); // Chained.\n-      request = redirect;\n+    } catch (IOException e) {\n+      responseReceiver.onFailure(new Failure.Builder()\n+          .request(request)\n+          .exception(e)\n+          .build());\n+    } finally {\n+      engine.release(true); // Release the connection if it isn't already released.\n+      dispatcher.finished(this);\n     }\n   }\n\\ No newline at end of file\n",
					"extendedDetails": {
						"oldValue": "Response",
						"newValue": "void"
					}
				},
				{
					"type": "Ymodifierchange",
					"commitMessage": "Use thread names everywhere.\n\nSometimes we name a thread both via its ExecutorService\nand via a NamedRunnable. The ExecutorService thread needs\nto be named because threads are cached and will be visible\nin a thread dump even when no runnables are running.\n\nNamedRunnables are also used because they provide additional\ncontext: the host or URL being serviced by a thread.\n",
					"commitDate": "2014-01-12, 6:47 AM",
					"commitName": "749a65b776c8fc4b39b6463695980275da34da51",
					"commitAuthor": "jwilson",
					"commitDateOld": "2014-01-07, 7:41 PM",
					"commitNameOld": "2fb9064eb6ecbd5bafc0bc8fd0e42933dd13fe7a",
					"commitAuthorOld": "jwilson",
					"daysBetweenCommits": 4.46,
					"commitsBetweenForRepo": 14,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,57 +1,16 @@\n-  private Response execute() throws IOException {\n-    Connection connection = null;\n-    Response redirectedBy = null;\n-\n-    while (true) {\n-      if (canceled) return null;\n-\n-      Request.Body body = request.body();\n-      if (body != null) {\n-        MediaType contentType = body.contentType();\n-        if (contentType == null) throw new IllegalStateException(\"contentType == null\");\n-\n-        Request.Builder requestBuilder = request.newBuilder();\n-        requestBuilder.header(\"Content-Type\", contentType.toString());\n-\n-        long contentLength = body.contentLength();\n-        if (contentLength != -1) {\n-          requestBuilder.header(\"Content-Length\", Long.toString(contentLength));\n-          requestBuilder.removeHeader(\"Transfer-Encoding\");\n-        } else {\n-          requestBuilder.header(\"Transfer-Encoding\", \"chunked\");\n-          requestBuilder.removeHeader(\"Content-Length\");\n-        }\n-\n-        request = requestBuilder.build();\n+  @Override protected void execute() {\n+    try {\n+      Response response = getResponse();\n+      if (response != null && !canceled) {\n+        responseReceiver.onResponse(response);\n       }\n-\n-      engine = new HttpEngine(client, request, false, connection, null);\n-      engine.sendRequest();\n-\n-      if (body != null) {\n-        body.writeTo(engine.getRequestBody());\n-      }\n-\n-      engine.readResponse();\n-\n-      Response response = engine.getResponse();\n-      Request redirect = processResponse(engine, response);\n-\n-      if (redirect == null) {\n-        engine.automaticallyReleaseConnectionToPool();\n-        return response.newBuilder()\n-            .body(new RealResponseBody(response, engine.getResponseBody()))\n-            .redirectedBy(redirectedBy)\n-            .build();\n-      }\n-\n-      if (!sameConnection(request, redirect)) {\n-        engine.automaticallyReleaseConnectionToPool();\n-      }\n-\n-      engine.release(false);\n-      connection = engine.getConnection();\n-      redirectedBy = response.newBuilder().redirectedBy(redirectedBy).build(); // Chained.\n-      request = redirect;\n+    } catch (IOException e) {\n+      responseReceiver.onFailure(new Failure.Builder()\n+          .request(request)\n+          .exception(e)\n+          .build());\n+    } finally {\n+      engine.release(true); // Release the connection if it isn't already released.\n+      dispatcher.finished(this);\n     }\n   }\n\\ No newline at end of file\n",
					"extendedDetails": {
						"oldValue": "[private]",
						"newValue": "[protected]"
					}
				},
				{
					"type": "Yexceptionschange",
					"commitMessage": "Use thread names everywhere.\n\nSometimes we name a thread both via its ExecutorService\nand via a NamedRunnable. The ExecutorService thread needs\nto be named because threads are cached and will be visible\nin a thread dump even when no runnables are running.\n\nNamedRunnables are also used because they provide additional\ncontext: the host or URL being serviced by a thread.\n",
					"commitDate": "2014-01-12, 6:47 AM",
					"commitName": "749a65b776c8fc4b39b6463695980275da34da51",
					"commitAuthor": "jwilson",
					"commitDateOld": "2014-01-07, 7:41 PM",
					"commitNameOld": "2fb9064eb6ecbd5bafc0bc8fd0e42933dd13fe7a",
					"commitAuthorOld": "jwilson",
					"daysBetweenCommits": 4.46,
					"commitsBetweenForRepo": 14,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,57 +1,16 @@\n-  private Response execute() throws IOException {\n-    Connection connection = null;\n-    Response redirectedBy = null;\n-\n-    while (true) {\n-      if (canceled) return null;\n-\n-      Request.Body body = request.body();\n-      if (body != null) {\n-        MediaType contentType = body.contentType();\n-        if (contentType == null) throw new IllegalStateException(\"contentType == null\");\n-\n-        Request.Builder requestBuilder = request.newBuilder();\n-        requestBuilder.header(\"Content-Type\", contentType.toString());\n-\n-        long contentLength = body.contentLength();\n-        if (contentLength != -1) {\n-          requestBuilder.header(\"Content-Length\", Long.toString(contentLength));\n-          requestBuilder.removeHeader(\"Transfer-Encoding\");\n-        } else {\n-          requestBuilder.header(\"Transfer-Encoding\", \"chunked\");\n-          requestBuilder.removeHeader(\"Content-Length\");\n-        }\n-\n-        request = requestBuilder.build();\n+  @Override protected void execute() {\n+    try {\n+      Response response = getResponse();\n+      if (response != null && !canceled) {\n+        responseReceiver.onResponse(response);\n       }\n-\n-      engine = new HttpEngine(client, request, false, connection, null);\n-      engine.sendRequest();\n-\n-      if (body != null) {\n-        body.writeTo(engine.getRequestBody());\n-      }\n-\n-      engine.readResponse();\n-\n-      Response response = engine.getResponse();\n-      Request redirect = processResponse(engine, response);\n-\n-      if (redirect == null) {\n-        engine.automaticallyReleaseConnectionToPool();\n-        return response.newBuilder()\n-            .body(new RealResponseBody(response, engine.getResponseBody()))\n-            .redirectedBy(redirectedBy)\n-            .build();\n-      }\n-\n-      if (!sameConnection(request, redirect)) {\n-        engine.automaticallyReleaseConnectionToPool();\n-      }\n-\n-      engine.release(false);\n-      connection = engine.getConnection();\n-      redirectedBy = response.newBuilder().redirectedBy(redirectedBy).build(); // Chained.\n-      request = redirect;\n+    } catch (IOException e) {\n+      responseReceiver.onFailure(new Failure.Builder()\n+          .request(request)\n+          .exception(e)\n+          .build());\n+    } finally {\n+      engine.release(true); // Release the connection if it isn't already released.\n+      dispatcher.finished(this);\n     }\n   }\n\\ No newline at end of file\n",
					"extendedDetails": {
						"oldValue": "[IOException]",
						"newValue": "[]"
					}
				},
				{
					"type": "Ybodychange",
					"commitMessage": "Use thread names everywhere.\n\nSometimes we name a thread both via its ExecutorService\nand via a NamedRunnable. The ExecutorService thread needs\nto be named because threads are cached and will be visible\nin a thread dump even when no runnables are running.\n\nNamedRunnables are also used because they provide additional\ncontext: the host or URL being serviced by a thread.\n",
					"commitDate": "2014-01-12, 6:47 AM",
					"commitName": "749a65b776c8fc4b39b6463695980275da34da51",
					"commitAuthor": "jwilson",
					"commitDateOld": "2014-01-07, 7:41 PM",
					"commitNameOld": "2fb9064eb6ecbd5bafc0bc8fd0e42933dd13fe7a",
					"commitAuthorOld": "jwilson",
					"daysBetweenCommits": 4.46,
					"commitsBetweenForRepo": 14,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,57 +1,16 @@\n-  private Response execute() throws IOException {\n-    Connection connection = null;\n-    Response redirectedBy = null;\n-\n-    while (true) {\n-      if (canceled) return null;\n-\n-      Request.Body body = request.body();\n-      if (body != null) {\n-        MediaType contentType = body.contentType();\n-        if (contentType == null) throw new IllegalStateException(\"contentType == null\");\n-\n-        Request.Builder requestBuilder = request.newBuilder();\n-        requestBuilder.header(\"Content-Type\", contentType.toString());\n-\n-        long contentLength = body.contentLength();\n-        if (contentLength != -1) {\n-          requestBuilder.header(\"Content-Length\", Long.toString(contentLength));\n-          requestBuilder.removeHeader(\"Transfer-Encoding\");\n-        } else {\n-          requestBuilder.header(\"Transfer-Encoding\", \"chunked\");\n-          requestBuilder.removeHeader(\"Content-Length\");\n-        }\n-\n-        request = requestBuilder.build();\n+  @Override protected void execute() {\n+    try {\n+      Response response = getResponse();\n+      if (response != null && !canceled) {\n+        responseReceiver.onResponse(response);\n       }\n-\n-      engine = new HttpEngine(client, request, false, connection, null);\n-      engine.sendRequest();\n-\n-      if (body != null) {\n-        body.writeTo(engine.getRequestBody());\n-      }\n-\n-      engine.readResponse();\n-\n-      Response response = engine.getResponse();\n-      Request redirect = processResponse(engine, response);\n-\n-      if (redirect == null) {\n-        engine.automaticallyReleaseConnectionToPool();\n-        return response.newBuilder()\n-            .body(new RealResponseBody(response, engine.getResponseBody()))\n-            .redirectedBy(redirectedBy)\n-            .build();\n-      }\n-\n-      if (!sameConnection(request, redirect)) {\n-        engine.automaticallyReleaseConnectionToPool();\n-      }\n-\n-      engine.release(false);\n-      connection = engine.getConnection();\n-      redirectedBy = response.newBuilder().redirectedBy(redirectedBy).build(); // Chained.\n-      request = redirect;\n+    } catch (IOException e) {\n+      responseReceiver.onFailure(new Failure.Builder()\n+          .request(request)\n+          .exception(e)\n+          .build());\n+    } finally {\n+      engine.release(true); // Release the connection if it isn't already released.\n+      dispatcher.finished(this);\n     }\n   }\n\\ No newline at end of file\n",
					"extendedDetails": {}
				}
			]
		},
		"2fb9064eb6ecbd5bafc0bc8fd0e42933dd13fe7a": {
			"type": "Ybodychange",
			"commitMessage": "Cleanup when a job finishes, cleanly or otherwise.\n\nThis also names the job thread.\n",
			"commitDate": "2014-01-07, 7:41 PM",
			"commitName": "2fb9064eb6ecbd5bafc0bc8fd0e42933dd13fe7a",
			"commitAuthor": "jwilson",
			"commitDateOld": "2014-01-05, 4:28 PM",
			"commitNameOld": "f3a450bf4f0e9428cf8b3c2780236162bbeb803a",
			"commitAuthorOld": "jwilson",
			"daysBetweenCommits": 2.13,
			"commitsBetweenForRepo": 11,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,57 +1,57 @@\n   private Response execute() throws IOException {\n     Connection connection = null;\n     Response redirectedBy = null;\n \n     while (true) {\n       if (canceled) return null;\n \n       Request.Body body = request.body();\n       if (body != null) {\n         MediaType contentType = body.contentType();\n         if (contentType == null) throw new IllegalStateException(\"contentType == null\");\n \n         Request.Builder requestBuilder = request.newBuilder();\n         requestBuilder.header(\"Content-Type\", contentType.toString());\n \n         long contentLength = body.contentLength();\n         if (contentLength != -1) {\n           requestBuilder.header(\"Content-Length\", Long.toString(contentLength));\n           requestBuilder.removeHeader(\"Transfer-Encoding\");\n         } else {\n           requestBuilder.header(\"Transfer-Encoding\", \"chunked\");\n           requestBuilder.removeHeader(\"Content-Length\");\n         }\n \n         request = requestBuilder.build();\n       }\n \n-      HttpEngine engine = new HttpEngine(client, request, false, connection, null);\n+      engine = new HttpEngine(client, request, false, connection, null);\n       engine.sendRequest();\n \n       if (body != null) {\n         body.writeTo(engine.getRequestBody());\n       }\n \n       engine.readResponse();\n \n       Response response = engine.getResponse();\n       Request redirect = processResponse(engine, response);\n \n       if (redirect == null) {\n         engine.automaticallyReleaseConnectionToPool();\n         return response.newBuilder()\n             .body(new RealResponseBody(response, engine.getResponseBody()))\n             .redirectedBy(redirectedBy)\n             .build();\n       }\n \n       if (!sameConnection(request, redirect)) {\n         engine.automaticallyReleaseConnectionToPool();\n       }\n \n       engine.release(false);\n       connection = engine.getConnection();\n       redirectedBy = response.newBuilder().redirectedBy(redirectedBy).build(); // Chained.\n       request = redirect;\n     }\n   }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"f3a450bf4f0e9428cf8b3c2780236162bbeb803a": {
			"type": "Ybodychange",
			"commitMessage": "Code to handle redirect limits in the async API.\n",
			"commitDate": "2014-01-05, 4:28 PM",
			"commitName": "f3a450bf4f0e9428cf8b3c2780236162bbeb803a",
			"commitAuthor": "jwilson",
			"commitDateOld": "2014-01-05, 7:06 AM",
			"commitNameOld": "a31a5192d1604131d5239fbf2f5280f1ac5eeeaa",
			"commitAuthorOld": "jwilson",
			"daysBetweenCommits": 0.39,
			"commitsBetweenForRepo": 3,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,56 +1,57 @@\n   private Response execute() throws IOException {\n     Connection connection = null;\n     Response redirectedBy = null;\n \n     while (true) {\n       if (canceled) return null;\n \n       Request.Body body = request.body();\n       if (body != null) {\n         MediaType contentType = body.contentType();\n         if (contentType == null) throw new IllegalStateException(\"contentType == null\");\n \n         Request.Builder requestBuilder = request.newBuilder();\n         requestBuilder.header(\"Content-Type\", contentType.toString());\n \n         long contentLength = body.contentLength();\n         if (contentLength != -1) {\n           requestBuilder.header(\"Content-Length\", Long.toString(contentLength));\n           requestBuilder.removeHeader(\"Transfer-Encoding\");\n         } else {\n           requestBuilder.header(\"Transfer-Encoding\", \"chunked\");\n           requestBuilder.removeHeader(\"Content-Length\");\n         }\n \n         request = requestBuilder.build();\n       }\n \n       HttpEngine engine = new HttpEngine(client, request, false, connection, null);\n       engine.sendRequest();\n \n       if (body != null) {\n         body.writeTo(engine.getRequestBody());\n       }\n \n       engine.readResponse();\n \n       Response response = engine.getResponse();\n       Request redirect = processResponse(engine, response);\n \n       if (redirect == null) {\n         engine.automaticallyReleaseConnectionToPool();\n         return response.newBuilder()\n             .body(new RealResponseBody(response, engine.getResponseBody()))\n             .redirectedBy(redirectedBy)\n             .build();\n       }\n \n-      // TODO: fail if too many redirects\n-      // TODO: fail if not following redirects\n-      engine.release(false);\n+      if (!sameConnection(request, redirect)) {\n+        engine.automaticallyReleaseConnectionToPool();\n+      }\n \n-      connection = sameConnection(request, redirect) ? engine.getConnection() : null;\n+      engine.release(false);\n+      connection = engine.getConnection();\n       redirectedBy = response.newBuilder().redirectedBy(redirectedBy).build(); // Chained.\n       request = redirect;\n     }\n   }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"a31a5192d1604131d5239fbf2f5280f1ac5eeeaa": {
			"type": "Ybodychange",
			"commitMessage": "Implement simple limits in the dispatcher.\n\nThis adds Dispatcher to the public API so that application\ncode can tweak the policy.\n",
			"commitDate": "2014-01-05, 7:06 AM",
			"commitName": "a31a5192d1604131d5239fbf2f5280f1ac5eeeaa",
			"commitAuthor": "jwilson",
			"commitDateOld": "2014-01-03, 2:36 PM",
			"commitNameOld": "9417fa5c2e84580411e0fa4905b1f109e2d49533",
			"commitAuthorOld": "jwilson",
			"daysBetweenCommits": 1.69,
			"commitsBetweenForRepo": 4,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,54 +1,56 @@\n   private Response execute() throws IOException {\n     Connection connection = null;\n     Response redirectedBy = null;\n \n     while (true) {\n+      if (canceled) return null;\n+\n       Request.Body body = request.body();\n       if (body != null) {\n         MediaType contentType = body.contentType();\n         if (contentType == null) throw new IllegalStateException(\"contentType == null\");\n \n         Request.Builder requestBuilder = request.newBuilder();\n         requestBuilder.header(\"Content-Type\", contentType.toString());\n \n         long contentLength = body.contentLength();\n         if (contentLength != -1) {\n           requestBuilder.header(\"Content-Length\", Long.toString(contentLength));\n           requestBuilder.removeHeader(\"Transfer-Encoding\");\n         } else {\n           requestBuilder.header(\"Transfer-Encoding\", \"chunked\");\n           requestBuilder.removeHeader(\"Content-Length\");\n         }\n \n         request = requestBuilder.build();\n       }\n \n-      HttpEngine engine = newEngine(connection);\n+      HttpEngine engine = new HttpEngine(client, request, false, connection, null);\n       engine.sendRequest();\n \n       if (body != null) {\n         body.writeTo(engine.getRequestBody());\n       }\n \n       engine.readResponse();\n \n       Response response = engine.getResponse();\n       Request redirect = processResponse(engine, response);\n \n       if (redirect == null) {\n         engine.automaticallyReleaseConnectionToPool();\n         return response.newBuilder()\n             .body(new RealResponseBody(response, engine.getResponseBody()))\n             .redirectedBy(redirectedBy)\n             .build();\n       }\n \n       // TODO: fail if too many redirects\n       // TODO: fail if not following redirects\n       engine.release(false);\n \n       connection = sameConnection(request, redirect) ? engine.getConnection() : null;\n       redirectedBy = response.newBuilder().redirectedBy(redirectedBy).build(); // Chained.\n       request = redirect;\n     }\n   }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"9417fa5c2e84580411e0fa4905b1f109e2d49533": {
			"type": "Ybodychange",
			"commitMessage": "Another round of header APIs cleanup.\n\nThis promotes Headers to a public API from the internal package.\nIt moves some of its methods to OkHeaders, which has been renamed\nfrom SyntheticHeaders.\n\nMaking the Headers class public API makes it possible to remove\nmore exotic APIs from Request and Response like the APIs to track\nheaders by index rather than by name.\n",
			"commitDate": "2014-01-03, 2:36 PM",
			"commitName": "9417fa5c2e84580411e0fa4905b1f109e2d49533",
			"commitAuthor": "jwilson",
			"commitDateOld": "2014-01-02, 9:52 PM",
			"commitNameOld": "b21ea3a7daf9de0a5deb9bf7cf6d791c2ff63d3b",
			"commitAuthorOld": "jwilson",
			"daysBetweenCommits": 0.7,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,54 +1,54 @@\n   private Response execute() throws IOException {\n     Connection connection = null;\n     Response redirectedBy = null;\n \n     while (true) {\n       Request.Body body = request.body();\n       if (body != null) {\n         MediaType contentType = body.contentType();\n         if (contentType == null) throw new IllegalStateException(\"contentType == null\");\n \n         Request.Builder requestBuilder = request.newBuilder();\n         requestBuilder.header(\"Content-Type\", contentType.toString());\n \n         long contentLength = body.contentLength();\n         if (contentLength != -1) {\n-          requestBuilder.setContentLength(contentLength);\n+          requestBuilder.header(\"Content-Length\", Long.toString(contentLength));\n           requestBuilder.removeHeader(\"Transfer-Encoding\");\n         } else {\n           requestBuilder.header(\"Transfer-Encoding\", \"chunked\");\n           requestBuilder.removeHeader(\"Content-Length\");\n         }\n \n         request = requestBuilder.build();\n       }\n \n       HttpEngine engine = newEngine(connection);\n       engine.sendRequest();\n \n       if (body != null) {\n         body.writeTo(engine.getRequestBody());\n       }\n \n       engine.readResponse();\n \n       Response response = engine.getResponse();\n       Request redirect = processResponse(engine, response);\n \n       if (redirect == null) {\n         engine.automaticallyReleaseConnectionToPool();\n         return response.newBuilder()\n-            .body(new Dispatcher.RealResponseBody(response, engine.getResponseBody()))\n+            .body(new RealResponseBody(response, engine.getResponseBody()))\n             .redirectedBy(redirectedBy)\n             .build();\n       }\n \n       // TODO: fail if too many redirects\n       // TODO: fail if not following redirects\n       engine.release(false);\n \n       connection = sameConnection(request, redirect) ? engine.getConnection() : null;\n       redirectedBy = response.newBuilder().redirectedBy(redirectedBy).build(); // Chained.\n       request = redirect;\n     }\n   }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"b21ea3a7daf9de0a5deb9bf7cf6d791c2ff63d3b": {
			"type": "Ybodychange",
			"commitMessage": "Make redirects work with the async API.\n",
			"commitDate": "2014-01-02, 9:52 PM",
			"commitName": "b21ea3a7daf9de0a5deb9bf7cf6d791c2ff63d3b",
			"commitAuthor": "jwilson",
			"commitDateOld": "2014-01-02, 7:23 AM",
			"commitNameOld": "0ef26ad2e9e6b28a181ebc128f96671cff295043",
			"commitAuthorOld": "jwilson",
			"daysBetweenCommits": 0.6,
			"commitsBetweenForRepo": 2,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,56 +1,54 @@\n   private Response execute() throws IOException {\n     Connection connection = null;\n     Response redirectedBy = null;\n \n     while (true) {\n       Request.Body body = request.body();\n       if (body != null) {\n         MediaType contentType = body.contentType();\n         if (contentType == null) throw new IllegalStateException(\"contentType == null\");\n \n         Request.Builder requestBuilder = request.newBuilder();\n         requestBuilder.header(\"Content-Type\", contentType.toString());\n \n         long contentLength = body.contentLength();\n         if (contentLength != -1) {\n           requestBuilder.setContentLength(contentLength);\n           requestBuilder.removeHeader(\"Transfer-Encoding\");\n         } else {\n           requestBuilder.header(\"Transfer-Encoding\", \"chunked\");\n           requestBuilder.removeHeader(\"Content-Length\");\n         }\n \n         request = requestBuilder.build();\n       }\n \n       HttpEngine engine = newEngine(connection);\n       engine.sendRequest();\n \n       if (body != null) {\n         body.writeTo(engine.getRequestBody());\n       }\n \n       engine.readResponse();\n \n-      Response engineResponse = engine.getResponse();\n-      Response response = engineResponse.newBuilder()\n-          .body(new Dispatcher.RealResponseBody(engineResponse, engine.getResponseBody()))\n-          .redirectedBy(redirectedBy)\n-          .build();\n-\n+      Response response = engine.getResponse();\n       Request redirect = processResponse(engine, response);\n \n       if (redirect == null) {\n         engine.automaticallyReleaseConnectionToPool();\n-        return response;\n+        return response.newBuilder()\n+            .body(new Dispatcher.RealResponseBody(response, engine.getResponseBody()))\n+            .redirectedBy(redirectedBy)\n+            .build();\n       }\n \n       // TODO: fail if too many redirects\n       // TODO: fail if not following redirects\n-      // TODO: release engine\n+      engine.release(false);\n \n       connection = sameConnection(request, redirect) ? engine.getConnection() : null;\n-      redirectedBy = response;\n+      redirectedBy = response.newBuilder().redirectedBy(redirectedBy).build(); // Chained.\n       request = redirect;\n     }\n   }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"0ef26ad2e9e6b28a181ebc128f96671cff295043": {
			"type": "Ybodychange",
			"commitMessage": "Remove some 'implementation detail' headers from the public API.\n\nApplication code doesn't need to worry about headers like\n'Connection' or 'Transfer-Encoding', so don't include them\nin the API.\n",
			"commitDate": "2014-01-02, 7:23 AM",
			"commitName": "0ef26ad2e9e6b28a181ebc128f96671cff295043",
			"commitAuthor": "jwilson",
			"commitDateOld": "2014-01-01, 7:30 AM",
			"commitNameOld": "dbca0acc6f8c188dfa48f07bb5886606bec8d28f",
			"commitAuthorOld": "jwilson",
			"daysBetweenCommits": 1,
			"commitsBetweenForRepo": 2,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,56 +1,56 @@\n   private Response execute() throws IOException {\n     Connection connection = null;\n     Response redirectedBy = null;\n \n     while (true) {\n       Request.Body body = request.body();\n       if (body != null) {\n         MediaType contentType = body.contentType();\n         if (contentType == null) throw new IllegalStateException(\"contentType == null\");\n \n         Request.Builder requestBuilder = request.newBuilder();\n         requestBuilder.header(\"Content-Type\", contentType.toString());\n \n         long contentLength = body.contentLength();\n         if (contentLength != -1) {\n           requestBuilder.setContentLength(contentLength);\n           requestBuilder.removeHeader(\"Transfer-Encoding\");\n         } else {\n-          requestBuilder.setChunked();\n+          requestBuilder.header(\"Transfer-Encoding\", \"chunked\");\n           requestBuilder.removeHeader(\"Content-Length\");\n         }\n \n         request = requestBuilder.build();\n       }\n \n       HttpEngine engine = newEngine(connection);\n       engine.sendRequest();\n \n       if (body != null) {\n         body.writeTo(engine.getRequestBody());\n       }\n \n       engine.readResponse();\n \n       Response engineResponse = engine.getResponse();\n       Response response = engineResponse.newBuilder()\n           .body(new Dispatcher.RealResponseBody(engineResponse, engine.getResponseBody()))\n           .redirectedBy(redirectedBy)\n           .build();\n \n       Request redirect = processResponse(engine, response);\n \n       if (redirect == null) {\n         engine.automaticallyReleaseConnectionToPool();\n         return response;\n       }\n \n       // TODO: fail if too many redirects\n       // TODO: fail if not following redirects\n       // TODO: release engine\n \n       connection = sameConnection(request, redirect) ? engine.getConnection() : null;\n       redirectedBy = response;\n       request = redirect;\n     }\n   }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"dbca0acc6f8c188dfa48f07bb5886606bec8d28f": {
			"type": "Ybodychange",
			"commitMessage": "Kill the Policy interface.\n\nThis interface was necessary while cleaning up the delicate\nintertwined relationship between HttpURLConnection and HttpEngine.\nWith this change HttpEngine no longer has a reverse dependency\non HttpURLConnection.\n",
			"commitDate": "2014-01-01, 7:30 AM",
			"commitName": "dbca0acc6f8c188dfa48f07bb5886606bec8d28f",
			"commitAuthor": "jwilson",
			"commitDateOld": "2013-12-30, 10:15 PM",
			"commitNameOld": "60f20dc23cb08d598d605f51f7526725ec42abd9",
			"commitAuthorOld": "jwilson",
			"daysBetweenCommits": 1.39,
			"commitsBetweenForRepo": 5,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,45 +1,56 @@\n   private Response execute() throws IOException {\n     Connection connection = null;\n     Response redirectedBy = null;\n \n     while (true) {\n       Request.Body body = request.body();\n       if (body != null) {\n         MediaType contentType = body.contentType();\n         if (contentType == null) throw new IllegalStateException(\"contentType == null\");\n-        if (request.header(\"Content-Type\") == null) {\n-          request = request.newBuilder().header(\"Content-Type\", contentType.toString()).build();\n+\n+        Request.Builder requestBuilder = request.newBuilder();\n+        requestBuilder.header(\"Content-Type\", contentType.toString());\n+\n+        long contentLength = body.contentLength();\n+        if (contentLength != -1) {\n+          requestBuilder.setContentLength(contentLength);\n+          requestBuilder.removeHeader(\"Transfer-Encoding\");\n+        } else {\n+          requestBuilder.setChunked();\n+          requestBuilder.removeHeader(\"Content-Length\");\n         }\n+\n+        request = requestBuilder.build();\n       }\n \n       HttpEngine engine = newEngine(connection);\n       engine.sendRequest();\n \n       if (body != null) {\n         body.writeTo(engine.getRequestBody());\n       }\n \n       engine.readResponse();\n \n       Response engineResponse = engine.getResponse();\n       Response response = engineResponse.newBuilder()\n           .body(new Dispatcher.RealResponseBody(engineResponse, engine.getResponseBody()))\n           .redirectedBy(redirectedBy)\n           .build();\n \n       Request redirect = processResponse(engine, response);\n \n       if (redirect == null) {\n         engine.automaticallyReleaseConnectionToPool();\n         return response;\n       }\n \n       // TODO: fail if too many redirects\n       // TODO: fail if not following redirects\n       // TODO: release engine\n \n       connection = sameConnection(request, redirect) ? engine.getConnection() : null;\n       redirectedBy = response;\n       request = redirect;\n     }\n   }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"14b6e76e7d7af9b99a7fdc1a56d7ee9309711722": {
			"type": "Ybodychange",
			"commitMessage": "Combine Request+RequestHeaders and Response+ResponseHeaders.\n\nThis cleans up a lot of the unnecessary moving parts in\nHttpEngine. That class is still stuck with some complexity\naround request and response bodies, but it's getting better.\n\nWe're also stuck escalating the visibility of a lot of\nmembers in Request and Response. I've got some ideas on\nhow to fix this; that'll have to wait for a follow up.\n",
			"commitDate": "2013-12-30, 2:08 PM",
			"commitName": "14b6e76e7d7af9b99a7fdc1a56d7ee9309711722",
			"commitAuthor": "jwilson",
			"commitDateOld": "2013-12-29, 6:17 PM",
			"commitNameOld": "350c43b6fe02401a73f967d9ef322061638b372a",
			"commitAuthorOld": "jwilson",
			"daysBetweenCommits": 0.83,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,50 +1,45 @@\n   private Response execute() throws IOException {\n     Connection connection = null;\n     Response redirectedBy = null;\n \n     while (true) {\n       Request.Body body = request.body();\n       if (body != null) {\n         MediaType contentType = body.contentType();\n         if (contentType == null) throw new IllegalStateException(\"contentType == null\");\n         if (request.header(\"Content-Type\") == null) {\n           request = request.newBuilder().header(\"Content-Type\", contentType.toString()).build();\n         }\n       }\n \n       HttpEngine engine = newEngine(connection);\n       engine.sendRequest();\n \n       if (body != null) {\n         body.writeTo(engine.getRequestBody());\n       }\n \n       engine.readResponse();\n \n-      int responseCode = engine.getResponseCode();\n-      Dispatcher.RealResponseBody responseBody = new Dispatcher.RealResponseBody(\n-          engine.getResponseHeaders(), engine.getResponseBody());\n-\n-      Response response = new Response.Builder(request, responseCode)\n-          .handshake(engine.getHandshake())\n-          .rawHeaders(engine.getResponseHeaders().getHeaders())\n-          .body(responseBody)\n+      Response engineResponse = engine.getResponse();\n+      Response response = engineResponse.newBuilder()\n+          .body(new Dispatcher.RealResponseBody(engineResponse, engine.getResponseBody()))\n           .redirectedBy(redirectedBy)\n           .build();\n \n       Request redirect = processResponse(engine, response);\n \n       if (redirect == null) {\n         engine.automaticallyReleaseConnectionToPool();\n         return response;\n       }\n \n       // TODO: fail if too many redirects\n       // TODO: fail if not following redirects\n       // TODO: release engine\n \n       connection = sameConnection(request, redirect) ? engine.getConnection() : null;\n       redirectedBy = response;\n       request = redirect;\n     }\n   }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"350c43b6fe02401a73f967d9ef322061638b372a": {
			"type": "Ybodychange",
			"commitMessage": "Make RawHeaders, RequestHeaders and ResponseHeaders immutable.\n\nThis introduces a new, poorly-named class ResponseStrategy\nthat pulls some code out of ResponseHeaders. That was necessary\nbecause the old method mutated itself and its parameters in\nplace.\n\nObvious follow-up for this is to combine ResponseHeaders with\nResponse, and RequestHeaders with Response.\n",
			"commitDate": "2013-12-29, 6:17 PM",
			"commitName": "350c43b6fe02401a73f967d9ef322061638b372a",
			"commitAuthor": "jwilson",
			"commitDateOld": "2013-12-29, 3:57 PM",
			"commitNameOld": "30ecba897fb624df201f0a014b54a604418a0e73",
			"commitAuthorOld": "jwilson",
			"daysBetweenCommits": 0.1,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,51 +1,50 @@\n   private Response execute() throws IOException {\n     Connection connection = null;\n     Response redirectedBy = null;\n \n     while (true) {\n-      HttpEngine engine = newEngine(connection);\n-\n       Request.Body body = request.body();\n       if (body != null) {\n         MediaType contentType = body.contentType();\n         if (contentType == null) throw new IllegalStateException(\"contentType == null\");\n-        if (engine.getRequestHeaders().getContentType() == null) {\n-          engine.getRequestHeaders().setContentType(contentType.toString());\n+        if (request.header(\"Content-Type\") == null) {\n+          request = request.newBuilder().header(\"Content-Type\", contentType.toString()).build();\n         }\n       }\n \n+      HttpEngine engine = newEngine(connection);\n       engine.sendRequest();\n \n       if (body != null) {\n         body.writeTo(engine.getRequestBody());\n       }\n \n       engine.readResponse();\n \n       int responseCode = engine.getResponseCode();\n       Dispatcher.RealResponseBody responseBody = new Dispatcher.RealResponseBody(\n           engine.getResponseHeaders(), engine.getResponseBody());\n \n       Response response = new Response.Builder(request, responseCode)\n           .handshake(engine.getHandshake())\n           .rawHeaders(engine.getResponseHeaders().getHeaders())\n           .body(responseBody)\n           .redirectedBy(redirectedBy)\n           .build();\n \n       Request redirect = processResponse(engine, response);\n \n       if (redirect == null) {\n         engine.automaticallyReleaseConnectionToPool();\n         return response;\n       }\n \n       // TODO: fail if too many redirects\n       // TODO: fail if not following redirects\n       // TODO: release engine\n \n       connection = sameConnection(request, redirect) ? engine.getConnection() : null;\n       redirectedBy = response;\n       request = redirect;\n     }\n   }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"e2bfa5dd6c0aee7d7e34b224a649500b9e5c267f": {
			"type": "Ybodychange",
			"commitMessage": "Introduce Handshake as a value object.\n\nI needed a non-terrible way to provide the HTTPS handshake\ninformation to the async API. Previously we were passing the\nlive socket around, which was leaky and gross.\n\nThis creates a new value object that captures the relevant\nbits of the handshake. We can use it in the response, the\nconnection, and also in the cache. It's plausible that in\nthe future we can use it to allow the application to block\nrequests if the handshake is insufficient.\n",
			"commitDate": "2013-12-28, 9:35 PM",
			"commitName": "e2bfa5dd6c0aee7d7e34b224a649500b9e5c267f",
			"commitAuthor": "jwilson",
			"commitDateOld": "2013-12-28, 5:24 PM",
			"commitNameOld": "37c01895cca5ec2bec26a3d381611f0938acd6d0",
			"commitAuthorOld": "jwilson",
			"daysBetweenCommits": 0.17,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,50 +1,51 @@\n   private Response execute() throws IOException {\n     Connection connection = null;\n     Response redirectedBy = null;\n \n     while (true) {\n       HttpEngine engine = newEngine(connection);\n \n       Request.Body body = request.body();\n       if (body != null) {\n         MediaType contentType = body.contentType();\n         if (contentType == null) throw new IllegalStateException(\"contentType == null\");\n         if (engine.getRequestHeaders().getContentType() == null) {\n           engine.getRequestHeaders().setContentType(contentType.toString());\n         }\n       }\n \n       engine.sendRequest();\n \n       if (body != null) {\n         body.writeTo(engine.getRequestBody());\n       }\n \n       engine.readResponse();\n \n       int responseCode = engine.getResponseCode();\n       Dispatcher.RealResponseBody responseBody = new Dispatcher.RealResponseBody(\n           engine.getResponseHeaders(), engine.getResponseBody());\n \n       Response response = new Response.Builder(request, responseCode)\n+          .handshake(engine.getHandshake())\n           .rawHeaders(engine.getResponseHeaders().getHeaders())\n           .body(responseBody)\n           .redirectedBy(redirectedBy)\n           .build();\n \n       Request redirect = processResponse(engine, response);\n \n       if (redirect == null) {\n         engine.automaticallyReleaseConnectionToPool();\n         return response;\n       }\n \n       // TODO: fail if too many redirects\n       // TODO: fail if not following redirects\n       // TODO: release engine\n \n       connection = sameConnection(request, redirect) ? engine.getConnection() : null;\n       redirectedBy = response;\n       request = redirect;\n     }\n   }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"37c01895cca5ec2bec26a3d381611f0938acd6d0": {
			"type": "Yintroduced",
			"commitMessage": "Define async APIs and switch Job to use HttpEngine directly.\n\nUsing HttpEngine directly introduces some duplicated code with\nHttpURLConnection. It also breaks the response cache. I think\nthis is the best route going forward; and eventually we could\ninvert this relationship to have HttpURLConnection depending on\nJob directly rather than vice versa.\n",
			"commitDate": "2013-12-28, 5:24 PM",
			"commitName": "37c01895cca5ec2bec26a3d381611f0938acd6d0",
			"commitAuthor": "jwilson",
			"diff": "@@ -0,0 +1,50 @@\n+  private Response execute() throws IOException {\n+    Connection connection = null;\n+    Response redirectedBy = null;\n+\n+    while (true) {\n+      HttpEngine engine = newEngine(connection);\n+\n+      Request.Body body = request.body();\n+      if (body != null) {\n+        MediaType contentType = body.contentType();\n+        if (contentType == null) throw new IllegalStateException(\"contentType == null\");\n+        if (engine.getRequestHeaders().getContentType() == null) {\n+          engine.getRequestHeaders().setContentType(contentType.toString());\n+        }\n+      }\n+\n+      engine.sendRequest();\n+\n+      if (body != null) {\n+        body.writeTo(engine.getRequestBody());\n+      }\n+\n+      engine.readResponse();\n+\n+      int responseCode = engine.getResponseCode();\n+      Dispatcher.RealResponseBody responseBody = new Dispatcher.RealResponseBody(\n+          engine.getResponseHeaders(), engine.getResponseBody());\n+\n+      Response response = new Response.Builder(request, responseCode)\n+          .rawHeaders(engine.getResponseHeaders().getHeaders())\n+          .body(responseBody)\n+          .redirectedBy(redirectedBy)\n+          .build();\n+\n+      Request redirect = processResponse(engine, response);\n+\n+      if (redirect == null) {\n+        engine.automaticallyReleaseConnectionToPool();\n+        return response;\n+      }\n+\n+      // TODO: fail if too many redirects\n+      // TODO: fail if not following redirects\n+      // TODO: release engine\n+\n+      connection = sameConnection(request, redirect) ? engine.getConnection() : null;\n+      redirectedBy = response;\n+      request = redirect;\n+    }\n+  }\n\\ No newline at end of file\n"
		}
	},
	"sha": "5224f3045ba9b171fce521777edf389f9206173c"
}