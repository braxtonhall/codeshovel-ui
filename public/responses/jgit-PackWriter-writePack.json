{
	"repo": "https://github.com/eclipse/jgit.git",
	"file": "org.eclipse.jgit/src/org/eclipse/jgit/internal/storage/pack/PackWriter.java",
	"method": {
		"longName": "public void writePack(ProgressMonitor compressMonitor, ProgressMonitor writeMonitor, OutputStream packStream);",
		"startLine": 1106,
		"methodName": "writePack",
		"isStatic": false,
		"isAbstract": false,
		"visibility": "public"
	},
	"history": {
		"d9bbb04c3ef28db1d2e492506a819b7ac5c5f9df": {
			"type": "Ybodychange",
			"commitMessage": "Introduce PostUploadHook to replace UploadPackLogger\n\nUploadPackLogger is incorrectly named--it can be used to trigger any\npost upload action, such as GC/compaction. This change introduces\nPostUploadHook/PostUploadHookChain to replace\nUploadPackLogger/UploadPackLoggerChain and deprecates the latter.\n\nIt also introduces PackStatistics as a replacement for\nPackWriter.Statistics, since the latter is not public API.\nIt changes PackWriter to use PackStatistics and reimplements\nPackWriter.Statistics to delegate to PackStatistics.\n\nChange-Id: Ic51df1613e471f568ffee25ae67e118425b38986\nSigned-off-by: Terry Parker <tparker@google.com>\n",
			"commitDate": "2015-06-12, 1:56 PM",
			"commitName": "d9bbb04c3ef28db1d2e492506a819b7ac5c5f9df",
			"commitAuthor": "Terry Parker",
			"commitDateOld": "2015-06-09, 5:20 PM",
			"commitNameOld": "9cbe2228376808239b7e9efb5d7424d6762b3982",
			"commitAuthorOld": "Yuxuan 'fishy' Wang",
			"daysBetweenCommits": 2.86,
			"commitsBetweenForRepo": 5,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,85 +1,85 @@\n \tpublic void writePack(ProgressMonitor compressMonitor,\n \t\t\tProgressMonitor writeMonitor, OutputStream packStream)\n \t\t\tthrows IOException {\n \t\tif (compressMonitor == null)\n \t\t\tcompressMonitor = NullProgressMonitor.INSTANCE;\n \t\tif (writeMonitor == null)\n \t\t\twriteMonitor = NullProgressMonitor.INSTANCE;\n \n \t\texcludeInPacks = null;\n \t\texcludeInPackLast = null;\n \n \t\tboolean needSearchForReuse = reuseSupport != null && (\n \t\t\t\t   reuseDeltas\n \t\t\t\t|| config.isReuseObjects()\n \t\t\t\t|| !cachedPacks.isEmpty());\n \n \t\tif (compressMonitor instanceof BatchingProgressMonitor) {\n \t\t\tlong delay = 1000;\n \t\t\tif (needSearchForReuse && config.isDeltaCompress())\n \t\t\t\tdelay = 500;\n \t\t\t((BatchingProgressMonitor) compressMonitor).setDelayStart(\n \t\t\t\t\tdelay,\n \t\t\t\t\tTimeUnit.MILLISECONDS);\n \t\t}\n \n \t\tif (needSearchForReuse)\n \t\t\tsearchForReuse(compressMonitor);\n \t\tif (config.isDeltaCompress())\n \t\t\tsearchForDeltas(compressMonitor);\n \n \t\tcrc32 = new CRC32();\n \t\tfinal PackOutputStream out = new PackOutputStream(\n \t\t\twriteMonitor,\n \t\t\tisIndexDisabled()\n \t\t\t\t? packStream\n \t\t\t\t: new CheckedOutputStream(packStream, crc32),\n \t\t\tthis);\n \n \t\tlong objCnt = getObjectCount();\n \t\tstats.totalObjects = objCnt;\n \t\tif (callback != null)\n \t\t\tcallback.setObjectCount(objCnt);\n \t\tbeginPhase(PackingPhase.WRITING, writeMonitor, objCnt);\n \t\tlong writeStart = System.currentTimeMillis();\n \t\ttry {\n \t\t\tout.writeFileHeader(PACK_VERSION_GENERATED, objCnt);\n \t\t\tout.flush();\n \n \t\t\twriteObjects(out);\n \t\t\tif (!edgeObjects.isEmpty() || !cachedPacks.isEmpty()) {\n-\t\t\t\tfor (Statistics.ObjectType typeStat : stats.objectTypes) {\n+\t\t\t\tfor (PackStatistics.ObjectType.Accumulator typeStat : stats.objectTypes) {\n \t\t\t\t\tif (typeStat == null)\n \t\t\t\t\t\tcontinue;\n \t\t\t\t\tstats.thinPackBytes += typeStat.bytes;\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tstats.reusedPacks = Collections.unmodifiableList(cachedPacks);\n \t\t\tfor (CachedPack pack : cachedPacks) {\n \t\t\t\tlong deltaCnt = pack.getDeltaCount();\n \t\t\t\tstats.reusedObjects += pack.getObjectCount();\n \t\t\t\tstats.reusedDeltas += deltaCnt;\n \t\t\t\tstats.totalDeltas += deltaCnt;\n \t\t\t\treuseSupport.copyPackAsIs(out, pack);\n \t\t\t}\n \t\t\twriteChecksum(out);\n \t\t\tout.flush();\n \t\t} finally {\n \t\t\tstats.timeWriting = System.currentTimeMillis() - writeStart;\n \t\t\tstats.depth = depth;\n \n-\t\t\tfor (Statistics.ObjectType typeStat : stats.objectTypes) {\n+\t\t\tfor (PackStatistics.ObjectType.Accumulator typeStat : stats.objectTypes) {\n \t\t\t\tif (typeStat == null)\n \t\t\t\t\tcontinue;\n \t\t\t\ttypeStat.cntDeltas += typeStat.reusedDeltas;\n \t\t\t\tstats.reusedObjects += typeStat.reusedObjects;\n \t\t\t\tstats.reusedDeltas += typeStat.reusedDeltas;\n \t\t\t\tstats.totalDeltas += typeStat.cntDeltas;\n \t\t\t}\n \t\t}\n \n \t\tstats.totalBytes = out.length();\n \t\treader.close();\n \t\tendPhase(writeMonitor);\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"53be446f6a0a9776c5fd0d507fe11b14d79104c2": {
			"type": "Ybodychange",
			"commitMessage": "Callback in PackWriter & BundleWriter.\n\nAdded callback in PackWriter and BundleWriter for the caller to get the\ncount of objects to write, and a chance to abort the write operation.\n\nChange-Id: I1baeedcc6946b1093652de4a707fe597a577e526\nSigned-off-by: Yuxuan 'fishy' Wang <fishywang@google.com>\n",
			"commitDate": "2015-06-09, 2:11 PM",
			"commitName": "53be446f6a0a9776c5fd0d507fe11b14d79104c2",
			"commitAuthor": "Yuxuan 'fishy' Wang",
			"commitDateOld": "2015-06-02, 7:49 PM",
			"commitNameOld": "dd22bc831a0ec47ecc999eb19be1bd8fad899e9b",
			"commitAuthorOld": "Terry Parker",
			"daysBetweenCommits": 6.76,
			"commitsBetweenForRepo": 18,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,83 +1,85 @@\n \tpublic void writePack(ProgressMonitor compressMonitor,\n \t\t\tProgressMonitor writeMonitor, OutputStream packStream)\n \t\t\tthrows IOException {\n \t\tif (compressMonitor == null)\n \t\t\tcompressMonitor = NullProgressMonitor.INSTANCE;\n \t\tif (writeMonitor == null)\n \t\t\twriteMonitor = NullProgressMonitor.INSTANCE;\n \n \t\texcludeInPacks = null;\n \t\texcludeInPackLast = null;\n \n \t\tboolean needSearchForReuse = reuseSupport != null && (\n \t\t\t\t   reuseDeltas\n \t\t\t\t|| config.isReuseObjects()\n \t\t\t\t|| !cachedPacks.isEmpty());\n \n \t\tif (compressMonitor instanceof BatchingProgressMonitor) {\n \t\t\tlong delay = 1000;\n \t\t\tif (needSearchForReuse && config.isDeltaCompress())\n \t\t\t\tdelay = 500;\n \t\t\t((BatchingProgressMonitor) compressMonitor).setDelayStart(\n \t\t\t\t\tdelay,\n \t\t\t\t\tTimeUnit.MILLISECONDS);\n \t\t}\n \n \t\tif (needSearchForReuse)\n \t\t\tsearchForReuse(compressMonitor);\n \t\tif (config.isDeltaCompress())\n \t\t\tsearchForDeltas(compressMonitor);\n \n \t\tcrc32 = new CRC32();\n \t\tfinal PackOutputStream out = new PackOutputStream(\n \t\t\twriteMonitor,\n \t\t\tisIndexDisabled()\n \t\t\t\t? packStream\n \t\t\t\t: new CheckedOutputStream(packStream, crc32),\n \t\t\tthis);\n \n \t\tlong objCnt = getObjectCount();\n \t\tstats.totalObjects = objCnt;\n+\t\tif (callback != null)\n+\t\t\tcallback.setObjectCount(objCnt);\n \t\tbeginPhase(PackingPhase.WRITING, writeMonitor, objCnt);\n \t\tlong writeStart = System.currentTimeMillis();\n \t\ttry {\n \t\t\tout.writeFileHeader(PACK_VERSION_GENERATED, objCnt);\n \t\t\tout.flush();\n \n \t\t\twriteObjects(out);\n \t\t\tif (!edgeObjects.isEmpty() || !cachedPacks.isEmpty()) {\n \t\t\t\tfor (Statistics.ObjectType typeStat : stats.objectTypes) {\n \t\t\t\t\tif (typeStat == null)\n \t\t\t\t\t\tcontinue;\n \t\t\t\t\tstats.thinPackBytes += typeStat.bytes;\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tstats.reusedPacks = Collections.unmodifiableList(cachedPacks);\n \t\t\tfor (CachedPack pack : cachedPacks) {\n \t\t\t\tlong deltaCnt = pack.getDeltaCount();\n \t\t\t\tstats.reusedObjects += pack.getObjectCount();\n \t\t\t\tstats.reusedDeltas += deltaCnt;\n \t\t\t\tstats.totalDeltas += deltaCnt;\n \t\t\t\treuseSupport.copyPackAsIs(out, pack);\n \t\t\t}\n \t\t\twriteChecksum(out);\n \t\t\tout.flush();\n \t\t} finally {\n \t\t\tstats.timeWriting = System.currentTimeMillis() - writeStart;\n \t\t\tstats.depth = depth;\n \n \t\t\tfor (Statistics.ObjectType typeStat : stats.objectTypes) {\n \t\t\t\tif (typeStat == null)\n \t\t\t\t\tcontinue;\n \t\t\t\ttypeStat.cntDeltas += typeStat.reusedDeltas;\n \t\t\t\tstats.reusedObjects += typeStat.reusedObjects;\n \t\t\t\tstats.reusedDeltas += typeStat.reusedDeltas;\n \t\t\t\tstats.totalDeltas += typeStat.cntDeltas;\n \t\t\t}\n \t\t}\n \n \t\tstats.totalBytes = out.length();\n \t\treader.close();\n \t\tendPhase(writeMonitor);\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"0e73d395061d1bfee365acaa2f79c392175d13bf": {
			"type": "Ybodychange",
			"commitMessage": "Use AutoClosable to close resources in bundle org.eclipse.jgit\n\n- use try-with-resource where possible\n- replace use of deprecated release() by close()\n\nChange-Id: I0f139c3535679087b7fa09649166bca514750b81\nSigned-off-by: Matthias Sohn <matthias.sohn@sap.com>",
			"commitDate": "2015-05-20, 3:01 PM",
			"commitName": "0e73d395061d1bfee365acaa2f79c392175d13bf",
			"commitAuthor": "Matthias Sohn",
			"commitDateOld": "2015-05-10, 10:45 AM",
			"commitNameOld": "53e39094bf012a4f5b3fe5557219707cb7b0f010",
			"commitAuthorOld": "Shawn Pearce",
			"daysBetweenCommits": 10.18,
			"commitsBetweenForRepo": 19,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,83 +1,83 @@\n \tpublic void writePack(ProgressMonitor compressMonitor,\n \t\t\tProgressMonitor writeMonitor, OutputStream packStream)\n \t\t\tthrows IOException {\n \t\tif (compressMonitor == null)\n \t\t\tcompressMonitor = NullProgressMonitor.INSTANCE;\n \t\tif (writeMonitor == null)\n \t\t\twriteMonitor = NullProgressMonitor.INSTANCE;\n \n \t\texcludeInPacks = null;\n \t\texcludeInPackLast = null;\n \n \t\tboolean needSearchForReuse = reuseSupport != null && (\n \t\t\t\t   reuseDeltas\n \t\t\t\t|| config.isReuseObjects()\n \t\t\t\t|| !cachedPacks.isEmpty());\n \n \t\tif (compressMonitor instanceof BatchingProgressMonitor) {\n \t\t\tlong delay = 1000;\n \t\t\tif (needSearchForReuse && config.isDeltaCompress())\n \t\t\t\tdelay = 500;\n \t\t\t((BatchingProgressMonitor) compressMonitor).setDelayStart(\n \t\t\t\t\tdelay,\n \t\t\t\t\tTimeUnit.MILLISECONDS);\n \t\t}\n \n \t\tif (needSearchForReuse)\n \t\t\tsearchForReuse(compressMonitor);\n \t\tif (config.isDeltaCompress())\n \t\t\tsearchForDeltas(compressMonitor);\n \n \t\tcrc32 = new CRC32();\n \t\tfinal PackOutputStream out = new PackOutputStream(\n \t\t\twriteMonitor,\n \t\t\tisIndexDisabled()\n \t\t\t\t? packStream\n \t\t\t\t: new CheckedOutputStream(packStream, crc32),\n \t\t\tthis);\n \n \t\tlong objCnt = getObjectCount();\n \t\tstats.totalObjects = objCnt;\n \t\tbeginPhase(PackingPhase.WRITING, writeMonitor, objCnt);\n \t\tlong writeStart = System.currentTimeMillis();\n \t\ttry {\n \t\t\tout.writeFileHeader(PACK_VERSION_GENERATED, objCnt);\n \t\t\tout.flush();\n \n \t\t\twriteObjects(out);\n \t\t\tif (!edgeObjects.isEmpty() || !cachedPacks.isEmpty()) {\n \t\t\t\tfor (Statistics.ObjectType typeStat : stats.objectTypes) {\n \t\t\t\t\tif (typeStat == null)\n \t\t\t\t\t\tcontinue;\n \t\t\t\t\tstats.thinPackBytes += typeStat.bytes;\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tstats.reusedPacks = Collections.unmodifiableList(cachedPacks);\n \t\t\tfor (CachedPack pack : cachedPacks) {\n \t\t\t\tlong deltaCnt = pack.getDeltaCount();\n \t\t\t\tstats.reusedObjects += pack.getObjectCount();\n \t\t\t\tstats.reusedDeltas += deltaCnt;\n \t\t\t\tstats.totalDeltas += deltaCnt;\n \t\t\t\treuseSupport.copyPackAsIs(out, pack);\n \t\t\t}\n \t\t\twriteChecksum(out);\n \t\t\tout.flush();\n \t\t} finally {\n \t\t\tstats.timeWriting = System.currentTimeMillis() - writeStart;\n \t\t\tstats.depth = depth;\n \n \t\t\tfor (Statistics.ObjectType typeStat : stats.objectTypes) {\n \t\t\t\tif (typeStat == null)\n \t\t\t\t\tcontinue;\n \t\t\t\ttypeStat.cntDeltas += typeStat.reusedDeltas;\n \t\t\t\tstats.reusedObjects += typeStat.reusedObjects;\n \t\t\t\tstats.reusedDeltas += typeStat.reusedDeltas;\n \t\t\t\tstats.totalDeltas += typeStat.cntDeltas;\n \t\t\t}\n \t\t}\n \n \t\tstats.totalBytes = out.length();\n-\t\treader.release();\n+\t\treader.close();\n \t\tendPhase(writeMonitor);\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"6e5c71b358e9b9b883f24f073e869ff6affe5bf4": {
			"type": "Ybodychange",
			"commitMessage": "Remove validate support when reusing cached pack\n\nCached packs are only used when writing over the network or to\na bundle file and reuse validation is always disabled in these\ntwo contexts. The client/consumer of the stream will be SHA-1\nchecksumming every object.\n\nReuse validation is most critical during local GC to avoid silently\nignoring corruption by stopping as soon as a problem is found and\nleaving everything alone for the end-user to debug and salvage.\nCached packs are not supported during local GC as the bitmap rebuild\nlogic does not support including a cached pack in the result.\n\nStrip out the validation and force PackWriter to always disable the\ncached pack feature if reuseValidation is enabled.\n\nChange-Id: If0d7baf2ae1bf1f7e71bf773151302c9f7887039\n",
			"commitDate": "2015-04-24, 11:31 AM",
			"commitName": "6e5c71b358e9b9b883f24f073e869ff6affe5bf4",
			"commitAuthor": "Shawn Pearce",
			"commitDateOld": "2015-02-09, 5:11 AM",
			"commitNameOld": "77030a5e94a90cfae223acc477c216603cf3f149",
			"commitAuthorOld": "Matthias Sohn",
			"daysBetweenCommits": 74.22,
			"commitsBetweenForRepo": 111,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,83 +1,83 @@\n \tpublic void writePack(ProgressMonitor compressMonitor,\n \t\t\tProgressMonitor writeMonitor, OutputStream packStream)\n \t\t\tthrows IOException {\n \t\tif (compressMonitor == null)\n \t\t\tcompressMonitor = NullProgressMonitor.INSTANCE;\n \t\tif (writeMonitor == null)\n \t\t\twriteMonitor = NullProgressMonitor.INSTANCE;\n \n \t\texcludeInPacks = null;\n \t\texcludeInPackLast = null;\n \n \t\tboolean needSearchForReuse = reuseSupport != null && (\n \t\t\t\t   reuseDeltas\n \t\t\t\t|| config.isReuseObjects()\n \t\t\t\t|| !cachedPacks.isEmpty());\n \n \t\tif (compressMonitor instanceof BatchingProgressMonitor) {\n \t\t\tlong delay = 1000;\n \t\t\tif (needSearchForReuse && config.isDeltaCompress())\n \t\t\t\tdelay = 500;\n \t\t\t((BatchingProgressMonitor) compressMonitor).setDelayStart(\n \t\t\t\t\tdelay,\n \t\t\t\t\tTimeUnit.MILLISECONDS);\n \t\t}\n \n \t\tif (needSearchForReuse)\n \t\t\tsearchForReuse(compressMonitor);\n \t\tif (config.isDeltaCompress())\n \t\t\tsearchForDeltas(compressMonitor);\n \n \t\tcrc32 = new CRC32();\n \t\tfinal PackOutputStream out = new PackOutputStream(\n \t\t\twriteMonitor,\n \t\t\tisIndexDisabled()\n \t\t\t\t? packStream\n \t\t\t\t: new CheckedOutputStream(packStream, crc32),\n \t\t\tthis);\n \n \t\tlong objCnt = getObjectCount();\n \t\tstats.totalObjects = objCnt;\n \t\tbeginPhase(PackingPhase.WRITING, writeMonitor, objCnt);\n \t\tlong writeStart = System.currentTimeMillis();\n \t\ttry {\n \t\t\tout.writeFileHeader(PACK_VERSION_GENERATED, objCnt);\n \t\t\tout.flush();\n \n \t\t\twriteObjects(out);\n \t\t\tif (!edgeObjects.isEmpty() || !cachedPacks.isEmpty()) {\n \t\t\t\tfor (Statistics.ObjectType typeStat : stats.objectTypes) {\n \t\t\t\t\tif (typeStat == null)\n \t\t\t\t\t\tcontinue;\n \t\t\t\t\tstats.thinPackBytes += typeStat.bytes;\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tstats.reusedPacks = Collections.unmodifiableList(cachedPacks);\n \t\t\tfor (CachedPack pack : cachedPacks) {\n \t\t\t\tlong deltaCnt = pack.getDeltaCount();\n \t\t\t\tstats.reusedObjects += pack.getObjectCount();\n \t\t\t\tstats.reusedDeltas += deltaCnt;\n \t\t\t\tstats.totalDeltas += deltaCnt;\n-\t\t\t\treuseSupport.copyPackAsIs(out, pack, reuseValidate);\n+\t\t\t\treuseSupport.copyPackAsIs(out, pack);\n \t\t\t}\n \t\t\twriteChecksum(out);\n \t\t\tout.flush();\n \t\t} finally {\n \t\t\tstats.timeWriting = System.currentTimeMillis() - writeStart;\n \t\t\tstats.depth = depth;\n \n \t\t\tfor (Statistics.ObjectType typeStat : stats.objectTypes) {\n \t\t\t\tif (typeStat == null)\n \t\t\t\t\tcontinue;\n \t\t\t\ttypeStat.cntDeltas += typeStat.reusedDeltas;\n \t\t\t\tstats.reusedObjects += typeStat.reusedObjects;\n \t\t\t\tstats.reusedDeltas += typeStat.reusedDeltas;\n \t\t\t\tstats.totalDeltas += typeStat.cntDeltas;\n \t\t\t}\n \t\t}\n \n \t\tstats.totalBytes = out.length();\n \t\treader.release();\n \t\tendPhase(writeMonitor);\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"bc90ce7788e77af11552799cecf65edeb97e3b7c": {
			"type": "Ybodychange",
			"commitMessage": "PackWriter: Report more stats during partial writes\n\nIt can be useful for a server operator to know how long a pack\nwriter spent writing out objects, even if the request aborts and\nnever finishes.\n\nRecord more of the stats data inside of a finally block, to\nensure these can be included into the server's monitoring.\n\nChange-Id: I00858aa393a948f8e742e64ae4c00953eadaef95\n",
			"commitDate": "2014-09-04, 12:45 PM",
			"commitName": "bc90ce7788e77af11552799cecf65edeb97e3b7c",
			"commitAuthor": "Shawn Pearce",
			"commitDateOld": "2014-03-29, 10:34 AM",
			"commitNameOld": "32ff57a2b2b9480f4d374a2592fada7f720b124f",
			"commitAuthorOld": "Robin Rosenberg",
			"daysBetweenCommits": 159.09,
			"commitsBetweenForRepo": 212,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,82 +1,83 @@\n \tpublic void writePack(ProgressMonitor compressMonitor,\n \t\t\tProgressMonitor writeMonitor, OutputStream packStream)\n \t\t\tthrows IOException {\n \t\tif (compressMonitor == null)\n \t\t\tcompressMonitor = NullProgressMonitor.INSTANCE;\n \t\tif (writeMonitor == null)\n \t\t\twriteMonitor = NullProgressMonitor.INSTANCE;\n \n \t\texcludeInPacks = null;\n \t\texcludeInPackLast = null;\n \n \t\tboolean needSearchForReuse = reuseSupport != null && (\n \t\t\t\t   reuseDeltas\n \t\t\t\t|| config.isReuseObjects()\n \t\t\t\t|| !cachedPacks.isEmpty());\n \n \t\tif (compressMonitor instanceof BatchingProgressMonitor) {\n \t\t\tlong delay = 1000;\n \t\t\tif (needSearchForReuse && config.isDeltaCompress())\n \t\t\t\tdelay = 500;\n \t\t\t((BatchingProgressMonitor) compressMonitor).setDelayStart(\n \t\t\t\t\tdelay,\n \t\t\t\t\tTimeUnit.MILLISECONDS);\n \t\t}\n \n \t\tif (needSearchForReuse)\n \t\t\tsearchForReuse(compressMonitor);\n \t\tif (config.isDeltaCompress())\n \t\t\tsearchForDeltas(compressMonitor);\n \n \t\tcrc32 = new CRC32();\n \t\tfinal PackOutputStream out = new PackOutputStream(\n \t\t\twriteMonitor,\n \t\t\tisIndexDisabled()\n \t\t\t\t? packStream\n \t\t\t\t: new CheckedOutputStream(packStream, crc32),\n \t\t\tthis);\n \n \t\tlong objCnt = getObjectCount();\n \t\tstats.totalObjects = objCnt;\n \t\tbeginPhase(PackingPhase.WRITING, writeMonitor, objCnt);\n \t\tlong writeStart = System.currentTimeMillis();\n+\t\ttry {\n+\t\t\tout.writeFileHeader(PACK_VERSION_GENERATED, objCnt);\n+\t\t\tout.flush();\n \n-\t\tout.writeFileHeader(PACK_VERSION_GENERATED, objCnt);\n-\t\tout.flush();\n+\t\t\twriteObjects(out);\n+\t\t\tif (!edgeObjects.isEmpty() || !cachedPacks.isEmpty()) {\n+\t\t\t\tfor (Statistics.ObjectType typeStat : stats.objectTypes) {\n+\t\t\t\t\tif (typeStat == null)\n+\t\t\t\t\t\tcontinue;\n+\t\t\t\t\tstats.thinPackBytes += typeStat.bytes;\n+\t\t\t\t}\n+\t\t\t}\n \n-\t\twriteObjects(out);\n-\t\tif (!edgeObjects.isEmpty() || !cachedPacks.isEmpty()) {\n+\t\t\tstats.reusedPacks = Collections.unmodifiableList(cachedPacks);\n+\t\t\tfor (CachedPack pack : cachedPacks) {\n+\t\t\t\tlong deltaCnt = pack.getDeltaCount();\n+\t\t\t\tstats.reusedObjects += pack.getObjectCount();\n+\t\t\t\tstats.reusedDeltas += deltaCnt;\n+\t\t\t\tstats.totalDeltas += deltaCnt;\n+\t\t\t\treuseSupport.copyPackAsIs(out, pack, reuseValidate);\n+\t\t\t}\n+\t\t\twriteChecksum(out);\n+\t\t\tout.flush();\n+\t\t} finally {\n+\t\t\tstats.timeWriting = System.currentTimeMillis() - writeStart;\n+\t\t\tstats.depth = depth;\n+\n \t\t\tfor (Statistics.ObjectType typeStat : stats.objectTypes) {\n \t\t\t\tif (typeStat == null)\n \t\t\t\t\tcontinue;\n-\t\t\t\tstats.thinPackBytes += typeStat.bytes;\n+\t\t\t\ttypeStat.cntDeltas += typeStat.reusedDeltas;\n+\t\t\t\tstats.reusedObjects += typeStat.reusedObjects;\n+\t\t\t\tstats.reusedDeltas += typeStat.reusedDeltas;\n+\t\t\t\tstats.totalDeltas += typeStat.cntDeltas;\n \t\t\t}\n \t\t}\n \n-\t\tfor (CachedPack pack : cachedPacks) {\n-\t\t\tlong deltaCnt = pack.getDeltaCount();\n-\t\t\tstats.reusedObjects += pack.getObjectCount();\n-\t\t\tstats.reusedDeltas += deltaCnt;\n-\t\t\tstats.totalDeltas += deltaCnt;\n-\t\t\treuseSupport.copyPackAsIs(out, pack, reuseValidate);\n-\t\t}\n-\t\twriteChecksum(out);\n-\t\tout.flush();\n-\t\tstats.timeWriting = System.currentTimeMillis() - writeStart;\n \t\tstats.totalBytes = out.length();\n-\t\tstats.reusedPacks = Collections.unmodifiableList(cachedPacks);\n-\t\tstats.depth = depth;\n-\n-\t\tfor (Statistics.ObjectType typeStat : stats.objectTypes) {\n-\t\t\tif (typeStat == null)\n-\t\t\t\tcontinue;\n-\t\t\ttypeStat.cntDeltas += typeStat.reusedDeltas;\n-\n-\t\t\tstats.reusedObjects += typeStat.reusedObjects;\n-\t\t\tstats.reusedDeltas += typeStat.reusedDeltas;\n-\t\t\tstats.totalDeltas += typeStat.cntDeltas;\n-\t\t}\n-\n \t\treader.release();\n \t\tendPhase(writeMonitor);\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"eb17495ca4ce95c63bacf81af16ab19ff042b65c": {
			"type": "Ybodychange",
			"commitMessage": "Disable CRC32 computation when no PackIndex will be created\n\nIf a server is streaming 3GiB worth of pack data to a client there\nis no reason to compute the CRC32 checksum on the objects. The\nCRC32 code computed by PackWriter is used only in the new index\ncreated by writeIndex(), which is never invoked for the native Git\nnetwork protocols.\n\nObject reuse may still compute its own CRC32 to verify the data\nbeing copied from an existing pack has not been corrupted. This\ncheck is done by the ObjectReader that implements ObjectReuseAsIs\nand has no relationship to the CRC32 being skipped during output.\n\nChange-Id: I05626f2e0d6ce19119b57d8a27193922636d60a7\n",
			"commitDate": "2013-04-10, 12:58 PM",
			"commitName": "eb17495ca4ce95c63bacf81af16ab19ff042b65c",
			"commitAuthor": "Shawn Pearce",
			"commitDateOld": "2013-04-10, 11:34 AM",
			"commitNameOld": "d0a533762586ce331a8f967042fa209c847c3c8d",
			"commitAuthorOld": "Shawn Pearce",
			"daysBetweenCommits": 0.06,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,77 +1,82 @@\n \tpublic void writePack(ProgressMonitor compressMonitor,\n \t\t\tProgressMonitor writeMonitor, OutputStream packStream)\n \t\t\tthrows IOException {\n \t\tif (compressMonitor == null)\n \t\t\tcompressMonitor = NullProgressMonitor.INSTANCE;\n \t\tif (writeMonitor == null)\n \t\t\twriteMonitor = NullProgressMonitor.INSTANCE;\n \n \t\texcludeInPacks = null;\n \t\texcludeInPackLast = null;\n \n \t\tboolean needSearchForReuse = reuseSupport != null && (\n \t\t\t\t   reuseDeltas\n \t\t\t\t|| config.isReuseObjects()\n \t\t\t\t|| !cachedPacks.isEmpty());\n \n \t\tif (compressMonitor instanceof BatchingProgressMonitor) {\n \t\t\tlong delay = 1000;\n \t\t\tif (needSearchForReuse && config.isDeltaCompress())\n \t\t\t\tdelay = 500;\n \t\t\t((BatchingProgressMonitor) compressMonitor).setDelayStart(\n \t\t\t\t\tdelay,\n \t\t\t\t\tTimeUnit.MILLISECONDS);\n \t\t}\n \n \t\tif (needSearchForReuse)\n \t\t\tsearchForReuse(compressMonitor);\n \t\tif (config.isDeltaCompress())\n \t\t\tsearchForDeltas(compressMonitor);\n \n-\t\tfinal PackOutputStream out = new PackOutputStream(writeMonitor,\n-\t\t\t\tpackStream, this);\n+\t\tcrc32 = new CRC32();\n+\t\tfinal PackOutputStream out = new PackOutputStream(\n+\t\t\twriteMonitor,\n+\t\t\tisIndexDisabled()\n+\t\t\t\t? packStream\n+\t\t\t\t: new CheckedOutputStream(packStream, crc32),\n+\t\t\tthis);\n \n \t\tlong objCnt = getObjectCount();\n \t\tstats.totalObjects = objCnt;\n \t\tbeginPhase(PackingPhase.WRITING, writeMonitor, objCnt);\n \t\tlong writeStart = System.currentTimeMillis();\n \n \t\tout.writeFileHeader(PACK_VERSION_GENERATED, objCnt);\n \t\tout.flush();\n \n \t\twriteObjects(out);\n \t\tif (!edgeObjects.isEmpty() || !cachedPacks.isEmpty()) {\n \t\t\tfor (Statistics.ObjectType typeStat : stats.objectTypes) {\n \t\t\t\tif (typeStat == null)\n \t\t\t\t\tcontinue;\n \t\t\t\tstats.thinPackBytes += typeStat.bytes;\n \t\t\t}\n \t\t}\n \n \t\tfor (CachedPack pack : cachedPacks) {\n \t\t\tlong deltaCnt = pack.getDeltaCount();\n \t\t\tstats.reusedObjects += pack.getObjectCount();\n \t\t\tstats.reusedDeltas += deltaCnt;\n \t\t\tstats.totalDeltas += deltaCnt;\n \t\t\treuseSupport.copyPackAsIs(out, pack, reuseValidate);\n \t\t}\n \t\twriteChecksum(out);\n \t\tout.flush();\n \t\tstats.timeWriting = System.currentTimeMillis() - writeStart;\n \t\tstats.totalBytes = out.length();\n \t\tstats.reusedPacks = Collections.unmodifiableList(cachedPacks);\n \t\tstats.depth = depth;\n \n \t\tfor (Statistics.ObjectType typeStat : stats.objectTypes) {\n \t\t\tif (typeStat == null)\n \t\t\t\tcontinue;\n \t\t\ttypeStat.cntDeltas += typeStat.reusedDeltas;\n \n \t\t\tstats.reusedObjects += typeStat.reusedObjects;\n \t\t\tstats.reusedDeltas += typeStat.reusedDeltas;\n \t\t\tstats.totalDeltas += typeStat.cntDeltas;\n \t\t}\n \n \t\treader.release();\n \t\tendPhase(writeMonitor);\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"f32b8612433e499090c76ded014dd5e94322b786": {
			"type": "Yfilerename",
			"commitMessage": "JGit 3.0: move internal classes into an internal subpackage\n\nThis breaks all existing callers once. Applications are not supposed\nto build against the internal storage API unless they can accept API\nchurn and make necessary updates as versions change.\n\nChange-Id: I2ab1327c202ef2003565e1b0770a583970e432e9\n",
			"commitDate": "2013-03-18, 9:30 AM",
			"commitName": "f32b8612433e499090c76ded014dd5e94322b786",
			"commitAuthor": "Shawn Pearce",
			"commitDateOld": "2013-03-18, 7:35 AM",
			"commitNameOld": "462bbc052e766ee9ea585cd4366165a8dac86496",
			"commitAuthorOld": "Shawn Pearce",
			"daysBetweenCommits": 0.08,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "",
			"extendedDetails": {
				"oldPath": "org.eclipse.jgit/src/org/eclipse/jgit/storage/pack/PackWriter.java",
				"newPath": "org.eclipse.jgit/src/org/eclipse/jgit/internal/storage/pack/PackWriter.java"
			}
		},
		"1421106d7627eb2c55b97b70d105b5ba1e26a2c0": {
			"type": "Ybodychange",
			"commitMessage": "Use long for more object counts in PackWriter\n\nPacks can contain up to 2^32-1 objects, which exceeds the range of a\nJava int. Try harder to accept higher object counts in some cases by\nusing long more often when we are working with the object count value.\n\nThis is a trivial refactoring, we may have to make even more changes\nto the object handling code to support more than 2^31-1 objects.\n\nChange-Id: I8cd8146e97cd1c738ad5b48fa9e33804982167e7\n",
			"commitDate": "2011-11-18, 3:55 PM",
			"commitName": "1421106d7627eb2c55b97b70d105b5ba1e26a2c0",
			"commitAuthor": "Shawn O. Pearce",
			"commitDateOld": "2011-11-18, 3:55 PM",
			"commitNameOld": "41a18d57bcaf3bb7eb4bcee5c1d53a222d07316b",
			"commitAuthorOld": "Shawn O. Pearce",
			"daysBetweenCommits": 0,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,77 +1,77 @@\n \tpublic void writePack(ProgressMonitor compressMonitor,\n \t\t\tProgressMonitor writeMonitor, OutputStream packStream)\n \t\t\tthrows IOException {\n \t\tif (compressMonitor == null)\n \t\t\tcompressMonitor = NullProgressMonitor.INSTANCE;\n \t\tif (writeMonitor == null)\n \t\t\twriteMonitor = NullProgressMonitor.INSTANCE;\n \n \t\texcludeInPacks = null;\n \t\texcludeInPackLast = null;\n \n \t\tboolean needSearchForReuse = reuseSupport != null && (\n \t\t\t\t   reuseDeltas\n \t\t\t\t|| config.isReuseObjects()\n \t\t\t\t|| !cachedPacks.isEmpty());\n \n \t\tif (compressMonitor instanceof BatchingProgressMonitor) {\n \t\t\tlong delay = 1000;\n \t\t\tif (needSearchForReuse && config.isDeltaCompress())\n \t\t\t\tdelay = 500;\n \t\t\t((BatchingProgressMonitor) compressMonitor).setDelayStart(\n \t\t\t\t\tdelay,\n \t\t\t\t\tTimeUnit.MILLISECONDS);\n \t\t}\n \n \t\tif (needSearchForReuse)\n \t\t\tsearchForReuse(compressMonitor);\n \t\tif (config.isDeltaCompress())\n \t\t\tsearchForDeltas(compressMonitor);\n \n \t\tfinal PackOutputStream out = new PackOutputStream(writeMonitor,\n \t\t\t\tpackStream, this);\n \n \t\tlong objCnt = getObjectCount();\n \t\tstats.totalObjects = objCnt;\n-\t\tbeginPhase(PackingPhase.WRITING, writeMonitor, (int) objCnt);\n+\t\tbeginPhase(PackingPhase.WRITING, writeMonitor, objCnt);\n \t\tlong writeStart = System.currentTimeMillis();\n \n \t\tout.writeFileHeader(PACK_VERSION_GENERATED, objCnt);\n \t\tout.flush();\n \n \t\twriteObjects(out);\n \t\tif (!edgeObjects.isEmpty() || !cachedPacks.isEmpty()) {\n \t\t\tfor (Statistics.ObjectType typeStat : stats.objectTypes) {\n \t\t\t\tif (typeStat == null)\n \t\t\t\t\tcontinue;\n \t\t\t\tstats.thinPackBytes += typeStat.bytes;\n \t\t\t}\n \t\t}\n \n \t\tfor (CachedPack pack : cachedPacks) {\n \t\t\tlong deltaCnt = pack.getDeltaCount();\n \t\t\tstats.reusedObjects += pack.getObjectCount();\n \t\t\tstats.reusedDeltas += deltaCnt;\n \t\t\tstats.totalDeltas += deltaCnt;\n \t\t\treuseSupport.copyPackAsIs(out, pack, reuseValidate);\n \t\t}\n \t\twriteChecksum(out);\n \t\tout.flush();\n \t\tstats.timeWriting = System.currentTimeMillis() - writeStart;\n \t\tstats.totalBytes = out.length();\n \t\tstats.reusedPacks = Collections.unmodifiableList(cachedPacks);\n \t\tstats.depth = depth;\n \n \t\tfor (Statistics.ObjectType typeStat : stats.objectTypes) {\n \t\t\tif (typeStat == null)\n \t\t\t\tcontinue;\n \t\t\ttypeStat.cntDeltas += typeStat.reusedDeltas;\n \n \t\t\tstats.reusedObjects += typeStat.reusedObjects;\n \t\t\tstats.reusedDeltas += typeStat.reusedDeltas;\n \t\t\tstats.totalDeltas += typeStat.cntDeltas;\n \t\t}\n \n \t\treader.release();\n \t\tendPhase(writeMonitor);\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"16b8ebf2d1d099ac355767b1b1853ae7bf8854f1": {
			"type": "Ybodychange",
			"commitMessage": "Add an object encapsulating the state of a PackWriter\n\nExposes essentially the same state machine to the programmer as is\nexposed to the client via a ProgressMonitor, using a wrapper around\nbeginTask()/endTask().\n\nChange-Id: Ic3622b4acea65d2b9b3551c668806981fa7293e3\n",
			"commitDate": "2011-11-14, 10:27 AM",
			"commitName": "16b8ebf2d1d099ac355767b1b1853ae7bf8854f1",
			"commitAuthor": "Dave Borowitz",
			"commitDateOld": "2011-09-14, 3:34 PM",
			"commitNameOld": "1b6a549ff350673402f797fe7f878175e2b5ba30",
			"commitAuthorOld": "Shawn O. Pearce",
			"daysBetweenCommits": 60.83,
			"commitsBetweenForRepo": 63,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,77 +1,77 @@\n \tpublic void writePack(ProgressMonitor compressMonitor,\n \t\t\tProgressMonitor writeMonitor, OutputStream packStream)\n \t\t\tthrows IOException {\n \t\tif (compressMonitor == null)\n \t\t\tcompressMonitor = NullProgressMonitor.INSTANCE;\n \t\tif (writeMonitor == null)\n \t\t\twriteMonitor = NullProgressMonitor.INSTANCE;\n \n \t\texcludeInPacks = null;\n \t\texcludeInPackLast = null;\n \n \t\tboolean needSearchForReuse = reuseSupport != null && (\n \t\t\t\t   reuseDeltas\n \t\t\t\t|| config.isReuseObjects()\n \t\t\t\t|| !cachedPacks.isEmpty());\n \n \t\tif (compressMonitor instanceof BatchingProgressMonitor) {\n \t\t\tlong delay = 1000;\n \t\t\tif (needSearchForReuse && config.isDeltaCompress())\n \t\t\t\tdelay = 500;\n \t\t\t((BatchingProgressMonitor) compressMonitor).setDelayStart(\n \t\t\t\t\tdelay,\n \t\t\t\t\tTimeUnit.MILLISECONDS);\n \t\t}\n \n \t\tif (needSearchForReuse)\n \t\t\tsearchForReuse(compressMonitor);\n \t\tif (config.isDeltaCompress())\n \t\t\tsearchForDeltas(compressMonitor);\n \n \t\tfinal PackOutputStream out = new PackOutputStream(writeMonitor,\n \t\t\t\tpackStream, this);\n \n \t\tlong objCnt = getObjectCount();\n \t\tstats.totalObjects = objCnt;\n-\t\twriteMonitor.beginTask(JGitText.get().writingObjects, (int) objCnt);\n+\t\tbeginPhase(PackingPhase.WRITING, writeMonitor, (int) objCnt);\n \t\tlong writeStart = System.currentTimeMillis();\n \n \t\tout.writeFileHeader(PACK_VERSION_GENERATED, objCnt);\n \t\tout.flush();\n \n \t\twriteObjects(out);\n \t\tif (!edgeObjects.isEmpty() || !cachedPacks.isEmpty()) {\n \t\t\tfor (Statistics.ObjectType typeStat : stats.objectTypes) {\n \t\t\t\tif (typeStat == null)\n \t\t\t\t\tcontinue;\n \t\t\t\tstats.thinPackBytes += typeStat.bytes;\n \t\t\t}\n \t\t}\n \n \t\tfor (CachedPack pack : cachedPacks) {\n \t\t\tlong deltaCnt = pack.getDeltaCount();\n \t\t\tstats.reusedObjects += pack.getObjectCount();\n \t\t\tstats.reusedDeltas += deltaCnt;\n \t\t\tstats.totalDeltas += deltaCnt;\n \t\t\treuseSupport.copyPackAsIs(out, pack, reuseValidate);\n \t\t}\n \t\twriteChecksum(out);\n \t\tout.flush();\n \t\tstats.timeWriting = System.currentTimeMillis() - writeStart;\n \t\tstats.totalBytes = out.length();\n \t\tstats.reusedPacks = Collections.unmodifiableList(cachedPacks);\n \t\tstats.depth = depth;\n \n \t\tfor (Statistics.ObjectType typeStat : stats.objectTypes) {\n \t\t\tif (typeStat == null)\n \t\t\t\tcontinue;\n \t\t\ttypeStat.cntDeltas += typeStat.reusedDeltas;\n \n \t\t\tstats.reusedObjects += typeStat.reusedObjects;\n \t\t\tstats.reusedDeltas += typeStat.reusedDeltas;\n \t\t\tstats.totalDeltas += typeStat.cntDeltas;\n \t\t}\n \n \t\treader.release();\n-\t\twriteMonitor.endTask();\n+\t\tendPhase(writeMonitor);\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"1b6a549ff350673402f797fe7f878175e2b5ba30": {
			"type": "Ybodychange",
			"commitMessage": "PackWriter: Export more statistics\n\nExport the shallow pack information, and also a handy function to\nsum up the total times.  Include the time writing out the index file,\nif it was created.\n\nChange-Id: I7f60ae6848455a357b25feedb23743bbf6c153cf\nSigned-off-by: Shawn O. Pearce <spearce@spearce.org>\n",
			"commitDate": "2011-09-14, 3:34 PM",
			"commitName": "1b6a549ff350673402f797fe7f878175e2b5ba30",
			"commitAuthor": "Shawn O. Pearce",
			"commitDateOld": "2011-08-21, 2:04 PM",
			"commitNameOld": "9952223e0645fd7a8cddc6093a7f449c6390238d",
			"commitAuthorOld": "Matt Fischer",
			"daysBetweenCommits": 24.06,
			"commitsBetweenForRepo": 25,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,76 +1,77 @@\n \tpublic void writePack(ProgressMonitor compressMonitor,\n \t\t\tProgressMonitor writeMonitor, OutputStream packStream)\n \t\t\tthrows IOException {\n \t\tif (compressMonitor == null)\n \t\t\tcompressMonitor = NullProgressMonitor.INSTANCE;\n \t\tif (writeMonitor == null)\n \t\t\twriteMonitor = NullProgressMonitor.INSTANCE;\n \n \t\texcludeInPacks = null;\n \t\texcludeInPackLast = null;\n \n \t\tboolean needSearchForReuse = reuseSupport != null && (\n \t\t\t\t   reuseDeltas\n \t\t\t\t|| config.isReuseObjects()\n \t\t\t\t|| !cachedPacks.isEmpty());\n \n \t\tif (compressMonitor instanceof BatchingProgressMonitor) {\n \t\t\tlong delay = 1000;\n \t\t\tif (needSearchForReuse && config.isDeltaCompress())\n \t\t\t\tdelay = 500;\n \t\t\t((BatchingProgressMonitor) compressMonitor).setDelayStart(\n \t\t\t\t\tdelay,\n \t\t\t\t\tTimeUnit.MILLISECONDS);\n \t\t}\n \n \t\tif (needSearchForReuse)\n \t\t\tsearchForReuse(compressMonitor);\n \t\tif (config.isDeltaCompress())\n \t\t\tsearchForDeltas(compressMonitor);\n \n \t\tfinal PackOutputStream out = new PackOutputStream(writeMonitor,\n \t\t\t\tpackStream, this);\n \n \t\tlong objCnt = getObjectCount();\n \t\tstats.totalObjects = objCnt;\n \t\twriteMonitor.beginTask(JGitText.get().writingObjects, (int) objCnt);\n \t\tlong writeStart = System.currentTimeMillis();\n \n \t\tout.writeFileHeader(PACK_VERSION_GENERATED, objCnt);\n \t\tout.flush();\n \n \t\twriteObjects(out);\n \t\tif (!edgeObjects.isEmpty() || !cachedPacks.isEmpty()) {\n \t\t\tfor (Statistics.ObjectType typeStat : stats.objectTypes) {\n \t\t\t\tif (typeStat == null)\n \t\t\t\t\tcontinue;\n \t\t\t\tstats.thinPackBytes += typeStat.bytes;\n \t\t\t}\n \t\t}\n \n \t\tfor (CachedPack pack : cachedPacks) {\n \t\t\tlong deltaCnt = pack.getDeltaCount();\n \t\t\tstats.reusedObjects += pack.getObjectCount();\n \t\t\tstats.reusedDeltas += deltaCnt;\n \t\t\tstats.totalDeltas += deltaCnt;\n \t\t\treuseSupport.copyPackAsIs(out, pack, reuseValidate);\n \t\t}\n \t\twriteChecksum(out);\n \t\tout.flush();\n \t\tstats.timeWriting = System.currentTimeMillis() - writeStart;\n \t\tstats.totalBytes = out.length();\n \t\tstats.reusedPacks = Collections.unmodifiableList(cachedPacks);\n+\t\tstats.depth = depth;\n \n \t\tfor (Statistics.ObjectType typeStat : stats.objectTypes) {\n \t\t\tif (typeStat == null)\n \t\t\t\tcontinue;\n \t\t\ttypeStat.cntDeltas += typeStat.reusedDeltas;\n \n \t\t\tstats.reusedObjects += typeStat.reusedObjects;\n \t\t\tstats.reusedDeltas += typeStat.reusedDeltas;\n \t\t\tstats.totalDeltas += typeStat.cntDeltas;\n \t\t}\n \n \t\treader.release();\n \t\twriteMonitor.endTask();\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"a1a8c6d77ec5bea13c4f5ca428e425d95e14e003": {
			"type": "Ybodychange",
			"commitMessage": "PackWriter: support excluding objects already in other packs\n\nThis can be useful when implementing garbage collection and there\nare packs that should not be copied, such as huge packs that have\na sibling \".keep\" file alongside of them.\n\nCallers driving PackWriter need to initialize the list of packs not\nto include objects from by passing each index to excludeObjects().\n\nChange-Id: Id7f34df69df97be406bcae184308e92b0e8690fd\nSigned-off-by: Shawn O. Pearce <spearce@spearce.org>\nSigned-off-by: Chris Aniszczyk <caniszczyk@gmail.com>\n",
			"commitDate": "2011-08-21, 1:59 PM",
			"commitName": "a1a8c6d77ec5bea13c4f5ca428e425d95e14e003",
			"commitAuthor": "Shawn O. Pearce",
			"commitDateOld": "2011-08-16, 12:18 PM",
			"commitNameOld": "74333e63b60440be5ff9f591f2203b635e26e3a0",
			"commitAuthorOld": "Shawn O. Pearce",
			"daysBetweenCommits": 5.07,
			"commitsBetweenForRepo": 7,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,73 +1,76 @@\n \tpublic void writePack(ProgressMonitor compressMonitor,\n \t\t\tProgressMonitor writeMonitor, OutputStream packStream)\n \t\t\tthrows IOException {\n \t\tif (compressMonitor == null)\n \t\t\tcompressMonitor = NullProgressMonitor.INSTANCE;\n \t\tif (writeMonitor == null)\n \t\t\twriteMonitor = NullProgressMonitor.INSTANCE;\n \n+\t\texcludeInPacks = null;\n+\t\texcludeInPackLast = null;\n+\n \t\tboolean needSearchForReuse = reuseSupport != null && (\n \t\t\t\t   reuseDeltas\n \t\t\t\t|| config.isReuseObjects()\n \t\t\t\t|| !cachedPacks.isEmpty());\n \n \t\tif (compressMonitor instanceof BatchingProgressMonitor) {\n \t\t\tlong delay = 1000;\n \t\t\tif (needSearchForReuse && config.isDeltaCompress())\n \t\t\t\tdelay = 500;\n \t\t\t((BatchingProgressMonitor) compressMonitor).setDelayStart(\n \t\t\t\t\tdelay,\n \t\t\t\t\tTimeUnit.MILLISECONDS);\n \t\t}\n \n \t\tif (needSearchForReuse)\n \t\t\tsearchForReuse(compressMonitor);\n \t\tif (config.isDeltaCompress())\n \t\t\tsearchForDeltas(compressMonitor);\n \n \t\tfinal PackOutputStream out = new PackOutputStream(writeMonitor,\n \t\t\t\tpackStream, this);\n \n \t\tlong objCnt = getObjectCount();\n \t\tstats.totalObjects = objCnt;\n \t\twriteMonitor.beginTask(JGitText.get().writingObjects, (int) objCnt);\n \t\tlong writeStart = System.currentTimeMillis();\n \n \t\tout.writeFileHeader(PACK_VERSION_GENERATED, objCnt);\n \t\tout.flush();\n \n \t\twriteObjects(out);\n \t\tif (!edgeObjects.isEmpty() || !cachedPacks.isEmpty()) {\n \t\t\tfor (Statistics.ObjectType typeStat : stats.objectTypes) {\n \t\t\t\tif (typeStat == null)\n \t\t\t\t\tcontinue;\n \t\t\t\tstats.thinPackBytes += typeStat.bytes;\n \t\t\t}\n \t\t}\n \n \t\tfor (CachedPack pack : cachedPacks) {\n \t\t\tlong deltaCnt = pack.getDeltaCount();\n \t\t\tstats.reusedObjects += pack.getObjectCount();\n \t\t\tstats.reusedDeltas += deltaCnt;\n \t\t\tstats.totalDeltas += deltaCnt;\n \t\t\treuseSupport.copyPackAsIs(out, pack, reuseValidate);\n \t\t}\n \t\twriteChecksum(out);\n \t\tout.flush();\n \t\tstats.timeWriting = System.currentTimeMillis() - writeStart;\n \t\tstats.totalBytes = out.length();\n \t\tstats.reusedPacks = Collections.unmodifiableList(cachedPacks);\n \n \t\tfor (Statistics.ObjectType typeStat : stats.objectTypes) {\n \t\t\tif (typeStat == null)\n \t\t\t\tcontinue;\n \t\t\ttypeStat.cntDeltas += typeStat.reusedDeltas;\n \n \t\t\tstats.reusedObjects += typeStat.reusedObjects;\n \t\t\tstats.reusedDeltas += typeStat.reusedDeltas;\n \t\t\tstats.totalDeltas += typeStat.cntDeltas;\n \t\t}\n \n \t\treader.release();\n \t\twriteMonitor.endTask();\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"68cc21b60d83b5c4fb1de6c34a79836c51dd9b3b": {
			"type": "Ybodychange",
			"commitMessage": "PackWriter: Skip progress messages on fast operations\n\nIf the \"Finding sources\" phase will complete in <1 second with no\ndelta compression enabled, don't bother showing the progress meter for\nthis phase.  Small repositories on the local filesystem tend to rip\nthrough this phase always subsecond and the ProgressMonitor display\ncan actually slow the operation down.\n\nIf delta compression is enabled, there are two phases that may run\nvery quickly. Set the timer to 500 milliseconds instead, reducing the\nrisk that the user has to wait longer than 1 second before any sort of\noutput from the packer occurs.\n\nChange-Id: I58110f17e2a5ffa0134f9768b94804d16bbb8399\nSigned-off-by: Shawn O. Pearce <spearce@spearce.org>\n",
			"commitDate": "2011-07-28, 10:22 AM",
			"commitName": "68cc21b60d83b5c4fb1de6c34a79836c51dd9b3b",
			"commitAuthor": "Shawn O. Pearce",
			"commitDateOld": "2011-04-01, 2:40 PM",
			"commitNameOld": "8ac65d33ed7a94f77cb066271669feebf9b882fc",
			"commitAuthorOld": "Shawn O. Pearce",
			"daysBetweenCommits": 117.82,
			"commitsBetweenForRepo": 141,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,62 +1,73 @@\n \tpublic void writePack(ProgressMonitor compressMonitor,\n \t\t\tProgressMonitor writeMonitor, OutputStream packStream)\n \t\t\tthrows IOException {\n \t\tif (compressMonitor == null)\n \t\t\tcompressMonitor = NullProgressMonitor.INSTANCE;\n \t\tif (writeMonitor == null)\n \t\t\twriteMonitor = NullProgressMonitor.INSTANCE;\n \n-\t\tif (reuseSupport != null && (\n+\t\tboolean needSearchForReuse = reuseSupport != null && (\n \t\t\t\t   reuseDeltas\n \t\t\t\t|| config.isReuseObjects()\n-\t\t\t\t|| !cachedPacks.isEmpty()))\n+\t\t\t\t|| !cachedPacks.isEmpty());\n+\n+\t\tif (compressMonitor instanceof BatchingProgressMonitor) {\n+\t\t\tlong delay = 1000;\n+\t\t\tif (needSearchForReuse && config.isDeltaCompress())\n+\t\t\t\tdelay = 500;\n+\t\t\t((BatchingProgressMonitor) compressMonitor).setDelayStart(\n+\t\t\t\t\tdelay,\n+\t\t\t\t\tTimeUnit.MILLISECONDS);\n+\t\t}\n+\n+\t\tif (needSearchForReuse)\n \t\t\tsearchForReuse(compressMonitor);\n \t\tif (config.isDeltaCompress())\n \t\t\tsearchForDeltas(compressMonitor);\n \n \t\tfinal PackOutputStream out = new PackOutputStream(writeMonitor,\n \t\t\t\tpackStream, this);\n \n \t\tlong objCnt = getObjectCount();\n \t\tstats.totalObjects = objCnt;\n \t\twriteMonitor.beginTask(JGitText.get().writingObjects, (int) objCnt);\n \t\tlong writeStart = System.currentTimeMillis();\n \n \t\tout.writeFileHeader(PACK_VERSION_GENERATED, objCnt);\n \t\tout.flush();\n \n \t\twriteObjects(out);\n \t\tif (!edgeObjects.isEmpty() || !cachedPacks.isEmpty()) {\n \t\t\tfor (Statistics.ObjectType typeStat : stats.objectTypes) {\n \t\t\t\tif (typeStat == null)\n \t\t\t\t\tcontinue;\n \t\t\t\tstats.thinPackBytes += typeStat.bytes;\n \t\t\t}\n \t\t}\n \n \t\tfor (CachedPack pack : cachedPacks) {\n \t\t\tlong deltaCnt = pack.getDeltaCount();\n \t\t\tstats.reusedObjects += pack.getObjectCount();\n \t\t\tstats.reusedDeltas += deltaCnt;\n \t\t\tstats.totalDeltas += deltaCnt;\n \t\t\treuseSupport.copyPackAsIs(out, pack, reuseValidate);\n \t\t}\n \t\twriteChecksum(out);\n \t\tout.flush();\n \t\tstats.timeWriting = System.currentTimeMillis() - writeStart;\n \t\tstats.totalBytes = out.length();\n \t\tstats.reusedPacks = Collections.unmodifiableList(cachedPacks);\n \n \t\tfor (Statistics.ObjectType typeStat : stats.objectTypes) {\n \t\t\tif (typeStat == null)\n \t\t\t\tcontinue;\n \t\t\ttypeStat.cntDeltas += typeStat.reusedDeltas;\n \n \t\t\tstats.reusedObjects += typeStat.reusedObjects;\n \t\t\tstats.reusedDeltas += typeStat.reusedDeltas;\n \t\t\tstats.totalDeltas += typeStat.cntDeltas;\n \t\t}\n \n \t\treader.release();\n \t\twriteMonitor.endTask();\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"9f5bbb5dd41f87d6428eb49c021e00d8099d0c17": {
			"type": "Ybodychange",
			"commitMessage": "PackWriter: Speed up pruning of objects from cached packs\n\nDuring object enumeration for the thin pack, very few objects come\nout that are duplicated with the cached pack. Typically these are\nonly cases where a blob or tree was cherry-picked forward, got a\ncopy or rename, or was reverted... all relatively infrequent events.\n\nSpeed up pruning of the thin pack object list by combining the phase\nwith the object representation selection. Implementers should already\nbe offering to reuse the object from the cached pack if it is stored\nthere, at which point the implementation can perform a very fast type\nof containment test using the cached pack's identity rather than yet\nanother index lookup.  For the local disk case this is probably not a\nbig improvement, but it does help on the DHT implementation where the\ntwo passes combined into one reduces latency.\n\nChange-Id: I6a07fc75d9075bf6233e967360b6546f9e9a2b33\nSigned-off-by: Shawn O. Pearce <spearce@spearce.org>\n",
			"commitDate": "2011-04-01, 2:40 PM",
			"commitName": "9f5bbb5dd41f87d6428eb49c021e00d8099d0c17",
			"commitAuthor": "Shawn O. Pearce",
			"commitDateOld": "2011-03-18, 11:31 AM",
			"commitNameOld": "bb1956e647d2f48ef36ef98a7f22120fdad0b37c",
			"commitAuthorOld": "Shawn O. Pearce",
			"daysBetweenCommits": 14.13,
			"commitsBetweenForRepo": 22,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,59 +1,62 @@\n \tpublic void writePack(ProgressMonitor compressMonitor,\n \t\t\tProgressMonitor writeMonitor, OutputStream packStream)\n \t\t\tthrows IOException {\n \t\tif (compressMonitor == null)\n \t\t\tcompressMonitor = NullProgressMonitor.INSTANCE;\n \t\tif (writeMonitor == null)\n \t\t\twriteMonitor = NullProgressMonitor.INSTANCE;\n \n-\t\tif ((reuseDeltas || config.isReuseObjects()) && reuseSupport != null)\n+\t\tif (reuseSupport != null && (\n+\t\t\t\t   reuseDeltas\n+\t\t\t\t|| config.isReuseObjects()\n+\t\t\t\t|| !cachedPacks.isEmpty()))\n \t\t\tsearchForReuse(compressMonitor);\n \t\tif (config.isDeltaCompress())\n \t\t\tsearchForDeltas(compressMonitor);\n \n \t\tfinal PackOutputStream out = new PackOutputStream(writeMonitor,\n \t\t\t\tpackStream, this);\n \n \t\tlong objCnt = getObjectCount();\n \t\tstats.totalObjects = objCnt;\n \t\twriteMonitor.beginTask(JGitText.get().writingObjects, (int) objCnt);\n \t\tlong writeStart = System.currentTimeMillis();\n \n \t\tout.writeFileHeader(PACK_VERSION_GENERATED, objCnt);\n \t\tout.flush();\n \n \t\twriteObjects(out);\n \t\tif (!edgeObjects.isEmpty() || !cachedPacks.isEmpty()) {\n \t\t\tfor (Statistics.ObjectType typeStat : stats.objectTypes) {\n \t\t\t\tif (typeStat == null)\n \t\t\t\t\tcontinue;\n \t\t\t\tstats.thinPackBytes += typeStat.bytes;\n \t\t\t}\n \t\t}\n \n \t\tfor (CachedPack pack : cachedPacks) {\n \t\t\tlong deltaCnt = pack.getDeltaCount();\n \t\t\tstats.reusedObjects += pack.getObjectCount();\n \t\t\tstats.reusedDeltas += deltaCnt;\n \t\t\tstats.totalDeltas += deltaCnt;\n \t\t\treuseSupport.copyPackAsIs(out, pack, reuseValidate);\n \t\t}\n \t\twriteChecksum(out);\n \t\tout.flush();\n \t\tstats.timeWriting = System.currentTimeMillis() - writeStart;\n \t\tstats.totalBytes = out.length();\n \t\tstats.reusedPacks = Collections.unmodifiableList(cachedPacks);\n \n \t\tfor (Statistics.ObjectType typeStat : stats.objectTypes) {\n \t\t\tif (typeStat == null)\n \t\t\t\tcontinue;\n \t\t\ttypeStat.cntDeltas += typeStat.reusedDeltas;\n \n \t\t\tstats.reusedObjects += typeStat.reusedObjects;\n \t\t\tstats.reusedDeltas += typeStat.reusedDeltas;\n \t\t\tstats.totalDeltas += typeStat.cntDeltas;\n \t\t}\n \n \t\treader.release();\n \t\twriteMonitor.endTask();\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"bb1956e647d2f48ef36ef98a7f22120fdad0b37c": {
			"type": "Ybodychange",
			"commitMessage": "PackWriter: Collect stats by object type\n\nFrequently enough I'm wondering how much of a pack is commits vs.\ntrees, and the total line doesn't really tell us this because its\na gross total from the pack. Computing the counts per object type\nis simple during packing, as PackWriter already has everything in\nmemory broken up by object type.  Its virtually free to get these\nvalues and track them.\n\nChange-Id: Id5e6b1902ea909c72f103a0fbca5d8bc316f9ab3\nSigned-off-by: Shawn O. Pearce <spearce@spearce.org>\n",
			"commitDate": "2011-03-18, 11:31 AM",
			"commitName": "bb1956e647d2f48ef36ef98a7f22120fdad0b37c",
			"commitAuthor": "Shawn O. Pearce",
			"commitDateOld": "2011-03-14, 8:01 AM",
			"commitNameOld": "7a9bf1e2e034ad922a6fe4c7fc5b0f43baa69267",
			"commitAuthorOld": "Shawn O. Pearce",
			"daysBetweenCommits": 4.15,
			"commitsBetweenForRepo": 28,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,46 +1,59 @@\n \tpublic void writePack(ProgressMonitor compressMonitor,\n \t\t\tProgressMonitor writeMonitor, OutputStream packStream)\n \t\t\tthrows IOException {\n \t\tif (compressMonitor == null)\n \t\t\tcompressMonitor = NullProgressMonitor.INSTANCE;\n \t\tif (writeMonitor == null)\n \t\t\twriteMonitor = NullProgressMonitor.INSTANCE;\n \n \t\tif ((reuseDeltas || config.isReuseObjects()) && reuseSupport != null)\n \t\t\tsearchForReuse(compressMonitor);\n \t\tif (config.isDeltaCompress())\n \t\t\tsearchForDeltas(compressMonitor);\n \n \t\tfinal PackOutputStream out = new PackOutputStream(writeMonitor,\n \t\t\t\tpackStream, this);\n \n \t\tlong objCnt = getObjectCount();\n \t\tstats.totalObjects = objCnt;\n \t\twriteMonitor.beginTask(JGitText.get().writingObjects, (int) objCnt);\n \t\tlong writeStart = System.currentTimeMillis();\n \n-\t\tlong headerStart = out.length();\n \t\tout.writeFileHeader(PACK_VERSION_GENERATED, objCnt);\n \t\tout.flush();\n-\t\tlong headerEnd = out.length();\n \n \t\twriteObjects(out);\n-\t\tif (!edgeObjects.isEmpty() || !cachedPacks.isEmpty())\n-\t\t\tstats.thinPackBytes = out.length() - (headerEnd - headerStart);\n+\t\tif (!edgeObjects.isEmpty() || !cachedPacks.isEmpty()) {\n+\t\t\tfor (Statistics.ObjectType typeStat : stats.objectTypes) {\n+\t\t\t\tif (typeStat == null)\n+\t\t\t\t\tcontinue;\n+\t\t\t\tstats.thinPackBytes += typeStat.bytes;\n+\t\t\t}\n+\t\t}\n \n \t\tfor (CachedPack pack : cachedPacks) {\n \t\t\tlong deltaCnt = pack.getDeltaCount();\n \t\t\tstats.reusedObjects += pack.getObjectCount();\n \t\t\tstats.reusedDeltas += deltaCnt;\n \t\t\tstats.totalDeltas += deltaCnt;\n \t\t\treuseSupport.copyPackAsIs(out, pack, reuseValidate);\n \t\t}\n \t\twriteChecksum(out);\n \t\tout.flush();\n \t\tstats.timeWriting = System.currentTimeMillis() - writeStart;\n \t\tstats.totalBytes = out.length();\n \t\tstats.reusedPacks = Collections.unmodifiableList(cachedPacks);\n \n+\t\tfor (Statistics.ObjectType typeStat : stats.objectTypes) {\n+\t\t\tif (typeStat == null)\n+\t\t\t\tcontinue;\n+\t\t\ttypeStat.cntDeltas += typeStat.reusedDeltas;\n+\n+\t\t\tstats.reusedObjects += typeStat.reusedObjects;\n+\t\t\tstats.reusedDeltas += typeStat.reusedDeltas;\n+\t\t\tstats.totalDeltas += typeStat.cntDeltas;\n+\t\t}\n+\n \t\treader.release();\n \t\twriteMonitor.endTask();\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"7a9bf1e2e034ad922a6fe4c7fc5b0f43baa69267": {
			"type": "Ybodychange",
			"commitMessage": "PackWriter: Rename getObjectsNumber to getObjectCount\n\nThis better matches with PackFile and CachedPack's methods\nthat return the same value.\n\nChange-Id: Idb9b7c71d2048dd2344a62c2cde20b4e34529ab7\nSigned-off-by: Shawn O. Pearce <spearce@spearce.org>\n",
			"commitDate": "2011-03-14, 8:01 AM",
			"commitName": "7a9bf1e2e034ad922a6fe4c7fc5b0f43baa69267",
			"commitAuthor": "Shawn O. Pearce",
			"commitDateOld": "2011-03-14, 8:01 AM",
			"commitNameOld": "65f9a6e58bd9296cbbe1cffc7cf079fd65991686",
			"commitAuthorOld": "Shawn O. Pearce",
			"daysBetweenCommits": 0,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,46 +1,46 @@\n \tpublic void writePack(ProgressMonitor compressMonitor,\n \t\t\tProgressMonitor writeMonitor, OutputStream packStream)\n \t\t\tthrows IOException {\n \t\tif (compressMonitor == null)\n \t\t\tcompressMonitor = NullProgressMonitor.INSTANCE;\n \t\tif (writeMonitor == null)\n \t\t\twriteMonitor = NullProgressMonitor.INSTANCE;\n \n \t\tif ((reuseDeltas || config.isReuseObjects()) && reuseSupport != null)\n \t\t\tsearchForReuse(compressMonitor);\n \t\tif (config.isDeltaCompress())\n \t\t\tsearchForDeltas(compressMonitor);\n \n \t\tfinal PackOutputStream out = new PackOutputStream(writeMonitor,\n \t\t\t\tpackStream, this);\n \n-\t\tlong objCnt = getObjectsNumber();\n+\t\tlong objCnt = getObjectCount();\n \t\tstats.totalObjects = objCnt;\n \t\twriteMonitor.beginTask(JGitText.get().writingObjects, (int) objCnt);\n \t\tlong writeStart = System.currentTimeMillis();\n \n \t\tlong headerStart = out.length();\n \t\tout.writeFileHeader(PACK_VERSION_GENERATED, objCnt);\n \t\tout.flush();\n \t\tlong headerEnd = out.length();\n \n \t\twriteObjects(out);\n \t\tif (!edgeObjects.isEmpty() || !cachedPacks.isEmpty())\n \t\t\tstats.thinPackBytes = out.length() - (headerEnd - headerStart);\n \n \t\tfor (CachedPack pack : cachedPacks) {\n \t\t\tlong deltaCnt = pack.getDeltaCount();\n \t\t\tstats.reusedObjects += pack.getObjectCount();\n \t\t\tstats.reusedDeltas += deltaCnt;\n \t\t\tstats.totalDeltas += deltaCnt;\n \t\t\treuseSupport.copyPackAsIs(out, pack, reuseValidate);\n \t\t}\n \t\twriteChecksum(out);\n \t\tout.flush();\n \t\tstats.timeWriting = System.currentTimeMillis() - writeStart;\n \t\tstats.totalBytes = out.length();\n \t\tstats.reusedPacks = Collections.unmodifiableList(cachedPacks);\n \n \t\treader.release();\n \t\twriteMonitor.endTask();\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"65f9a6e58bd9296cbbe1cffc7cf079fd65991686": {
			"type": "Ybodychange",
			"commitMessage": "Fix dumb transport push\n\nPackWriter incorrectly returned 0 from getObjectsNumber() when the\npack has not been written yet. This caused dumb transports like\namazon-s3:// and sftp:// to abort early and never write out a pack,\nunder the assumption that the pack had no objects.\n\nUntil the pack header is written to the output stream, compute the\ncurrent object count each time it is requested. Once the header is\nstarted, use the object count from the stats object.\n\nChange-Id: I041a2368ae0cfe6f649ec28658d41a6355933900\nSigned-off-by: Shawn O. Pearce <spearce@spearce.org>\n",
			"commitDate": "2011-03-14, 8:01 AM",
			"commitName": "65f9a6e58bd9296cbbe1cffc7cf079fd65991686",
			"commitAuthor": "Shawn O. Pearce",
			"commitDateOld": "2011-03-13, 4:39 PM",
			"commitNameOld": "bd970007be5c07375b9915033992de9a167e8196",
			"commitAuthorOld": "Shawn O. Pearce",
			"daysBetweenCommits": 0.64,
			"commitsBetweenForRepo": 2,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,51 +1,46 @@\n \tpublic void writePack(ProgressMonitor compressMonitor,\n \t\t\tProgressMonitor writeMonitor, OutputStream packStream)\n \t\t\tthrows IOException {\n \t\tif (compressMonitor == null)\n \t\t\tcompressMonitor = NullProgressMonitor.INSTANCE;\n \t\tif (writeMonitor == null)\n \t\t\twriteMonitor = NullProgressMonitor.INSTANCE;\n \n \t\tif ((reuseDeltas || config.isReuseObjects()) && reuseSupport != null)\n \t\t\tsearchForReuse(compressMonitor);\n \t\tif (config.isDeltaCompress())\n \t\t\tsearchForDeltas(compressMonitor);\n \n \t\tfinal PackOutputStream out = new PackOutputStream(writeMonitor,\n \t\t\t\tpackStream, this);\n \n-\t\tlong objCnt = 0;\n-\t\tfor (List<ObjectToPack> list : objectsLists)\n-\t\t\tobjCnt += list.size();\n-\t\tfor (CachedPack pack : cachedPacks)\n-\t\t\tobjCnt += pack.getObjectCount();\n+\t\tlong objCnt = getObjectsNumber();\n \t\tstats.totalObjects = objCnt;\n-\n \t\twriteMonitor.beginTask(JGitText.get().writingObjects, (int) objCnt);\n \t\tlong writeStart = System.currentTimeMillis();\n \n \t\tlong headerStart = out.length();\n \t\tout.writeFileHeader(PACK_VERSION_GENERATED, objCnt);\n \t\tout.flush();\n \t\tlong headerEnd = out.length();\n \n \t\twriteObjects(out);\n \t\tif (!edgeObjects.isEmpty() || !cachedPacks.isEmpty())\n \t\t\tstats.thinPackBytes = out.length() - (headerEnd - headerStart);\n \n \t\tfor (CachedPack pack : cachedPacks) {\n \t\t\tlong deltaCnt = pack.getDeltaCount();\n \t\t\tstats.reusedObjects += pack.getObjectCount();\n \t\t\tstats.reusedDeltas += deltaCnt;\n \t\t\tstats.totalDeltas += deltaCnt;\n \t\t\treuseSupport.copyPackAsIs(out, pack, reuseValidate);\n \t\t}\n \t\twriteChecksum(out);\n \t\tout.flush();\n \t\tstats.timeWriting = System.currentTimeMillis() - writeStart;\n \t\tstats.totalBytes = out.length();\n \t\tstats.reusedPacks = Collections.unmodifiableList(cachedPacks);\n \n \t\treader.release();\n \t\twriteMonitor.endTask();\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"a468cb57c2f2fbd8da163f002b505255ea768244": {
			"type": "Ybodychange",
			"commitMessage": "PackWriter: Validate reused cached packs\n\nIf object reuse validation is enabled, the output pack is going to\nprobably be stored locally.  When reusing an existing cached pack\nto save object enumeration costs, ensure the cached pack has not\nbeen corrupted by checking its SHA-1 trailer.  If it has, writing\nwill abort and the output pack won't be complete.  This prevents\nanyone from trying to use the output pack, and catches corruption\nbefore it can be carried any further.\n\nChange-Id: If89d0d4e429d9f4c86f14de6c0020902705153e6\nSigned-off-by: Shawn O. Pearce <spearce@spearce.org>\n",
			"commitDate": "2011-03-02, 12:49 PM",
			"commitName": "a468cb57c2f2fbd8da163f002b505255ea768244",
			"commitAuthor": "Shawn O. Pearce",
			"commitDateOld": "2011-03-02, 12:23 PM",
			"commitNameOld": "1b2062fe37b43e59e40e360139e03e1221fa5b6b",
			"commitAuthorOld": "Shawn O. Pearce",
			"daysBetweenCommits": 0.02,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,51 +1,51 @@\n \tpublic void writePack(ProgressMonitor compressMonitor,\n \t\t\tProgressMonitor writeMonitor, OutputStream packStream)\n \t\t\tthrows IOException {\n \t\tif (compressMonitor == null)\n \t\t\tcompressMonitor = NullProgressMonitor.INSTANCE;\n \t\tif (writeMonitor == null)\n \t\t\twriteMonitor = NullProgressMonitor.INSTANCE;\n \n \t\tif ((reuseDeltas || config.isReuseObjects()) && reuseSupport != null)\n \t\t\tsearchForReuse(compressMonitor);\n \t\tif (config.isDeltaCompress())\n \t\t\tsearchForDeltas(compressMonitor);\n \n \t\tfinal PackOutputStream out = new PackOutputStream(writeMonitor,\n \t\t\t\tpackStream, this);\n \n \t\tlong objCnt = 0;\n \t\tfor (List<ObjectToPack> list : objectsLists)\n \t\t\tobjCnt += list.size();\n \t\tfor (CachedPack pack : cachedPacks)\n \t\t\tobjCnt += pack.getObjectCount();\n \t\tstats.totalObjects = objCnt;\n \n \t\twriteMonitor.beginTask(JGitText.get().writingObjects, (int) objCnt);\n \t\tlong writeStart = System.currentTimeMillis();\n \n \t\tlong headerStart = out.length();\n \t\tout.writeFileHeader(PACK_VERSION_GENERATED, objCnt);\n \t\tout.flush();\n \t\tlong headerEnd = out.length();\n \n \t\twriteObjects(out);\n \t\tif (!edgeObjects.isEmpty() || !cachedPacks.isEmpty())\n \t\t\tstats.thinPackBytes = out.length() - (headerEnd - headerStart);\n \n \t\tfor (CachedPack pack : cachedPacks) {\n \t\t\tlong deltaCnt = pack.getDeltaCount();\n \t\t\tstats.reusedObjects += pack.getObjectCount();\n \t\t\tstats.reusedDeltas += deltaCnt;\n \t\t\tstats.totalDeltas += deltaCnt;\n-\t\t\treuseSupport.copyPackAsIs(out, pack);\n+\t\t\treuseSupport.copyPackAsIs(out, pack, reuseValidate);\n \t\t}\n \t\twriteChecksum(out);\n \t\tout.flush();\n \t\tstats.timeWriting = System.currentTimeMillis() - writeStart;\n \t\tstats.totalBytes = out.length();\n \t\tstats.reusedPacks = Collections.unmodifiableList(cachedPacks);\n \n \t\treader.release();\n \t\twriteMonitor.endTask();\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"388ba7e005fdc5b61a7a494fa44ba24489d0c6d0": {
			"type": "Ybodychange",
			"commitMessage": "PackWriter: Correct total delta count when reusing pack\n\nIf the CachedPack knows its delta count, we need to increment both\nthe totalDeltas and reusedDeltas fields of the stats object.\n\nChange-Id: I70113609c22476ce7f1e4d9a92f486e9b0f59e44\nSigned-off-by: Shawn O. Pearce <spearce@spearce.org>\n",
			"commitDate": "2011-02-18, 5:36 PM",
			"commitName": "388ba7e005fdc5b61a7a494fa44ba24489d0c6d0",
			"commitAuthor": "Shawn O. Pearce",
			"commitDateOld": "2011-02-18, 5:36 PM",
			"commitNameOld": "4275c4c1cffeffae6b12eb6aa2df957c23107b48",
			"commitAuthorOld": "Shawn O. Pearce",
			"daysBetweenCommits": 0,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,49 +1,51 @@\n \tpublic void writePack(ProgressMonitor compressMonitor,\n \t\t\tProgressMonitor writeMonitor, OutputStream packStream)\n \t\t\tthrows IOException {\n \t\tif (compressMonitor == null)\n \t\t\tcompressMonitor = NullProgressMonitor.INSTANCE;\n \t\tif (writeMonitor == null)\n \t\t\twriteMonitor = NullProgressMonitor.INSTANCE;\n \n \t\tif ((reuseDeltas || config.isReuseObjects()) && reuseSupport != null)\n \t\t\tsearchForReuse(compressMonitor);\n \t\tif (config.isDeltaCompress())\n \t\t\tsearchForDeltas(compressMonitor);\n \n \t\tfinal PackOutputStream out = new PackOutputStream(writeMonitor,\n \t\t\t\tpackStream, this);\n \n \t\tlong objCnt = 0;\n \t\tfor (List<ObjectToPack> list : objectsLists)\n \t\t\tobjCnt += list.size();\n \t\tfor (CachedPack pack : cachedPacks)\n \t\t\tobjCnt += pack.getObjectCount();\n \t\tstats.totalObjects = objCnt;\n \n \t\twriteMonitor.beginTask(JGitText.get().writingObjects, (int) objCnt);\n \t\tlong writeStart = System.currentTimeMillis();\n \n \t\tlong headerStart = out.length();\n \t\tout.writeFileHeader(PACK_VERSION_GENERATED, objCnt);\n \t\tout.flush();\n \t\tlong headerEnd = out.length();\n \n \t\twriteObjects(out);\n \t\tif (!edgeObjects.isEmpty() || !cachedPacks.isEmpty())\n \t\t\tstats.thinPackBytes = out.length() - (headerEnd - headerStart);\n \n \t\tfor (CachedPack pack : cachedPacks) {\n+\t\t\tlong deltaCnt = pack.getDeltaCount();\n \t\t\tstats.reusedObjects += pack.getObjectCount();\n-\t\t\tstats.reusedDeltas += pack.getDeltaCount();\n+\t\t\tstats.reusedDeltas += deltaCnt;\n+\t\t\tstats.totalDeltas += deltaCnt;\n \t\t\treuseSupport.copyPackAsIs(out, pack);\n \t\t}\n \t\twriteChecksum(out);\n \t\tout.flush();\n \t\tstats.timeWriting = System.currentTimeMillis() - writeStart;\n \t\tstats.totalBytes = out.length();\n \t\tstats.reusedPacks = Collections.unmodifiableList(cachedPacks);\n \n \t\treader.release();\n \t\twriteMonitor.endTask();\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"14f99dc29d67fa4d2cb227ab906c5c8379499f6b": {
			"type": "Ybodychange",
			"commitMessage": "PackWriter: Try for accurate delta reuse on cached pack\n\nIf a cached pack is used, it might know how many deltas are contained\nwithin it.  Record that count as part of our reusedDeltas field\nfor the stats line we show clients.\n\nChange-Id: I1c61fb817305a95eeac654cccf132cba20b2339c\nSigned-off-by: Shawn O. Pearce <spearce@spearce.org>\n",
			"commitDate": "2011-02-15, 4:32 PM",
			"commitName": "14f99dc29d67fa4d2cb227ab906c5c8379499f6b",
			"commitAuthor": "Shawn O. Pearce",
			"commitDateOld": "2011-02-13, 1:43 PM",
			"commitNameOld": "c8c4524b6b36c1d97e715de9e1ff1aa18763a390",
			"commitAuthorOld": "Shawn O. Pearce",
			"daysBetweenCommits": 2.12,
			"commitsBetweenForRepo": 10,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,48 +1,49 @@\n \tpublic void writePack(ProgressMonitor compressMonitor,\n \t\t\tProgressMonitor writeMonitor, OutputStream packStream)\n \t\t\tthrows IOException {\n \t\tif (compressMonitor == null)\n \t\t\tcompressMonitor = NullProgressMonitor.INSTANCE;\n \t\tif (writeMonitor == null)\n \t\t\twriteMonitor = NullProgressMonitor.INSTANCE;\n \n \t\tif ((reuseDeltas || config.isReuseObjects()) && reuseSupport != null)\n \t\t\tsearchForReuse(compressMonitor);\n \t\tif (config.isDeltaCompress())\n \t\t\tsearchForDeltas(compressMonitor);\n \n \t\tfinal PackOutputStream out = new PackOutputStream(writeMonitor,\n \t\t\t\tpackStream, this);\n \n \t\tlong objCnt = 0;\n \t\tfor (List<ObjectToPack> list : objectsLists)\n \t\t\tobjCnt += list.size();\n \t\tfor (CachedPack pack : cachedPacks)\n \t\t\tobjCnt += pack.getObjectCount();\n \t\tstats.totalObjects = objCnt;\n \n \t\twriteMonitor.beginTask(JGitText.get().writingObjects, (int) objCnt);\n \t\tlong writeStart = System.currentTimeMillis();\n \n \t\tlong headerStart = out.length();\n \t\tout.writeFileHeader(PACK_VERSION_GENERATED, objCnt);\n \t\tout.flush();\n \t\tlong headerEnd = out.length();\n \n \t\twriteObjects(out);\n \t\tif (!edgeObjects.isEmpty() || !cachedPacks.isEmpty())\n \t\t\tstats.thinPackBytes = out.length() - (headerEnd - headerStart);\n \n \t\tfor (CachedPack pack : cachedPacks) {\n \t\t\tstats.reusedObjects += pack.getObjectCount();\n+\t\t\tstats.reusedDeltas += pack.getDeltaCount();\n \t\t\treuseSupport.copyPackAsIs(out, pack);\n \t\t}\n \t\twriteChecksum(out);\n \t\tout.flush();\n \t\tstats.timeWriting = System.currentTimeMillis() - writeStart;\n \t\tstats.totalBytes = out.length();\n \t\tstats.reusedPacks = Collections.unmodifiableList(cachedPacks);\n \n \t\treader.release();\n \t\twriteMonitor.endTask();\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"c8c4524b6b36c1d97e715de9e1ff1aa18763a390": {
			"type": "Ybodychange",
			"commitMessage": "UploadPack: Expose PackWriter activity to a logger\n\nThe UploadPackLogger interface allows applications that embed\nGitServlet or otherwise use UploadPack to service clients to\ntrack and log how PackWriter was used, and what it sent.  This\nprovides more granularity into the request activity than might\nbe available from the HTTP server logs, helping administrators\nto better understand utilization and Git server performance.\n\nChange-Id: I1d36b060eb3385339d5f986e68192789ef70fc4e\nSigned-off-by: Shawn O. Pearce <spearce@spearce.org>\n",
			"commitDate": "2011-02-13, 1:43 PM",
			"commitName": "c8c4524b6b36c1d97e715de9e1ff1aa18763a390",
			"commitAuthor": "Shawn O. Pearce",
			"commitDateOld": "2011-02-13, 1:43 PM",
			"commitNameOld": "5664fb3bfb63e4db49dc07d13ace419e810186c2",
			"commitAuthorOld": "Shawn O. Pearce",
			"daysBetweenCommits": 0,
			"commitsBetweenForRepo": 3,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,36 +1,48 @@\n \tpublic void writePack(ProgressMonitor compressMonitor,\n \t\t\tProgressMonitor writeMonitor, OutputStream packStream)\n \t\t\tthrows IOException {\n \t\tif (compressMonitor == null)\n \t\t\tcompressMonitor = NullProgressMonitor.INSTANCE;\n \t\tif (writeMonitor == null)\n \t\t\twriteMonitor = NullProgressMonitor.INSTANCE;\n \n \t\tif ((reuseDeltas || config.isReuseObjects()) && reuseSupport != null)\n \t\t\tsearchForReuse(compressMonitor);\n \t\tif (config.isDeltaCompress())\n \t\t\tsearchForDeltas(compressMonitor);\n \n \t\tfinal PackOutputStream out = new PackOutputStream(writeMonitor,\n \t\t\t\tpackStream, this);\n \n \t\tlong objCnt = 0;\n \t\tfor (List<ObjectToPack> list : objectsLists)\n \t\t\tobjCnt += list.size();\n \t\tfor (CachedPack pack : cachedPacks)\n \t\t\tobjCnt += pack.getObjectCount();\n \t\tstats.totalObjects = objCnt;\n \n \t\twriteMonitor.beginTask(JGitText.get().writingObjects, (int) objCnt);\n+\t\tlong writeStart = System.currentTimeMillis();\n+\n+\t\tlong headerStart = out.length();\n \t\tout.writeFileHeader(PACK_VERSION_GENERATED, objCnt);\n \t\tout.flush();\n+\t\tlong headerEnd = out.length();\n+\n \t\twriteObjects(out);\n+\t\tif (!edgeObjects.isEmpty() || !cachedPacks.isEmpty())\n+\t\t\tstats.thinPackBytes = out.length() - (headerEnd - headerStart);\n+\n \t\tfor (CachedPack pack : cachedPacks) {\n \t\t\tstats.reusedObjects += pack.getObjectCount();\n \t\t\treuseSupport.copyPackAsIs(out, pack);\n \t\t}\n \t\twriteChecksum(out);\n+\t\tout.flush();\n+\t\tstats.timeWriting = System.currentTimeMillis() - writeStart;\n+\t\tstats.totalBytes = out.length();\n+\t\tstats.reusedPacks = Collections.unmodifiableList(cachedPacks);\n \n \t\treader.release();\n \t\twriteMonitor.endTask();\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"461b012e9565af8174e5b9d2b2c3a582011ce77e": {
			"type": "Ybodychange",
			"commitMessage": "PackWriter: Support reuse of entire packs\n\nThe most expensive part of packing a repository for transport to\nanother system is enumerating all of the objects in the repository.\nOnce this gets to the size of the linux-2.6 repository (1.8 million\nobjects), enumeration can take several CPU minutes and costs a lot\nof temporary working set memory.\n\nTeach PackWriter to efficiently reuse an existing \"cached pack\"\nby answering a clone request with a thin pack followed by a larger\ncached pack appended to the end.  This requires the repository\nowner to first construct the cached pack by hand, and record the\ntip commits inside of $GIT_DIR/objects/info/cached-packs:\n\n  cd $GIT_DIR\n  root=$(git rev-parse master)\n  tmp=objects/.tmp-$$\n  names=$(echo $root | git pack-objects --keep-true-parents --revs $tmp)\n  for n in $names; do\n    chmod a-w $tmp-$n.pack $tmp-$n.idx\n    touch objects/pack/pack-$n.keep\n    mv $tmp-$n.pack objects/pack/pack-$n.pack\n    mv $tmp-$n.idx objects/pack/pack-$n.idx\n  done\n\n  (echo \"+ $root\";\n   for n in $names; do echo \"P $n\"; done;\n   echo) >>objects/info/cached-packs\n\n  git repack -a -d\n\nWhen a clone request needs to include $root, the corresponding\ncached pack will be copied as-is, rather than enumerating all of\nthe objects that are reachable from $root.\n\nFor a linux-2.6 kernel repository that should be about 376 MiB,\nthe above process creates two packs of 368 MiB and 38 MiB[1].\nThis is a local disk usage increase of ~26 MiB, due to reduced\ndelta compression between the large cached pack and the smaller\nrecent activity pack.  The overhead is similar to 1 full copy of\nthe compressed project sources.\n\nWith this cached pack in hand, JGit daemon completes a clone request\nin 1m17s less time, but a slightly larger data transfer (+2.39 MiB):\n\n  Before:\n    remote: Counting objects: 1861830, done\n    remote: Finding sources: 100% (1861830/1861830)\n    remote: Getting sizes: 100% (88243/88243)\n    remote: Compressing objects: 100% (88184/88184)\n    Receiving objects: 100% (1861830/1861830), 376.01 MiB | 19.01 MiB/s, done.\n    remote: Total 1861830 (delta 4706), reused 1851053 (delta 1553844)\n    Resolving deltas: 100% (1564621/1564621), done.\n\n    real  3m19.005s\n\n  After:\n    remote: Counting objects: 1601, done\n    remote: Counting objects: 1828460, done\n    remote: Finding sources: 100% (50475/50475)\n    remote: Getting sizes: 100% (18843/18843)\n    remote: Compressing objects: 100% (7585/7585)\n    remote: Total 1861830 (delta 2407), reused 1856197 (delta 37510)\n    Receiving objects: 100% (1861830/1861830), 378.40 MiB | 31.31 MiB/s, done.\n    Resolving deltas: 100% (1559477/1559477), done.\n\n    real 2m2.938s\n\nRepository owners can periodically refresh their cached packs by\nrepacking their repository, folding all newer objects into a larger\ncached pack.  Since repacking is already considered to be a normal\nGit maintenance activity, this isn't a very big burden.\n\n[1] In this test $root was set back about two weeks.\n\nChange-Id: Ib87131d5c4b5e8c5cacb0f4fe16ff4ece554734b\nSigned-off-by: Shawn O. Pearce <spearce@spearce.org>\n",
			"commitDate": "2011-02-03, 1:20 PM",
			"commitName": "461b012e9565af8174e5b9d2b2c3a582011ce77e",
			"commitAuthor": "Shawn O. Pearce",
			"commitDateOld": "2011-02-02, 5:17 PM",
			"commitNameOld": "71f168fcd77ec100d68233d3d467f770304f6eb8",
			"commitAuthorOld": "Shawn O. Pearce",
			"daysBetweenCommits": 0.84,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,27 +1,36 @@\n \tpublic void writePack(ProgressMonitor compressMonitor,\n \t\t\tProgressMonitor writeMonitor, OutputStream packStream)\n \t\t\tthrows IOException {\n \t\tif (compressMonitor == null)\n \t\t\tcompressMonitor = NullProgressMonitor.INSTANCE;\n \t\tif (writeMonitor == null)\n \t\t\twriteMonitor = NullProgressMonitor.INSTANCE;\n \n \t\tif ((reuseDeltas || config.isReuseObjects()) && reuseSupport != null)\n \t\t\tsearchForReuse(compressMonitor);\n \t\tif (config.isDeltaCompress())\n \t\t\tsearchForDeltas(compressMonitor);\n \n \t\tfinal PackOutputStream out = new PackOutputStream(writeMonitor,\n \t\t\t\tpackStream, this);\n \n-\t\tint objCnt = getObjectsNumber();\n+\t\tlong objCnt = 0;\n+\t\tfor (List<ObjectToPack> list : objectsLists)\n+\t\t\tobjCnt += list.size();\n+\t\tfor (CachedPack pack : cachedPacks)\n+\t\t\tobjCnt += pack.getObjectCount();\n \t\tstats.totalObjects = objCnt;\n-\t\twriteMonitor.beginTask(JGitText.get().writingObjects, objCnt);\n+\n+\t\twriteMonitor.beginTask(JGitText.get().writingObjects, (int) objCnt);\n \t\tout.writeFileHeader(PACK_VERSION_GENERATED, objCnt);\n \t\tout.flush();\n \t\twriteObjects(out);\n+\t\tfor (CachedPack pack : cachedPacks) {\n+\t\t\tstats.reusedObjects += pack.getObjectCount();\n+\t\t\treuseSupport.copyPackAsIs(out, pack);\n+\t\t}\n \t\twriteChecksum(out);\n \n \t\treader.release();\n \t\twriteMonitor.endTask();\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"71f168fcd77ec100d68233d3d467f770304f6eb8": {
			"type": "Ybodychange",
			"commitMessage": "PackWriter: Display totals after sending objects\n\nCGit pack-objects displays a totals line after the pack data\nwas fully written.  This can be useful to understand some of\nthe decisions made by the packer, and has been a great tool\nfor helping to debug some of that code.\n\nTrack some of the basic values, and send it to the client when\npacking is done:\n\n  remote: Counting objects: 1826776, done\n  remote: Finding sources: 100% (55121/55121)\n  remote: Getting sizes: 100% (25654/25654)\n  remote: Compressing objects: 100% (11434/11434)\n  remote: Total 1861830 (delta 3926), reused 1854705 (delta 38306)\n  Receiving objects: 100% (1861830/1861830), 386.03 MiB | 30.32 MiB/s, done.\n\nChange-Id: If3b039017a984ed5d5ae80940ce32bda93652df5\nSigned-off-by: Shawn O. Pearce <spearce@spearce.org>\n",
			"commitDate": "2011-02-02, 5:17 PM",
			"commitName": "71f168fcd77ec100d68233d3d467f770304f6eb8",
			"commitAuthor": "Shawn O. Pearce",
			"commitDateOld": "2011-02-01, 7:12 AM",
			"commitNameOld": "13bcf05a9ea2d4943faef2c879aac65d37517eb6",
			"commitAuthorOld": "Shawn O. Pearce",
			"daysBetweenCommits": 1.42,
			"commitsBetweenForRepo": 6,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,26 +1,27 @@\n \tpublic void writePack(ProgressMonitor compressMonitor,\n \t\t\tProgressMonitor writeMonitor, OutputStream packStream)\n \t\t\tthrows IOException {\n \t\tif (compressMonitor == null)\n \t\t\tcompressMonitor = NullProgressMonitor.INSTANCE;\n \t\tif (writeMonitor == null)\n \t\t\twriteMonitor = NullProgressMonitor.INSTANCE;\n \n \t\tif ((reuseDeltas || config.isReuseObjects()) && reuseSupport != null)\n \t\t\tsearchForReuse(compressMonitor);\n \t\tif (config.isDeltaCompress())\n \t\t\tsearchForDeltas(compressMonitor);\n \n \t\tfinal PackOutputStream out = new PackOutputStream(writeMonitor,\n \t\t\t\tpackStream, this);\n \n \t\tint objCnt = getObjectsNumber();\n+\t\tstats.totalObjects = objCnt;\n \t\twriteMonitor.beginTask(JGitText.get().writingObjects, objCnt);\n \t\tout.writeFileHeader(PACK_VERSION_GENERATED, objCnt);\n \t\tout.flush();\n \t\twriteObjects(out);\n \t\twriteChecksum(out);\n \n \t\treader.release();\n \t\twriteMonitor.endTask();\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"28ba4747bc166243ecff86cdc7460cbc969a8eb4": {
			"type": "Ybodychange",
			"commitMessage": "Allow ObjectReuseAsIs to have more control over write ordering\n\nThe reuse system used by an object database may be able to benefit\nfrom knowing what objects are coming next, and even improve data\nthroughput by delaying (or moving up) objects that are stored near\neach other in the source database.\n\nPushing the iteration down into the reuse code makes it possible\nfor a smarter implementation to aggregate reuse.  But for the\nstandard pack file format on disk we don't bother, its quite\nefficient already.\n\nChange-Id: I64f0048ca7071a8b44950d6c2a5dfbca3be6bba6\nSigned-off-by: Shawn O. Pearce <spearce@spearce.org>\n",
			"commitDate": "2010-08-20, 5:59 PM",
			"commitName": "28ba4747bc166243ecff86cdc7460cbc969a8eb4",
			"commitAuthor": "Shawn O. Pearce",
			"commitDateOld": "2010-08-20, 5:41 PM",
			"commitNameOld": "f048af3fd19547d3692f5df968571ffd7556b688",
			"commitAuthorOld": "Shawn O. Pearce",
			"daysBetweenCommits": 0.01,
			"commitsBetweenForRepo": 2,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,26 +1,26 @@\n \tpublic void writePack(ProgressMonitor compressMonitor,\n \t\t\tProgressMonitor writeMonitor, OutputStream packStream)\n \t\t\tthrows IOException {\n \t\tif (compressMonitor == null)\n \t\t\tcompressMonitor = NullProgressMonitor.INSTANCE;\n \t\tif (writeMonitor == null)\n \t\t\twriteMonitor = NullProgressMonitor.INSTANCE;\n \n \t\tif ((reuseDeltas || config.isReuseObjects()) && reuseSupport != null)\n \t\t\tsearchForReuse(compressMonitor);\n \t\tif (config.isDeltaCompress())\n \t\t\tsearchForDeltas(compressMonitor);\n \n \t\tfinal PackOutputStream out = new PackOutputStream(writeMonitor,\n \t\t\t\tpackStream, this);\n \n \t\tint objCnt = getObjectsNumber();\n \t\twriteMonitor.beginTask(JGitText.get().writingObjects, objCnt);\n \t\tout.writeFileHeader(PACK_VERSION_GENERATED, objCnt);\n \t\tout.flush();\n-\t\twriteObjects(writeMonitor, out);\n+\t\twriteObjects(out);\n \t\twriteChecksum(out);\n \n \t\treader.release();\n \t\twriteMonitor.endTask();\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"b85af06324644e699bd2cc7e2047ae1f65f35db5": {
			"type": "Ybodychange",
			"commitMessage": "Allow object reuse selection to occur in parallel\n\nObjectReader implementations may wish to use multiple threads in\norder to evaluate object reuse faster.  Let the reader make that\ndecision by passing the iteration down into the reader.\n\nBecause the work is pushed into the reader, it may need to locate a\ngiven ObjectToPack given its ObjectId.  This can easily occur if the\nreader has sent a list of ObjectIds to the object database and gets\nback information keyed only by ObjectId, without the ObjectToPack\nhandle.  Expose lookup using the PackWriter's own internal map,\nso the reader doesn't need to build a redundant copy to track the\nassocation of ObjectId back to ObjectToPack.\n\nChange-Id: I0c536405a55034881fb5db92a2d2a99534faed34\nSigned-off-by: Shawn O. Pearce <spearce@spearce.org>\n",
			"commitDate": "2010-08-20, 5:41 PM",
			"commitName": "b85af06324644e699bd2cc7e2047ae1f65f35db5",
			"commitAuthor": "Shawn O. Pearce",
			"commitDateOld": "2010-08-20, 5:41 PM",
			"commitNameOld": "cc6210619b82dc0c7bdb014b5ccf29d6f93e5ef3",
			"commitAuthorOld": "Shawn O. Pearce",
			"daysBetweenCommits": 0,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,26 +1,26 @@\n \tpublic void writePack(ProgressMonitor compressMonitor,\n \t\t\tProgressMonitor writeMonitor, OutputStream packStream)\n \t\t\tthrows IOException {\n \t\tif (compressMonitor == null)\n \t\t\tcompressMonitor = NullProgressMonitor.INSTANCE;\n \t\tif (writeMonitor == null)\n \t\t\twriteMonitor = NullProgressMonitor.INSTANCE;\n \n \t\tif ((reuseDeltas || config.isReuseObjects()) && reuseSupport != null)\n-\t\t\tsearchForReuse();\n+\t\t\tsearchForReuse(compressMonitor);\n \t\tif (config.isDeltaCompress())\n \t\t\tsearchForDeltas(compressMonitor);\n \n \t\tfinal PackOutputStream out = new PackOutputStream(writeMonitor,\n \t\t\t\tpackStream, this);\n \n \t\tint objCnt = getObjectsNumber();\n \t\twriteMonitor.beginTask(JGitText.get().writingObjects, objCnt);\n \t\tout.writeFileHeader(PACK_VERSION_GENERATED, objCnt);\n \t\tout.flush();\n \t\twriteObjects(writeMonitor, out);\n \t\twriteChecksum(out);\n \n \t\treader.release();\n \t\twriteMonitor.endTask();\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"cc6210619b82dc0c7bdb014b5ccf29d6f93e5ef3": {
			"type": "Ybodychange",
			"commitMessage": "Flush the pack header as soon as its ready\n\nWhen the output stream is deeply buffered (e.g. 1 MiB or more in\nan HTTP servlet on some containers) trying to kick out the header\nearlier will prevent the client from stalling hard while the first\n1 MiB is received and it can process the pack header.  Forcing a\nflush here lets the client see the header and start its progress\nmonitor for \"Receiving objects: (1/N)\" so the user knows there\nis still activity occurring, even though the buffering may cause\nthere to be some lag as the buffer fills up on the sending side.\n\nChange-Id: I3edf39e8f703fe87a738dc236d426b194db85e3a\nSigned-off-by: Shawn O. Pearce <spearce@spearce.org>\n",
			"commitDate": "2010-08-20, 5:41 PM",
			"commitName": "cc6210619b82dc0c7bdb014b5ccf29d6f93e5ef3",
			"commitAuthor": "Shawn O. Pearce",
			"commitDateOld": "2010-07-28, 12:13 PM",
			"commitNameOld": "1a06179ea707ab088b6543df77be5cf0ea44c497",
			"commitAuthorOld": "Shawn O. Pearce",
			"daysBetweenCommits": 23.23,
			"commitsBetweenForRepo": 49,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,25 +1,26 @@\n \tpublic void writePack(ProgressMonitor compressMonitor,\n \t\t\tProgressMonitor writeMonitor, OutputStream packStream)\n \t\t\tthrows IOException {\n \t\tif (compressMonitor == null)\n \t\t\tcompressMonitor = NullProgressMonitor.INSTANCE;\n \t\tif (writeMonitor == null)\n \t\t\twriteMonitor = NullProgressMonitor.INSTANCE;\n \n \t\tif ((reuseDeltas || config.isReuseObjects()) && reuseSupport != null)\n \t\t\tsearchForReuse();\n \t\tif (config.isDeltaCompress())\n \t\t\tsearchForDeltas(compressMonitor);\n \n \t\tfinal PackOutputStream out = new PackOutputStream(writeMonitor,\n \t\t\t\tpackStream, this);\n \n \t\tint objCnt = getObjectsNumber();\n \t\twriteMonitor.beginTask(JGitText.get().writingObjects, objCnt);\n \t\tout.writeFileHeader(PACK_VERSION_GENERATED, objCnt);\n+\t\tout.flush();\n \t\twriteObjects(writeMonitor, out);\n \t\twriteChecksum(out);\n \n \t\treader.release();\n \t\twriteMonitor.endTask();\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"1a06179ea707ab088b6543df77be5cf0ea44c497": {
			"type": "Ybodychange",
			"commitMessage": "Move PackWriter configuration to PackConfig\n\nThis refactoring permits applications to configure global per-process\nsettings for all packing and easily pass it through to per-request\nPackWriters, ensuring that the process configuration overrides the\nrepository specific settings.\n\nFor example this might help in a daemon environment where the server\nwants to cap the resources used to serve a dynamic upload pack\nrequest, even though the repository's own pack.* settings might be\nconfigured to be more aggressive.  This allows fast but less bandwidth\nefficient serving of clients, while still retaining good compression\nthrough a cron managed `git gc`.\n\nChange-Id: I58cc5e01b48924b1a99f79aa96c8150cdfc50846\nSigned-off-by: Shawn O. Pearce <spearce@spearce.org>\n",
			"commitDate": "2010-07-28, 12:13 PM",
			"commitName": "1a06179ea707ab088b6543df77be5cf0ea44c497",
			"commitAuthor": "Shawn O. Pearce",
			"commitDateOld": "2010-07-28, 10:50 AM",
			"commitNameOld": "1b783d037091266b035e1727db6b6ce7a397ef63",
			"commitAuthorOld": "Shawn O. Pearce",
			"daysBetweenCommits": 0.06,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,25 +1,25 @@\n \tpublic void writePack(ProgressMonitor compressMonitor,\n \t\t\tProgressMonitor writeMonitor, OutputStream packStream)\n \t\t\tthrows IOException {\n \t\tif (compressMonitor == null)\n \t\t\tcompressMonitor = NullProgressMonitor.INSTANCE;\n \t\tif (writeMonitor == null)\n \t\t\twriteMonitor = NullProgressMonitor.INSTANCE;\n \n-\t\tif ((reuseDeltas || reuseObjects) && reuseSupport != null)\n+\t\tif ((reuseDeltas || config.isReuseObjects()) && reuseSupport != null)\n \t\t\tsearchForReuse();\n-\t\tif (deltaCompress)\n+\t\tif (config.isDeltaCompress())\n \t\t\tsearchForDeltas(compressMonitor);\n \n \t\tfinal PackOutputStream out = new PackOutputStream(writeMonitor,\n \t\t\t\tpackStream, this);\n \n \t\tint objCnt = getObjectsNumber();\n \t\twriteMonitor.beginTask(JGitText.get().writingObjects, objCnt);\n \t\tout.writeFileHeader(PACK_VERSION_GENERATED, objCnt);\n \t\twriteObjects(writeMonitor, out);\n \t\twriteChecksum(out);\n \n \t\treader.release();\n \t\twriteMonitor.endTask();\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"21f76c2a69836ec618c82eb9305656dcec70befb": {
			"type": "Ybodychange",
			"commitMessage": "Remove static progress task names from PackWriter\n\nThese need to be dynamic based on the current thread's environment\nat time of execution in order to be properly localized for the end\nuser that will be seeing these messages.\n\nChange-Id: I4976f462cfe606edd2761c0e36b2f6b20f63d53c\nSigned-off-by: Shawn O. Pearce <spearce@spearce.org>\n",
			"commitDate": "2010-07-28, 10:50 AM",
			"commitName": "21f76c2a69836ec618c82eb9305656dcec70befb",
			"commitAuthor": "Shawn O. Pearce",
			"commitDateOld": "2010-07-27, 9:40 AM",
			"commitNameOld": "a00377a7e23dbde315598ee20f61c45d031e159a",
			"commitAuthorOld": "Robin Stocker",
			"daysBetweenCommits": 1.05,
			"commitsBetweenForRepo": 4,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,24 +1,25 @@\n \tpublic void writePack(ProgressMonitor compressMonitor,\n \t\t\tProgressMonitor writeMonitor, OutputStream packStream)\n \t\t\tthrows IOException {\n \t\tif (compressMonitor == null)\n \t\t\tcompressMonitor = NullProgressMonitor.INSTANCE;\n \t\tif (writeMonitor == null)\n \t\t\twriteMonitor = NullProgressMonitor.INSTANCE;\n \n \t\tif ((reuseDeltas || reuseObjects) && reuseSupport != null)\n \t\t\tsearchForReuse();\n \t\tif (deltaCompress)\n \t\t\tsearchForDeltas(compressMonitor);\n \n \t\tfinal PackOutputStream out = new PackOutputStream(writeMonitor,\n \t\t\t\tpackStream, this);\n \n-\t\twriteMonitor.beginTask(WRITING_OBJECTS_PROGRESS, getObjectsNumber());\n-\t\tout.writeFileHeader(PACK_VERSION_GENERATED, getObjectsNumber());\n+\t\tint objCnt = getObjectsNumber();\n+\t\twriteMonitor.beginTask(JGitText.get().writingObjects, objCnt);\n+\t\tout.writeFileHeader(PACK_VERSION_GENERATED, objCnt);\n \t\twriteObjects(writeMonitor, out);\n \t\twriteChecksum(out);\n \n \t\treader.release();\n \t\twriteMonitor.endTask();\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"dfad23bf3d9b17cc3e9d736fa3daf6ace52dbc33": {
			"type": "Ybodychange",
			"commitMessage": "Implement delta generation during packing\n\nPackWriter now produces new deltas if there is not a suitable delta\navailable for reuse from an existing pack file.  This permits JGit to\nsend less data on the wire by sending a delta relative to an object\nthe other side already has, instead of sending the whole object.\n\nThe delta searching algorithm is similar in style to what C Git\nuses, but apparently has some differences (see below for more on).\nBriefly, objects that should be considered for delta compression are\npushed onto a list.  This list is then sorted by a rough similarity\nscore, which is derived from the path name the object was discovered\nat in the repository during object counting.  The list is then\nwalked in order.\n\nAt each position in the list, up to $WINDOW objects prior to it\nare attempted as delta bases.  Each object in the window is tried,\nand the shortest delta instruction sequence selects the base object.\nSome rough rules are used to prevent pathological behavior during\nthis matching phase, like skipping pairings of objects that are\nnot similar enough in size.\n\nPackWriter intentionally excludes commits and annotated tags from\nthis new delta search phase.  In the JGit repository only 28 out\nof 2600+ commits can be delta compressed by C Git.  As the commit\ncount tends to be a fair percentage of the total number of objects\nin the repository, and they generally do not delta compress well,\nskipping over them can improve performance with little increase in\nthe output pack size.\n\nBecause this implementation was rebuilt from scratch based on my own\nmemory of how the packing algorithm has evolved over the years in\nC Git, PackWriter, DeltaWindow, and DeltaEncoder don't use exactly\nthe same rules everywhere, and that leads JGit to produce different\n(but logically equivalent) pack files.\n\n  Repository | Pack Size (bytes)                | Packing Time\n             | JGit     - CGit     = Difference | JGit / CGit\n  -----------+----------------------------------+-----------------\n   git       | 25094348 - 24322890 = +771458    | 59.434s / 59.133s\n   jgit      |  5669515 -  5709046 = - 39531    |  6.654s /  6.806s\n   linux-2.6 |     389M -     386M = +3M        |  20m02s / 18m01s\n\nFor the above tests pack.threads was set to 1, window size=10,\ndelta depth=50, and delta and object reuse was disabled for both\nimplementations.  Both implementations were reading from an already\nfully packed repository on local disk.  The running time reported\nis after 1 warm-up run of the tested implementation.\n\nPackWriter is writing 771 KiB more data on git.git, 3M more on\nlinux-2.6, but is actually 39.5 KiB smaller on jgit.git.  Being\nlarger by less than 0.7% on linux-2.6 isn't bad, nor is taking an\nextra 2 minutes to pack.  On the running time side, JGit is at a\nmajor disadvantage because linux-2.6 doesn't fit into the default\nWindowCache of 20M, while C Git is able to mmap the entire pack and\nhave it available instantly in physical memory (assuming hot cache).\n\nCGit also has a feature where it caches deltas that were created\nduring the compression phase, and uses those cached deltas during\nthe writing phase.  PackWriter does not implement this (yet),\nand therefore must create every delta twice.  This could easily\naccount for the increased running time we are seeing.\n\nChange-Id: I6292edc66c2e95fbe45b519b65fdb3918068889c\nSigned-off-by: Shawn O. Pearce <spearce@spearce.org>\n",
			"commitDate": "2010-07-09, 7:14 PM",
			"commitName": "dfad23bf3d9b17cc3e9d736fa3daf6ace52dbc33",
			"commitAuthor": "Shawn O. Pearce",
			"commitDateOld": "2010-07-09, 7:12 PM",
			"commitNameOld": "074055d747026c47040d0306585863ad5d428860",
			"commitAuthorOld": "Shawn O. Pearce",
			"daysBetweenCommits": 0,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,22 +1,24 @@\n \tpublic void writePack(ProgressMonitor compressMonitor,\n \t\t\tProgressMonitor writeMonitor, OutputStream packStream)\n \t\t\tthrows IOException {\n \t\tif (compressMonitor == null)\n \t\t\tcompressMonitor = NullProgressMonitor.INSTANCE;\n \t\tif (writeMonitor == null)\n \t\t\twriteMonitor = NullProgressMonitor.INSTANCE;\n \n \t\tif ((reuseDeltas || reuseObjects) && reuseSupport != null)\n \t\t\tsearchForReuse();\n+\t\tif (deltaCompress)\n+\t\t\tsearchForDeltas(compressMonitor);\n \n \t\tfinal PackOutputStream out = new PackOutputStream(writeMonitor,\n \t\t\t\tpackStream, this);\n \n \t\twriteMonitor.beginTask(WRITING_OBJECTS_PROGRESS, getObjectsNumber());\n \t\tout.writeFileHeader(PACK_VERSION_GENERATED, getObjectsNumber());\n \t\twriteObjects(writeMonitor, out);\n \t\twriteChecksum(out);\n \n \t\treader.release();\n \t\twriteMonitor.endTask();\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"074055d747026c47040d0306585863ad5d428860": {
			"type": "Ybodychange",
			"commitMessage": "debug-show-packdelta:  Dump a pack delta to the console\n\nThis is a horribly crude application, it doesn't even verify that\nthe object its dumping is delta encoded.  Its method of getting the\ndelta is pretty abusive to the public PackWriter API, because right\nnow we don't want to expose the real internal low-level methods\nactually required to do this.\n\nChange-Id: I437a17ceb98708b5603a2061126eb251e82f4ed4\nSigned-off-by: Shawn O. Pearce <spearce@spearce.org>\n",
			"commitDate": "2010-07-09, 7:12 PM",
			"commitName": "074055d747026c47040d0306585863ad5d428860",
			"commitAuthor": "Shawn O. Pearce",
			"commitDateOld": "2010-07-09, 7:06 PM",
			"commitNameOld": "4569d77e13c7bbf0c7466cbc57d0eefd117cb206",
			"commitAuthorOld": "Shawn O. Pearce",
			"daysBetweenCommits": 0,
			"commitsBetweenForRepo": 4,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,22 +1,22 @@\n \tpublic void writePack(ProgressMonitor compressMonitor,\n \t\t\tProgressMonitor writeMonitor, OutputStream packStream)\n \t\t\tthrows IOException {\n \t\tif (compressMonitor == null)\n \t\t\tcompressMonitor = NullProgressMonitor.INSTANCE;\n \t\tif (writeMonitor == null)\n \t\t\twriteMonitor = NullProgressMonitor.INSTANCE;\n \n \t\tif ((reuseDeltas || reuseObjects) && reuseSupport != null)\n \t\t\tsearchForReuse();\n \n \t\tfinal PackOutputStream out = new PackOutputStream(writeMonitor,\n-\t\t\t\tpackStream, isDeltaBaseAsOffset());\n+\t\t\t\tpackStream, this);\n \n \t\twriteMonitor.beginTask(WRITING_OBJECTS_PROGRESS, getObjectsNumber());\n \t\tout.writeFileHeader(PACK_VERSION_GENERATED, getObjectsNumber());\n \t\twriteObjects(writeMonitor, out);\n \t\twriteChecksum(out);\n \n \t\treader.release();\n \t\twriteMonitor.endTask();\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"4569d77e13c7bbf0c7466cbc57d0eefd117cb206": {
			"type": "Ybodychange",
			"commitMessage": "Correctly classify the compressing objects phase\n\nSearching for reuse candidates should be fast compared to actually\ndoing delta compression.  So pull the progress monitor out of this\nphase and rename it back to identify the compressing objects state.\n\nChange-Id: I5eb80919f21c1251e0e3420ff7774126f1f79b27\nSigned-off-by: Shawn O. Pearce <spearce@spearce.org>\n",
			"commitDate": "2010-07-09, 7:06 PM",
			"commitName": "4569d77e13c7bbf0c7466cbc57d0eefd117cb206",
			"commitAuthor": "Shawn O. Pearce",
			"commitDateOld": "2010-07-09, 7:02 PM",
			"commitNameOld": "6730f9e3c830d997d1731bf36414e626bda42ad8",
			"commitAuthorOld": "Shawn O. Pearce",
			"daysBetweenCommits": 0,
			"commitsBetweenForRepo": 2,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,22 +1,22 @@\n \tpublic void writePack(ProgressMonitor compressMonitor,\n \t\t\tProgressMonitor writeMonitor, OutputStream packStream)\n \t\t\tthrows IOException {\n \t\tif (compressMonitor == null)\n \t\t\tcompressMonitor = NullProgressMonitor.INSTANCE;\n \t\tif (writeMonitor == null)\n \t\t\twriteMonitor = NullProgressMonitor.INSTANCE;\n \n \t\tif ((reuseDeltas || reuseObjects) && reuseSupport != null)\n-\t\t\tsearchForReuse(compressMonitor);\n+\t\t\tsearchForReuse();\n \n \t\tfinal PackOutputStream out = new PackOutputStream(writeMonitor,\n \t\t\t\tpackStream, isDeltaBaseAsOffset());\n \n \t\twriteMonitor.beginTask(WRITING_OBJECTS_PROGRESS, getObjectsNumber());\n \t\tout.writeFileHeader(PACK_VERSION_GENERATED, getObjectsNumber());\n \t\twriteObjects(writeMonitor, out);\n \t\twriteChecksum(out);\n \n \t\treader.release();\n \t\twriteMonitor.endTask();\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"6b62e53b607630b6c00411741972838ced552f4d": {
			"type": "Ymultichange(Yparameterchange,Ybodychange)",
			"commitMessage": "Move PackWriter progress monitors onto the operations\n\nRather than taking the ProgressMonitor objects in our constructor and\ncarrying them around as instance fields, take them as arguments to the\nactual time consuming operations we need to run.\n\nChange-Id: I2b230d07e277de029b1061c807e67de5428cc1c4\nSigned-off-by: Shawn O. Pearce <spearce@spearce.org>\n",
			"commitDate": "2010-06-28, 11:47 AM",
			"commitName": "6b62e53b607630b6c00411741972838ced552f4d",
			"commitAuthor": "Shawn O. Pearce",
			"subchanges": [
				{
					"type": "Yparameterchange",
					"commitMessage": "Move PackWriter progress monitors onto the operations\n\nRather than taking the ProgressMonitor objects in our constructor and\ncarrying them around as instance fields, take them as arguments to the\nactual time consuming operations we need to run.\n\nChange-Id: I2b230d07e277de029b1061c807e67de5428cc1c4\nSigned-off-by: Shawn O. Pearce <spearce@spearce.org>\n",
					"commitDate": "2010-06-28, 11:47 AM",
					"commitName": "6b62e53b607630b6c00411741972838ced552f4d",
					"commitAuthor": "Shawn O. Pearce",
					"commitDateOld": "2010-06-28, 11:47 AM",
					"commitNameOld": "f288c27e465a91e80b53c4100c0d9b2f2341a9aa",
					"commitAuthorOld": "Shawn O. Pearce",
					"daysBetweenCommits": 0,
					"commitsBetweenForRepo": 1,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,15 +1,22 @@\n-\tpublic void writePack(OutputStream packStream) throws IOException {\n-\t\tif ((reuseDeltas || reuseObjects) && reuseSupport != null)\n-\t\t\tsearchForReuse();\n+\tpublic void writePack(ProgressMonitor compressMonitor,\n+\t\t\tProgressMonitor writeMonitor, OutputStream packStream)\n+\t\t\tthrows IOException {\n+\t\tif (compressMonitor == null)\n+\t\t\tcompressMonitor = NullProgressMonitor.INSTANCE;\n+\t\tif (writeMonitor == null)\n+\t\t\twriteMonitor = NullProgressMonitor.INSTANCE;\n \n-\t\tfinal PackOutputStream out = new PackOutputStream(packStream,\n-\t\t\t\tisDeltaBaseAsOffset());\n+\t\tif ((reuseDeltas || reuseObjects) && reuseSupport != null)\n+\t\t\tsearchForReuse(compressMonitor);\n+\n+\t\tfinal PackOutputStream out = new PackOutputStream(writeMonitor,\n+\t\t\t\tpackStream, isDeltaBaseAsOffset());\n \n \t\twriteMonitor.beginTask(WRITING_OBJECTS_PROGRESS, getObjectsNumber());\n \t\tout.writeFileHeader(PACK_VERSION_GENERATED, getObjectsNumber());\n-\t\twriteObjects(out);\n+\t\twriteObjects(writeMonitor, out);\n \t\twriteChecksum(out);\n \n \t\treader.release();\n \t\twriteMonitor.endTask();\n \t}\n\\ No newline at end of file\n",
					"extendedDetails": {
						"oldValue": "[packStream-OutputStream]",
						"newValue": "[compressMonitor-ProgressMonitor, writeMonitor-ProgressMonitor, packStream-OutputStream]"
					}
				},
				{
					"type": "Ybodychange",
					"commitMessage": "Move PackWriter progress monitors onto the operations\n\nRather than taking the ProgressMonitor objects in our constructor and\ncarrying them around as instance fields, take them as arguments to the\nactual time consuming operations we need to run.\n\nChange-Id: I2b230d07e277de029b1061c807e67de5428cc1c4\nSigned-off-by: Shawn O. Pearce <spearce@spearce.org>\n",
					"commitDate": "2010-06-28, 11:47 AM",
					"commitName": "6b62e53b607630b6c00411741972838ced552f4d",
					"commitAuthor": "Shawn O. Pearce",
					"commitDateOld": "2010-06-28, 11:47 AM",
					"commitNameOld": "f288c27e465a91e80b53c4100c0d9b2f2341a9aa",
					"commitAuthorOld": "Shawn O. Pearce",
					"daysBetweenCommits": 0,
					"commitsBetweenForRepo": 1,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,15 +1,22 @@\n-\tpublic void writePack(OutputStream packStream) throws IOException {\n-\t\tif ((reuseDeltas || reuseObjects) && reuseSupport != null)\n-\t\t\tsearchForReuse();\n+\tpublic void writePack(ProgressMonitor compressMonitor,\n+\t\t\tProgressMonitor writeMonitor, OutputStream packStream)\n+\t\t\tthrows IOException {\n+\t\tif (compressMonitor == null)\n+\t\t\tcompressMonitor = NullProgressMonitor.INSTANCE;\n+\t\tif (writeMonitor == null)\n+\t\t\twriteMonitor = NullProgressMonitor.INSTANCE;\n \n-\t\tfinal PackOutputStream out = new PackOutputStream(packStream,\n-\t\t\t\tisDeltaBaseAsOffset());\n+\t\tif ((reuseDeltas || reuseObjects) && reuseSupport != null)\n+\t\t\tsearchForReuse(compressMonitor);\n+\n+\t\tfinal PackOutputStream out = new PackOutputStream(writeMonitor,\n+\t\t\t\tpackStream, isDeltaBaseAsOffset());\n \n \t\twriteMonitor.beginTask(WRITING_OBJECTS_PROGRESS, getObjectsNumber());\n \t\tout.writeFileHeader(PACK_VERSION_GENERATED, getObjectsNumber());\n-\t\twriteObjects(out);\n+\t\twriteObjects(writeMonitor, out);\n \t\twriteChecksum(out);\n \n \t\treader.release();\n \t\twriteMonitor.endTask();\n \t}\n\\ No newline at end of file\n",
					"extendedDetails": {}
				}
			]
		},
		"f288c27e465a91e80b53c4100c0d9b2f2341a9aa": {
			"type": "Ybodychange",
			"commitMessage": "Pass the PackOutputStream down the call stack\n\nRather than storing this in an instance member, pass it down the\ncalling stack.  Its cleaner, we don't have to poke the stream as\na temporary field, and then unset it.\n\nChange-Id: I0fd323371bc12edb10f0493bf11885d7057aeb13\nSigned-off-by: Shawn O. Pearce <spearce@spearce.org>\n",
			"commitDate": "2010-06-28, 11:47 AM",
			"commitName": "f288c27e465a91e80b53c4100c0d9b2f2341a9aa",
			"commitAuthor": "Shawn O. Pearce",
			"commitDateOld": "2010-06-28, 11:47 AM",
			"commitNameOld": "1ad2feb7b3d48d8bfedfdd03ee6ca4f599041476",
			"commitAuthorOld": "Shawn O. Pearce",
			"daysBetweenCommits": 0,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,15 +1,15 @@\n \tpublic void writePack(OutputStream packStream) throws IOException {\n \t\tif ((reuseDeltas || reuseObjects) && reuseSupport != null)\n \t\t\tsearchForReuse();\n \n-\t\tout = new PackOutputStream(packStream, isDeltaBaseAsOffset());\n+\t\tfinal PackOutputStream out = new PackOutputStream(packStream,\n+\t\t\t\tisDeltaBaseAsOffset());\n \n \t\twriteMonitor.beginTask(WRITING_OBJECTS_PROGRESS, getObjectsNumber());\n \t\tout.writeFileHeader(PACK_VERSION_GENERATED, getObjectsNumber());\n-\t\twriteObjects();\n-\t\twriteChecksum();\n+\t\twriteObjects(out);\n+\t\twriteChecksum(out);\n \n-\t\tout = null;\n \t\treader.release();\n \t\twriteMonitor.endTask();\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"a45728d7a4fe1b83953ba38ec980caa6a3f1d3c4": {
			"type": "Ybodychange",
			"commitMessage": "Ensure ObjectReader used by PackWriter is released\n\nThe ObjectReader API demands that we release the reader when we are\ndone with it.  PackWriter contains a reader, which it uses for the\nentire packing session.  Expose the release of the reader through\na release method on the writer.\n\nThis still doesn't address the RevWalk and TreeWalk users, who\ndon't correctly release their reader.  But its a small step in the\nright direction.\n\nChange-Id: I5cb0b5c1b432434a799fceb21b86479e09b84a0a\nSigned-off-by: Shawn O. Pearce <spearce@spearce.org>\n",
			"commitDate": "2010-06-28, 10:25 AM",
			"commitName": "a45728d7a4fe1b83953ba38ec980caa6a3f1d3c4",
			"commitAuthor": "Shawn O. Pearce",
			"commitDateOld": "2010-06-28, 10:16 AM",
			"commitNameOld": "b5aa52e98a8e1ee9b8530fc2c37a04df224aa0c1",
			"commitAuthorOld": "Shawn O. Pearce",
			"daysBetweenCommits": 0.01,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,18 +1,15 @@\n \tpublic void writePack(OutputStream packStream) throws IOException {\n-\t\ttry {\n-\t\t\tif ((reuseDeltas || reuseObjects) && reuseSupport != null)\n-\t\t\t\tsearchForReuse();\n+\t\tif ((reuseDeltas || reuseObjects) && reuseSupport != null)\n+\t\t\tsearchForReuse();\n \n-\t\t\tout = new PackOutputStream(packStream, isDeltaBaseAsOffset());\n+\t\tout = new PackOutputStream(packStream, isDeltaBaseAsOffset());\n \n-\t\t\tint cnt = getObjectsNumber();\n-\t\t\twriteMonitor.beginTask(WRITING_OBJECTS_PROGRESS, cnt);\n-\t\t\tout.writeFileHeader(PACK_VERSION_GENERATED, cnt);\n-\t\t\twriteObjects();\n-\t\t\twriteChecksum();\n-\t\t\twriteMonitor.endTask();\n-\t\t} finally {\n-\t\t\tout = null;\n-\t\t\treader.release();\n-\t\t}\n+\t\twriteMonitor.beginTask(WRITING_OBJECTS_PROGRESS, getObjectsNumber());\n+\t\tout.writeFileHeader(PACK_VERSION_GENERATED, getObjectsNumber());\n+\t\twriteObjects();\n+\t\twriteChecksum();\n+\n+\t\tout = null;\n+\t\treader.release();\n+\t\twriteMonitor.endTask();\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"b5aa52e98a8e1ee9b8530fc2c37a04df224aa0c1": {
			"type": "Ybodychange",
			"commitMessage": "Ensure PackWriter releases its ObjectReader\n\nChange-Id: I3f8af29066cc5a2132dc4a75c9654d97800f2f18\nSigned-off-by: Shawn O. Pearce <spearce@spearce.org>\n",
			"commitDate": "2010-06-28, 10:16 AM",
			"commitName": "b5aa52e98a8e1ee9b8530fc2c37a04df224aa0c1",
			"commitAuthor": "Shawn O. Pearce",
			"commitDateOld": "2010-06-26, 6:51 PM",
			"commitNameOld": "ea21c111cb7ac0c8dc39c4df3fe90c08ddcce066",
			"commitAuthorOld": "Shawn O. Pearce",
			"daysBetweenCommits": 1.64,
			"commitsBetweenForRepo": 4,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,15 +1,18 @@\n \tpublic void writePack(OutputStream packStream) throws IOException {\n-\t\tif ((reuseDeltas || reuseObjects) && reuseSupport != null)\n-\t\t\tsearchForReuse();\n+\t\ttry {\n+\t\t\tif ((reuseDeltas || reuseObjects) && reuseSupport != null)\n+\t\t\t\tsearchForReuse();\n \n-\t\tout = new PackOutputStream(packStream, isDeltaBaseAsOffset());\n+\t\t\tout = new PackOutputStream(packStream, isDeltaBaseAsOffset());\n \n-\t\twriteMonitor.beginTask(WRITING_OBJECTS_PROGRESS, getObjectsNumber());\n-\t\tout.writeFileHeader(PACK_VERSION_GENERATED, getObjectsNumber());\n-\t\twriteObjects();\n-\t\twriteChecksum();\n-\n-\t\tout = null;\n-\t\treader.release();\n-\t\twriteMonitor.endTask();\n+\t\t\tint cnt = getObjectsNumber();\n+\t\t\twriteMonitor.beginTask(WRITING_OBJECTS_PROGRESS, cnt);\n+\t\t\tout.writeFileHeader(PACK_VERSION_GENERATED, cnt);\n+\t\t\twriteObjects();\n+\t\t\twriteChecksum();\n+\t\t\twriteMonitor.endTask();\n+\t\t} finally {\n+\t\t\tout = null;\n+\t\t\treader.release();\n+\t\t}\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"ea21c111cb7ac0c8dc39c4df3fe90c08ddcce066": {
			"type": "Yfilerename",
			"commitMessage": "Move PackWriter over to storage.pack.PackWriter\n\nSimilar to what we did with the file code, move the pack writer\ninto its own package so the related classes and their package\nprivate methods are hidden from the rest of the library.\n\nChange-Id: Ic1b5c7c8c8d266e90c910d8d68dfc8e93586854f\nSigned-off-by: Shawn O. Pearce <spearce@spearce.org>\n",
			"commitDate": "2010-06-26, 6:51 PM",
			"commitName": "ea21c111cb7ac0c8dc39c4df3fe90c08ddcce066",
			"commitAuthor": "Shawn O. Pearce",
			"commitDateOld": "2010-06-26, 6:50 PM",
			"commitNameOld": "71aace52f7bfc36c65c92ab54c6f020dffc873ab",
			"commitAuthorOld": "Shawn O. Pearce",
			"daysBetweenCommits": 0,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "",
			"extendedDetails": {
				"oldPath": "org.eclipse.jgit/src/org/eclipse/jgit/lib/PackWriter.java",
				"newPath": "org.eclipse.jgit/src/org/eclipse/jgit/storage/pack/PackWriter.java"
			}
		},
		"ece88b99eb2ea6541b667aa066573184c25b6a8b": {
			"type": "Ybodychange",
			"commitMessage": "Redo PackWriter object reuse output\n\nOutput of selected reuses is refactored to use a new ObjectReuseAsIs\ninterface that extends the ObjectReader.  This interface allows the\nreader to control how it performs the reuse into the output stream,\nbut also allows it to throw an exception to request the writer to\nfind a different candidate representation.\n\nThe PackFile reuse code was overhauled, cleaning up the APIs so they\naren't exposed in the object loader, but instead are now a single\nmethod on the PackFile itself.  The reuse algorithm was changed to do\na data verification pass, followed by the copy pass to the output.\nThis permits us to work around a corrupt object in a pack file by\nseeking another copy of that object when this one is bad.\n\nThe reuse code was also optimized for the common case, where the\nin-pack representation is under 16 KiB.  In these smaller cases\ndata is sent to the pack writer more directly, avoiding some copying.\n\nChange-Id: I6350c2b444118305e8446ce1dfd049259832bcca\nSigned-off-by: Shawn O. Pearce <spearce@spearce.org>\n",
			"commitDate": "2010-06-26, 2:46 PM",
			"commitName": "ece88b99eb2ea6541b667aa066573184c25b6a8b",
			"commitAuthor": "Shawn O. Pearce",
			"commitDateOld": "2010-06-26, 2:16 PM",
			"commitNameOld": "bf4ffff07fb5be4a405ca13ae8baa13dee693b10",
			"commitAuthorOld": "Shawn O. Pearce",
			"daysBetweenCommits": 0.02,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,14 +1,15 @@\n \tpublic void writePack(OutputStream packStream) throws IOException {\n-\t\tif (reuseDeltas || reuseObjects)\n+\t\tif ((reuseDeltas || reuseObjects) && reuseSupport != null)\n \t\t\tsearchForReuse();\n \n-\t\tout = new PackOutputStream(packStream);\n+\t\tout = new PackOutputStream(packStream, isDeltaBaseAsOffset());\n \n \t\twriteMonitor.beginTask(WRITING_OBJECTS_PROGRESS, getObjectsNumber());\n-\t\twriteHeader();\n+\t\tout.writeFileHeader(PACK_VERSION_GENERATED, getObjectsNumber());\n \t\twriteObjects();\n \t\twriteChecksum();\n \n-\t\twindowCursor.release();\n+\t\tout = null;\n+\t\treader.release();\n \t\twriteMonitor.endTask();\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"2156aa894cefbabd322fc405138c306bb4e939cd": {
			"type": "Ybodychange",
			"commitMessage": "Reduce multi-level buffered streams in transport code\n\nSome transports actually provide stream buffering on their own,\nwithout needing to be wrapped up inside of a BufferedInputStream in\norder to smooth out system calls to read or write.  A great example\nof this is the JSch SSH client, or the Apache MINA SSHD server.\nBoth use custom buffering to packetize the streams into the encrypted\nSSH channel, and wrapping them up inside of a BufferedInputStream\nor BufferedOutputStream is relatively pointless.\n\nOur SideBandOutputStream implementation also provides some fairly\nlarge buffering, equal to one complete side-band packet on the main\ndata channel.  Wrapping that inside of a BufferedOutputStream just to\nsmooth out small writes from PackWriter causes extra data copies, and\nprovides no advantage.  We can save some memory and some CPU cycles\nby letting PackWriter dump directly into the SideBandOutputStream's\ninternal buffer array.\n\nInstead we push the buffering streams down to be as close to the\nnetwork socket (or operating system pipe) as possible.  This allows\nus to smooth out the smaller reads/writes from pkt-line messages\nduring advertisement and negotation, but avoid copying altogether\nwhen the stream switches to larger writes over a side band channel.\n\nChange-Id: I2f6f16caee64783c77d3dd1b2a41b3cc0c64c159\nSigned-off-by: Shawn O. Pearce <spearce@spearce.org>\n",
			"commitDate": "2010-03-12, 4:08 PM",
			"commitName": "2156aa894cefbabd322fc405138c306bb4e939cd",
			"commitAuthor": "Shawn O. Pearce",
			"commitDateOld": "2009-09-29, 4:47 PM",
			"commitNameOld": "1a6964c8274c50f0253db75f010d78ef0e739343",
			"commitAuthorOld": "Git Development Community",
			"daysBetweenCommits": 164.01,
			"commitsBetweenForRepo": 153,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,17 +1,14 @@\n \tpublic void writePack(OutputStream packStream) throws IOException {\n \t\tif (reuseDeltas || reuseObjects)\n \t\t\tsearchForReuse();\n \n-\t\tif (!(packStream instanceof BufferedOutputStream))\n-\t\t\tpackStream = new BufferedOutputStream(packStream);\n \t\tout = new PackOutputStream(packStream);\n \n \t\twriteMonitor.beginTask(WRITING_OBJECTS_PROGRESS, getObjectsNumber());\n \t\twriteHeader();\n \t\twriteObjects();\n \t\twriteChecksum();\n \n-\t\tout.flush();\n \t\twindowCursor.release();\n \t\twriteMonitor.endTask();\n \t}\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"1a6964c8274c50f0253db75f010d78ef0e739343": {
			"type": "Yintroduced",
			"commitMessage": "Initial JGit contribution to eclipse.org\n\nPer CQ 3448 this is the initial contribution of the JGit project\nto eclipse.org.  It is derived from the historical JGit repository\nat commit 3a2dd9921c8a08740a9e02c421469e5b1a9e47cb.\n\nSigned-off-by: Shawn O. Pearce <spearce@spearce.org>\n",
			"commitDate": "2009-09-29, 4:47 PM",
			"commitName": "1a6964c8274c50f0253db75f010d78ef0e739343",
			"commitAuthor": "Git Development Community",
			"diff": "@@ -0,0 +1,17 @@\n+\tpublic void writePack(OutputStream packStream) throws IOException {\n+\t\tif (reuseDeltas || reuseObjects)\n+\t\t\tsearchForReuse();\n+\n+\t\tif (!(packStream instanceof BufferedOutputStream))\n+\t\t\tpackStream = new BufferedOutputStream(packStream);\n+\t\tout = new PackOutputStream(packStream);\n+\n+\t\twriteMonitor.beginTask(WRITING_OBJECTS_PROGRESS, getObjectsNumber());\n+\t\twriteHeader();\n+\t\twriteObjects();\n+\t\twriteChecksum();\n+\n+\t\tout.flush();\n+\t\twindowCursor.release();\n+\t\twriteMonitor.endTask();\n+\t}\n\\ No newline at end of file\n"
		}
	},
	"sha": "bd1a82502680b5de5bf86f6c4470185fd1602386"
}