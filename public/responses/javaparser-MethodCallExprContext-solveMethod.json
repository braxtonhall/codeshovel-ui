{
	"repo": "https://github.com/javaparser/javaparser.git",
	"file": "javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/MethodCallExprContext.java",
	"method": {
		"longName": "public SymbolReference<ResolvedMethodDeclaration> solveMethod(String name, List<ResolvedType> argumentsTypes, boolean staticOnly, TypeSolver typeSolver);",
		"startLine": 153,
		"methodName": "solveMethod",
		"isStatic": false,
		"isAbstract": false,
		"visibility": "public"
	},
	"history": {
		"09232ff6b0ea19e850482f3a87ac6ef1c063c759": {
			"type": "Yfilerename",
			"commitMessage": "rename JSS modules\n",
			"commitDate": "2018-01-10, 4:52 AM",
			"commitName": "09232ff6b0ea19e850482f3a87ac6ef1c063c759",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2018-01-10, 12:01 AM",
			"commitNameOld": "30c04db173cc439556df2a238c99cd81ada320ff",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 0.2,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "",
			"extendedDetails": {
				"oldPath": "java-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/MethodCallExprContext.java",
				"newPath": "javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/MethodCallExprContext.java"
			}
		},
		"1db4cd7914d4f36224a4a8944e546650d5fc5a4d": {
			"type": "Ybodychange",
			"commitMessage": "Fix issue #300\n",
			"commitDate": "2017-12-10, 6:34 AM",
			"commitName": "1db4cd7914d4f36224a4a8944e546650d5fc5a4d",
			"commitAuthor": "Marcos CÃ©sar de Oliveira",
			"commitDateOld": "2017-09-28, 1:36 PM",
			"commitNameOld": "5d8d0cb7947efcf2282f7d056302dd905f348532",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 72.75,
			"commitsBetweenForRepo": 81,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,47 +1,10 @@\n     public SymbolReference<ResolvedMethodDeclaration> solveMethod(String name, List<ResolvedType> argumentsTypes, boolean staticOnly, TypeSolver typeSolver) {\n-        if (wrappedNode.getScope().isPresent()) {\n-            Expression scope = wrappedNode.getScope().get();\n-\n-            // consider static methods\n-            if (scope instanceof NameExpr) {\n-                NameExpr scopeAsName = (NameExpr) scope;\n-                SymbolReference<ResolvedTypeDeclaration> symbolReference = this.solveType(scopeAsName.getName().getId(), typeSolver);\n-                if (symbolReference.isSolved() && symbolReference.getCorrespondingDeclaration().isType()) {\n-                    ResolvedTypeDeclaration typeDeclaration = symbolReference.getCorrespondingDeclaration().asType();\n-                    return MethodResolutionLogic.solveMethodInType(typeDeclaration, name, argumentsTypes, false, typeSolver);\n-                }\n+        Collection<ResolvedReferenceTypeDeclaration> rrtds = findTypeDeclarations(wrappedNode.getScope(), typeSolver);\n+        for (ResolvedReferenceTypeDeclaration rrtd : rrtds) {\n+            SymbolReference<ResolvedMethodDeclaration> res = MethodResolutionLogic.solveMethodInType(rrtd, name, argumentsTypes, false, typeSolver);\n+            if (res.isSolved()) {\n+                return res;\n             }\n-\n-            ResolvedType typeOfScope = null;\n-            try {\n-                typeOfScope = JavaParserFacade.get(typeSolver).getType(scope);\n-            } catch (Exception e) {\n-                throw new RuntimeException(String.format(\"Issue calculating the type of the scope of \" + this), e);\n-            }\n-            if (typeOfScope.isWildcard()) {\n-                if (typeOfScope.asWildcard().isExtends() || typeOfScope.asWildcard().isSuper()) {\n-                    return MethodResolutionLogic.solveMethodInType(typeOfScope.asWildcard().getBoundedType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, false, typeSolver);\n-                } else {\n-                    return MethodResolutionLogic.solveMethodInType(new ReflectionClassDeclaration(Object.class, typeSolver), name, argumentsTypes, false, typeSolver);\n-                }\n-            } else if (typeOfScope.isArray()) {\n-                // method call on array are Object methods\n-                return MethodResolutionLogic.solveMethodInType(new ReflectionClassDeclaration(Object.class, typeSolver), name, argumentsTypes, false, typeSolver);\n-            } else if (typeOfScope.isTypeVariable()) {\n-                for (ResolvedTypeParameterDeclaration.Bound bound : typeOfScope.asTypeParameter().getBounds()) {\n-                    SymbolReference<ResolvedMethodDeclaration> res = MethodResolutionLogic.solveMethodInType(bound.getType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, false, typeSolver);\n-                    if (res.isSolved()) {\n-                        return res;\n-                    }\n-                }\n-                return SymbolReference.unsolved(ResolvedMethodDeclaration.class);\n-            } else if (typeOfScope.isConstraint()){\n-                return MethodResolutionLogic.solveMethodInType(typeOfScope.asConstraintType().getBound().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n-            } else {\n-                return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, argumentsTypes, false, typeSolver);\n-            }\n-        } else {\n-            ResolvedType typeOfScope = JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n-            return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, argumentsTypes, false, typeSolver);\n         }\n+        return SymbolReference.unsolved(ResolvedMethodDeclaration.class);\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"5d8d0cb7947efcf2282f7d056302dd905f348532": {
			"type": "Ymultichange(Yparameterchange,Yreturntypechange,Ybodychange)",
			"commitMessage": "more work on converting to moved classes\n",
			"commitDate": "2017-09-28, 1:36 PM",
			"commitName": "5d8d0cb7947efcf2282f7d056302dd905f348532",
			"commitAuthor": "Federico Tomassetti",
			"subchanges": [
				{
					"type": "Yparameterchange",
					"commitMessage": "more work on converting to moved classes\n",
					"commitDate": "2017-09-28, 1:36 PM",
					"commitName": "5d8d0cb7947efcf2282f7d056302dd905f348532",
					"commitAuthor": "Federico Tomassetti",
					"commitDateOld": "2017-08-28, 2:15 AM",
					"commitNameOld": "abec22a71cd36e52d79a4575c21294ffd48c7016",
					"commitAuthorOld": "mlangkabel",
					"daysBetweenCommits": 31.47,
					"commitsBetweenForRepo": 14,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,47 +1,47 @@\n-    public SymbolReference<MethodDeclaration> solveMethod(String name, List<Type> argumentsTypes, boolean staticOnly, TypeSolver typeSolver) {\n+    public SymbolReference<ResolvedMethodDeclaration> solveMethod(String name, List<ResolvedType> argumentsTypes, boolean staticOnly, TypeSolver typeSolver) {\n         if (wrappedNode.getScope().isPresent()) {\n             Expression scope = wrappedNode.getScope().get();\n \n             // consider static methods\n             if (scope instanceof NameExpr) {\n                 NameExpr scopeAsName = (NameExpr) scope;\n-                SymbolReference<TypeDeclaration> symbolReference = this.solveType(scopeAsName.getName().getId(), typeSolver);\n+                SymbolReference<ResolvedTypeDeclaration> symbolReference = this.solveType(scopeAsName.getName().getId(), typeSolver);\n                 if (symbolReference.isSolved() && symbolReference.getCorrespondingDeclaration().isType()) {\n-                    TypeDeclaration typeDeclaration = symbolReference.getCorrespondingDeclaration().asType();\n+                    ResolvedTypeDeclaration typeDeclaration = symbolReference.getCorrespondingDeclaration().asType();\n                     return MethodResolutionLogic.solveMethodInType(typeDeclaration, name, argumentsTypes, false, typeSolver);\n                 }\n             }\n \n-            Type typeOfScope = null;\n+            ResolvedType typeOfScope = null;\n             try {\n                 typeOfScope = JavaParserFacade.get(typeSolver).getType(scope);\n             } catch (Exception e) {\n                 throw new RuntimeException(String.format(\"Issue calculating the type of the scope of \" + this), e);\n             }\n             if (typeOfScope.isWildcard()) {\n                 if (typeOfScope.asWildcard().isExtends() || typeOfScope.asWildcard().isSuper()) {\n                     return MethodResolutionLogic.solveMethodInType(typeOfScope.asWildcard().getBoundedType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, false, typeSolver);\n                 } else {\n                     return MethodResolutionLogic.solveMethodInType(new ReflectionClassDeclaration(Object.class, typeSolver), name, argumentsTypes, false, typeSolver);\n                 }\n             } else if (typeOfScope.isArray()) {\n                 // method call on array are Object methods\n                 return MethodResolutionLogic.solveMethodInType(new ReflectionClassDeclaration(Object.class, typeSolver), name, argumentsTypes, false, typeSolver);\n             } else if (typeOfScope.isTypeVariable()) {\n-                for (TypeParameterDeclaration.Bound bound : typeOfScope.asTypeParameter().getBounds(typeSolver)) {\n-                    SymbolReference<MethodDeclaration> res = MethodResolutionLogic.solveMethodInType(bound.getType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, false, typeSolver);\n+                for (ResolvedTypeParameterDeclaration.Bound bound : typeOfScope.asTypeParameter().getBounds()) {\n+                    SymbolReference<ResolvedMethodDeclaration> res = MethodResolutionLogic.solveMethodInType(bound.getType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, false, typeSolver);\n                     if (res.isSolved()) {\n                         return res;\n                     }\n                 }\n-                return SymbolReference.unsolved(MethodDeclaration.class);\n+                return SymbolReference.unsolved(ResolvedMethodDeclaration.class);\n             } else if (typeOfScope.isConstraint()){\n                 return MethodResolutionLogic.solveMethodInType(typeOfScope.asConstraintType().getBound().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n             } else {\n                 return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, argumentsTypes, false, typeSolver);\n             }\n         } else {\n-            Type typeOfScope = JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n+            ResolvedType typeOfScope = JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n             return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, argumentsTypes, false, typeSolver);\n         }\n     }\n\\ No newline at end of file\n",
					"extendedDetails": {
						"oldValue": "[name-String, argumentsTypes-List<Type>, staticOnly-boolean, typeSolver-TypeSolver]",
						"newValue": "[name-String, argumentsTypes-List<ResolvedType>, staticOnly-boolean, typeSolver-TypeSolver]"
					}
				},
				{
					"type": "Yreturntypechange",
					"commitMessage": "more work on converting to moved classes\n",
					"commitDate": "2017-09-28, 1:36 PM",
					"commitName": "5d8d0cb7947efcf2282f7d056302dd905f348532",
					"commitAuthor": "Federico Tomassetti",
					"commitDateOld": "2017-08-28, 2:15 AM",
					"commitNameOld": "abec22a71cd36e52d79a4575c21294ffd48c7016",
					"commitAuthorOld": "mlangkabel",
					"daysBetweenCommits": 31.47,
					"commitsBetweenForRepo": 14,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,47 +1,47 @@\n-    public SymbolReference<MethodDeclaration> solveMethod(String name, List<Type> argumentsTypes, boolean staticOnly, TypeSolver typeSolver) {\n+    public SymbolReference<ResolvedMethodDeclaration> solveMethod(String name, List<ResolvedType> argumentsTypes, boolean staticOnly, TypeSolver typeSolver) {\n         if (wrappedNode.getScope().isPresent()) {\n             Expression scope = wrappedNode.getScope().get();\n \n             // consider static methods\n             if (scope instanceof NameExpr) {\n                 NameExpr scopeAsName = (NameExpr) scope;\n-                SymbolReference<TypeDeclaration> symbolReference = this.solveType(scopeAsName.getName().getId(), typeSolver);\n+                SymbolReference<ResolvedTypeDeclaration> symbolReference = this.solveType(scopeAsName.getName().getId(), typeSolver);\n                 if (symbolReference.isSolved() && symbolReference.getCorrespondingDeclaration().isType()) {\n-                    TypeDeclaration typeDeclaration = symbolReference.getCorrespondingDeclaration().asType();\n+                    ResolvedTypeDeclaration typeDeclaration = symbolReference.getCorrespondingDeclaration().asType();\n                     return MethodResolutionLogic.solveMethodInType(typeDeclaration, name, argumentsTypes, false, typeSolver);\n                 }\n             }\n \n-            Type typeOfScope = null;\n+            ResolvedType typeOfScope = null;\n             try {\n                 typeOfScope = JavaParserFacade.get(typeSolver).getType(scope);\n             } catch (Exception e) {\n                 throw new RuntimeException(String.format(\"Issue calculating the type of the scope of \" + this), e);\n             }\n             if (typeOfScope.isWildcard()) {\n                 if (typeOfScope.asWildcard().isExtends() || typeOfScope.asWildcard().isSuper()) {\n                     return MethodResolutionLogic.solveMethodInType(typeOfScope.asWildcard().getBoundedType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, false, typeSolver);\n                 } else {\n                     return MethodResolutionLogic.solveMethodInType(new ReflectionClassDeclaration(Object.class, typeSolver), name, argumentsTypes, false, typeSolver);\n                 }\n             } else if (typeOfScope.isArray()) {\n                 // method call on array are Object methods\n                 return MethodResolutionLogic.solveMethodInType(new ReflectionClassDeclaration(Object.class, typeSolver), name, argumentsTypes, false, typeSolver);\n             } else if (typeOfScope.isTypeVariable()) {\n-                for (TypeParameterDeclaration.Bound bound : typeOfScope.asTypeParameter().getBounds(typeSolver)) {\n-                    SymbolReference<MethodDeclaration> res = MethodResolutionLogic.solveMethodInType(bound.getType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, false, typeSolver);\n+                for (ResolvedTypeParameterDeclaration.Bound bound : typeOfScope.asTypeParameter().getBounds()) {\n+                    SymbolReference<ResolvedMethodDeclaration> res = MethodResolutionLogic.solveMethodInType(bound.getType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, false, typeSolver);\n                     if (res.isSolved()) {\n                         return res;\n                     }\n                 }\n-                return SymbolReference.unsolved(MethodDeclaration.class);\n+                return SymbolReference.unsolved(ResolvedMethodDeclaration.class);\n             } else if (typeOfScope.isConstraint()){\n                 return MethodResolutionLogic.solveMethodInType(typeOfScope.asConstraintType().getBound().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n             } else {\n                 return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, argumentsTypes, false, typeSolver);\n             }\n         } else {\n-            Type typeOfScope = JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n+            ResolvedType typeOfScope = JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n             return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, argumentsTypes, false, typeSolver);\n         }\n     }\n\\ No newline at end of file\n",
					"extendedDetails": {
						"oldValue": "SymbolReference<MethodDeclaration>",
						"newValue": "SymbolReference<ResolvedMethodDeclaration>"
					}
				},
				{
					"type": "Ybodychange",
					"commitMessage": "more work on converting to moved classes\n",
					"commitDate": "2017-09-28, 1:36 PM",
					"commitName": "5d8d0cb7947efcf2282f7d056302dd905f348532",
					"commitAuthor": "Federico Tomassetti",
					"commitDateOld": "2017-08-28, 2:15 AM",
					"commitNameOld": "abec22a71cd36e52d79a4575c21294ffd48c7016",
					"commitAuthorOld": "mlangkabel",
					"daysBetweenCommits": 31.47,
					"commitsBetweenForRepo": 14,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,47 +1,47 @@\n-    public SymbolReference<MethodDeclaration> solveMethod(String name, List<Type> argumentsTypes, boolean staticOnly, TypeSolver typeSolver) {\n+    public SymbolReference<ResolvedMethodDeclaration> solveMethod(String name, List<ResolvedType> argumentsTypes, boolean staticOnly, TypeSolver typeSolver) {\n         if (wrappedNode.getScope().isPresent()) {\n             Expression scope = wrappedNode.getScope().get();\n \n             // consider static methods\n             if (scope instanceof NameExpr) {\n                 NameExpr scopeAsName = (NameExpr) scope;\n-                SymbolReference<TypeDeclaration> symbolReference = this.solveType(scopeAsName.getName().getId(), typeSolver);\n+                SymbolReference<ResolvedTypeDeclaration> symbolReference = this.solveType(scopeAsName.getName().getId(), typeSolver);\n                 if (symbolReference.isSolved() && symbolReference.getCorrespondingDeclaration().isType()) {\n-                    TypeDeclaration typeDeclaration = symbolReference.getCorrespondingDeclaration().asType();\n+                    ResolvedTypeDeclaration typeDeclaration = symbolReference.getCorrespondingDeclaration().asType();\n                     return MethodResolutionLogic.solveMethodInType(typeDeclaration, name, argumentsTypes, false, typeSolver);\n                 }\n             }\n \n-            Type typeOfScope = null;\n+            ResolvedType typeOfScope = null;\n             try {\n                 typeOfScope = JavaParserFacade.get(typeSolver).getType(scope);\n             } catch (Exception e) {\n                 throw new RuntimeException(String.format(\"Issue calculating the type of the scope of \" + this), e);\n             }\n             if (typeOfScope.isWildcard()) {\n                 if (typeOfScope.asWildcard().isExtends() || typeOfScope.asWildcard().isSuper()) {\n                     return MethodResolutionLogic.solveMethodInType(typeOfScope.asWildcard().getBoundedType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, false, typeSolver);\n                 } else {\n                     return MethodResolutionLogic.solveMethodInType(new ReflectionClassDeclaration(Object.class, typeSolver), name, argumentsTypes, false, typeSolver);\n                 }\n             } else if (typeOfScope.isArray()) {\n                 // method call on array are Object methods\n                 return MethodResolutionLogic.solveMethodInType(new ReflectionClassDeclaration(Object.class, typeSolver), name, argumentsTypes, false, typeSolver);\n             } else if (typeOfScope.isTypeVariable()) {\n-                for (TypeParameterDeclaration.Bound bound : typeOfScope.asTypeParameter().getBounds(typeSolver)) {\n-                    SymbolReference<MethodDeclaration> res = MethodResolutionLogic.solveMethodInType(bound.getType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, false, typeSolver);\n+                for (ResolvedTypeParameterDeclaration.Bound bound : typeOfScope.asTypeParameter().getBounds()) {\n+                    SymbolReference<ResolvedMethodDeclaration> res = MethodResolutionLogic.solveMethodInType(bound.getType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, false, typeSolver);\n                     if (res.isSolved()) {\n                         return res;\n                     }\n                 }\n-                return SymbolReference.unsolved(MethodDeclaration.class);\n+                return SymbolReference.unsolved(ResolvedMethodDeclaration.class);\n             } else if (typeOfScope.isConstraint()){\n                 return MethodResolutionLogic.solveMethodInType(typeOfScope.asConstraintType().getBound().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n             } else {\n                 return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, argumentsTypes, false, typeSolver);\n             }\n         } else {\n-            Type typeOfScope = JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n+            ResolvedType typeOfScope = JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n             return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, argumentsTypes, false, typeSolver);\n         }\n     }\n\\ No newline at end of file\n",
					"extendedDetails": {}
				}
			]
		},
		"acdac6790f4424f8097b3aa6c888e825cac485f9": {
			"type": "Ybodychange",
			"commitMessage": "Fixes for type inference\n",
			"commitDate": "2017-03-09, 5:22 PM",
			"commitName": "acdac6790f4424f8097b3aa6c888e825cac485f9",
			"commitAuthor": "xdrop",
			"commitDateOld": "2017-03-08, 7:31 PM",
			"commitNameOld": "17ac5ada0476c72aa79a2e0c39311e90bfa0fe60",
			"commitAuthorOld": "xdrop",
			"daysBetweenCommits": 0.91,
			"commitsBetweenForRepo": 3,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,45 +1,47 @@\n     public SymbolReference<MethodDeclaration> solveMethod(String name, List<Type> argumentsTypes, boolean staticOnly, TypeSolver typeSolver) {\n         if (wrappedNode.getScope().isPresent()) {\n             Expression scope = wrappedNode.getScope().get();\n \n             // consider static methods\n             if (scope instanceof NameExpr) {\n                 NameExpr scopeAsName = (NameExpr) scope;\n                 SymbolReference<TypeDeclaration> symbolReference = this.solveType(scopeAsName.getName().getId(), typeSolver);\n                 if (symbolReference.isSolved() && symbolReference.getCorrespondingDeclaration().isType()) {\n                     TypeDeclaration typeDeclaration = symbolReference.getCorrespondingDeclaration().asType();\n-                    return MethodResolutionLogic.solveMethodInType(typeDeclaration, name, argumentsTypes, typeSolver, false);\n+                    return MethodResolutionLogic.solveMethodInType(typeDeclaration, name, argumentsTypes, false, typeSolver);\n                 }\n             }\n \n             Type typeOfScope = null;\n             try {\n                 typeOfScope = JavaParserFacade.get(typeSolver).getType(scope);\n             } catch (Exception e) {\n                 throw new RuntimeException(String.format(\"Issue calculating the type of the scope of \" + this), e);\n             }\n             if (typeOfScope.isWildcard()) {\n                 if (typeOfScope.asWildcard().isExtends() || typeOfScope.asWildcard().isSuper()) {\n-                    return MethodResolutionLogic.solveMethodInType(typeOfScope.asWildcard().getBoundedType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver, false);\n+                    return MethodResolutionLogic.solveMethodInType(typeOfScope.asWildcard().getBoundedType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, false, typeSolver);\n                 } else {\n-                    return MethodResolutionLogic.solveMethodInType(new ReflectionClassDeclaration(Object.class, typeSolver), name, argumentsTypes, typeSolver, false);\n+                    return MethodResolutionLogic.solveMethodInType(new ReflectionClassDeclaration(Object.class, typeSolver), name, argumentsTypes, false, typeSolver);\n                 }\n             } else if (typeOfScope.isArray()) {\n                 // method call on array are Object methods\n-                return MethodResolutionLogic.solveMethodInType(new ReflectionClassDeclaration(Object.class, typeSolver), name, argumentsTypes, typeSolver, false);\n+                return MethodResolutionLogic.solveMethodInType(new ReflectionClassDeclaration(Object.class, typeSolver), name, argumentsTypes, false, typeSolver);\n             } else if (typeOfScope.isTypeVariable()) {\n                 for (TypeParameterDeclaration.Bound bound : typeOfScope.asTypeParameter().getBounds(typeSolver)) {\n-                    SymbolReference<MethodDeclaration> res = MethodResolutionLogic.solveMethodInType(bound.getType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver, false);\n+                    SymbolReference<MethodDeclaration> res = MethodResolutionLogic.solveMethodInType(bound.getType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, false, typeSolver);\n                     if (res.isSolved()) {\n                         return res;\n                     }\n                 }\n                 return SymbolReference.unsolved(MethodDeclaration.class);\n+            } else if (typeOfScope.isConstraint()){\n+                return MethodResolutionLogic.solveMethodInType(typeOfScope.asConstraintType().getBound().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n             } else {\n-                return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver, false);\n+                return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, argumentsTypes, false, typeSolver);\n             }\n         } else {\n             Type typeOfScope = JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n-            return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver, false);\n+            return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, argumentsTypes, false, typeSolver);\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"17ac5ada0476c72aa79a2e0c39311e90bfa0fe60": {
			"type": "Ymultichange(Yparameterchange,Ybodychange)",
			"commitMessage": "Fix issues with inherited methods in interfaces not being resolved\n",
			"commitDate": "2017-03-08, 7:31 PM",
			"commitName": "17ac5ada0476c72aa79a2e0c39311e90bfa0fe60",
			"commitAuthor": "xdrop",
			"subchanges": [
				{
					"type": "Yparameterchange",
					"commitMessage": "Fix issues with inherited methods in interfaces not being resolved\n",
					"commitDate": "2017-03-08, 7:31 PM",
					"commitName": "17ac5ada0476c72aa79a2e0c39311e90bfa0fe60",
					"commitAuthor": "xdrop",
					"commitDateOld": "2017-03-08, 1:40 PM",
					"commitNameOld": "e5fe2b597be66d230f8824277c1d4167fa2bb609",
					"commitAuthorOld": "Federico Tomassetti",
					"daysBetweenCommits": 0.24,
					"commitsBetweenForRepo": 1,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,45 +1,45 @@\n-    public SymbolReference<MethodDeclaration> solveMethod(String name, List<Type> argumentsTypes, TypeSolver typeSolver) {\n+    public SymbolReference<MethodDeclaration> solveMethod(String name, List<Type> argumentsTypes, boolean staticOnly, TypeSolver typeSolver) {\n         if (wrappedNode.getScope().isPresent()) {\n             Expression scope = wrappedNode.getScope().get();\n \n             // consider static methods\n             if (scope instanceof NameExpr) {\n                 NameExpr scopeAsName = (NameExpr) scope;\n                 SymbolReference<TypeDeclaration> symbolReference = this.solveType(scopeAsName.getName().getId(), typeSolver);\n                 if (symbolReference.isSolved() && symbolReference.getCorrespondingDeclaration().isType()) {\n                     TypeDeclaration typeDeclaration = symbolReference.getCorrespondingDeclaration().asType();\n-                    return MethodResolutionLogic.solveMethodInType(typeDeclaration, name, argumentsTypes, typeSolver);\n+                    return MethodResolutionLogic.solveMethodInType(typeDeclaration, name, argumentsTypes, typeSolver, false);\n                 }\n             }\n \n             Type typeOfScope = null;\n             try {\n                 typeOfScope = JavaParserFacade.get(typeSolver).getType(scope);\n             } catch (Exception e) {\n                 throw new RuntimeException(String.format(\"Issue calculating the type of the scope of \" + this), e);\n             }\n             if (typeOfScope.isWildcard()) {\n                 if (typeOfScope.asWildcard().isExtends() || typeOfScope.asWildcard().isSuper()) {\n-                    return MethodResolutionLogic.solveMethodInType(typeOfScope.asWildcard().getBoundedType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n+                    return MethodResolutionLogic.solveMethodInType(typeOfScope.asWildcard().getBoundedType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver, false);\n                 } else {\n-                    return MethodResolutionLogic.solveMethodInType(new ReflectionClassDeclaration(Object.class, typeSolver), name, argumentsTypes, typeSolver);\n+                    return MethodResolutionLogic.solveMethodInType(new ReflectionClassDeclaration(Object.class, typeSolver), name, argumentsTypes, typeSolver, false);\n                 }\n             } else if (typeOfScope.isArray()) {\n                 // method call on array are Object methods\n-                return MethodResolutionLogic.solveMethodInType(new ReflectionClassDeclaration(Object.class, typeSolver), name, argumentsTypes, typeSolver);\n+                return MethodResolutionLogic.solveMethodInType(new ReflectionClassDeclaration(Object.class, typeSolver), name, argumentsTypes, typeSolver, false);\n             } else if (typeOfScope.isTypeVariable()) {\n                 for (TypeParameterDeclaration.Bound bound : typeOfScope.asTypeParameter().getBounds(typeSolver)) {\n-                    SymbolReference<MethodDeclaration> res = MethodResolutionLogic.solveMethodInType(bound.getType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n+                    SymbolReference<MethodDeclaration> res = MethodResolutionLogic.solveMethodInType(bound.getType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver, false);\n                     if (res.isSolved()) {\n                         return res;\n                     }\n                 }\n                 return SymbolReference.unsolved(MethodDeclaration.class);\n             } else {\n-                return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n+                return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver, false);\n             }\n         } else {\n             Type typeOfScope = JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n-            return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n+            return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver, false);\n         }\n     }\n\\ No newline at end of file\n",
					"extendedDetails": {
						"oldValue": "[name-String, argumentsTypes-List<Type>, typeSolver-TypeSolver]",
						"newValue": "[name-String, argumentsTypes-List<Type>, staticOnly-boolean, typeSolver-TypeSolver]"
					}
				},
				{
					"type": "Ybodychange",
					"commitMessage": "Fix issues with inherited methods in interfaces not being resolved\n",
					"commitDate": "2017-03-08, 7:31 PM",
					"commitName": "17ac5ada0476c72aa79a2e0c39311e90bfa0fe60",
					"commitAuthor": "xdrop",
					"commitDateOld": "2017-03-08, 1:40 PM",
					"commitNameOld": "e5fe2b597be66d230f8824277c1d4167fa2bb609",
					"commitAuthorOld": "Federico Tomassetti",
					"daysBetweenCommits": 0.24,
					"commitsBetweenForRepo": 1,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,45 +1,45 @@\n-    public SymbolReference<MethodDeclaration> solveMethod(String name, List<Type> argumentsTypes, TypeSolver typeSolver) {\n+    public SymbolReference<MethodDeclaration> solveMethod(String name, List<Type> argumentsTypes, boolean staticOnly, TypeSolver typeSolver) {\n         if (wrappedNode.getScope().isPresent()) {\n             Expression scope = wrappedNode.getScope().get();\n \n             // consider static methods\n             if (scope instanceof NameExpr) {\n                 NameExpr scopeAsName = (NameExpr) scope;\n                 SymbolReference<TypeDeclaration> symbolReference = this.solveType(scopeAsName.getName().getId(), typeSolver);\n                 if (symbolReference.isSolved() && symbolReference.getCorrespondingDeclaration().isType()) {\n                     TypeDeclaration typeDeclaration = symbolReference.getCorrespondingDeclaration().asType();\n-                    return MethodResolutionLogic.solveMethodInType(typeDeclaration, name, argumentsTypes, typeSolver);\n+                    return MethodResolutionLogic.solveMethodInType(typeDeclaration, name, argumentsTypes, typeSolver, false);\n                 }\n             }\n \n             Type typeOfScope = null;\n             try {\n                 typeOfScope = JavaParserFacade.get(typeSolver).getType(scope);\n             } catch (Exception e) {\n                 throw new RuntimeException(String.format(\"Issue calculating the type of the scope of \" + this), e);\n             }\n             if (typeOfScope.isWildcard()) {\n                 if (typeOfScope.asWildcard().isExtends() || typeOfScope.asWildcard().isSuper()) {\n-                    return MethodResolutionLogic.solveMethodInType(typeOfScope.asWildcard().getBoundedType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n+                    return MethodResolutionLogic.solveMethodInType(typeOfScope.asWildcard().getBoundedType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver, false);\n                 } else {\n-                    return MethodResolutionLogic.solveMethodInType(new ReflectionClassDeclaration(Object.class, typeSolver), name, argumentsTypes, typeSolver);\n+                    return MethodResolutionLogic.solveMethodInType(new ReflectionClassDeclaration(Object.class, typeSolver), name, argumentsTypes, typeSolver, false);\n                 }\n             } else if (typeOfScope.isArray()) {\n                 // method call on array are Object methods\n-                return MethodResolutionLogic.solveMethodInType(new ReflectionClassDeclaration(Object.class, typeSolver), name, argumentsTypes, typeSolver);\n+                return MethodResolutionLogic.solveMethodInType(new ReflectionClassDeclaration(Object.class, typeSolver), name, argumentsTypes, typeSolver, false);\n             } else if (typeOfScope.isTypeVariable()) {\n                 for (TypeParameterDeclaration.Bound bound : typeOfScope.asTypeParameter().getBounds(typeSolver)) {\n-                    SymbolReference<MethodDeclaration> res = MethodResolutionLogic.solveMethodInType(bound.getType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n+                    SymbolReference<MethodDeclaration> res = MethodResolutionLogic.solveMethodInType(bound.getType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver, false);\n                     if (res.isSolved()) {\n                         return res;\n                     }\n                 }\n                 return SymbolReference.unsolved(MethodDeclaration.class);\n             } else {\n-                return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n+                return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver, false);\n             }\n         } else {\n             Type typeOfScope = JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n-            return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n+            return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver, false);\n         }\n     }\n\\ No newline at end of file\n",
					"extendedDetails": {}
				}
			]
		},
		"e5fe2b597be66d230f8824277c1d4167fa2bb609": {
			"type": "Ybodychange",
			"commitMessage": "typo\n",
			"commitDate": "2017-03-08, 1:40 PM",
			"commitName": "e5fe2b597be66d230f8824277c1d4167fa2bb609",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2017-01-11, 4:45 PM",
			"commitNameOld": "065875981b4d1ffa4bf3535d7c89319a4a3345f1",
			"commitAuthorOld": "xdrop",
			"daysBetweenCommits": 55.87,
			"commitsBetweenForRepo": 52,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,45 +1,45 @@\n     public SymbolReference<MethodDeclaration> solveMethod(String name, List<Type> argumentsTypes, TypeSolver typeSolver) {\n         if (wrappedNode.getScope().isPresent()) {\n             Expression scope = wrappedNode.getScope().get();\n \n             // consider static methods\n             if (scope instanceof NameExpr) {\n                 NameExpr scopeAsName = (NameExpr) scope;\n                 SymbolReference<TypeDeclaration> symbolReference = this.solveType(scopeAsName.getName().getId(), typeSolver);\n                 if (symbolReference.isSolved() && symbolReference.getCorrespondingDeclaration().isType()) {\n                     TypeDeclaration typeDeclaration = symbolReference.getCorrespondingDeclaration().asType();\n                     return MethodResolutionLogic.solveMethodInType(typeDeclaration, name, argumentsTypes, typeSolver);\n                 }\n             }\n \n             Type typeOfScope = null;\n             try {\n                 typeOfScope = JavaParserFacade.get(typeSolver).getType(scope);\n             } catch (Exception e) {\n-                throw new RuntimeException(String.format(\"Issur calculating the type of the scope of \" + this), e);\n+                throw new RuntimeException(String.format(\"Issue calculating the type of the scope of \" + this), e);\n             }\n             if (typeOfScope.isWildcard()) {\n                 if (typeOfScope.asWildcard().isExtends() || typeOfScope.asWildcard().isSuper()) {\n                     return MethodResolutionLogic.solveMethodInType(typeOfScope.asWildcard().getBoundedType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n                 } else {\n                     return MethodResolutionLogic.solveMethodInType(new ReflectionClassDeclaration(Object.class, typeSolver), name, argumentsTypes, typeSolver);\n                 }\n             } else if (typeOfScope.isArray()) {\n                 // method call on array are Object methods\n                 return MethodResolutionLogic.solveMethodInType(new ReflectionClassDeclaration(Object.class, typeSolver), name, argumentsTypes, typeSolver);\n             } else if (typeOfScope.isTypeVariable()) {\n                 for (TypeParameterDeclaration.Bound bound : typeOfScope.asTypeParameter().getBounds(typeSolver)) {\n                     SymbolReference<MethodDeclaration> res = MethodResolutionLogic.solveMethodInType(bound.getType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n                     if (res.isSolved()) {\n                         return res;\n                     }\n                 }\n                 return SymbolReference.unsolved(MethodDeclaration.class);\n             } else {\n                 return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n             }\n         } else {\n             Type typeOfScope = JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n             return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"065875981b4d1ffa4bf3535d7c89319a4a3345f1": {
			"type": "Ybodychange",
			"commitMessage": "Update for JavaParser 3.0.0\n",
			"commitDate": "2017-01-11, 4:45 PM",
			"commitName": "065875981b4d1ffa4bf3535d7c89319a4a3345f1",
			"commitAuthor": "xdrop",
			"commitDateOld": "2017-01-06, 1:11 AM",
			"commitNameOld": "860a4c0c034e1b8232e3d1ec17e7f11879850470",
			"commitAuthorOld": "",
			"daysBetweenCommits": 5.65,
			"commitsBetweenForRepo": 4,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,44 +1,45 @@\n     public SymbolReference<MethodDeclaration> solveMethod(String name, List<Type> argumentsTypes, TypeSolver typeSolver) {\n-        if (wrappedNode.getScope() != null) {\n+        if (wrappedNode.getScope().isPresent()) {\n+            Expression scope = wrappedNode.getScope().get();\n \n             // consider static methods\n-            if (wrappedNode.getScope() instanceof NameExpr) {\n-                NameExpr scopeAsName = (NameExpr) wrappedNode.getScope();\n+            if (scope instanceof NameExpr) {\n+                NameExpr scopeAsName = (NameExpr) scope;\n                 SymbolReference<TypeDeclaration> symbolReference = this.solveType(scopeAsName.getName().getId(), typeSolver);\n                 if (symbolReference.isSolved() && symbolReference.getCorrespondingDeclaration().isType()) {\n                     TypeDeclaration typeDeclaration = symbolReference.getCorrespondingDeclaration().asType();\n                     return MethodResolutionLogic.solveMethodInType(typeDeclaration, name, argumentsTypes, typeSolver);\n                 }\n             }\n \n             Type typeOfScope = null;\n             try {\n-                typeOfScope = JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n+                typeOfScope = JavaParserFacade.get(typeSolver).getType(scope);\n             } catch (Exception e) {\n                 throw new RuntimeException(String.format(\"Issur calculating the type of the scope of \" + this), e);\n             }\n             if (typeOfScope.isWildcard()) {\n                 if (typeOfScope.asWildcard().isExtends() || typeOfScope.asWildcard().isSuper()) {\n                     return MethodResolutionLogic.solveMethodInType(typeOfScope.asWildcard().getBoundedType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n                 } else {\n                     return MethodResolutionLogic.solveMethodInType(new ReflectionClassDeclaration(Object.class, typeSolver), name, argumentsTypes, typeSolver);\n                 }\n             } else if (typeOfScope.isArray()) {\n                 // method call on array are Object methods\n                 return MethodResolutionLogic.solveMethodInType(new ReflectionClassDeclaration(Object.class, typeSolver), name, argumentsTypes, typeSolver);\n             } else if (typeOfScope.isTypeVariable()) {\n                 for (TypeParameterDeclaration.Bound bound : typeOfScope.asTypeParameter().getBounds(typeSolver)) {\n                     SymbolReference<MethodDeclaration> res = MethodResolutionLogic.solveMethodInType(bound.getType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n                     if (res.isSolved()) {\n                         return res;\n                     }\n                 }\n                 return SymbolReference.unsolved(MethodDeclaration.class);\n             } else {\n                 return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n             }\n         } else {\n             Type typeOfScope = JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n             return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"e47162df70ac5344d1a7b8c08220474224e64536": {
			"type": "Ybodychange",
			"commitMessage": "minor\n",
			"commitDate": "2016-12-13, 8:55 AM",
			"commitName": "e47162df70ac5344d1a7b8c08220474224e64536",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2016-12-13, 8:45 AM",
			"commitNameOld": "cb5ffb7fdd56f1b768d25da330fa3b29ecb74eaf",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 0.01,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,45 +1,44 @@\n     public SymbolReference<MethodDeclaration> solveMethod(String name, List<Type> argumentsTypes, TypeSolver typeSolver) {\n         if (wrappedNode.getScope() != null) {\n \n             // consider static methods\n             if (wrappedNode.getScope() instanceof NameExpr) {\n                 NameExpr scopeAsName = (NameExpr) wrappedNode.getScope();\n                 SymbolReference<TypeDeclaration> symbolReference = this.solveType(scopeAsName.getName().getId(), typeSolver);\n                 if (symbolReference.isSolved() && symbolReference.getCorrespondingDeclaration().isType()) {\n                     TypeDeclaration typeDeclaration = symbolReference.getCorrespondingDeclaration().asType();\n                     return MethodResolutionLogic.solveMethodInType(typeDeclaration, name, argumentsTypes, typeSolver);\n                 }\n             }\n \n             Type typeOfScope = null;\n             try {\n                 typeOfScope = JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n             } catch (Exception e) {\n                 throw new RuntimeException(String.format(\"Issur calculating the type of the scope of \" + this), e);\n             }\n             if (typeOfScope.isWildcard()) {\n                 if (typeOfScope.asWildcard().isExtends() || typeOfScope.asWildcard().isSuper()) {\n                     return MethodResolutionLogic.solveMethodInType(typeOfScope.asWildcard().getBoundedType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n                 } else {\n                     return MethodResolutionLogic.solveMethodInType(new ReflectionClassDeclaration(Object.class, typeSolver), name, argumentsTypes, typeSolver);\n                 }\n-            } else if (typeOfScope.isArray() /*&& typeOfScope.asArrayType().getComponentType().isReferenceType()*/) {\n+            } else if (typeOfScope.isArray()) {\n                 // method call on array are Object methods\n                 return MethodResolutionLogic.solveMethodInType(new ReflectionClassDeclaration(Object.class, typeSolver), name, argumentsTypes, typeSolver);\n-//                return MethodResolutionLogic.solveMethodInType(typeOfScope.asArrayType().getComponentType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n             } else if (typeOfScope.isTypeVariable()) {\n                 for (TypeParameterDeclaration.Bound bound : typeOfScope.asTypeParameter().getBounds(typeSolver)) {\n                     SymbolReference<MethodDeclaration> res = MethodResolutionLogic.solveMethodInType(bound.getType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n                     if (res.isSolved()) {\n                         return res;\n                     }\n                 }\n                 return SymbolReference.unsolved(MethodDeclaration.class);\n             } else {\n                 return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n             }\n         } else {\n             Type typeOfScope = JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n             return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"c990d23490f5c4ac4322119b03d5951b63eef055": {
			"type": "Ybodychange",
			"commitMessage": "loads of changes to support our code",
			"commitDate": "2016-12-13, 5:10 AM",
			"commitName": "c990d23490f5c4ac4322119b03d5951b63eef055",
			"commitAuthor": "Fred LefÃ©vÃ¨re-Laoide",
			"commitDateOld": "2016-11-21, 10:58 AM",
			"commitNameOld": "6e1380f412d334f1c887d15edf0b4610c3cf0da2",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 21.76,
			"commitsBetweenForRepo": 13,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,43 +1,45 @@\n     public SymbolReference<MethodDeclaration> solveMethod(String name, List<Type> argumentsTypes, TypeSolver typeSolver) {\n         if (wrappedNode.getScope() != null) {\n \n             // consider static methods\n             if (wrappedNode.getScope() instanceof NameExpr) {\n                 NameExpr scopeAsName = (NameExpr) wrappedNode.getScope();\n-                SymbolReference symbolReference = this.solveType(scopeAsName.getName().getId(), typeSolver);\n+                SymbolReference<TypeDeclaration> symbolReference = this.solveType(scopeAsName.getName().getId(), typeSolver);\n                 if (symbolReference.isSolved() && symbolReference.getCorrespondingDeclaration().isType()) {\n                     TypeDeclaration typeDeclaration = symbolReference.getCorrespondingDeclaration().asType();\n                     return MethodResolutionLogic.solveMethodInType(typeDeclaration, name, argumentsTypes, typeSolver);\n                 }\n             }\n \n             Type typeOfScope = null;\n             try {\n                 typeOfScope = JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n             } catch (Exception e) {\n                 throw new RuntimeException(String.format(\"Issur calculating the type of the scope of \" + this), e);\n             }\n             if (typeOfScope.isWildcard()) {\n                 if (typeOfScope.asWildcard().isExtends() || typeOfScope.asWildcard().isSuper()) {\n                     return MethodResolutionLogic.solveMethodInType(typeOfScope.asWildcard().getBoundedType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n                 } else {\n                     return MethodResolutionLogic.solveMethodInType(new ReflectionClassDeclaration(Object.class, typeSolver), name, argumentsTypes, typeSolver);\n                 }\n-            } else if (typeOfScope.isArray() && typeOfScope.asArrayType().getComponentType().isReferenceType()) {\n-                return MethodResolutionLogic.solveMethodInType(typeOfScope.asArrayType().getComponentType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n+            } else if (typeOfScope.isArray() /*&& typeOfScope.asArrayType().getComponentType().isReferenceType()*/) {\n+                // method call on array are Object methods\n+                return MethodResolutionLogic.solveMethodInType(new ReflectionClassDeclaration(Object.class, typeSolver), name, argumentsTypes, typeSolver);\n+//                return MethodResolutionLogic.solveMethodInType(typeOfScope.asArrayType().getComponentType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n             } else if (typeOfScope.isTypeVariable()) {\n                 for (TypeParameterDeclaration.Bound bound : typeOfScope.asTypeParameter().getBounds(typeSolver)) {\n                     SymbolReference<MethodDeclaration> res = MethodResolutionLogic.solveMethodInType(bound.getType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n                     if (res.isSolved()) {\n                         return res;\n                     }\n                 }\n                 return SymbolReference.unsolved(MethodDeclaration.class);\n             } else {\n                 return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n             }\n         } else {\n             Type typeOfScope = JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n             return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"6e1380f412d334f1c887d15edf0b4610c3cf0da2": {
			"type": "Ybodychange",
			"commitMessage": "adapt to alpha.10\n",
			"commitDate": "2016-11-21, 10:58 AM",
			"commitName": "6e1380f412d334f1c887d15edf0b4610c3cf0da2",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2016-11-09, 9:15 AM",
			"commitNameOld": "ca3e3a946698cf3a4f93e6fb7b4d2b16ee2e3ed5",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 12.07,
			"commitsBetweenForRepo": 7,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,43 +1,43 @@\n     public SymbolReference<MethodDeclaration> solveMethod(String name, List<Type> argumentsTypes, TypeSolver typeSolver) {\n         if (wrappedNode.getScope() != null) {\n \n             // consider static methods\n             if (wrappedNode.getScope() instanceof NameExpr) {\n                 NameExpr scopeAsName = (NameExpr) wrappedNode.getScope();\n-                SymbolReference symbolReference = this.solveType(scopeAsName.getName(), typeSolver);\n+                SymbolReference symbolReference = this.solveType(scopeAsName.getName().getId(), typeSolver);\n                 if (symbolReference.isSolved() && symbolReference.getCorrespondingDeclaration().isType()) {\n                     TypeDeclaration typeDeclaration = symbolReference.getCorrespondingDeclaration().asType();\n                     return MethodResolutionLogic.solveMethodInType(typeDeclaration, name, argumentsTypes, typeSolver);\n                 }\n             }\n \n             Type typeOfScope = null;\n             try {\n                 typeOfScope = JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n             } catch (Exception e) {\n                 throw new RuntimeException(String.format(\"Issur calculating the type of the scope of \" + this), e);\n             }\n             if (typeOfScope.isWildcard()) {\n                 if (typeOfScope.asWildcard().isExtends() || typeOfScope.asWildcard().isSuper()) {\n                     return MethodResolutionLogic.solveMethodInType(typeOfScope.asWildcard().getBoundedType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n                 } else {\n                     return MethodResolutionLogic.solveMethodInType(new ReflectionClassDeclaration(Object.class, typeSolver), name, argumentsTypes, typeSolver);\n                 }\n             } else if (typeOfScope.isArray() && typeOfScope.asArrayType().getComponentType().isReferenceType()) {\n                 return MethodResolutionLogic.solveMethodInType(typeOfScope.asArrayType().getComponentType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n             } else if (typeOfScope.isTypeVariable()) {\n                 for (TypeParameterDeclaration.Bound bound : typeOfScope.asTypeParameter().getBounds(typeSolver)) {\n                     SymbolReference<MethodDeclaration> res = MethodResolutionLogic.solveMethodInType(bound.getType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n                     if (res.isSolved()) {\n                         return res;\n                     }\n                 }\n                 return SymbolReference.unsolved(MethodDeclaration.class);\n             } else {\n                 return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n             }\n         } else {\n             Type typeOfScope = JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n             return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"ca3e3a946698cf3a4f93e6fb7b4d2b16ee2e3ed5": {
			"type": "Ybodychange",
			"commitMessage": "changes necessary to support jpalpha8\n",
			"commitDate": "2016-11-09, 9:15 AM",
			"commitName": "ca3e3a946698cf3a4f93e6fb7b4d2b16ee2e3ed5",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2016-11-06, 5:49 AM",
			"commitNameOld": "03055f925053b3970b9d14cce3a3b9a0d002366d",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 3.14,
			"commitsBetweenForRepo": 13,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,43 +1,43 @@\n     public SymbolReference<MethodDeclaration> solveMethod(String name, List<Type> argumentsTypes, TypeSolver typeSolver) {\n-        if (wrappedNode.getScope().isPresent()) {\n+        if (wrappedNode.getScope() != null) {\n \n             // consider static methods\n-            if (wrappedNode.getScope().get() instanceof NameExpr) {\n-                NameExpr scopeAsName = (NameExpr) wrappedNode.getScope().get();\n+            if (wrappedNode.getScope() instanceof NameExpr) {\n+                NameExpr scopeAsName = (NameExpr) wrappedNode.getScope();\n                 SymbolReference symbolReference = this.solveType(scopeAsName.getName(), typeSolver);\n                 if (symbolReference.isSolved() && symbolReference.getCorrespondingDeclaration().isType()) {\n                     TypeDeclaration typeDeclaration = symbolReference.getCorrespondingDeclaration().asType();\n                     return MethodResolutionLogic.solveMethodInType(typeDeclaration, name, argumentsTypes, typeSolver);\n                 }\n             }\n \n             Type typeOfScope = null;\n             try {\n-                typeOfScope = JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope().get());\n+                typeOfScope = JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n             } catch (Exception e) {\n                 throw new RuntimeException(String.format(\"Issur calculating the type of the scope of \" + this), e);\n             }\n             if (typeOfScope.isWildcard()) {\n                 if (typeOfScope.asWildcard().isExtends() || typeOfScope.asWildcard().isSuper()) {\n                     return MethodResolutionLogic.solveMethodInType(typeOfScope.asWildcard().getBoundedType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n                 } else {\n                     return MethodResolutionLogic.solveMethodInType(new ReflectionClassDeclaration(Object.class, typeSolver), name, argumentsTypes, typeSolver);\n                 }\n             } else if (typeOfScope.isArray() && typeOfScope.asArrayType().getComponentType().isReferenceType()) {\n                 return MethodResolutionLogic.solveMethodInType(typeOfScope.asArrayType().getComponentType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n             } else if (typeOfScope.isTypeVariable()) {\n                 for (TypeParameterDeclaration.Bound bound : typeOfScope.asTypeParameter().getBounds(typeSolver)) {\n                     SymbolReference<MethodDeclaration> res = MethodResolutionLogic.solveMethodInType(bound.getType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n                     if (res.isSolved()) {\n                         return res;\n                     }\n                 }\n                 return SymbolReference.unsolved(MethodDeclaration.class);\n             } else {\n                 return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n             }\n         } else {\n             Type typeOfScope = JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n             return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"9c53c2cbc607ea694438ade8630be0c155a33162": {
			"type": "Yfilerename",
			"commitMessage": "renamed packages to com.github.javapaerser\n",
			"commitDate": "2016-10-19, 11:39 PM",
			"commitName": "9c53c2cbc607ea694438ade8630be0c155a33162",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2016-10-19, 11:32 PM",
			"commitNameOld": "b1da215b407e8cfc2c77182f0ab3e67e0ab16ef3",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 0,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "",
			"extendedDetails": {
				"oldPath": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/javaparsermodel/contexts/MethodCallExprContext.java",
				"newPath": "java-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/MethodCallExprContext.java"
			}
		},
		"0d14741fef3a17451db153cfe379e398da4b4b79": {
			"type": "Ybodychange",
			"commitMessage": "minor fix\n",
			"commitDate": "2016-10-19, 10:35 AM",
			"commitName": "0d14741fef3a17451db153cfe379e398da4b4b79",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2016-10-19, 10:35 AM",
			"commitNameOld": "4601dfb9d1acf7f564948b7ddbb9201d62849ad7",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 0,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,42 +1,42 @@\n     public SymbolReference<MethodDeclaration> solveMethod(String name, List<Type> argumentsTypes, TypeSolver typeSolver) {\n-        if (wrappedNode.getScope() != null) {\n+        if (wrappedNode.getScope().isPresent()) {\n             // consider static methods\n             if (wrappedNode.getScope().get() instanceof NameExpr) {\n                 NameExpr scopeAsName = (NameExpr)wrappedNode.getScope().get();\n                 SymbolReference symbolReference = this.solveType(scopeAsName.getName(), typeSolver);\n                 if (symbolReference.isSolved() && symbolReference.getCorrespondingDeclaration().isType()) {\n                     TypeDeclaration typeDeclaration = symbolReference.getCorrespondingDeclaration().asType();\n                     return MethodResolutionLogic.solveMethodInType(typeDeclaration, name, argumentsTypes, typeSolver);\n                 }\n             }\n \n             Type typeOfScope = null;\n             try {\n                 typeOfScope = JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope().get());\n             } catch (Exception e) {\n                 throw new RuntimeException(String.format(\"Issur calculating the type of the scope of \" + this), e);\n             }\n             if (typeOfScope.isWildcard()) {\n                 if (typeOfScope.asWildcard().isExtends() || typeOfScope.asWildcard().isSuper()) {\n                     return MethodResolutionLogic.solveMethodInType(typeOfScope.asWildcard().getBoundedType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n                 } else {\n                     return MethodResolutionLogic.solveMethodInType(new ReflectionClassDeclaration(Object.class, typeSolver), name, argumentsTypes, typeSolver);\n                 }\n             } else if (typeOfScope.isArray() && typeOfScope.asArrayType().getComponentType().isReferenceType()) {\n                 return MethodResolutionLogic.solveMethodInType(typeOfScope.asArrayType().getComponentType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n             } else if (typeOfScope.isTypeVariable()) {\n                 for (TypeParameterDeclaration.Bound bound : typeOfScope.asTypeParameter().getBounds(typeSolver)) {\n                     SymbolReference<MethodDeclaration> res = MethodResolutionLogic.solveMethodInType(bound.getType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n                     if (res.isSolved()) {\n                         return res;\n                     }\n                 }\n                 return SymbolReference.unsolved(MethodDeclaration.class);\n             } else {\n                 return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n             }\n         } else {\n             Type typeOfScope = JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n             return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"341e081a5f8909a3a467671befcca2941b786d3d": {
			"type": "Ybodychange",
			"commitMessage": "issue91: solve compilation issues\n",
			"commitDate": "2016-10-19, 10:33 AM",
			"commitName": "341e081a5f8909a3a467671befcca2941b786d3d",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2016-10-19, 8:04 AM",
			"commitNameOld": "683012de2a3a28358e848f8b145d462eb8b322ba",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 0.1,
			"commitsBetweenForRepo": 6,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,42 +1,42 @@\n     public SymbolReference<MethodDeclaration> solveMethod(String name, List<Type> argumentsTypes, TypeSolver typeSolver) {\n         if (wrappedNode.getScope() != null) {\n             // consider static methods\n-            if (wrappedNode.getScope() instanceof NameExpr) {\n-                NameExpr scopeAsName = (NameExpr)wrappedNode.getScope();\n+            if (wrappedNode.getScope().get() instanceof NameExpr) {\n+                NameExpr scopeAsName = (NameExpr)wrappedNode.getScope().get();\n                 SymbolReference symbolReference = this.solveType(scopeAsName.getName(), typeSolver);\n                 if (symbolReference.isSolved() && symbolReference.getCorrespondingDeclaration().isType()) {\n                     TypeDeclaration typeDeclaration = symbolReference.getCorrespondingDeclaration().asType();\n                     return MethodResolutionLogic.solveMethodInType(typeDeclaration, name, argumentsTypes, typeSolver);\n                 }\n             }\n \n             Type typeOfScope = null;\n             try {\n-                typeOfScope = JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n+                typeOfScope = JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope().get());\n             } catch (Exception e) {\n                 throw new RuntimeException(String.format(\"Issur calculating the type of the scope of \" + this), e);\n             }\n             if (typeOfScope.isWildcard()) {\n                 if (typeOfScope.asWildcard().isExtends() || typeOfScope.asWildcard().isSuper()) {\n                     return MethodResolutionLogic.solveMethodInType(typeOfScope.asWildcard().getBoundedType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n                 } else {\n                     return MethodResolutionLogic.solveMethodInType(new ReflectionClassDeclaration(Object.class, typeSolver), name, argumentsTypes, typeSolver);\n                 }\n             } else if (typeOfScope.isArray() && typeOfScope.asArrayType().getComponentType().isReferenceType()) {\n                 return MethodResolutionLogic.solveMethodInType(typeOfScope.asArrayType().getComponentType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n             } else if (typeOfScope.isTypeVariable()) {\n                 for (TypeParameterDeclaration.Bound bound : typeOfScope.asTypeParameter().getBounds(typeSolver)) {\n                     SymbolReference<MethodDeclaration> res = MethodResolutionLogic.solveMethodInType(bound.getType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n                     if (res.isSolved()) {\n                         return res;\n                     }\n                 }\n                 return SymbolReference.unsolved(MethodDeclaration.class);\n             } else {\n                 return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n             }\n         } else {\n             Type typeOfScope = JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n             return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"88db8b2a8b93bcc692cb8fd5085ba68b8bcf1968": {
			"type": "Ymultichange(Yparameterchange,Ybodychange)",
			"commitMessage": "issue90: using the right terminology for parameters and arguments\n",
			"commitDate": "2016-10-17, 10:25 AM",
			"commitName": "88db8b2a8b93bcc692cb8fd5085ba68b8bcf1968",
			"commitAuthor": "Federico Tomassetti",
			"subchanges": [
				{
					"type": "Yparameterchange",
					"commitMessage": "issue90: using the right terminology for parameters and arguments\n",
					"commitDate": "2016-10-17, 10:25 AM",
					"commitName": "88db8b2a8b93bcc692cb8fd5085ba68b8bcf1968",
					"commitAuthor": "Federico Tomassetti",
					"commitDateOld": "2016-10-16, 9:48 AM",
					"commitNameOld": "f271890077d290431fd7cdc45e3bf172fb2f834c",
					"commitAuthorOld": "Federico Tomassetti",
					"daysBetweenCommits": 1.03,
					"commitsBetweenForRepo": 4,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,42 +1,42 @@\n-    public SymbolReference<MethodDeclaration> solveMethod(String name, List<Type> parameterTypes, TypeSolver typeSolver) {\n+    public SymbolReference<MethodDeclaration> solveMethod(String name, List<Type> argumentsTypes, TypeSolver typeSolver) {\n         if (wrappedNode.getScope() != null) {\n             // consider static methods\n             if (wrappedNode.getScope() instanceof NameExpr) {\n                 NameExpr scopeAsName = (NameExpr)wrappedNode.getScope();\n                 SymbolReference symbolReference = this.solveType(scopeAsName.getName(), typeSolver);\n                 if (symbolReference.isSolved() && symbolReference.getCorrespondingDeclaration().isType()) {\n                     TypeDeclaration typeDeclaration = symbolReference.getCorrespondingDeclaration().asType();\n-                    return MethodResolutionLogic.solveMethodInType(typeDeclaration, name, parameterTypes, typeSolver);\n+                    return MethodResolutionLogic.solveMethodInType(typeDeclaration, name, argumentsTypes, typeSolver);\n                 }\n             }\n \n             Type typeOfScope = null;\n             try {\n                 typeOfScope = JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n             } catch (Exception e) {\n                 throw new RuntimeException(String.format(\"Issur calculating the type of the scope of \" + this), e);\n             }\n             if (typeOfScope.isWildcard()) {\n                 if (typeOfScope.asWildcard().isExtends() || typeOfScope.asWildcard().isSuper()) {\n-                    return MethodResolutionLogic.solveMethodInType(typeOfScope.asWildcard().getBoundedType().asReferenceType().getTypeDeclaration(), name, parameterTypes, typeSolver);\n+                    return MethodResolutionLogic.solveMethodInType(typeOfScope.asWildcard().getBoundedType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n                 } else {\n-                    return MethodResolutionLogic.solveMethodInType(new ReflectionClassDeclaration(Object.class, typeSolver), name, parameterTypes, typeSolver);\n+                    return MethodResolutionLogic.solveMethodInType(new ReflectionClassDeclaration(Object.class, typeSolver), name, argumentsTypes, typeSolver);\n                 }\n             } else if (typeOfScope.isArray() && typeOfScope.asArrayType().getComponentType().isReferenceType()) {\n-                return MethodResolutionLogic.solveMethodInType(typeOfScope.asArrayType().getComponentType().asReferenceType().getTypeDeclaration(), name, parameterTypes, typeSolver);\n+                return MethodResolutionLogic.solveMethodInType(typeOfScope.asArrayType().getComponentType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n             } else if (typeOfScope.isTypeVariable()) {\n                 for (TypeParameterDeclaration.Bound bound : typeOfScope.asTypeParameter().getBounds(typeSolver)) {\n-                    SymbolReference<MethodDeclaration> res = MethodResolutionLogic.solveMethodInType(bound.getType().asReferenceType().getTypeDeclaration(), name, parameterTypes, typeSolver);\n+                    SymbolReference<MethodDeclaration> res = MethodResolutionLogic.solveMethodInType(bound.getType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n                     if (res.isSolved()) {\n                         return res;\n                     }\n                 }\n                 return SymbolReference.unsolved(MethodDeclaration.class);\n             } else {\n-                return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, parameterTypes, typeSolver);\n+                return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n             }\n         } else {\n             Type typeOfScope = JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n-            return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, parameterTypes, typeSolver);\n+            return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n         }\n     }\n\\ No newline at end of file\n",
					"extendedDetails": {
						"oldValue": "[name-String, parameterTypes-List<Type>, typeSolver-TypeSolver]",
						"newValue": "[name-String, argumentsTypes-List<Type>, typeSolver-TypeSolver]"
					}
				},
				{
					"type": "Ybodychange",
					"commitMessage": "issue90: using the right terminology for parameters and arguments\n",
					"commitDate": "2016-10-17, 10:25 AM",
					"commitName": "88db8b2a8b93bcc692cb8fd5085ba68b8bcf1968",
					"commitAuthor": "Federico Tomassetti",
					"commitDateOld": "2016-10-16, 9:48 AM",
					"commitNameOld": "f271890077d290431fd7cdc45e3bf172fb2f834c",
					"commitAuthorOld": "Federico Tomassetti",
					"daysBetweenCommits": 1.03,
					"commitsBetweenForRepo": 4,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,42 +1,42 @@\n-    public SymbolReference<MethodDeclaration> solveMethod(String name, List<Type> parameterTypes, TypeSolver typeSolver) {\n+    public SymbolReference<MethodDeclaration> solveMethod(String name, List<Type> argumentsTypes, TypeSolver typeSolver) {\n         if (wrappedNode.getScope() != null) {\n             // consider static methods\n             if (wrappedNode.getScope() instanceof NameExpr) {\n                 NameExpr scopeAsName = (NameExpr)wrappedNode.getScope();\n                 SymbolReference symbolReference = this.solveType(scopeAsName.getName(), typeSolver);\n                 if (symbolReference.isSolved() && symbolReference.getCorrespondingDeclaration().isType()) {\n                     TypeDeclaration typeDeclaration = symbolReference.getCorrespondingDeclaration().asType();\n-                    return MethodResolutionLogic.solveMethodInType(typeDeclaration, name, parameterTypes, typeSolver);\n+                    return MethodResolutionLogic.solveMethodInType(typeDeclaration, name, argumentsTypes, typeSolver);\n                 }\n             }\n \n             Type typeOfScope = null;\n             try {\n                 typeOfScope = JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n             } catch (Exception e) {\n                 throw new RuntimeException(String.format(\"Issur calculating the type of the scope of \" + this), e);\n             }\n             if (typeOfScope.isWildcard()) {\n                 if (typeOfScope.asWildcard().isExtends() || typeOfScope.asWildcard().isSuper()) {\n-                    return MethodResolutionLogic.solveMethodInType(typeOfScope.asWildcard().getBoundedType().asReferenceType().getTypeDeclaration(), name, parameterTypes, typeSolver);\n+                    return MethodResolutionLogic.solveMethodInType(typeOfScope.asWildcard().getBoundedType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n                 } else {\n-                    return MethodResolutionLogic.solveMethodInType(new ReflectionClassDeclaration(Object.class, typeSolver), name, parameterTypes, typeSolver);\n+                    return MethodResolutionLogic.solveMethodInType(new ReflectionClassDeclaration(Object.class, typeSolver), name, argumentsTypes, typeSolver);\n                 }\n             } else if (typeOfScope.isArray() && typeOfScope.asArrayType().getComponentType().isReferenceType()) {\n-                return MethodResolutionLogic.solveMethodInType(typeOfScope.asArrayType().getComponentType().asReferenceType().getTypeDeclaration(), name, parameterTypes, typeSolver);\n+                return MethodResolutionLogic.solveMethodInType(typeOfScope.asArrayType().getComponentType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n             } else if (typeOfScope.isTypeVariable()) {\n                 for (TypeParameterDeclaration.Bound bound : typeOfScope.asTypeParameter().getBounds(typeSolver)) {\n-                    SymbolReference<MethodDeclaration> res = MethodResolutionLogic.solveMethodInType(bound.getType().asReferenceType().getTypeDeclaration(), name, parameterTypes, typeSolver);\n+                    SymbolReference<MethodDeclaration> res = MethodResolutionLogic.solveMethodInType(bound.getType().asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n                     if (res.isSolved()) {\n                         return res;\n                     }\n                 }\n                 return SymbolReference.unsolved(MethodDeclaration.class);\n             } else {\n-                return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, parameterTypes, typeSolver);\n+                return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n             }\n         } else {\n             Type typeOfScope = JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n-            return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, parameterTypes, typeSolver);\n+            return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, argumentsTypes, typeSolver);\n         }\n     }\n\\ No newline at end of file\n",
					"extendedDetails": {}
				}
			]
		},
		"656bb37a1dba87d61d24e69f2346f35dbc73d81d": {
			"type": "Ybodychange",
			"commitMessage": "remove TypeDeclaration.solveMethod\n",
			"commitDate": "2016-10-16, 9:13 AM",
			"commitName": "656bb37a1dba87d61d24e69f2346f35dbc73d81d",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2016-10-14, 1:57 PM",
			"commitNameOld": "051dbd94c17c4f142d3fe9e8fbd03c29d09ace54",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 1.8,
			"commitsBetweenForRepo": 18,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,42 +1,42 @@\n     public SymbolReference<MethodDeclaration> solveMethod(String name, List<Type> parameterTypes, TypeSolver typeSolver) {\n         if (wrappedNode.getScope() != null) {\n             // consider static methods\n             if (wrappedNode.getScope() instanceof NameExpr) {\n                 NameExpr scopeAsName = (NameExpr)wrappedNode.getScope();\n                 SymbolReference symbolReference = this.solveType(scopeAsName.getName(), typeSolver);\n                 if (symbolReference.isSolved() && symbolReference.getCorrespondingDeclaration().isType()) {\n                     TypeDeclaration typeDeclaration = symbolReference.getCorrespondingDeclaration().asType();\n-                    return typeDeclaration.solveMethod(name, parameterTypes);\n+                    return MethodResolutionLogic.solveMethodInType(typeDeclaration, name, parameterTypes, typeSolver);\n                 }\n             }\n \n             Type typeOfScope = null;\n             try {\n                 typeOfScope = JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n             } catch (Exception e) {\n                 throw new RuntimeException(String.format(\"Issur calculating the type of the scope of \" + this), e);\n             }\n             if (typeOfScope.isWildcard()) {\n                 if (typeOfScope.asWildcard().isExtends() || typeOfScope.asWildcard().isSuper()) {\n-                    return typeOfScope.asWildcard().getBoundedType().asReferenceType().solveMethod(name, parameterTypes);\n+                    return MethodResolutionLogic.solveMethodInType(typeOfScope.asWildcard().getBoundedType().asReferenceType().getTypeDeclaration(), name, parameterTypes, typeSolver);\n                 } else {\n-                    return new ReferenceTypeImpl(new ReflectionClassDeclaration(Object.class, typeSolver), typeSolver).solveMethod(name, parameterTypes);\n+                    return MethodResolutionLogic.solveMethodInType(new ReflectionClassDeclaration(Object.class, typeSolver), name, parameterTypes, typeSolver);\n                 }\n             } else if (typeOfScope.isArray() && typeOfScope.asArrayType().getComponentType().isReferenceType()) {\n-                return typeOfScope.asArrayType().getComponentType().asReferenceType().solveMethod(name, parameterTypes);\n+                return MethodResolutionLogic.solveMethodInType(typeOfScope.asArrayType().getComponentType().asReferenceType().getTypeDeclaration(), name, parameterTypes, typeSolver);\n             } else if (typeOfScope.isTypeVariable()) {\n                 for (TypeParameterDeclaration.Bound bound : typeOfScope.asTypeParameter().getBounds(typeSolver)) {\n-                    SymbolReference<MethodDeclaration> res = bound.getType().asReferenceType().solveMethod(name, parameterTypes);\n+                    SymbolReference<MethodDeclaration> res = MethodResolutionLogic.solveMethodInType(bound.getType().asReferenceType().getTypeDeclaration(), name, parameterTypes, typeSolver);\n                     if (res.isSolved()) {\n                         return res;\n                     }\n                 }\n                 return SymbolReference.unsolved(MethodDeclaration.class);\n             } else {\n-                return typeOfScope.asReferenceType().solveMethod(name, parameterTypes);\n+                return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, parameterTypes, typeSolver);\n             }\n         } else {\n             Type typeOfScope = JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n-            return typeOfScope.asReferenceType().solveMethod(name, parameterTypes);\n+            return MethodResolutionLogic.solveMethodInType(typeOfScope.asReferenceType().getTypeDeclaration(), name, parameterTypes, typeSolver);\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"051dbd94c17c4f142d3fe9e8fbd03c29d09ace54": {
			"type": "Ybodychange",
			"commitMessage": "add test JavaParserClassDeclarationTest.testGetSuperclassWithTypeParameters\n",
			"commitDate": "2016-10-14, 1:57 PM",
			"commitName": "051dbd94c17c4f142d3fe9e8fbd03c29d09ace54",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2016-10-14, 10:24 AM",
			"commitNameOld": "70f3e66c944670a818922f101162226ef604b263",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 0.15,
			"commitsBetweenForRepo": 2,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,42 +1,42 @@\n     public SymbolReference<MethodDeclaration> solveMethod(String name, List<Type> parameterTypes, TypeSolver typeSolver) {\n         if (wrappedNode.getScope() != null) {\n             // consider static methods\n             if (wrappedNode.getScope() instanceof NameExpr) {\n                 NameExpr scopeAsName = (NameExpr)wrappedNode.getScope();\n                 SymbolReference symbolReference = this.solveType(scopeAsName.getName(), typeSolver);\n                 if (symbolReference.isSolved() && symbolReference.getCorrespondingDeclaration().isType()) {\n                     TypeDeclaration typeDeclaration = symbolReference.getCorrespondingDeclaration().asType();\n                     return typeDeclaration.solveMethod(name, parameterTypes);\n                 }\n             }\n \n             Type typeOfScope = null;\n             try {\n                 typeOfScope = JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n             } catch (Exception e) {\n                 throw new RuntimeException(String.format(\"Issur calculating the type of the scope of \" + this), e);\n             }\n             if (typeOfScope.isWildcard()) {\n                 if (typeOfScope.asWildcard().isExtends() || typeOfScope.asWildcard().isSuper()) {\n-                    return typeOfScope.asWildcard().getBoundedType().asReferenceTypeUsage().solveMethod(name, parameterTypes);\n+                    return typeOfScope.asWildcard().getBoundedType().asReferenceType().solveMethod(name, parameterTypes);\n                 } else {\n                     return new ReferenceTypeImpl(new ReflectionClassDeclaration(Object.class, typeSolver), typeSolver).solveMethod(name, parameterTypes);\n                 }\n-            } else if (typeOfScope.isArray() && typeOfScope.asArrayTypeUsage().getComponentType().isReferenceType()) {\n-                return typeOfScope.asArrayTypeUsage().getComponentType().asReferenceTypeUsage().solveMethod(name, parameterTypes);\n+            } else if (typeOfScope.isArray() && typeOfScope.asArrayType().getComponentType().isReferenceType()) {\n+                return typeOfScope.asArrayType().getComponentType().asReferenceType().solveMethod(name, parameterTypes);\n             } else if (typeOfScope.isTypeVariable()) {\n                 for (TypeParameterDeclaration.Bound bound : typeOfScope.asTypeParameter().getBounds(typeSolver)) {\n-                    SymbolReference<MethodDeclaration> res = bound.getType().asReferenceTypeUsage().solveMethod(name, parameterTypes);\n+                    SymbolReference<MethodDeclaration> res = bound.getType().asReferenceType().solveMethod(name, parameterTypes);\n                     if (res.isSolved()) {\n                         return res;\n                     }\n                 }\n                 return SymbolReference.unsolved(MethodDeclaration.class);\n             } else {\n-                return typeOfScope.asReferenceTypeUsage().solveMethod(name, parameterTypes);\n+                return typeOfScope.asReferenceType().solveMethod(name, parameterTypes);\n             }\n         } else {\n             Type typeOfScope = JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n-            return typeOfScope.asReferenceTypeUsage().solveMethod(name, parameterTypes);\n+            return typeOfScope.asReferenceType().solveMethod(name, parameterTypes);\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"ecc78c8b480ceb41019f764c983aaa69c2dabfe3": {
			"type": "Ybodychange",
			"commitMessage": "reorganize packages in model\n",
			"commitDate": "2016-10-14, 9:51 AM",
			"commitName": "ecc78c8b480ceb41019f764c983aaa69c2dabfe3",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2016-10-13, 11:36 PM",
			"commitNameOld": "8d234965b572759181da7787fead07b225e9e5ca",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 0.43,
			"commitsBetweenForRepo": 5,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,42 +1,42 @@\n     public SymbolReference<MethodDeclaration> solveMethod(String name, List<Type> parameterTypes, TypeSolver typeSolver) {\n         if (wrappedNode.getScope() != null) {\n             // consider static methods\n             if (wrappedNode.getScope() instanceof NameExpr) {\n                 NameExpr scopeAsName = (NameExpr)wrappedNode.getScope();\n                 SymbolReference symbolReference = this.solveType(scopeAsName.getName(), typeSolver);\n                 if (symbolReference.isSolved() && symbolReference.getCorrespondingDeclaration().isType()) {\n                     TypeDeclaration typeDeclaration = symbolReference.getCorrespondingDeclaration().asType();\n                     return typeDeclaration.solveMethod(name, parameterTypes);\n                 }\n             }\n \n             Type typeOfScope = null;\n             try {\n                 typeOfScope = JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n             } catch (Exception e) {\n                 throw new RuntimeException(String.format(\"Issur calculating the type of the scope of \" + this), e);\n             }\n             if (typeOfScope.isWildcard()) {\n                 if (typeOfScope.asWildcard().isExtends() || typeOfScope.asWildcard().isSuper()) {\n                     return typeOfScope.asWildcard().getBoundedType().asReferenceTypeUsage().solveMethod(name, parameterTypes);\n                 } else {\n                     return new ReferenceTypeImpl(new ReflectionClassDeclaration(Object.class, typeSolver), typeSolver).solveMethod(name, parameterTypes);\n                 }\n             } else if (typeOfScope.isArray() && typeOfScope.asArrayTypeUsage().getComponentType().isReferenceType()) {\n                 return typeOfScope.asArrayTypeUsage().getComponentType().asReferenceTypeUsage().solveMethod(name, parameterTypes);\n             } else if (typeOfScope.isTypeVariable()) {\n-                for (me.tomassetti.symbolsolver.model.resolution.TypeParameter.Bound bound : typeOfScope.asTypeParameter().getBounds(typeSolver)) {\n+                for (TypeParameterDeclaration.Bound bound : typeOfScope.asTypeParameter().getBounds(typeSolver)) {\n                     SymbolReference<MethodDeclaration> res = bound.getType().asReferenceTypeUsage().solveMethod(name, parameterTypes);\n                     if (res.isSolved()) {\n                         return res;\n                     }\n                 }\n                 return SymbolReference.unsolved(MethodDeclaration.class);\n             } else {\n                 return typeOfScope.asReferenceTypeUsage().solveMethod(name, parameterTypes);\n             }\n         } else {\n             Type typeOfScope = JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n             return typeOfScope.asReferenceTypeUsage().solveMethod(name, parameterTypes);\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"82eb44707b620803d424188a1eb8708fcaf093cb": {
			"type": "Ymultichange(Yparameterchange,Ybodychange)",
			"commitMessage": "rename TypeUsage into Type\n",
			"commitDate": "2016-10-13, 1:11 PM",
			"commitName": "82eb44707b620803d424188a1eb8708fcaf093cb",
			"commitAuthor": "Federico Tomassetti",
			"subchanges": [
				{
					"type": "Yparameterchange",
					"commitMessage": "rename TypeUsage into Type\n",
					"commitDate": "2016-10-13, 1:11 PM",
					"commitName": "82eb44707b620803d424188a1eb8708fcaf093cb",
					"commitAuthor": "Federico Tomassetti",
					"commitDateOld": "2016-10-12, 2:43 PM",
					"commitNameOld": "401a56f412ca186a00a2282d9088e8cb7b67e0e5",
					"commitAuthorOld": "Federico Tomassetti",
					"daysBetweenCommits": 0.94,
					"commitsBetweenForRepo": 21,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,42 +1,42 @@\n-    public SymbolReference<MethodDeclaration> solveMethod(String name, List<TypeUsage> parameterTypes, TypeSolver typeSolver) {\n+    public SymbolReference<MethodDeclaration> solveMethod(String name, List<Type> parameterTypes, TypeSolver typeSolver) {\n         if (wrappedNode.getScope() != null) {\n             // consider static methods\n             if (wrappedNode.getScope() instanceof NameExpr) {\n                 NameExpr scopeAsName = (NameExpr)wrappedNode.getScope();\n                 SymbolReference symbolReference = this.solveType(scopeAsName.getName(), typeSolver);\n                 if (symbolReference.isSolved() && symbolReference.getCorrespondingDeclaration().isType()) {\n                     TypeDeclaration typeDeclaration = symbolReference.getCorrespondingDeclaration().asType();\n                     return typeDeclaration.solveMethod(name, parameterTypes);\n                 }\n             }\n \n-            TypeUsage typeOfScope = null;\n+            Type typeOfScope = null;\n             try {\n                 typeOfScope = JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n             } catch (Exception e) {\n                 throw new RuntimeException(String.format(\"Issur calculating the type of the scope of \" + this), e);\n             }\n             if (typeOfScope.isWildcard()) {\n                 if (typeOfScope.asWildcard().isExtends() || typeOfScope.asWildcard().isSuper()) {\n                     return typeOfScope.asWildcard().getBoundedType().asReferenceTypeUsage().solveMethod(name, parameterTypes);\n                 } else {\n-                    return new ReferenceTypeUsageImpl(new ReflectionClassDeclaration(Object.class, typeSolver), typeSolver).solveMethod(name, parameterTypes);\n+                    return new ReferenceTypeImpl(new ReflectionClassDeclaration(Object.class, typeSolver), typeSolver).solveMethod(name, parameterTypes);\n                 }\n             } else if (typeOfScope.isArray() && typeOfScope.asArrayTypeUsage().getComponentType().isReferenceType()) {\n                 return typeOfScope.asArrayTypeUsage().getComponentType().asReferenceTypeUsage().solveMethod(name, parameterTypes);\n             } else if (typeOfScope.isTypeVariable()) {\n-                for (TypeParameter.Bound bound : typeOfScope.asTypeParameter().getBounds(typeSolver)) {\n+                for (me.tomassetti.symbolsolver.model.resolution.TypeParameter.Bound bound : typeOfScope.asTypeParameter().getBounds(typeSolver)) {\n                     SymbolReference<MethodDeclaration> res = bound.getType().asReferenceTypeUsage().solveMethod(name, parameterTypes);\n                     if (res.isSolved()) {\n                         return res;\n                     }\n                 }\n                 return SymbolReference.unsolved(MethodDeclaration.class);\n             } else {\n                 return typeOfScope.asReferenceTypeUsage().solveMethod(name, parameterTypes);\n             }\n         } else {\n-            TypeUsage typeOfScope = JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n+            Type typeOfScope = JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n             return typeOfScope.asReferenceTypeUsage().solveMethod(name, parameterTypes);\n         }\n     }\n\\ No newline at end of file\n",
					"extendedDetails": {
						"oldValue": "[name-String, parameterTypes-List<TypeUsage>, typeSolver-TypeSolver]",
						"newValue": "[name-String, parameterTypes-List<Type>, typeSolver-TypeSolver]"
					}
				},
				{
					"type": "Ybodychange",
					"commitMessage": "rename TypeUsage into Type\n",
					"commitDate": "2016-10-13, 1:11 PM",
					"commitName": "82eb44707b620803d424188a1eb8708fcaf093cb",
					"commitAuthor": "Federico Tomassetti",
					"commitDateOld": "2016-10-12, 2:43 PM",
					"commitNameOld": "401a56f412ca186a00a2282d9088e8cb7b67e0e5",
					"commitAuthorOld": "Federico Tomassetti",
					"daysBetweenCommits": 0.94,
					"commitsBetweenForRepo": 21,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,42 +1,42 @@\n-    public SymbolReference<MethodDeclaration> solveMethod(String name, List<TypeUsage> parameterTypes, TypeSolver typeSolver) {\n+    public SymbolReference<MethodDeclaration> solveMethod(String name, List<Type> parameterTypes, TypeSolver typeSolver) {\n         if (wrappedNode.getScope() != null) {\n             // consider static methods\n             if (wrappedNode.getScope() instanceof NameExpr) {\n                 NameExpr scopeAsName = (NameExpr)wrappedNode.getScope();\n                 SymbolReference symbolReference = this.solveType(scopeAsName.getName(), typeSolver);\n                 if (symbolReference.isSolved() && symbolReference.getCorrespondingDeclaration().isType()) {\n                     TypeDeclaration typeDeclaration = symbolReference.getCorrespondingDeclaration().asType();\n                     return typeDeclaration.solveMethod(name, parameterTypes);\n                 }\n             }\n \n-            TypeUsage typeOfScope = null;\n+            Type typeOfScope = null;\n             try {\n                 typeOfScope = JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n             } catch (Exception e) {\n                 throw new RuntimeException(String.format(\"Issur calculating the type of the scope of \" + this), e);\n             }\n             if (typeOfScope.isWildcard()) {\n                 if (typeOfScope.asWildcard().isExtends() || typeOfScope.asWildcard().isSuper()) {\n                     return typeOfScope.asWildcard().getBoundedType().asReferenceTypeUsage().solveMethod(name, parameterTypes);\n                 } else {\n-                    return new ReferenceTypeUsageImpl(new ReflectionClassDeclaration(Object.class, typeSolver), typeSolver).solveMethod(name, parameterTypes);\n+                    return new ReferenceTypeImpl(new ReflectionClassDeclaration(Object.class, typeSolver), typeSolver).solveMethod(name, parameterTypes);\n                 }\n             } else if (typeOfScope.isArray() && typeOfScope.asArrayTypeUsage().getComponentType().isReferenceType()) {\n                 return typeOfScope.asArrayTypeUsage().getComponentType().asReferenceTypeUsage().solveMethod(name, parameterTypes);\n             } else if (typeOfScope.isTypeVariable()) {\n-                for (TypeParameter.Bound bound : typeOfScope.asTypeParameter().getBounds(typeSolver)) {\n+                for (me.tomassetti.symbolsolver.model.resolution.TypeParameter.Bound bound : typeOfScope.asTypeParameter().getBounds(typeSolver)) {\n                     SymbolReference<MethodDeclaration> res = bound.getType().asReferenceTypeUsage().solveMethod(name, parameterTypes);\n                     if (res.isSolved()) {\n                         return res;\n                     }\n                 }\n                 return SymbolReference.unsolved(MethodDeclaration.class);\n             } else {\n                 return typeOfScope.asReferenceTypeUsage().solveMethod(name, parameterTypes);\n             }\n         } else {\n-            TypeUsage typeOfScope = JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n+            Type typeOfScope = JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n             return typeOfScope.asReferenceTypeUsage().solveMethod(name, parameterTypes);\n         }\n     }\n\\ No newline at end of file\n",
					"extendedDetails": {}
				}
			]
		},
		"401a56f412ca186a00a2282d9088e8cb7b67e0e5": {
			"type": "Ybodychange",
			"commitMessage": "issue80: working on lambdas assigned to variables\n",
			"commitDate": "2016-10-12, 2:43 PM",
			"commitName": "401a56f412ca186a00a2282d9088e8cb7b67e0e5",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2016-10-12, 1:53 PM",
			"commitNameOld": "38d780df85a22c9baffb1f772a45b063cad73aab",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 0.03,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,37 +1,42 @@\n     public SymbolReference<MethodDeclaration> solveMethod(String name, List<TypeUsage> parameterTypes, TypeSolver typeSolver) {\n         if (wrappedNode.getScope() != null) {\n             // consider static methods\n             if (wrappedNode.getScope() instanceof NameExpr) {\n                 NameExpr scopeAsName = (NameExpr)wrappedNode.getScope();\n                 SymbolReference symbolReference = this.solveType(scopeAsName.getName(), typeSolver);\n                 if (symbolReference.isSolved() && symbolReference.getCorrespondingDeclaration().isType()) {\n                     TypeDeclaration typeDeclaration = symbolReference.getCorrespondingDeclaration().asType();\n                     return typeDeclaration.solveMethod(name, parameterTypes);\n                 }\n             }\n \n-            TypeUsage typeOfScope = JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n+            TypeUsage typeOfScope = null;\n+            try {\n+                typeOfScope = JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n+            } catch (Exception e) {\n+                throw new RuntimeException(String.format(\"Issur calculating the type of the scope of \" + this), e);\n+            }\n             if (typeOfScope.isWildcard()) {\n                 if (typeOfScope.asWildcard().isExtends() || typeOfScope.asWildcard().isSuper()) {\n                     return typeOfScope.asWildcard().getBoundedType().asReferenceTypeUsage().solveMethod(name, parameterTypes);\n                 } else {\n                     return new ReferenceTypeUsageImpl(new ReflectionClassDeclaration(Object.class, typeSolver), typeSolver).solveMethod(name, parameterTypes);\n                 }\n             } else if (typeOfScope.isArray() && typeOfScope.asArrayTypeUsage().getComponentType().isReferenceType()) {\n                 return typeOfScope.asArrayTypeUsage().getComponentType().asReferenceTypeUsage().solveMethod(name, parameterTypes);\n             } else if (typeOfScope.isTypeVariable()) {\n                 for (TypeParameter.Bound bound : typeOfScope.asTypeParameter().getBounds(typeSolver)) {\n                     SymbolReference<MethodDeclaration> res = bound.getType().asReferenceTypeUsage().solveMethod(name, parameterTypes);\n                     if (res.isSolved()) {\n                         return res;\n                     }\n                 }\n                 return SymbolReference.unsolved(MethodDeclaration.class);\n             } else {\n                 return typeOfScope.asReferenceTypeUsage().solveMethod(name, parameterTypes);\n             }\n         } else {\n             TypeUsage typeOfScope = JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n             return typeOfScope.asReferenceTypeUsage().solveMethod(name, parameterTypes);\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"a16d5b37001074f2fa6eea4d1d1ef7e0466ca51b": {
			"type": "Ybodychange",
			"commitMessage": "issue80: improving resolution of methods on type parameters\n",
			"commitDate": "2016-10-09, 2:06 AM",
			"commitName": "a16d5b37001074f2fa6eea4d1d1ef7e0466ca51b",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2016-10-08, 1:17 PM",
			"commitNameOld": "cb7655f9661f11dab8ec9e2533722d649a16e715",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 0.53,
			"commitsBetweenForRepo": 6,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,29 +1,37 @@\n     public SymbolReference<MethodDeclaration> solveMethod(String name, List<TypeUsage> parameterTypes, TypeSolver typeSolver) {\n         if (wrappedNode.getScope() != null) {\n             // consider static methods\n             if (wrappedNode.getScope() instanceof NameExpr) {\n                 NameExpr scopeAsName = (NameExpr)wrappedNode.getScope();\n                 SymbolReference symbolReference = this.solveType(scopeAsName.getName(), typeSolver);\n                 if (symbolReference.isSolved() && symbolReference.getCorrespondingDeclaration().isType()) {\n                     TypeDeclaration typeDeclaration = symbolReference.getCorrespondingDeclaration().asType();\n                     return typeDeclaration.solveMethod(name, parameterTypes);\n                 }\n             }\n \n             TypeUsage typeOfScope = JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n             if (typeOfScope.isWildcard()) {\n                 if (typeOfScope.asWildcard().isExtends() || typeOfScope.asWildcard().isSuper()) {\n                     return typeOfScope.asWildcard().getBoundedType().asReferenceTypeUsage().solveMethod(name, parameterTypes);\n                 } else {\n                     return new ReferenceTypeUsageImpl(new ReflectionClassDeclaration(Object.class, typeSolver), typeSolver).solveMethod(name, parameterTypes);\n                 }\n             } else if (typeOfScope.isArray() && typeOfScope.asArrayTypeUsage().getComponentType().isReferenceType()) {\n                 return typeOfScope.asArrayTypeUsage().getComponentType().asReferenceTypeUsage().solveMethod(name, parameterTypes);\n+            } else if (typeOfScope.isTypeVariable()) {\n+                for (TypeParameter.Bound bound : typeOfScope.asTypeParameter().getBounds(typeSolver)) {\n+                    SymbolReference<MethodDeclaration> res = bound.getType().asReferenceTypeUsage().solveMethod(name, parameterTypes);\n+                    if (res.isSolved()) {\n+                        return res;\n+                    }\n+                }\n+                return SymbolReference.unsolved(MethodDeclaration.class);\n             } else {\n                 return typeOfScope.asReferenceTypeUsage().solveMethod(name, parameterTypes);\n             }\n         } else {\n             TypeUsage typeOfScope = JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n             return typeOfScope.asReferenceTypeUsage().solveMethod(name, parameterTypes);\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"cb7655f9661f11dab8ec9e2533722d649a16e715": {
			"type": "Ybodychange",
			"commitMessage": "issue80: improving resolution of static methods\n",
			"commitDate": "2016-10-08, 1:17 PM",
			"commitName": "cb7655f9661f11dab8ec9e2533722d649a16e715",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2016-10-05, 6:04 AM",
			"commitNameOld": "84afc7be2fabd511eccc69e29fca9c4238c9469e",
			"commitAuthorOld": "rpau",
			"daysBetweenCommits": 3.3,
			"commitsBetweenForRepo": 12,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,19 +1,29 @@\n     public SymbolReference<MethodDeclaration> solveMethod(String name, List<TypeUsage> parameterTypes, TypeSolver typeSolver) {\n         if (wrappedNode.getScope() != null) {\n+            // consider static methods\n+            if (wrappedNode.getScope() instanceof NameExpr) {\n+                NameExpr scopeAsName = (NameExpr)wrappedNode.getScope();\n+                SymbolReference symbolReference = this.solveType(scopeAsName.getName(), typeSolver);\n+                if (symbolReference.isSolved() && symbolReference.getCorrespondingDeclaration().isType()) {\n+                    TypeDeclaration typeDeclaration = symbolReference.getCorrespondingDeclaration().asType();\n+                    return typeDeclaration.solveMethod(name, parameterTypes);\n+                }\n+            }\n+\n             TypeUsage typeOfScope = JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n             if (typeOfScope.isWildcard()) {\n                 if (typeOfScope.asWildcard().isExtends() || typeOfScope.asWildcard().isSuper()) {\n                     return typeOfScope.asWildcard().getBoundedType().asReferenceTypeUsage().solveMethod(name, parameterTypes);\n                 } else {\n                     return new ReferenceTypeUsageImpl(new ReflectionClassDeclaration(Object.class, typeSolver), typeSolver).solveMethod(name, parameterTypes);\n                 }\n             } else if (typeOfScope.isArray() && typeOfScope.asArrayTypeUsage().getComponentType().isReferenceType()) {\n                 return typeOfScope.asArrayTypeUsage().getComponentType().asReferenceTypeUsage().solveMethod(name, parameterTypes);\n             } else {\n                 return typeOfScope.asReferenceTypeUsage().solveMethod(name, parameterTypes);\n             }\n         } else {\n             TypeUsage typeOfScope = JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n             return typeOfScope.asReferenceTypeUsage().solveMethod(name, parameterTypes);\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"2c3f615e6b24358b86d6453e24dac35849ffde26": {
			"type": "Ybodychange",
			"commitMessage": "added another fix and tests for method call on array access\n",
			"commitDate": "2016-09-23, 3:10 AM",
			"commitName": "2c3f615e6b24358b86d6453e24dac35849ffde26",
			"commitAuthor": "malte_langkabel",
			"commitDateOld": "2016-09-22, 5:06 AM",
			"commitNameOld": "a541f77a5a66a911e347d294aa76d8703e72e7db",
			"commitAuthorOld": "malte_langkabel",
			"daysBetweenCommits": 0.92,
			"commitsBetweenForRepo": 2,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,17 +1,19 @@\n     public SymbolReference<MethodDeclaration> solveMethod(String name, List<TypeUsage> parameterTypes, TypeSolver typeSolver) {\n         if (wrappedNode.getScope() != null) {\n             TypeUsage typeOfScope = JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n             if (typeOfScope.isWildcard()) {\n                 if (typeOfScope.asWildcard().isExtends() || typeOfScope.asWildcard().isSuper()) {\n                     return typeOfScope.asWildcard().getBoundedType().asReferenceTypeUsage().solveMethod(name, parameterTypes);\n                 } else {\n                     return new ReferenceTypeUsageImpl(new ReflectionClassDeclaration(Object.class, typeSolver), typeSolver).solveMethod(name, parameterTypes);\n                 }\n+            } else if (typeOfScope.isArray() && typeOfScope.asArrayTypeUsage().getComponentType().isReferenceType()) {\n+                return typeOfScope.asArrayTypeUsage().getComponentType().asReferenceTypeUsage().solveMethod(name, parameterTypes);\n             } else {\n                 return typeOfScope.asReferenceTypeUsage().solveMethod(name, parameterTypes);\n             }\n         } else {\n             TypeUsage typeOfScope = JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n             return typeOfScope.asReferenceTypeUsage().solveMethod(name, parameterTypes);\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"8e655d386a595ea1927ebeded58939d7b8a7ce0c": {
			"type": "Yfilerename",
			"commitMessage": "test JavaParserClassDeclaration\n",
			"commitDate": "2015-11-22, 2:45 AM",
			"commitName": "8e655d386a595ea1927ebeded58939d7b8a7ce0c",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2015-11-22, 2:03 AM",
			"commitNameOld": "68d87977d826a8c48711297732b7ae10f3dc1f1f",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 0.03,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "",
			"extendedDetails": {
				"oldPath": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/resolution/javaparser/contexts/MethodCallExprContext.java",
				"newPath": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/javaparsermodel/contexts/MethodCallExprContext.java"
			}
		},
		"4a18b1ee8ed716d6e32e190f728f1eee57148872": {
			"type": "Ybodychange",
			"commitMessage": "modules: extraction of the model module\n",
			"commitDate": "2015-11-13, 1:59 AM",
			"commitName": "4a18b1ee8ed716d6e32e190f728f1eee57148872",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2015-11-13, 1:12 AM",
			"commitNameOld": "f4b07b1a2deac6d1b562424ac2380b92cec77a90",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 0.03,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,17 +1,17 @@\n     public SymbolReference<MethodDeclaration> solveMethod(String name, List<TypeUsage> parameterTypes, TypeSolver typeSolver) {\n         if (wrappedNode.getScope() != null) {\n             TypeUsage typeOfScope = JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n             if (typeOfScope.isWildcard()) {\n                 if (typeOfScope.asWildcard().isExtends() || typeOfScope.asWildcard().isSuper()) {\n                     return typeOfScope.asWildcard().getBoundedType().asReferenceTypeUsage().solveMethod(name, parameterTypes);\n                 } else {\n-                    return new ReferenceTypeUsage(new ReflectionClassDeclaration(Object.class, typeSolver), typeSolver).solveMethod(name, parameterTypes);\n+                    return new ReferenceTypeUsageImpl(new ReflectionClassDeclaration(Object.class, typeSolver), typeSolver).solveMethod(name, parameterTypes);\n                 }\n             } else {\n                 return typeOfScope.asReferenceTypeUsage().solveMethod(name, parameterTypes);\n             }\n         } else {\n             TypeUsage typeOfScope = JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n             return typeOfScope.asReferenceTypeUsage().solveMethod(name, parameterTypes);\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"f4b07b1a2deac6d1b562424ac2380b92cec77a90": {
			"type": "Yfilerename",
			"commitMessage": "modules: organization in modules\n",
			"commitDate": "2015-11-13, 1:12 AM",
			"commitName": "f4b07b1a2deac6d1b562424ac2380b92cec77a90",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2015-11-13, 12:53 AM",
			"commitNameOld": "d96a8ff67d857a2988488f1fc31202f0e2ed8061",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 0.01,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "",
			"extendedDetails": {
				"oldPath": "src/main/java/me/tomassetti/symbolsolver/resolution/javaparser/contexts/MethodCallExprContext.java",
				"newPath": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/resolution/javaparser/contexts/MethodCallExprContext.java"
			}
		},
		"40ddb5e17127d2139e4b66b980ad11004749e86a": {
			"type": "Ybodychange",
			"commitMessage": "remove TypeSolver from ReferenceTypeUsage interface\n",
			"commitDate": "2015-11-02, 12:14 PM",
			"commitName": "40ddb5e17127d2139e4b66b980ad11004749e86a",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2015-11-02, 12:11 PM",
			"commitNameOld": "e21fca16e413a8bf31d613aa97a744d075c374dd",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 0,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,17 +1,17 @@\n     public SymbolReference<MethodDeclaration> solveMethod(String name, List<TypeUsage> parameterTypes, TypeSolver typeSolver) {\n         if (wrappedNode.getScope() != null) {\n             TypeUsage typeOfScope = JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n             if (typeOfScope.isWildcard()) {\n                 if (typeOfScope.asWildcard().isExtends() || typeOfScope.asWildcard().isSuper()) {\n-                    return typeOfScope.asWildcard().getBoundedType().asReferenceTypeUsage().solveMethod(name, parameterTypes, typeSolver);\n+                    return typeOfScope.asWildcard().getBoundedType().asReferenceTypeUsage().solveMethod(name, parameterTypes);\n                 } else {\n-                    return new ReferenceTypeUsage(new ReflectionClassDeclaration(Object.class, typeSolver), typeSolver).solveMethod(name, parameterTypes, typeSolver);\n+                    return new ReferenceTypeUsage(new ReflectionClassDeclaration(Object.class, typeSolver), typeSolver).solveMethod(name, parameterTypes);\n                 }\n             } else {\n-                return typeOfScope.asReferenceTypeUsage().solveMethod(name, parameterTypes, typeSolver);\n+                return typeOfScope.asReferenceTypeUsage().solveMethod(name, parameterTypes);\n             }\n         } else {\n             TypeUsage typeOfScope = JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n-            return typeOfScope.asReferenceTypeUsage().solveMethod(name, parameterTypes, typeSolver);\n+            return typeOfScope.asReferenceTypeUsage().solveMethod(name, parameterTypes);\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"965ab8585c3e8be1dff784e749e37dad31151ec8": {
			"type": "Ybodychange",
			"commitMessage": "wip\n",
			"commitDate": "2015-11-01, 6:57 AM",
			"commitName": "965ab8585c3e8be1dff784e749e37dad31151ec8",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2015-11-01, 3:29 AM",
			"commitNameOld": "26c12a20f1206e2a1f63c46b6b41c304af8c7389",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 0.14,
			"commitsBetweenForRepo": 3,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,9 +1,17 @@\n     public SymbolReference<MethodDeclaration> solveMethod(String name, List<TypeUsage> parameterTypes, TypeSolver typeSolver) {\n         if (wrappedNode.getScope() != null) {\n             TypeUsage typeOfScope = JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n-            return typeOfScope.asReferenceTypeUsage().solveMethod(name, parameterTypes, typeSolver);\n+            if (typeOfScope.isWildcard()) {\n+                if (typeOfScope.asWildcard().isExtends() || typeOfScope.asWildcard().isSuper()) {\n+                    return typeOfScope.asWildcard().getBoundedType().asReferenceTypeUsage().solveMethod(name, parameterTypes, typeSolver);\n+                } else {\n+                    return new ReferenceTypeUsage(new ReflectionClassDeclaration(Object.class, typeSolver), typeSolver).solveMethod(name, parameterTypes, typeSolver);\n+                }\n+            } else {\n+                return typeOfScope.asReferenceTypeUsage().solveMethod(name, parameterTypes, typeSolver);\n+            }\n         } else {\n             TypeUsage typeOfScope = JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n             return typeOfScope.asReferenceTypeUsage().solveMethod(name, parameterTypes, typeSolver);\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"362cdf49fd4c7ea6d60f3172fd2804f8aa765f4c": {
			"type": "Ybodychange",
			"commitMessage": "simpligy TypeUsage\n",
			"commitDate": "2015-10-30, 6:30 AM",
			"commitName": "362cdf49fd4c7ea6d60f3172fd2804f8aa765f4c",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2015-10-30, 5:49 AM",
			"commitNameOld": "392bb1e6e3f4b86c3bb812a95752e4921772c705",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 0.03,
			"commitsBetweenForRepo": 4,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,9 +1,9 @@\n     public SymbolReference<MethodDeclaration> solveMethod(String name, List<TypeUsage> parameterTypes, TypeSolver typeSolver) {\n         if (wrappedNode.getScope() != null) {\n             TypeUsage typeOfScope = JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n-            return typeOfScope.solveMethod(name, parameterTypes, typeSolver);\n+            return typeOfScope.asReferenceTypeUsage().solveMethod(name, parameterTypes, typeSolver);\n         } else {\n             TypeUsage typeOfScope = JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n-            return typeOfScope.solveMethod(name, parameterTypes, typeSolver);\n+            return typeOfScope.asReferenceTypeUsage().solveMethod(name, parameterTypes, typeSolver);\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"b36f33050149a62a5b3c8c7451ae93f736715029": {
			"type": "Yfilerename",
			"commitMessage": "reorganize packages\n",
			"commitDate": "2015-10-30, 2:53 AM",
			"commitName": "b36f33050149a62a5b3c8c7451ae93f736715029",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2015-10-30, 2:29 AM",
			"commitNameOld": "90999800bdc73eacb5ef25dafcd36c8518af3072",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 0.02,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "",
			"extendedDetails": {
				"oldPath": "src/main/java/me/tomassetti/symbolsolver/model/javaparser/contexts/MethodCallExprContext.java",
				"newPath": "src/main/java/me/tomassetti/symbolsolver/resolution/javaparser/contexts/MethodCallExprContext.java"
			}
		},
		"d393205e2ee874242b73e4fe819d1bc874587d8a": {
			"type": "Ybodychange",
			"commitMessage": "wip\n",
			"commitDate": "2015-08-17, 9:43 AM",
			"commitName": "d393205e2ee874242b73e4fe819d1bc874587d8a",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2015-08-16, 11:28 PM",
			"commitNameOld": "542ea71d2308fcf66c1942862737bfcf04178797",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 0.43,
			"commitsBetweenForRepo": 3,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,9 +1,9 @@\n     public SymbolReference<MethodDeclaration> solveMethod(String name, List<TypeUsage> parameterTypes, TypeSolver typeSolver) {\n         if (wrappedNode.getScope() != null) {\n             TypeUsage typeOfScope = JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n             return typeOfScope.solveMethod(name, parameterTypes, typeSolver);\n         } else {\n-            throw new UnsupportedOperationException();\n-            //return JavaParserFactory.getContext(wrappedNode.getParentNode()).solveSymbol(name, typeSolver);\n+            TypeUsage typeOfScope = JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n+            return typeOfScope.solveMethod(name, parameterTypes, typeSolver);\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"627b56302d259409e9bc50b20d77803484f18b5c": {
			"type": "Ybodychange",
			"commitMessage": "introduce cache in JavaParserFacade\n",
			"commitDate": "2015-08-05, 7:25 AM",
			"commitName": "627b56302d259409e9bc50b20d77803484f18b5c",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2015-08-05, 6:30 AM",
			"commitNameOld": "fd2e083224d3ee0e9ccca4431d63a84601e0d606",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 0.04,
			"commitsBetweenForRepo": 3,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,9 +1,9 @@\n     public SymbolReference<MethodDeclaration> solveMethod(String name, List<TypeUsage> parameterTypes, TypeSolver typeSolver) {\n         if (wrappedNode.getScope() != null) {\n-            TypeUsage typeOfScope = new JavaParserFacade(typeSolver).getType(wrappedNode.getScope());\n+            TypeUsage typeOfScope = JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n             return typeOfScope.solveMethod(name, parameterTypes, typeSolver);\n         } else {\n             throw new UnsupportedOperationException();\n             //return JavaParserFactory.getContext(wrappedNode.getParentNode()).solveSymbol(name, typeSolver);\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"80f951258992f75441239c79e0f31eda7d47e107": {
			"type": "Ybodychange",
			"commitMessage": "wip\n",
			"commitDate": "2015-08-04, 6:54 AM",
			"commitName": "80f951258992f75441239c79e0f31eda7d47e107",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2015-08-02, 11:53 PM",
			"commitNameOld": "8415b0bc2abfc2eb094745336a1cd27a4c96fa4b",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 1.29,
			"commitsBetweenForRepo": 7,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,9 +1,9 @@\n     public SymbolReference<MethodDeclaration> solveMethod(String name, List<TypeUsage> parameterTypes, TypeSolver typeSolver) {\n         if (wrappedNode.getScope() != null) {\n             TypeUsage typeOfScope = new JavaParserFacade(typeSolver).getType(wrappedNode.getScope());\n-            return typeOfScope.solveMethod(name, parameterTypes);\n+            return typeOfScope.solveMethod(name, parameterTypes, typeSolver);\n         } else {\n             throw new UnsupportedOperationException();\n             //return JavaParserFactory.getContext(wrappedNode.getParentNode()).solveSymbol(name, typeSolver);\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"8415b0bc2abfc2eb094745336a1cd27a4c96fa4b": {
			"type": "Ybodychange",
			"commitMessage": "wip\n",
			"commitDate": "2015-08-02, 11:53 PM",
			"commitName": "8415b0bc2abfc2eb094745336a1cd27a4c96fa4b",
			"commitAuthor": "Federico Tomassetti",
			"commitDateOld": "2015-08-02, 11:37 PM",
			"commitNameOld": "630eb94d43670f2080c7273584d49c0b0d4162f1",
			"commitAuthorOld": "Federico Tomassetti",
			"daysBetweenCommits": 0.01,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,8 +1,9 @@\n     public SymbolReference<MethodDeclaration> solveMethod(String name, List<TypeUsage> parameterTypes, TypeSolver typeSolver) {\n         if (wrappedNode.getScope() != null) {\n             TypeUsage typeOfScope = new JavaParserFacade(typeSolver).getType(wrappedNode.getScope());\n             return typeOfScope.solveMethod(name, parameterTypes);\n         } else {\n-            return JavaParserFactory.getContext(wrappedNode.getParentNode()).solveSymbol(name, typeSolver);\n+            throw new UnsupportedOperationException();\n+            //return JavaParserFactory.getContext(wrappedNode.getParentNode()).solveSymbol(name, typeSolver);\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"8b8cc6cddbf5af0c93c4ceffd015f6328c932149": {
			"type": "Ymultichange(Yparameterchange,Ybodychange)",
			"commitMessage": "wip\n",
			"commitDate": "2015-07-31, 11:52 AM",
			"commitName": "8b8cc6cddbf5af0c93c4ceffd015f6328c932149",
			"commitAuthor": "Federico Tomassetti",
			"subchanges": [
				{
					"type": "Yparameterchange",
					"commitMessage": "wip\n",
					"commitDate": "2015-07-31, 11:52 AM",
					"commitName": "8b8cc6cddbf5af0c93c4ceffd015f6328c932149",
					"commitAuthor": "Federico Tomassetti",
					"commitDateOld": "2015-07-31, 9:08 AM",
					"commitNameOld": "2f49331fb22511346eea8800d27907de44409d5b",
					"commitAuthorOld": "Federico Tomassetti",
					"daysBetweenCommits": 0.11,
					"commitsBetweenForRepo": 1,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,15 +1,8 @@\n-    public SymbolReference<MethodDeclaration> solveMethod(String name, List<TypeReference> parameterTypes, TypeSolver typeSolver) {\n+    public SymbolReference<MethodDeclaration> solveMethod(String name, List<TypeUsage> parameterTypes, TypeSolver typeSolver) {\n         if (wrappedNode.getScope() != null) {\n-            // TODO resolve the scope and get a context from there\n-            SymbolReference<SymbolDeclaration> declScope = new JavaParserFacade(typeSolver).solve(wrappedNode.getScope());\n-            if (declScope.isSolved()) {\n-                TypeDeclaration typeOfDeclScope = declScope.getCorrespondingDeclaration().getType();\n-                return typeOfDeclScope.getContext().solveMethod(name, parameterTypes, typeSolver);\n-            } else {\n-                // TODO this should be improved to indicate that is the scope that has not been solved\n-                throw new UnsolvedSymbolException(this, name);\n-            }\n+            TypeUsage typeOfScope = new JavaParserFacade(typeSolver).getType(wrappedNode.getScope());\n+            return typeOfScope.solveMethod(name, parameterTypes);\n         } else {\n             return JavaParserFactory.getContext(wrappedNode.getParentNode()).solveSymbol(name, typeSolver);\n         }\n     }\n\\ No newline at end of file\n",
					"extendedDetails": {
						"oldValue": "[name-String, parameterTypes-List<TypeReference>, typeSolver-TypeSolver]",
						"newValue": "[name-String, parameterTypes-List<TypeUsage>, typeSolver-TypeSolver]"
					}
				},
				{
					"type": "Ybodychange",
					"commitMessage": "wip\n",
					"commitDate": "2015-07-31, 11:52 AM",
					"commitName": "8b8cc6cddbf5af0c93c4ceffd015f6328c932149",
					"commitAuthor": "Federico Tomassetti",
					"commitDateOld": "2015-07-31, 9:08 AM",
					"commitNameOld": "2f49331fb22511346eea8800d27907de44409d5b",
					"commitAuthorOld": "Federico Tomassetti",
					"daysBetweenCommits": 0.11,
					"commitsBetweenForRepo": 1,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,15 +1,8 @@\n-    public SymbolReference<MethodDeclaration> solveMethod(String name, List<TypeReference> parameterTypes, TypeSolver typeSolver) {\n+    public SymbolReference<MethodDeclaration> solveMethod(String name, List<TypeUsage> parameterTypes, TypeSolver typeSolver) {\n         if (wrappedNode.getScope() != null) {\n-            // TODO resolve the scope and get a context from there\n-            SymbolReference<SymbolDeclaration> declScope = new JavaParserFacade(typeSolver).solve(wrappedNode.getScope());\n-            if (declScope.isSolved()) {\n-                TypeDeclaration typeOfDeclScope = declScope.getCorrespondingDeclaration().getType();\n-                return typeOfDeclScope.getContext().solveMethod(name, parameterTypes, typeSolver);\n-            } else {\n-                // TODO this should be improved to indicate that is the scope that has not been solved\n-                throw new UnsolvedSymbolException(this, name);\n-            }\n+            TypeUsage typeOfScope = new JavaParserFacade(typeSolver).getType(wrappedNode.getScope());\n+            return typeOfScope.solveMethod(name, parameterTypes);\n         } else {\n             return JavaParserFactory.getContext(wrappedNode.getParentNode()).solveSymbol(name, typeSolver);\n         }\n     }\n\\ No newline at end of file\n",
					"extendedDetails": {}
				}
			]
		},
		"2f49331fb22511346eea8800d27907de44409d5b": {
			"type": "Yintroduced",
			"commitMessage": "start to resolve references to method\n",
			"commitDate": "2015-07-31, 9:08 AM",
			"commitName": "2f49331fb22511346eea8800d27907de44409d5b",
			"commitAuthor": "Federico Tomassetti",
			"diff": "@@ -0,0 +1,15 @@\n+    public SymbolReference<MethodDeclaration> solveMethod(String name, List<TypeReference> parameterTypes, TypeSolver typeSolver) {\n+        if (wrappedNode.getScope() != null) {\n+            // TODO resolve the scope and get a context from there\n+            SymbolReference<SymbolDeclaration> declScope = new JavaParserFacade(typeSolver).solve(wrappedNode.getScope());\n+            if (declScope.isSolved()) {\n+                TypeDeclaration typeOfDeclScope = declScope.getCorrespondingDeclaration().getType();\n+                return typeOfDeclScope.getContext().solveMethod(name, parameterTypes, typeSolver);\n+            } else {\n+                // TODO this should be improved to indicate that is the scope that has not been solved\n+                throw new UnsolvedSymbolException(this, name);\n+            }\n+        } else {\n+            return JavaParserFactory.getContext(wrappedNode.getParentNode()).solveSymbol(name, typeSolver);\n+        }\n+    }\n\\ No newline at end of file\n"
		}
	},
	"sha": "97555053af3025556efe1a168fd7943dac28a2a6"
}