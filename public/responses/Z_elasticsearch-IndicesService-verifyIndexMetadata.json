{
	"repo": "https://github.com/elastic/elasticsearch.git",
	"file": "server/src/main/java/org/elasticsearch/indices/IndicesService.java",
	"method": {
		"longName": "public void verifyIndexMetadata(IndexMetaData metaData, IndexMetaData metaDataUpdate);",
		"startLine": 550,
		"methodName": "verifyIndexMetadata",
		"isStatic": false,
		"isAbstract": false,
		"visibility": "public"
	},
	"history": {
		"700d9ecc953fa30df0d12d086f0e9d9322446459": {
			"type": "Ybodychange",
			"commitMessage": "Remove the `update_all_types` option. (#28288)\n\nThis option is not useful in 7.x since no indices may have more than one type\r\nanymore.\r\n\r\n",
			"commitDate": "2018-01-22, 3:03 AM",
			"commitName": "700d9ecc953fa30df0d12d086f0e9d9322446459",
			"commitAuthor": "Adrien Grand",
			"commitDateOld": "2018-01-11, 10:30 AM",
			"commitNameOld": "99f88f15c5febbca2d13b5b5fda27b844153bf1a",
			"commitAuthorOld": "Tim Brooks",
			"daysBetweenCommits": 10.69,
			"commitsBetweenForRepo": 91,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,19 +1,19 @@\n     public synchronized void verifyIndexMetadata(IndexMetaData metaData, IndexMetaData metaDataUpdate) throws IOException {\n         final List<Closeable> closeables = new ArrayList<>();\n         try {\n             IndicesFieldDataCache indicesFieldDataCache = new IndicesFieldDataCache(settings, new IndexFieldDataCache.Listener() {});\n             closeables.add(indicesFieldDataCache);\n             IndicesQueryCache indicesQueryCache = new IndicesQueryCache(settings);\n             closeables.add(indicesQueryCache);\n             // this will also fail if some plugin fails etc. which is nice since we can verify that early\n             final IndexService service =\n                 createIndexService(\"metadata verification\", metaData, indicesQueryCache, indicesFieldDataCache, emptyList());\n             closeables.add(() -> service.close(\"metadata verification\", false));\n-            service.mapperService().merge(metaData, MapperService.MergeReason.MAPPING_RECOVERY, true);\n+            service.mapperService().merge(metaData, MapperService.MergeReason.MAPPING_RECOVERY);\n             if (metaData.equals(metaDataUpdate) == false) {\n                 service.updateMetaData(metaDataUpdate);\n             }\n         } finally {\n             IOUtils.close(closeables);\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"99f88f15c5febbca2d13b5b5fda27b844153bf1a": {
			"type": "Yfilerename",
			"commitMessage": "Rename core module to server (#28180)\n\nThis is related to #27933. It renames the core module to server. This is\r\nthe first step towards introducing an elasticsearch-core jar.",
			"commitDate": "2018-01-11, 10:30 AM",
			"commitName": "99f88f15c5febbca2d13b5b5fda27b844153bf1a",
			"commitAuthor": "Tim Brooks",
			"commitDateOld": "2018-01-11, 8:31 AM",
			"commitNameOld": "7d0eb3292b8f8ba27ef50dbbf38783dc68c70728",
			"commitAuthorOld": "Martijn van Groningen",
			"daysBetweenCommits": 0.08,
			"commitsBetweenForRepo": 1,
			"commitsBetweenForFile": 1,
			"diff": "",
			"extendedDetails": {
				"oldPath": "core/src/main/java/org/elasticsearch/indices/IndicesService.java",
				"newPath": "server/src/main/java/org/elasticsearch/indices/IndicesService.java"
			}
		},
		"8f873620ee5a22008a97d29ca4fa448790cf8f0d": {
			"type": "Ybodychange",
			"commitMessage": "Inline global checkpoints\n\nToday we rely on background syncs to relay the global checkpoint under\r\nthe mandate of the primary to its replicas. This means that the global\r\ncheckpoint on a replica can lag far behind the primary. The commit moves\r\nto inlining global checkpoints with replication requests. When a\r\nreplication operation is performed, the primary will send the latest\r\nglobal checkpoint inline with the replica requests. This keeps the\r\nreplicas closer in-sync with the primary.\r\n\r\nHowever, consider a replication request that is not followed by another\r\nreplication request for an indefinite period of time. When the replicas\r\nrespond to the primary with their local checkpoint, the primary will\r\nadvance its global checkpoint. During this indefinite period of time,\r\nthe replicas will not be notified of the advanced global\r\ncheckpoint. This necessitates a need for another sync. To achieve this,\r\nwe perform a global checkpoint sync when a shard falls idle.\r\n\r\nRelates #24513\r\n",
			"commitDate": "2017-05-09, 12:08 PM",
			"commitName": "8f873620ee5a22008a97d29ca4fa448790cf8f0d",
			"commitAuthor": "Jason Tedor",
			"commitDateOld": "2017-04-11, 10:26 AM",
			"commitNameOld": "5cace8e48aa3d9a9e5a82e31a8110cfad8998aef",
			"commitAuthorOld": "Lee Hinman",
			"daysBetweenCommits": 28.07,
			"commitsBetweenForRepo": 325,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,19 +1,19 @@\n     public synchronized void verifyIndexMetadata(IndexMetaData metaData, IndexMetaData metaDataUpdate) throws IOException {\n         final List<Closeable> closeables = new ArrayList<>();\n         try {\n             IndicesFieldDataCache indicesFieldDataCache = new IndicesFieldDataCache(settings, new IndexFieldDataCache.Listener() {});\n             closeables.add(indicesFieldDataCache);\n             IndicesQueryCache indicesQueryCache = new IndicesQueryCache(settings);\n             closeables.add(indicesQueryCache);\n             // this will also fail if some plugin fails etc. which is nice since we can verify that early\n             final IndexService service =\n-                createIndexService(\"metadata verification\", metaData, indicesQueryCache, indicesFieldDataCache, emptyList(), s -> {});\n+                createIndexService(\"metadata verification\", metaData, indicesQueryCache, indicesFieldDataCache, emptyList());\n             closeables.add(() -> service.close(\"metadata verification\", false));\n             service.mapperService().merge(metaData, MapperService.MergeReason.MAPPING_RECOVERY, true);\n             if (metaData.equals(metaDataUpdate) == false) {\n                 service.updateMetaData(metaDataUpdate);\n             }\n         } finally {\n             IOUtils.close(closeables);\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"63af03a1042a6ae1ed333aaabcd9cfc3a9fc3fec": {
			"type": "Ybodychange",
			"commitMessage": "Atomic mapping updates across types (#22220)\n\nThis commit makes mapping updates atomic when multiple types in an index are updated. Mappings for an index are now applied in a single atomic operation, which also allows to optimize some of the cross-type updates and checks.",
			"commitDate": "2016-12-19, 5:39 AM",
			"commitName": "63af03a1042a6ae1ed333aaabcd9cfc3a9fc3fec",
			"commitAuthor": "Yannick Welsch",
			"commitDateOld": "2016-12-15, 8:06 AM",
			"commitNameOld": "b6cbcc49ba590ead3cd6d95953eabe22f7d47fef",
			"commitAuthorOld": "Boaz Leskes",
			"daysBetweenCommits": 3.9,
			"commitsBetweenForRepo": 37,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,23 +1,19 @@\n     public synchronized void verifyIndexMetadata(IndexMetaData metaData, IndexMetaData metaDataUpdate) throws IOException {\n         final List<Closeable> closeables = new ArrayList<>();\n         try {\n             IndicesFieldDataCache indicesFieldDataCache = new IndicesFieldDataCache(settings, new IndexFieldDataCache.Listener() {});\n             closeables.add(indicesFieldDataCache);\n             IndicesQueryCache indicesQueryCache = new IndicesQueryCache(settings);\n             closeables.add(indicesQueryCache);\n             // this will also fail if some plugin fails etc. which is nice since we can verify that early\n             final IndexService service =\n                 createIndexService(\"metadata verification\", metaData, indicesQueryCache, indicesFieldDataCache, emptyList(), s -> {});\n             closeables.add(() -> service.close(\"metadata verification\", false));\n-            for (ObjectCursor<MappingMetaData> typeMapping : metaData.getMappings().values()) {\n-                // don't apply the default mapping, it has been applied when the mapping was created\n-                service.mapperService().merge(typeMapping.value.type(), typeMapping.value.source(),\n-                    MapperService.MergeReason.MAPPING_RECOVERY, true);\n-            }\n+            service.mapperService().merge(metaData, MapperService.MergeReason.MAPPING_RECOVERY, true);\n             if (metaData.equals(metaDataUpdate) == false) {\n                 service.updateMetaData(metaDataUpdate);\n             }\n         } finally {\n             IOUtils.close(closeables);\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"6418f89feb55970c04474e3cced6ff1031725e39": {
			"type": "Ymultichange(Yparameterchange,Ybodychange)",
			"commitMessage": "Remove NodeServicesProvider\n\nInstead provide services where they are needed. The class worked\nwell as a temporary measure to easy removal of guice from the index\nlevel but now we can remove it entirely.\n\n-1 @Inject annotation\n",
			"commitDate": "2016-10-08, 4:35 AM",
			"commitName": "6418f89feb55970c04474e3cced6ff1031725e39",
			"commitAuthor": "Nik Everett",
			"subchanges": [
				{
					"type": "Yparameterchange",
					"commitMessage": "Remove NodeServicesProvider\n\nInstead provide services where they are needed. The class worked\nwell as a temporary measure to easy removal of guice from the index\nlevel but now we can remove it entirely.\n\n-1 @Inject annotation\n",
					"commitDate": "2016-10-08, 4:35 AM",
					"commitName": "6418f89feb55970c04474e3cced6ff1031725e39",
					"commitAuthor": "Nik Everett",
					"commitDateOld": "2016-10-05, 3:22 AM",
					"commitNameOld": "a008959f7a1b9fbe970a9631a96c73ac7a1458df",
					"commitAuthorOld": "Simon Willnauer",
					"daysBetweenCommits": 3.05,
					"commitsBetweenForRepo": 47,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,23 +1,23 @@\n-    public synchronized void verifyIndexMetadata(final NodeServicesProvider nodeServicesProvider, IndexMetaData metaData, IndexMetaData metaDataUpdate) throws IOException {\n+    public synchronized void verifyIndexMetadata(IndexMetaData metaData, IndexMetaData metaDataUpdate) throws IOException {\n         final List<Closeable> closeables = new ArrayList<>();\n         try {\n             IndicesFieldDataCache indicesFieldDataCache = new IndicesFieldDataCache(settings, new IndexFieldDataCache.Listener() {});\n             closeables.add(indicesFieldDataCache);\n             IndicesQueryCache indicesQueryCache = new IndicesQueryCache(settings);\n             closeables.add(indicesQueryCache);\n             // this will also fail if some plugin fails etc. which is nice since we can verify that early\n-            final IndexService service = createIndexService(\"metadata verification\", nodeServicesProvider,\n-                metaData, indicesQueryCache, indicesFieldDataCache, Collections.emptyList());\n+            final IndexService service = createIndexService(\"metadata verification\", metaData, indicesQueryCache, indicesFieldDataCache,\n+                    emptyList());\n             closeables.add(() -> service.close(\"metadata verification\", false));\n             for (ObjectCursor<MappingMetaData> typeMapping : metaData.getMappings().values()) {\n                 // don't apply the default mapping, it has been applied when the mapping was created\n                 service.mapperService().merge(typeMapping.value.type(), typeMapping.value.source(),\n                     MapperService.MergeReason.MAPPING_RECOVERY, true);\n             }\n             if (metaData.equals(metaDataUpdate) == false) {\n                 service.updateMetaData(metaDataUpdate);\n             }\n         } finally {\n             IOUtils.close(closeables);\n         }\n     }\n\\ No newline at end of file\n",
					"extendedDetails": {
						"oldValue": "[nodeServicesProvider-NodeServicesProvider(modifiers-final), metaData-IndexMetaData, metaDataUpdate-IndexMetaData]",
						"newValue": "[metaData-IndexMetaData, metaDataUpdate-IndexMetaData]"
					}
				},
				{
					"type": "Ybodychange",
					"commitMessage": "Remove NodeServicesProvider\n\nInstead provide services where they are needed. The class worked\nwell as a temporary measure to easy removal of guice from the index\nlevel but now we can remove it entirely.\n\n-1 @Inject annotation\n",
					"commitDate": "2016-10-08, 4:35 AM",
					"commitName": "6418f89feb55970c04474e3cced6ff1031725e39",
					"commitAuthor": "Nik Everett",
					"commitDateOld": "2016-10-05, 3:22 AM",
					"commitNameOld": "a008959f7a1b9fbe970a9631a96c73ac7a1458df",
					"commitAuthorOld": "Simon Willnauer",
					"daysBetweenCommits": 3.05,
					"commitsBetweenForRepo": 47,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,23 +1,23 @@\n-    public synchronized void verifyIndexMetadata(final NodeServicesProvider nodeServicesProvider, IndexMetaData metaData, IndexMetaData metaDataUpdate) throws IOException {\n+    public synchronized void verifyIndexMetadata(IndexMetaData metaData, IndexMetaData metaDataUpdate) throws IOException {\n         final List<Closeable> closeables = new ArrayList<>();\n         try {\n             IndicesFieldDataCache indicesFieldDataCache = new IndicesFieldDataCache(settings, new IndexFieldDataCache.Listener() {});\n             closeables.add(indicesFieldDataCache);\n             IndicesQueryCache indicesQueryCache = new IndicesQueryCache(settings);\n             closeables.add(indicesQueryCache);\n             // this will also fail if some plugin fails etc. which is nice since we can verify that early\n-            final IndexService service = createIndexService(\"metadata verification\", nodeServicesProvider,\n-                metaData, indicesQueryCache, indicesFieldDataCache, Collections.emptyList());\n+            final IndexService service = createIndexService(\"metadata verification\", metaData, indicesQueryCache, indicesFieldDataCache,\n+                    emptyList());\n             closeables.add(() -> service.close(\"metadata verification\", false));\n             for (ObjectCursor<MappingMetaData> typeMapping : metaData.getMappings().values()) {\n                 // don't apply the default mapping, it has been applied when the mapping was created\n                 service.mapperService().merge(typeMapping.value.type(), typeMapping.value.source(),\n                     MapperService.MergeReason.MAPPING_RECOVERY, true);\n             }\n             if (metaData.equals(metaDataUpdate) == false) {\n                 service.updateMetaData(metaDataUpdate);\n             }\n         } finally {\n             IOUtils.close(closeables);\n         }\n     }\n\\ No newline at end of file\n",
					"extendedDetails": {}
				}
			]
		},
		"ef0e3db0de6928ddca70d18e929223980f283fe1": {
			"type": "Ymultichange(Yparameterchange,Ybodychange)",
			"commitMessage": "Validates new dynamic settings from the current state\n\nThanks to https://github.com/elastic/elasticsearch/pull/19088 the settings are now validated against dynamic updaters on the master.\nThough only the new settings are applied to the IndexService created for the validation.\nBecause of this we cannot check the transition from one value to another in a dynamic updaters.\nThis change creates the IndexService from the current settings and validates that the new dynamic settings\ncan replace the current settings.\nThis change also removes the validation of dynamic settings when an index is opened.\nThe validation should have occurred when the settings have been updated.\n",
			"commitDate": "2016-06-28, 6:35 AM",
			"commitName": "ef0e3db0de6928ddca70d18e929223980f283fe1",
			"commitAuthor": "Jim Ferenczi",
			"subchanges": [
				{
					"type": "Yparameterchange",
					"commitMessage": "Validates new dynamic settings from the current state\n\nThanks to https://github.com/elastic/elasticsearch/pull/19088 the settings are now validated against dynamic updaters on the master.\nThough only the new settings are applied to the IndexService created for the validation.\nBecause of this we cannot check the transition from one value to another in a dynamic updaters.\nThis change creates the IndexService from the current settings and validates that the new dynamic settings\ncan replace the current settings.\nThis change also removes the validation of dynamic settings when an index is opened.\nThe validation should have occurred when the settings have been updated.\n",
					"commitDate": "2016-06-28, 6:35 AM",
					"commitName": "ef0e3db0de6928ddca70d18e929223980f283fe1",
					"commitAuthor": "Jim Ferenczi",
					"commitDateOld": "2016-06-27, 8:18 AM",
					"commitNameOld": "4fb1c4fe5ad7017d60b2b6aae08f55f407805386",
					"commitAuthorOld": "Simon Willnauer",
					"daysBetweenCommits": 0.93,
					"commitsBetweenForRepo": 19,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,21 +1,23 @@\n-    public synchronized void verifyIndexMetadata(final NodeServicesProvider nodeServicesProvider, IndexMetaData metaData) throws IOException {\n+    public synchronized void verifyIndexMetadata(final NodeServicesProvider nodeServicesProvider, IndexMetaData metaData, IndexMetaData metaDataUpdate) throws IOException {\n         final List<Closeable> closeables = new ArrayList<>();\n         try {\n             IndicesFieldDataCache indicesFieldDataCache = new IndicesFieldDataCache(settings, new IndexFieldDataCache.Listener() {});\n             closeables.add(indicesFieldDataCache);\n             IndicesQueryCache indicesQueryCache = new IndicesQueryCache(settings);\n             closeables.add(indicesQueryCache);\n             // this will also fail if some plugin fails etc. which is nice since we can verify that early\n             final IndexService service = createIndexService(\"metadata verification\", nodeServicesProvider,\n                 metaData, indicesQueryCache, indicesFieldDataCache, Collections.emptyList());\n             closeables.add(() -> service.close(\"metadata verification\", false));\n             for (ObjectCursor<MappingMetaData> typeMapping : metaData.getMappings().values()) {\n                 // don't apply the default mapping, it has been applied when the mapping was created\n                 service.mapperService().merge(typeMapping.value.type(), typeMapping.value.source(),\n                     MapperService.MergeReason.MAPPING_RECOVERY, true);\n             }\n-            service.getIndexSettings().getScopedSettings().validateUpdate(metaData.getSettings());\n+            if (metaData.equals(metaDataUpdate) == false) {\n+                service.updateMetaData(metaDataUpdate);\n+            }\n         } finally {\n             IOUtils.close(closeables);\n         }\n     }\n\\ No newline at end of file\n",
					"extendedDetails": {
						"oldValue": "[nodeServicesProvider-NodeServicesProvider(modifiers-final), metaData-IndexMetaData]",
						"newValue": "[nodeServicesProvider-NodeServicesProvider(modifiers-final), metaData-IndexMetaData, metaDataUpdate-IndexMetaData]"
					}
				},
				{
					"type": "Ybodychange",
					"commitMessage": "Validates new dynamic settings from the current state\n\nThanks to https://github.com/elastic/elasticsearch/pull/19088 the settings are now validated against dynamic updaters on the master.\nThough only the new settings are applied to the IndexService created for the validation.\nBecause of this we cannot check the transition from one value to another in a dynamic updaters.\nThis change creates the IndexService from the current settings and validates that the new dynamic settings\ncan replace the current settings.\nThis change also removes the validation of dynamic settings when an index is opened.\nThe validation should have occurred when the settings have been updated.\n",
					"commitDate": "2016-06-28, 6:35 AM",
					"commitName": "ef0e3db0de6928ddca70d18e929223980f283fe1",
					"commitAuthor": "Jim Ferenczi",
					"commitDateOld": "2016-06-27, 8:18 AM",
					"commitNameOld": "4fb1c4fe5ad7017d60b2b6aae08f55f407805386",
					"commitAuthorOld": "Simon Willnauer",
					"daysBetweenCommits": 0.93,
					"commitsBetweenForRepo": 19,
					"commitsBetweenForFile": 1,
					"diff": "@@ -1,21 +1,23 @@\n-    public synchronized void verifyIndexMetadata(final NodeServicesProvider nodeServicesProvider, IndexMetaData metaData) throws IOException {\n+    public synchronized void verifyIndexMetadata(final NodeServicesProvider nodeServicesProvider, IndexMetaData metaData, IndexMetaData metaDataUpdate) throws IOException {\n         final List<Closeable> closeables = new ArrayList<>();\n         try {\n             IndicesFieldDataCache indicesFieldDataCache = new IndicesFieldDataCache(settings, new IndexFieldDataCache.Listener() {});\n             closeables.add(indicesFieldDataCache);\n             IndicesQueryCache indicesQueryCache = new IndicesQueryCache(settings);\n             closeables.add(indicesQueryCache);\n             // this will also fail if some plugin fails etc. which is nice since we can verify that early\n             final IndexService service = createIndexService(\"metadata verification\", nodeServicesProvider,\n                 metaData, indicesQueryCache, indicesFieldDataCache, Collections.emptyList());\n             closeables.add(() -> service.close(\"metadata verification\", false));\n             for (ObjectCursor<MappingMetaData> typeMapping : metaData.getMappings().values()) {\n                 // don't apply the default mapping, it has been applied when the mapping was created\n                 service.mapperService().merge(typeMapping.value.type(), typeMapping.value.source(),\n                     MapperService.MergeReason.MAPPING_RECOVERY, true);\n             }\n-            service.getIndexSettings().getScopedSettings().validateUpdate(metaData.getSettings());\n+            if (metaData.equals(metaDataUpdate) == false) {\n+                service.updateMetaData(metaDataUpdate);\n+            }\n         } finally {\n             IOUtils.close(closeables);\n         }\n     }\n\\ No newline at end of file\n",
					"extendedDetails": {}
				}
			]
		},
		"4fb1c4fe5ad7017d60b2b6aae08f55f407805386": {
			"type": "Ybodychange",
			"commitMessage": "Validate settings against dynamic updaters on the master (#19088)\n\nToday all settings are only validated against their validators\r\nthat are available when settings are registered. Yet, some settings updaters\r\nhave validators that are dynamic ie. their validation depends on other variables\r\nthat are only available at runtime. We do not run those validators when settings\r\nare updated causing index updates to fail on the data nodes instead of on the master.\r\n\r\nRelates to #19046",
			"commitDate": "2016-06-27, 8:18 AM",
			"commitName": "4fb1c4fe5ad7017d60b2b6aae08f55f407805386",
			"commitAuthor": "Simon Willnauer",
			"commitDateOld": "2016-06-23, 12:30 AM",
			"commitNameOld": "04da1bda0ddb42a66c6b8481a544f24647bd0ce4",
			"commitAuthorOld": "Tanguy Leroux",
			"daysBetweenCommits": 4.32,
			"commitsBetweenForRepo": 35,
			"commitsBetweenForFile": 1,
			"diff": "@@ -1,20 +1,21 @@\n     public synchronized void verifyIndexMetadata(final NodeServicesProvider nodeServicesProvider, IndexMetaData metaData) throws IOException {\n         final List<Closeable> closeables = new ArrayList<>();\n         try {\n             IndicesFieldDataCache indicesFieldDataCache = new IndicesFieldDataCache(settings, new IndexFieldDataCache.Listener() {});\n             closeables.add(indicesFieldDataCache);\n             IndicesQueryCache indicesQueryCache = new IndicesQueryCache(settings);\n             closeables.add(indicesQueryCache);\n             // this will also fail if some plugin fails etc. which is nice since we can verify that early\n             final IndexService service = createIndexService(\"metadata verification\", nodeServicesProvider,\n                 metaData, indicesQueryCache, indicesFieldDataCache, Collections.emptyList());\n+            closeables.add(() -> service.close(\"metadata verification\", false));\n             for (ObjectCursor<MappingMetaData> typeMapping : metaData.getMappings().values()) {\n                 // don't apply the default mapping, it has been applied when the mapping was created\n                 service.mapperService().merge(typeMapping.value.type(), typeMapping.value.source(),\n                     MapperService.MergeReason.MAPPING_RECOVERY, true);\n             }\n-            closeables.add(() -> service.close(\"metadata verification\", false));\n+            service.getIndexSettings().getScopedSettings().validateUpdate(metaData.getSettings());\n         } finally {\n             IOUtils.close(closeables);\n         }\n     }\n\\ No newline at end of file\n",
			"extendedDetails": {}
		},
		"8127a06b2ec40fd5f31a6915143386dd853abc2b": {
			"type": "Yintroduced",
			"commitMessage": "Recover broken IndexMetaData as closed\n\nToday if something is wrong with the IndexMetaData we detect it very\nlate and most of the time if that happens we already allocated the index\nand get endless loops and full log files on data-nodes. This change tries\nto verify IndexService creattion during initial state recovery on the master\nand if the recovery fails the index is imported as `closed` and won't be allocated\nat all.\n\nCloses #17187\n",
			"commitDate": "2016-03-21, 2:50 PM",
			"commitName": "8127a06b2ec40fd5f31a6915143386dd853abc2b",
			"commitAuthor": "Simon Willnauer",
			"diff": "@@ -0,0 +1,20 @@\n+    public synchronized void verifyIndexMetadata(final NodeServicesProvider nodeServicesProvider, IndexMetaData metaData) throws IOException {\n+        final List<Closeable> closeables = new ArrayList<>();\n+        try {\n+            IndicesFieldDataCache indicesFieldDataCache = new IndicesFieldDataCache(settings, new IndexFieldDataCache.Listener() {});\n+            closeables.add(indicesFieldDataCache);\n+            IndicesQueryCache indicesQueryCache = new IndicesQueryCache(settings);\n+            closeables.add(indicesQueryCache);\n+            // this will also fail if some plugin fails etc. which is nice since we can verify that early\n+            final IndexService service = createIndexService(\"metadata verification\", nodeServicesProvider,\n+                metaData, indicesQueryCache, indicesFieldDataCache, Collections.emptyList());\n+            for (ObjectCursor<MappingMetaData> typeMapping : metaData.getMappings().values()) {\n+                // don't apply the default mapping, it has been applied when the mapping was created\n+                service.mapperService().merge(typeMapping.value.type(), typeMapping.value.source(),\n+                    MapperService.MergeReason.MAPPING_RECOVERY, true);\n+            }\n+            closeables.add(() -> service.close(\"metadata verification\", false));\n+        } finally {\n+            IOUtils.close(closeables);\n+        }\n+    }\n\\ No newline at end of file\n"
		}
	},
	"sha": "767c69593c67befb843686de8ea51b7bc87728c9"
}